{"version":3,"file":"background.ts.js","sources":["../../src/util/typo/profiles/profile-store.ts","../../node_modules/idb/build/index.js","../../src/runtime/extension/background/background.ts"],"sourcesContent":["import type { IDBPDatabase } from \"idb\";\n\nexport interface savedProfile {\n  token: string | null;\n  settings: [string, unknown][];\n}\n\nexport class TypoProfileStore {\n  private readonly _db: Promise<IDBPDatabase>;\n\n  constructor(\n    db: Promise<IDBPDatabase>,\n    private readonly _profileListStore: string,\n    private readonly _currentProfileStore: string,\n    private readonly _settingsStore: string,\n    private readonly _tokenStore: string\n  ) {\n    this._db = this.init(db);\n  }\n\n  private async init(db: Promise<IDBPDatabase>): Promise<IDBPDatabase> {\n    /* make sure a default profile exists */\n    const profile = await (await db).get(this._currentProfileStore, \"current_profile\");\n    if (profile === undefined) {\n      await (await db).put(this._currentProfileStore, \"Default\", \"current_profile\");\n    }\n\n    const profiles = await (await db).getAllKeys(this._profileListStore);\n    if (profiles.length === 0) {\n      await (await db).put(this._profileListStore, {}, \"Default\");\n    }\n\n    return db;\n  }\n\n  public async getProfiles(): Promise<string[]> {\n    return (await (await this._db).getAllKeys(this._profileListStore)).map(key => key.toString());\n  }\n\n  public async getCurrentProfile(): Promise<string> {\n    return (await (await this._db).get(this._currentProfileStore, \"current_profile\"));\n  }\n\n  public async createAndActivateProfile(profile: string): Promise<void> {\n\n    /* save current data to saved profiles */\n    const currentProfile = await this.getCurrentProfile();\n    const currentProfileData = await this.exportCurrentProfile();\n    await this.setSavedProfile(currentProfile, currentProfileData);\n\n    /* change current profile name and clear data */\n    await (await this._db).put(this._currentProfileStore, profile, \"current_profile\");\n    await this.setSavedProfile(profile, { token: null, settings: [] });\n    await this.loadProfile({ token: null, settings: [] });\n  }\n\n  public async switchToProfile(profile: string): Promise<void> {\n\n    /* save current data to saved profiles */\n    const currentProfile = await this.getCurrentProfile();\n    const currentProfileData = await this.exportCurrentProfile();\n    await this.setSavedProfile(currentProfile, currentProfileData);\n\n    await this.loadProfile(await this.getSavedProfile(profile));\n    await (await this._db).put(this._currentProfileStore, profile, \"current_profile\");\n  }\n\n  public async deleteProfile(profile: string): Promise<void> {\n    const currentProfile = await this.getCurrentProfile();\n    if (currentProfile === profile) {\n      throw new Error(\"Cannot delete current profile\");\n    }\n    await (await this._db).delete(this._profileListStore, profile);\n  }\n\n  private async getSavedProfile(profile: string): Promise<savedProfile> {\n    const result =  (await (await this._db).get(this._profileListStore, profile));\n    return result ?? { token: null, settings: {} };\n  }\n\n  private async setSavedProfile(profile: string, savedProfile: savedProfile): Promise<void> {\n    await (await this._db).put(this._profileListStore, savedProfile, profile);\n  }\n\n  private async exportCurrentProfile(): Promise<savedProfile> {\n    const settingKeys = await (await this._db).getAllKeys(this._settingsStore);\n    const settings = new Map<string, unknown>();\n    for (const key of settingKeys.map(k => k.toString())) {\n      const value = await (await this._db).get(this._settingsStore, key);\n      settings.set(key, value);\n    }\n\n    return {\n      token: await (await this._db).get(this._tokenStore, \"token\"),\n      settings: Array.from(settings.entries())\n    };\n  }\n\n  private async loadProfile(savedProfile: savedProfile): Promise<void> {\n    await (await this._db).clear(this._settingsStore);\n    await (await this._db).put(this._tokenStore, savedProfile.token, \"token\");\n    for (const [key, value] of savedProfile.settings) {\n      await (await this._db).put(this._settingsStore, value, key);\n    }\n  }\n\n}","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","import { TypoProfileStore } from \"@/util/typo/profiles/profile-store\";\nimport { openDB } from \"idb\";\n\n\nconst db = openDB(\"skribbl_typo\", 1, {\n  upgrade: (database) => {\n    database.createObjectStore(\"settings\");\n    database.createObjectStore(\"token\");\n    database.createObjectStore(\"current_profile\");\n    database.createObjectStore(\"profiles\");\n  },\n});\n\nconst profileStore = new TypoProfileStore(db, \"profiles\", \"current_profile\", \"settings\", \"token\");\n\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n\n  /* if token requested, fetch and send back */\n  if (request.type === \"get token\") {\n    (async () => {\n      const data = await (await db).get(\"token\", \"token\");\n      const token = data ?? null;\n      sendResponse(token);\n    })();\n    return true;\n  }\n\n  /* if token provided, save for future use */\n  else if (request.type === \"set token\") {\n    (async () => {\n      await (await db).put(\"token\", request.token ?? null, \"token\");\n    })();\n  }\n\n  else if(request.type === \"get setting\"){\n    (async () => {\n      const data = await (await db).get(\"settings\", request.key);\n      sendResponse(data);\n    })();\n    return true;\n  }\n\n  else if(request.type === \"set setting\"){\n    (async () => {\n      await (await db).put(\"settings\", request.value, request.key);\n    })();\n  }\n\n  /* if profile list requested, fetch and send back */\n  if (request.type === \"get profiles\") {\n    (async () => {\n      const profiles = await profileStore.getProfiles();\n      sendResponse(profiles);\n    })();\n    return true;\n  }\n\n  /* if profile deletion requested, delete */\n  if (request.type === \"delete profile\") {\n    (async () => {\n      await profileStore.deleteProfile(request.profile);\n      sendResponse(undefined);\n    })();\n    return true;\n  }\n\n  /* if current profile requested, send name back */\n  if (request.type === \"get profile\") {\n    (async () => {\n      const key = await profileStore.getCurrentProfile();\n      sendResponse(key);\n    })();\n    return true;\n  }\n\n  /* if switch profile requested, set */\n  if (request.type === \"switch profile\") {\n    (async () => {\n      await profileStore.switchToProfile(request.profile);\n      sendResponse(undefined);\n    })();\n    return true;\n  }\n\n  /* if create profile requested, create */\n  if (request.type === \"create profile\") {\n    (async () => {\n      await profileStore.createAndActivateProfile(request.profile);\n      sendResponse(undefined);\n    })();\n    return true;\n  }\n\n  /* if reset requested, clear all */\n  if (request.type === \"reset\") {\n    (async () => {\n      await (await db).clear(\"settings\");\n      await (await db).clear(\"token\");\n      await (await db).clear(\"current_profile\");\n      await (await db).clear(\"profiles\");\n      sendResponse(undefined);\n    })();\n    return true;\n  }\n});"],"names":["db","target"],"mappings":"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","x_google_ignoreList":[1]}