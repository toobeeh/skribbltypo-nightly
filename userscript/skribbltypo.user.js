// ==UserScript==
// @name         skribbltypo
// @namespace    vite-plugin-monkey
// @version      27.1.3 beta-usc 7124cd9
// @author       tobeh
// @description  The toolbox for everything you need on skribbl.io
// @updateURL    https://get.typo.rip/userscript/skribbltypo.user.js
// @match        https://skribbl.io/*
// @grant        GM_addStyle
// @run-at       document-start
// ==/UserScript==

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const t=document.createElement("style");t.textContent=e,document.head.append(t)})(' div.svelte-kfudwd.svelte-kfudwd{display:flex;justify-content:flex-start;align-items:center;gap:.5em;cursor:pointer;padding:.2em}div.disabled.svelte-kfudwd.svelte-kfudwd{opacity:.5;pointer-events:none}div.svelte-kfudwd img.svelte-kfudwd{height:1.5em;aspect-ratio:1;filter:drop-shadow(3px 3px 0px rgba(0,0,0,.3));-webkit-user-select:none;user-select:none}div.svelte-kfudwd span.svelte-kfudwd{-webkit-user-select:none;user-select:none;font-weight:600}b.svelte-rvotkt{font-size:1.1rem}.typo-numeric-setting.svelte-i0zktq.svelte-i0zktq{display:grid;align-items:center;grid-template-columns:auto auto;grid-template-rows:auto auto auto}.typo-numeric-setting.svelte-i0zktq b.svelte-i0zktq{font-size:1.1rem}.typo-numeric-setting.svelte-i0zktq input.svelte-i0zktq:invalid{border-color:unset}.typo-numeric-setting.svelte-i0zktq input[type=number].svelte-i0zktq{width:10ex}.typo-numeric-setting.svelte-i0zktq input[type=range].svelte-i0zktq{grid-column:span 2}.typo-numeric-setting.svelte-zlhfg4.svelte-zlhfg4{display:flex;flex-direction:column;justify-items:stretch;gap:.5rem}.typo-numeric-setting.svelte-zlhfg4 b.svelte-zlhfg4{font-size:1.1rem}.typo-text-setting.svelte-xq58hp.svelte-xq58hp{display:grid;align-items:center;grid-template-columns:auto auto;grid-template-rows:auto auto}.typo-text-setting.svelte-xq58hp b.svelte-xq58hp{font-size:1.1rem}.typo-text-setting.svelte-xq58hp input.svelte-xq58hp:invalid{border-color:unset}.typo-text-setting.svelte-xq58hp input.svelte-xq58hp{grid-column:span 2}.color-picker.svelte-1x2m4l5.svelte-1x2m4l5.svelte-1x2m4l5{color:var(--COLOR_PANEL_TEXT);-webkit-user-select:none;user-select:none;display:flex;flex-direction:column;gap:.5rem;width:100%}.color-picker.svelte-1x2m4l5 .picker-header.svelte-1x2m4l5.svelte-1x2m4l5{display:flex;width:100%;flex-direction:row;gap:1rem;align-items:center;justify-content:center}.color-picker.svelte-1x2m4l5 .picker-header.svelte-1x2m4l5>img.svelte-1x2m4l5{-webkit-user-select:none;user-select:none;height:1.2rem;width:1.2rem;filter:drop-shadow(3px 3px 0px rgba(0,0,0,.3))}.color-picker.svelte-1x2m4l5 .picker-header h3.svelte-1x2m4l5.svelte-1x2m4l5{margin-bottom:0}.color-picker.svelte-1x2m4l5 .color-rect.svelte-1x2m4l5.svelte-1x2m4l5{width:100%;aspect-ratio:1;position:relative;cursor:crosshair;border-radius:3px}.color-picker.svelte-1x2m4l5 .color-rect .color-thumb.svelte-1x2m4l5.svelte-1x2m4l5{position:absolute;width:1rem;height:1rem;border-radius:50%;background-color:#fff}.color-picker.svelte-1x2m4l5 .color-rect .color-thumb.listen.svelte-1x2m4l5.svelte-1x2m4l5{display:none}.color-picker.svelte-1x2m4l5 .hue-rect.svelte-1x2m4l5.svelte-1x2m4l5{width:100%;height:1rem;position:relative;cursor:pointer;border-radius:3px;background:linear-gradient(to right,#ff0400,#ffc300 12.5%,#fff200,#dcff00 18.75%,#7dff00,#1dff00 31.25%,#00ff13,#00ff42 37.5%,#00fdff,#003eff 62.5%,#000fff,#2100ff 68.75%,#8000ff,#e000ff 81.25%,#f0e,#ff00bf 87.5%,red)}.color-picker.svelte-1x2m4l5 .hue-rect .hue-thumb.svelte-1x2m4l5.svelte-1x2m4l5{position:absolute;width:1rem;height:1rem;border-radius:50%;background-color:#fff}.color-picker.svelte-1x2m4l5 .alpha-rect.svelte-1x2m4l5.svelte-1x2m4l5{width:100%;height:1rem;position:relative;cursor:pointer;border-radius:3px}.color-picker.svelte-1x2m4l5 .alpha-rect .alpha-thumb.svelte-1x2m4l5.svelte-1x2m4l5{position:absolute;width:1rem;height:1rem;border-radius:50%;background-color:#fff}@keyframes svelte-1bdf7g-slideIn{0%{transform:scaleY(0);opacity:0}to{transform:scaleY(1);opacity:100}}@keyframes svelte-1bdf7g-slideOut{0%{transform:scaleY(1);opacity:100}to{transform:scaleY(0);opacity:0}}.typo-color-picker-button.svelte-1bdf7g.svelte-1bdf7g{aspect-ratio:1;position:relative}.typo-color-picker-button.svelte-1bdf7g .color-picker-button-content.svelte-1bdf7g{position:absolute;top:0;right:0;bottom:0;left:0;cursor:pointer}.typo-color-picker-button.svelte-1bdf7g .color-picker-popout.svelte-1bdf7g{position:absolute;z-index:10;width:20em;border-radius:10px;padding:1rem;background-color:var(--COLOR_PANEL_HI);filter:drop-shadow(0 5px 10px rgba(0,0,0,.3));animation:svelte-1bdf7g-slideIn .08s ease-out}.typo-color-picker-button.svelte-1bdf7g .color-picker-popout.closing.svelte-1bdf7g{animation:svelte-1bdf7g-slideOut .08s ease-out forwards}.typo-text-setting.svelte-1pjx4sn.svelte-1pjx4sn{gap:.5rem;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start}.typo-text-setting.svelte-1pjx4sn b.svelte-1pjx4sn{font-size:1.1rem}.typo-chat-controls{grid-area:chat;display:flex;justify-items:center;justify-content:end;gap:.5rem;margin-top:.5rem;margin-right:.5rem;margin-left:auto;height:min-content;z-index:1;-webkit-user-select:none;user-select:none}.typo-controls.svelte-1c97t9h.svelte-1c97t9h{position:fixed;display:flex;align-items:center;gap:.5em;z-index:100}.typo-controls.topleft.svelte-1c97t9h.svelte-1c97t9h{left:.5em;top:.5em}.typo-controls.topright.svelte-1c97t9h.svelte-1c97t9h{right:.5em;top:.5em}.typo-controls.bottomright.svelte-1c97t9h.svelte-1c97t9h{right:.5em;bottom:.5em}.typo-controls.bottomleft.svelte-1c97t9h.svelte-1c97t9h{left:.5em;bottom:.5em}.typo-controls.vertical.svelte-1c97t9h.svelte-1c97t9h{flex-direction:column}.typo-controls.horizontal.svelte-1c97t9h.svelte-1c97t9h{flex-direction:row}@media (max-aspect-ratio: 1){.typo-controls.svelte-1c97t9h:not(.expanded)>:not(.typo-controls-mobile-expand){display:none}}.typo-controls.svelte-1c97t9h .typo-controls-mobile-expand.svelte-1c97t9h{display:none}@media (max-aspect-ratio: 1){.typo-controls.svelte-1c97t9h .typo-controls-mobile-expand.svelte-1c97t9h{display:grid;place-content:center;height:2rem;aspect-ratio:1;border-radius:100%;background-color:var(--COLOR_PANEL_HI);background-size:1.2rem;background-position:center;background-repeat:no-repeat;cursor:pointer;-webkit-user-select:none;user-select:none;opacity:.9}}.typo-customizer-actions.svelte-2foe7d{position:absolute;display:flex;flex-direction:column;gap:4px;top:40px;right:4px}@media (max-aspect-ratio: 1){.typo-customizer-actions.svelte-2foe7d{gap:1.25vh;top:7.5vh;right:1.25vh}}.typo-toast-container{position:fixed;left:0;right:0;top:0;height:0;overflow:visible;z-index:10000;display:flex;flex-direction:column;align-items:center;gap:1rem;padding-top:1rem}#home .panel.typo-panel:has(.typo-panel-tab:empty:nth-child(2)) .panel-header.svelte-14yq9xv .svelte-14yq9xv:nth-child(1){display:none}#home .panel.typo-panel:has(.typo-panel-tab:empty:nth-child(3)) .panel-header.svelte-14yq9xv .svelte-14yq9xv:nth-child(2){display:none}#home .panel.typo-panel:has(.typo-panel-tab:empty:nth-child(4)) .panel-header.svelte-14yq9xv .svelte-14yq9xv:nth-child(3){display:none}#home .panel.typo-panel:has(.typo-panel-tab:empty:nth-child(5)) .panel-header.svelte-14yq9xv .svelte-14yq9xv:nth-child(4){display:none}#home .panel.typo-panel:not(:has(.typo-panel-tab:not(:empty))){display:none}#home .panel.panel-right{margin-left:20px}@media (max-aspect-ratio: 1){#home .panel.panel-right{margin-left:0;order:2}}#home .panel.panel-left{margin-right:20px}@media (max-aspect-ratio: 1){#home .panel.panel-left{margin-right:0;order:3}}#home .panel.typo-panel{flex:0 0 400px;max-height:calc(400px - 2em);margin-top:2em;display:flex;flex-direction:column;align-items:normal;justify-content:flex-start;color:var(--COLOR_PANEL_TEXT)}#home .panel.typo-panel .panel-header.svelte-14yq9xv.svelte-14yq9xv{display:flex;justify-content:space-between;font-weight:600}#home .panel.typo-panel .panel-header.svelte-14yq9xv h2.svelte-14yq9xv{cursor:pointer}#home .panel.typo-panel .panel-header.svelte-14yq9xv h2.inactive.svelte-14yq9xv{opacity:.5}#home .panel.typo-panel .typo-panel-tab.svelte-14yq9xv.svelte-14yq9xv{margin-top:1rem;overflow:auto;flex-grow:1}#home .panel.typo-panel>div.svelte-14yq9xv.svelte-14yq9xv:empty{display:none}.typo-toolbar{grid-area:4/3/4/3;border-radius:3px;background-color:var(--COLOR_CHAT_BG_BASE);display:flex;align-items:center;justify-content:space-evenly}@media (max-aspect-ratio: 1){.typo-toolbar{display:none}}.typo-toolbar:empty{display:none}#game-canvas #game-rate.typo-icons :is(.like,.dislike){background-repeat:no-repeat;background-size:90%;background-position:center}#game-canvas #game-rate.typo-icons .like,#game-wrapper:has(#game-rate.typo-icons) .player-bubble .icon[style*=thumbsup]{background-image:var(--file-img-thumbsup-gif)!important}#game-canvas #game-rate.typo-icons .dislike,#game-wrapper:has(#game-rate.typo-icons) .player-bubble .icon[style*=thumbsdown]{background-image:var(--file-img-thumbsdown-gif)!important}@keyframes svelte-c1csua-bounceload{0%{transform:scale(.5)}to{transform:translate(-40%) scale(1.5)}}div.svelte-c1csua.svelte-c1csua{display:flex;justify-content:center;align-items:center;gap:.5em;padding:.8em}div.svelte-c1csua .icon.svelte-c1csua{display:inline-block;height:1.5em;aspect-ratio:1;background-image:url(/img/size.gif);background-size:1em;background-repeat:no-repeat;background-position:center;transform:scale(1.5);filter:drop-shadow(3px 3px 0 rgba(0,0,0,.3));animation:svelte-c1csua-bounceload .5s infinite;animation-direction:alternate;animation-timing-function:ease-in-out;transform-origin:center;margin-right:.5em;margin-left:.5em}div.svelte-c1csua span.svelte-c1csua{color:var(--COLOR_PANEL_TEXT);font-weight:700}.typo-icon-button.svelte-b0w31n.svelte-b0w31n{-webkit-user-select:none;user-select:none;display:block;cursor:pointer;filter:drop-shadow(3px 3px 0px rgba(0,0,0,.3))}.typo-icon-button.disabled.svelte-b0w31n.svelte-b0w31n{pointer-events:none;opacity:.5}.typo-icon-button.svelte-b0w31n img.svelte-b0w31n{aspect-ratio:1;transform:translateY(0);transition:transform 65ms ease-in-out}.typo-icon-button.svelte-b0w31n:hover img.effect.svelte-b0w31n{transform:translateY(-3px)}.typo-icon-button.greyscale.svelte-b0w31n img.svelte-b0w31n{filter:grayscale(.7);opacity:.7}.typo-icon-button.greyscale.svelte-b0w31n img.svelte-b0w31n:hover{filter:grayscale(0);opacity:1}@keyframes svelte-12e6hb5-slideIn{0%{transform:translateY(-50vh);opacity:0}to{transform:translateY(0);opacity:100}}@keyframes svelte-12e6hb5-slideOut{0%{transform:translateY(0);opacity:100}to{transform:translateY(-50vh);opacity:0}}.typo-toast.svelte-12e6hb5.svelte-12e6hb5{padding:1rem 3rem 1rem 1rem;background-color:var(--COLOR_PANEL_HI);border-radius:5px;color:var(--COLOR_PANEL_TEXT);filter:drop-shadow(0 5px 10px rgba(0,0,0,.3));min-width:clamp(20rem,20rem,80%);position:relative;animation:svelte-12e6hb5-slideIn .15s ease-out;display:flex;flex-direction:column;align-items:flex-start;white-space-collapse:preserve;gap:.5rem}.typo-toast.closing.svelte-12e6hb5.svelte-12e6hb5{animation:svelte-12e6hb5-slideOut .15s ease-out forwards}.typo-toast.loading.svelte-12e6hb5.svelte-12e6hb5{cursor:progress}.typo-toast.svelte-12e6hb5 form.svelte-12e6hb5{display:flex;width:100%}.typo-toast.svelte-12e6hb5 form input[type=submit].svelte-12e6hb5{display:none}.typo-toast.svelte-12e6hb5 .typo-toast-confirm.svelte-12e6hb5{width:100%;display:flex;flex-direction:row;gap:1rem}.typo-toast.svelte-12e6hb5 .typo-toast-confirm span.svelte-12e6hb5{display:flex;flex-direction:row;gap:.5rem;cursor:pointer;align-items:center}.typo-toast.svelte-12e6hb5 .close-toast.svelte-12e6hb5{position:absolute;right:.5rem;top:0;font-weight:900;opacity:.7;cursor:pointer;font-size:2rem}.typo-chat-message.svelte-1q3466u.svelte-1q3466u{display:flex;flex-direction:row;align-items:center}.typo-chat-message.svelte-1q3466u b.info.svelte-1q3466u{color:var(--COLOR_CHAT_TEXT_DRAWING)}.typo-chat-message.svelte-1q3466u b.error.svelte-1q3466u{color:var(--COLOR_CHAT_TEXT_LEAVE)}.typo-chat-message.svelte-1q3466u b.success.svelte-1q3466u{color:var(--COLOR_CHAT_TEXT_GUESSED)}.typo-chat-message.svelte-1q3466u b.normal.svelte-1q3466u{color:var(--COLOR_CHAT_TEXT_BASE)}.typo-chat-message.svelte-1q3466u span.svelte-1q3466u{white-space:preserve}.typo-avatar-container.svelte-ma71bf.svelte-ma71bf{width:var(--typo-avatar-container-size);aspect-ratio:1;position:relative;z-index:0}.typo-avatar-container.svelte-ma71bf .typo-avatar-layer.svelte-ma71bf{position:absolute}.typo-avatar-container.svelte-ma71bf .typo-avatar-layer.svelte-ma71bf:is(.color,.mouth,.eyes,.special){background-repeat:no-repeat}.typo-avatar-container.svelte-ma71bf .typo-avatar-layer.svelte-ma71bf:is(.color,.mouth,.eyes){top:0;right:0;bottom:0;left:0}.typo-avatar-container.svelte-ma71bf .typo-avatar-layer.color.svelte-ma71bf{z-index:0;background-image:url(https://skribbl.io/img/avatar/color_atlas.gif)}.typo-avatar-container.svelte-ma71bf .typo-avatar-layer.mouth.svelte-ma71bf{z-index:1;background-image:url(https://skribbl.io/img/avatar/mouth_atlas.gif)}.typo-avatar-container.svelte-ma71bf .typo-avatar-layer.eyes.svelte-ma71bf{z-index:2;background-image:url(https://skribbl.io/img/avatar/eyes_atlas.gif)}.typo-avatar-container.svelte-ma71bf .typo-avatar-layer.special.svelte-ma71bf{z-index:3;background-image:url(https://skribbl.io/img/avatar/special_atlas.gif);inset:calc(-1 * var(--typo-avatar-container-size) * 32 / 48 / 2)}@keyframes svelte-1lmlzvv-slideIn{0%{transform:scaleY(0);opacity:0}to{transform:scaleY(1);opacity:100}}@keyframes svelte-1lmlzvv-slideOut{0%{transform:scaleY(1);opacity:100}to{transform:scaleY(0);opacity:0}}.typo-area-flyout.svelte-1lmlzvv.svelte-1lmlzvv.svelte-1lmlzvv{position:relative;color:var(--COLOR_PANEL_TEXT);z-index:1;border-radius:10px;padding:1em;animation:svelte-1lmlzvv-slideIn .08s ease-out;display:flex;gap:1rem;flex-direction:column;align-items:center}.typo-area-flyout.align-top.svelte-1lmlzvv.svelte-1lmlzvv.svelte-1lmlzvv{align-self:start;transform-origin:top}.typo-area-flyout.align-bottom.svelte-1lmlzvv.svelte-1lmlzvv.svelte-1lmlzvv{align-self:end;transform-origin:bottom}.typo-area-flyout.closing.svelte-1lmlzvv.svelte-1lmlzvv.svelte-1lmlzvv{animation:svelte-1lmlzvv-slideOut .08s ease-out forwards}.typo-area-flyout.svelte-1lmlzvv.svelte-1lmlzvv.svelte-1lmlzvv:after{animation:svelte-1lmlzvv-slideIn .08s ease-out;background:var(--COLOR_PANEL_BG);content:"";position:absolute;top:0;right:0;bottom:0;left:0;border-radius:10px;z-index:-1;transform:none!important;-webkit-backdrop-filter:blur(2px);backdrop-filter:blur(2px)}.typo-area-flyout.closing.svelte-1lmlzvv.svelte-1lmlzvv.svelte-1lmlzvv:after{animation:svelte-1lmlzvv-slideOut .08s ease-out forwards}.typo-area-flyout.svelte-1lmlzvv .close-explicit.svelte-1lmlzvv.svelte-1lmlzvv{position:absolute;top:0;right:.5rem;font-size:1.5rem;font-weight:900;cursor:pointer;z-index:1}.typo-area-flyout.svelte-1lmlzvv>h3.svelte-1lmlzvv.svelte-1lmlzvv{display:flex;gap:1em;align-items:center}.typo-area-flyout.svelte-1lmlzvv>h3.svelte-1lmlzvv>img.svelte-1lmlzvv{-webkit-user-select:none;user-select:none;height:1.8em;width:1.8em;filter:drop-shadow(3px 3px 0px rgba(0,0,0,.3))}.typo-area-flyout.svelte-1lmlzvv>.content.svelte-1lmlzvv.svelte-1lmlzvv{width:100%;overflow-y:auto}.typo-area-flyout.svelte-1lmlzvv>.content.padding.svelte-1lmlzvv.svelte-1lmlzvv{padding:0 1em}.typo-command-preview.svelte-19nsl5m.svelte-19nsl5m{display:flex;flex-direction:column;gap:1rem}.typo-command-preview.svelte-19nsl5m.svelte-19nsl5m:not(:has(.typo-command-result)){gap:.2rem}.typo-command-preview.svelte-19nsl5m .typo-command-result.svelte-19nsl5m{display:flex;flex-direction:column;gap:.2rem}.typo-command-preview.svelte-19nsl5m .typo-command-result .typo-command-result-synopsis.svelte-19nsl5m{display:flex;gap:.4rem;flex-wrap:wrap;align-items:center}.typo-command-preview.svelte-19nsl5m .typo-command-result .typo-command-result-synopsis .typo-command-result-arg.svelte-19nsl5m{background-color:var(--COLOR_PANEL_BG);padding:.2rem;border-radius:3px;opacity:.5}.typo-command-preview.svelte-19nsl5m .typo-command-result .typo-command-result-synopsis .typo-command-result-arg.current.svelte-19nsl5m{opacity:1}.typo-command-preview.svelte-19nsl5m .typo-command-result .typo-command-result-synopsis .typo-command-result-id.svelte-19nsl5m{padding:.2rem;border-radius:3px;font-weight:bolder}.typo-command-preview.svelte-19nsl5m .typo-command-result .typo-command-result-synopsis .typo-command-result-id.current.svelte-19nsl5m{background-color:var(--COLOR_PANEL_BG)}.typo-command-preview.svelte-19nsl5m .typo-command-result .typo-command-result-description .typo-command-result-param-type.svelte-19nsl5m{display:block;opacity:.7}.typo-command-preview.svelte-19nsl5m .typo-command-result .typo-command-result-state.svelte-19nsl5m{display:flex;gap:.5rem;align-items:center;margin-top:.3rem;opacity:.7}.typo-command-preview.svelte-19nsl5m .typo-command-result .typo-command-result-state img.svelte-19nsl5m{height:1.3rem}.chat-form:has(#typo-command-input) input:not(#typo-command-input){display:none}#game-chat:has(.typo-emojis-enabled) .typo-emoji-container{display:inline-flex;flex-wrap:wrap;align-items:center;gap:1ex}#game-chat:has(.typo-emojis-enabled) .typo-emoji-container .typo-emoji{background-image:var(--typo-emoji-url);color:transparent;overflow:hidden;width:1.5em;height:1.5em;background-size:contain;background-repeat:no-repeat;background-position:center;display:inline-block;image-rendering:auto}#game-chat:has(.typo-emojis-enabled) .typo-emoji-container .typo-emoji::selection{background-color:transparent;color:transparent}.typo-command-preview.svelte-198xt5o.svelte-198xt5o{display:flex;flex-wrap:wrap;flex-direction:row;gap:.5ex;justify-content:space-evenly}.typo-command-preview.svelte-198xt5o .emoji-picker-candidate.svelte-198xt5o{height:2.5em;aspect-ratio:1;image-rendering:auto;cursor:pointer;transition:transform .1s}.typo-command-preview.svelte-198xt5o .emoji-picker-candidate.svelte-198xt5o:hover{transform:scale(.9)}.typo-emoji-picker-hint.svelte-198xt5o.svelte-198xt5o{text-align:center;margin-bottom:1em;font-weight:600;text-overflow:ellipsis;overflow:hidden}form.chat-form.typo-extended input{padding-right:2.5em}.typo-ping-info.svelte-wetrhq{position:absolute;top:-1.2em;right:.2em;opacity:.5;font-weight:700;font-size:.8em}.typo-chat-profile-link{cursor:pointer}.typo-flat-button.svelte-1nuwppq.svelte-1nuwppq{padding:.5rem;border-radius:.5em;position:relative;-webkit-user-select:none;user-select:none;font-weight:700;text-shadow:1px 1px 0 rgba(0,0,0,.168627451)}.typo-flat-button.disabled.svelte-1nuwppq.svelte-1nuwppq{pointer-events:none;opacity:.5}.typo-flat-button.green.svelte-1nuwppq.svelte-1nuwppq{background-color:var(--COLOR_BUTTON_SUBMIT_BG);color:var(--COLOR_BUTTON_SUBMIT_TEXT)}.typo-flat-button.orange.svelte-1nuwppq.svelte-1nuwppq{background-color:var(--COLOR_BUTTON_DANGER_BG);color:var(--COLOR_BUTTON_DANGER_TEXT)}.typo-flat-button.blue.svelte-1nuwppq.svelte-1nuwppq{background-color:var(--COLOR_BUTTON_NORMAL_BG);color:var(--COLOR_BUTTON_NORMAL_TEXT)}.typo-flat-button.svelte-1nuwppq>span.svelte-1nuwppq{z-index:2;position:relative}.typo-flat-button.svelte-1nuwppq.svelte-1nuwppq:after{position:absolute;top:0;right:0;bottom:0;left:0;content:"";z-index:0;opacity:0;background:#000;transition:opacity .1s;border-radius:.5em}.typo-flat-button.svelte-1nuwppq.svelte-1nuwppq:hover:after{opacity:.1}.typo-quickreact-focus.svelte-yvtrmi.svelte-yvtrmi:focus{outline:none}.typo-quickreact-keys.svelte-yvtrmi.svelte-yvtrmi{display:grid;grid-template-columns:1fr 1fr;gap:1rem}.typo-quickreact-keys.svelte-yvtrmi b.svelte-yvtrmi{grid-column:span 2;text-align:center}@keyframes svelte-lwvpkp-slideIn{0%{transform:translateY(50vh);opacity:0}to{transform:translateY(0);opacity:100}}@keyframes svelte-lwvpkp-slideOut{0%{transform:translateY(0);opacity:100}to{transform:translateY(50vh);opacity:0}}@keyframes svelte-lwvpkp-fadeIn{0%{opacity:0}to{opacity:100}}@keyframes svelte-lwvpkp-fadeOut{0%{opacity:100}to{opacity:0}}div.content.svelte-lwvpkp.svelte-lwvpkp.svelte-lwvpkp{position:fixed;top:10vh;right:0;bottom:0;left:0;max-width:100vw;background:var(--COLOR_PANEL_BG);z-index:9999;animation:svelte-lwvpkp-slideIn .15s ease-out;-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px);display:flex;flex-direction:column;align-items:center;color:var(--COLOR_PANEL_TEXT)}div.content.closing.svelte-lwvpkp.svelte-lwvpkp.svelte-lwvpkp{animation:svelte-lwvpkp-slideOut .15s ease-out forwards}div.content.svelte-lwvpkp .content-title.svelte-lwvpkp.svelte-lwvpkp{display:flex;justify-content:space-between;width:100%;align-items:center;padding-left:2em;padding-right:2em}div.content.svelte-lwvpkp .content-title.svelte-lwvpkp>div.svelte-lwvpkp:last-child{-webkit-user-select:none;user-select:none;position:relative;top:-2vh;cursor:pointer;font-weight:700;font-size:2.5rem;opacity:.7}div.content.svelte-lwvpkp .content-title.svelte-lwvpkp>div.svelte-lwvpkp:last-child:hover{opacity:1}div.content.svelte-lwvpkp .content-wrapper.svelte-lwvpkp.svelte-lwvpkp{overscroll-behavior:none;display:flex;flex-direction:column;overflow-y:scroll;width:100%;align-items:stretch;flex-grow:1;padding:0 .5rem}div.content-top.svelte-lwvpkp.svelte-lwvpkp.svelte-lwvpkp{position:fixed;top:calc(7vh + 1px);z-index:9999;background:var(--COLOR_PANEL_BG);clip-path:polygon(100% 0,0% 100%,100% 100%);-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px);border:none;height:3vh;width:100vw;animation:svelte-lwvpkp-slideIn .15s ease-out}div.content-top.closing.svelte-lwvpkp.svelte-lwvpkp.svelte-lwvpkp{animation:svelte-lwvpkp-slideOut .15s ease-out forwards}div.backdrop.svelte-lwvpkp.svelte-lwvpkp.svelte-lwvpkp{position:fixed;top:0;right:0;bottom:0;left:0;background:#00000080;z-index:9998;animation:svelte-lwvpkp-fadeIn .15s ease-out}div.backdrop.closing.svelte-lwvpkp.svelte-lwvpkp.svelte-lwvpkp{animation:svelte-lwvpkp-fadeOut .15s ease-out forwards}body:has(.typo-modal){overflow:hidden}@keyframes svelte-1n76u56-slideIn{0%{transform:translateY(50vh);opacity:0}to{transform:translateY(0);opacity:100}}@keyframes svelte-1n76u56-slideOut{0%{transform:translateY(0);opacity:100}to{transform:translateY(50vh);opacity:0}}@keyframes svelte-1n76u56-fadeIn{0%{opacity:0}to{opacity:100}}@keyframes svelte-1n76u56-fadeOut{0%{opacity:100}to{opacity:0}}div.content.svelte-1n76u56.svelte-1n76u56.svelte-1n76u56{background:var(--COLOR_PANEL_BG);animation:svelte-1n76u56-slideIn .15s ease-out;-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px);max-height:calc(100vh - 4rem);max-width:calc(100vh - 4rem);display:flex;flex-direction:column;align-items:center;color:var(--COLOR_PANEL_TEXT);padding:2rem;border-radius:3px}div.content.closing.svelte-1n76u56.svelte-1n76u56.svelte-1n76u56{animation:svelte-1n76u56-slideOut .15s ease-out forwards}div.content.svelte-1n76u56 .content-title.svelte-1n76u56.svelte-1n76u56{display:flex;justify-content:space-between;width:100%;align-items:center;padding-left:2em;padding-right:2em}div.content.svelte-1n76u56 .content-title.svelte-1n76u56>div.svelte-1n76u56:last-child{-webkit-user-select:none;user-select:none;position:relative;top:-2vh;right:-2rem;cursor:pointer;font-weight:700;font-size:2.5rem;opacity:.7}div.content.svelte-1n76u56 .content-title.svelte-1n76u56>div.svelte-1n76u56:last-child:hover{opacity:1}div.content.svelte-1n76u56 .content-wrapper.svelte-1n76u56.svelte-1n76u56{overscroll-behavior:none;display:flex;flex-direction:column;overflow-y:scroll;width:100%;flex-grow:1;align-items:stretch;padding:0 .5rem}div.backdrop.svelte-1n76u56.svelte-1n76u56.svelte-1n76u56{position:fixed;top:0;right:0;bottom:0;left:0;background:#00000080;z-index:9999;animation:svelte-1n76u56-fadeIn .15s ease-out;display:grid;place-content:center;padding:3rem}div.backdrop.closing.svelte-1n76u56.svelte-1n76u56.svelte-1n76u56{animation:svelte-1n76u56-fadeOut .15s ease-out forwards}.typo-gallery-grid.svelte-skb05m.svelte-skb05m.svelte-skb05m{display:grid;grid-template-columns:20rem auto;gap:2rem;width:100%;padding-left:2rem;padding-right:2rem;padding-top:2rem;flex-grow:1;overflow:hidden}.typo-gallery-grid.svelte-skb05m h3.svelte-skb05m.svelte-skb05m{text-align:center}.typo-gallery-grid.svelte-skb05m .gallery-sidebar.svelte-skb05m.svelte-skb05m{display:flex;flex-direction:column;gap:.5rem;border-right:1px solid var(--COLOR_PANEL_BORDER_FOCUS);padding-right:2rem;margin-bottom:2rem;transition:opacity .06s;grid-area:1/1/1/1}.typo-gallery-grid.svelte-skb05m .gallery-sidebar.svelte-skb05m>.svelte-skb05m:not(span,.navigate-page){margin-bottom:1rem}.typo-gallery-grid.svelte-skb05m .gallery-sidebar .navigate-page.svelte-skb05m.svelte-skb05m{width:100%;justify-content:space-between;display:flex;gap:1rem;align-items:center;margin-top:auto}.typo-gallery-grid.svelte-skb05m .gallery-sidebar .navigate-page span.svelte-skb05m.svelte-skb05m{font-weight:600;-webkit-user-select:none;user-select:none}.typo-gallery-grid.svelte-skb05m .gallery-sidebar.present.svelte-skb05m.svelte-skb05m{opacity:0;pointer-events:none}.typo-gallery-grid.svelte-skb05m .gallery-results.svelte-skb05m.svelte-skb05m{height:100%;overflow:auto;display:grid;grid-template-columns:repeat(auto-fill,20rem);gap:1rem;justify-content:space-between;margin-bottom:2rem;grid-area:1/2/1/2;transition:opacity .06s}.typo-gallery-grid.svelte-skb05m .gallery-results img.svelte-skb05m.svelte-skb05m{width:100%;cursor:pointer;border-radius:3px}.typo-gallery-grid.svelte-skb05m .gallery-results .loading.svelte-skb05m.svelte-skb05m{grid-column:1/-1;display:grid}.typo-gallery-grid.svelte-skb05m .gallery-results.present.svelte-skb05m.svelte-skb05m{opacity:0;pointer-events:none}.typo-gallery-grid.svelte-skb05m .present-image.svelte-skb05m.svelte-skb05m{grid-area:1/2/1/2;display:flex;flex-wrap:wrap;justify-content:center;align-items:center;overflow:auto}.typo-gallery-grid.svelte-skb05m .present-image img.svelte-skb05m.svelte-skb05m{border-radius:3px}.typo-gallery-grid.svelte-skb05m .present-sidebar.svelte-skb05m.svelte-skb05m{display:flex;flex-direction:column;gap:.5rem;border-right:1px solid var(--COLOR_PANEL_BORDER_FOCUS);padding-right:2rem;margin-bottom:2rem;grid-area:1/1/1/1}.typo-gallery-grid.svelte-skb05m .present-sidebar .exit-present.svelte-skb05m.svelte-skb05m{cursor:pointer;display:flex;gap:1rem;justify-content:center;align-items:center;font-weight:600;margin-top:auto}.typo-themes-browser-header.svelte-17gbclg.svelte-17gbclg{padding-bottom:1rem;text-align:center}.typo-themes-browser-list.svelte-17gbclg.svelte-17gbclg{display:flex;flex-direction:row;gap:1rem;flex-wrap:wrap;justify-content:center}.typo-themes-browser-item.svelte-17gbclg.svelte-17gbclg{background-color:var(--COLOR_PANEL_HI);border-radius:3px;padding:1rem;gap:1rem;justify-content:start;align-items:center;width:clamp(min(100%,30em),min(100%,30em),max(100%,30em));display:grid;grid-template-columns:auto 1fr}.typo-themes-browser-item.svelte-17gbclg span.svelte-17gbclg{opacity:.5}.typo-themes-browser-item.svelte-17gbclg div.svelte-17gbclg{justify-self:end}.typo-themes-editor.svelte-1gh1qig.svelte-1gh1qig{display:flex;flex-direction:column;height:100%}.typo-themes-editor-header.svelte-1gh1qig.svelte-1gh1qig{padding-bottom:1rem;text-align:center}.typo-themes-editor-content.svelte-1gh1qig.svelte-1gh1qig{display:flex;flex-direction:column;gap:2rem;align-items:start;padding:0 2rem;overflow:auto}details.svelte-1gh1qig.svelte-1gh1qig{border-radius:3px;padding:.5rem 1rem}details[open].svelte-1gh1qig.svelte-1gh1qig{background-color:var(--COLOR_PANEL_HI)}details[open].svelte-1gh1qig summary.svelte-1gh1qig{margin-bottom:.5rem}summary.svelte-1gh1qig.svelte-1gh1qig{font-weight:700;cursor:pointer;-webkit-user-select:none;user-select:none;font-size:1.2rem}.typo-themes-editor-content-section.svelte-1gh1qig.svelte-1gh1qig{display:flex;flex-direction:row;gap:3rem;flex-wrap:wrap;align-items:center;width:100%;padding-bottom:.5rem}.typo-themes-editor-content-section.svelte-1gh1qig .group.svelte-1gh1qig{display:flex;flex-direction:row;gap:1rem;align-items:center}.typo-themes-editor-content-section.svelte-1gh1qig .group.svelte-1gh1qig:vertical{flex-direction:column}.typo-themes-editor-content-section.svelte-1gh1qig .group input.svelte-1gh1qig{width:auto;box-sizing:border-box}.color-pickers.svelte-1gh1qig.svelte-1gh1qig,.style-hooks.svelte-1gh1qig.svelte-1gh1qig{display:grid;grid-template-columns:auto auto;grid-gap:.5rem 2rem}.typo-themes-list-header.svelte-wdh6rb.svelte-wdh6rb.svelte-wdh6rb{padding-bottom:1rem;text-align:center}.typo-themes-list-list.svelte-wdh6rb.svelte-wdh6rb.svelte-wdh6rb{display:flex;flex-direction:row;gap:1rem;flex-wrap:wrap;justify-content:center}.typo-themes-list-item.svelte-wdh6rb.svelte-wdh6rb.svelte-wdh6rb{background-color:var(--COLOR_PANEL_HI);border-radius:3px;padding:1rem;gap:1rem;justify-content:center;align-items:start;display:flex;flex-direction:column;width:clamp(min(100%,20em),min(100%,20em),max(100%,20em))}.typo-themes-list-item.svelte-wdh6rb .active-marker.svelte-wdh6rb.svelte-wdh6rb{display:flex;gap:.5rem;align-items:center}.typo-themes-list-item.svelte-wdh6rb .active-marker img.svelte-wdh6rb.svelte-wdh6rb{height:1.5rem;aspect-ratio:1}.typo-themes-list-item.svelte-wdh6rb>div.svelte-wdh6rb.svelte-wdh6rb{display:flex;flex-direction:row;gap:1rem;width:100%}.typo-themes-list-item.svelte-wdh6rb>div span.svelte-wdh6rb.svelte-wdh6rb{opacity:.5}.typo-themes-list-item.svelte-wdh6rb>div.svelte-wdh6rb>.svelte-wdh6rb:last-child:not(:first-child){flex-grow:1;text-align:end}.typo-themes-content.svelte-1ikbg14.svelte-1ikbg14{padding:1rem;width:100%;height:100%;display:flex;flex-direction:column;overflow:auto}.typo-themes-navigation.svelte-1ikbg14.svelte-1ikbg14{display:flex;align-items:center;justify-content:center;gap:2rem;margin-top:1rem;margin-bottom:2rem}.typo-themes-navigation.svelte-1ikbg14 h3.svelte-1ikbg14{opacity:.5;cursor:pointer}.typo-themes-navigation.svelte-1ikbg14 h3.selected.svelte-1ikbg14{opacity:1}.typo-themes-tab.svelte-1ikbg14.svelte-1ikbg14{overflow:auto}.typo-palette-builder-container.svelte-nspiqx.svelte-nspiqx{background-color:var(--COLOR_PANEL_HI);border-radius:3px;gap:2rem;padding:1rem;display:grid;grid-template-columns:auto auto;flex-direction:column}.typo-palette-builder-container.svelte-nspiqx .typo-palette-builder-inputs.svelte-nspiqx{display:flex;flex-direction:column;gap:.5rem}.typo-palette-builder-container.svelte-nspiqx .typo-palette-builder-inputs b.svelte-nspiqx{margin-top:.5rem}.typo-palette-builder-container.svelte-nspiqx .typo-palette-builder-actions.svelte-nspiqx{display:flex;flex-direction:column;gap:.5rem}.typo-palette-builder-container.svelte-nspiqx .typo-palette-builder-colors.svelte-nspiqx{display:grid;gap:.2rem}.typo-color-palette-manage-list.svelte-vvz4gm{display:flex;flex-direction:row-reverse;gap:1rem;flex-wrap:wrap;justify-content:flex-end}#game-toolbar .typo-palette.colors.svelte-1mmx4c4.svelte-1mmx4c4{height:fit-content}.typo-palette-picker.svelte-1mmx4c4.svelte-1mmx4c4{display:grid;overflow:hidden;border-radius:var(--BORDER_RADIUS);max-width:calc(13 * var(--UNIT) / 2);overflow-x:auto}.typo-palette-picker.svelte-1mmx4c4 .typo-palette-picker-item.svelte-1mmx4c4{aspect-ratio:1;height:calc(var(--UNIT) / 2);cursor:pointer;position:relative}.typo-palette-picker.svelte-1mmx4c4 .typo-palette-picker-item.svelte-1mmx4c4:after{content:"";position:absolute;left:2px;top:2px;right:2px;bottom:2px;border-radius:3px}.typo-palette-picker.svelte-1mmx4c4 .typo-palette-picker-item.svelte-1mmx4c4:hover:after{border-width:3px;border-style:solid;border-color:#0009}.color-tools.svelte-iqw7hb.svelte-iqw7hb{height:var(--UNIT);width:calc(var(--UNIT) / 2)}.color-tools.svelte-iqw7hb .pipette.svelte-iqw7hb,.color-tools.svelte-iqw7hb .picker.svelte-iqw7hb{height:50%;width:100%;color:var(--COLOR_TOOL_TEXT);background-color:var(--COLOR_TOOL_BASE);cursor:pointer;background-size:contain;background-position:center;background-repeat:no-repeat}.color-tools.svelte-iqw7hb .pipette.svelte-iqw7hb:hover,.color-tools.svelte-iqw7hb .picker.svelte-iqw7hb:hover{background-color:var(--COLOR_TOOL_HOVER)}.color-tools.svelte-iqw7hb .pipette.selected.svelte-iqw7hb{background-color:var(--COLOR_TOOL_ACTIVE)}.color-tools.svelte-iqw7hb .pipette.svelte-iqw7hb{border-bottom:1px solid lightgray;background-image:var(--file-img-crosshair-gif);border-radius:var(--BORDER_RADIUS) var(--BORDER_RADIUS) 0 0}.color-tools.svelte-iqw7hb .picker.svelte-iqw7hb{border-top:1px solid lightgray;background-image:var(--file-img-inspect-gif);border-radius:0 0 var(--BORDER_RADIUS) var(--BORDER_RADIUS)}canvas.svelte-18097wc{border-radius:3px;width:10rem}@keyframes svelte-15kb90n-drop-in{0%{transform:translateY(-50%);opacity:0}to{transform:translateY(0);opacity:1}}.typo-drop.svelte-15kb90n{position:absolute;bottom:5px;height:48px;aspect-ratio:1;background-size:cover;background-position:center;cursor:pointer;-webkit-user-select:none;user-select:none;animation:svelte-15kb90n-drop-in .05s ease-in forwards}.typo-drop-claims.svelte-qhyy9.svelte-qhyy9{display:flex;flex-direction:column;gap:.5rem}.typo-drop-claims.svelte-qhyy9 .typo-drop-claims-claim.svelte-qhyy9{display:flex;gap:.4rem}@keyframes svelte-dq3z80-warn-blink{0%{opacity:1}25%{opacity:0}50%{opacity:0}75%{opacity:1}to{opacity:1}}#game-word .hints{position:relative}.typo-hints-overlay.svelte-dq3z80.svelte-dq3z80{position:absolute;display:flex;gap:.08em;z-index:10}.typo-hints-overlay.warning.svelte-dq3z80.svelte-dq3z80{z-index:11;animation:svelte-dq3z80-warn-blink .7s infinite}.typo-hints-overlay.warning.svelte-dq3z80 .overlay-character.warning.svelte-dq3z80{opacity:1;color:red;background-color:var(--COLOR_CHAT_BG_BASE)}.typo-hints-overlay.warning.svelte-dq3z80 .overlay-character.svelte-dq3z80:not(.warning){opacity:0}.typo-hints-overlay.correct.svelte-dq3z80 .overlay-character.warning.svelte-dq3z80{opacity:0}.typo-hints-overlay.svelte-dq3z80 .overlay-character.svelte-dq3z80{width:1ch;color:inherit;opacity:.6}.typo-hints-overlay.svelte-dq3z80 .overlay-character.hidden.svelte-dq3z80{opacity:0}.agent-content.svelte-z5nxkg.svelte-z5nxkg{z-index:1;width:100%;display:flex;flex-direction:column;gap:1rem;position:relative}.agent-content.svelte-z5nxkg>img.svelte-z5nxkg{width:100%;border-radius:3px;cursor:pointer}.agent-inputs.svelte-z5nxkg.svelte-z5nxkg{display:flex;gap:1rem}.agent-inputs.svelte-z5nxkg input.svelte-z5nxkg{flex-grow:1}.status-info.svelte-1y63bp4.svelte-1y63bp4,.typo-lobby-status-settings.svelte-1y63bp4.svelte-1y63bp4{display:flex;flex-direction:column;gap:1rem}.typo-lobby-status-settings.svelte-1y63bp4 .status-settings.svelte-1y63bp4{display:flex;gap:1rem;flex-direction:column}.typo-cabin.svelte-10x5c2g.svelte-10x5c2g{height:100%;overflow:auto;position:relative}.typo-cabin.svelte-10x5c2g .typo-cabin-saving.svelte-10x5c2g{position:absolute;top:0;right:0;bottom:0;left:0;display:none;place-content:center;z-index:2}.typo-cabin.loading.svelte-10x5c2g .typo-cabin-saving.svelte-10x5c2g{display:grid}.typo-cabin.loading.svelte-10x5c2g .typo-cabin-picker.svelte-10x5c2g{opacity:.2}.typo-cabin.svelte-10x5c2g .typo-cabin-scroll.svelte-10x5c2g{height:100%;overflow:auto;padding-right:.5rem}.typo-cabin-picker.svelte-10x5c2g.svelte-10x5c2g{display:grid;grid-template-columns:1fr 1fr 1fr;grid-gap:.5rem}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-scene.svelte-10x5c2g{order:0;grid-column:span 3;width:100%;aspect-ratio:3;background-color:var(--COLOR_PANEL_BG);border-radius:5px;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:.5rem;overflow:hidden;transition:transform .1s;cursor:pointer;-webkit-user-select:none;user-select:none;position:relative}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-scene .typo-cabin-scene-thumb.svelte-10x5c2g{position:absolute;top:0;right:0;bottom:0;left:0;background-size:cover;background-position:center;background-repeat:no-repeat;z-index:0;opacity:1;transition:opacity .1s}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-scene.svelte-10x5c2g:hover{transform:scale(.95)}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-scene:hover .typo-cabin-scene-info.svelte-10x5c2g{opacity:1}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-scene:hover .typo-cabin-scene-thumb.svelte-10x5c2g{opacity:.2}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-scene .typo-cabin-scene-info.svelte-10x5c2g{opacity:0;text-align:center;font-size:.8rem;transition:opacity .1s;z-index:1}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-scene .typo-cabin-scene-info.visible.svelte-10x5c2g{opacity:1}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-slot.svelte-10x5c2g{background-color:var(--COLOR_PANEL_BG);border-radius:5px;width:100%;aspect-ratio:1;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:.5rem;overflow:hidden;transition:transform .1s;cursor:pointer;-webkit-user-select:none;user-select:none;position:relative}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-slot .typo-cabin-slot-thumb.svelte-10x5c2g{position:absolute;top:0;right:0;bottom:0;left:0;background-size:cover;background-position:center;background-repeat:no-repeat;z-index:0;opacity:1;transition:opacity .1s}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-slot.svelte-10x5c2g:hover:not(.dragging){transform:scale(.9)}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-slot:hover:not(.dragging) .typo-cabin-slot-info.svelte-10x5c2g{opacity:1}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-slot:hover:not(.dragging) .typo-cabin-slot-thumb.svelte-10x5c2g{opacity:.2}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-slot .typo-cabin-slot-info.svelte-10x5c2g{opacity:0;text-align:center;font-size:.8rem;transition:opacity .1s;z-index:1}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-slot .typo-cabin-slot-info.visible.svelte-10x5c2g{opacity:1}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-slot.locked.svelte-10x5c2g{cursor:not-allowed}.typo-cabin-picker.svelte-10x5c2g .typo-cabin-slot.locked .typo-cabin-slot-info.svelte-10x5c2g{opacity:.9}.typo-sprite-picker.svelte-1bcvdme.svelte-1bcvdme{display:flex;flex-direction:column;width:100%;align-items:center;gap:2rem;margin-bottom:2rem;overflow:auto}.typo-sprite-picker.svelte-1bcvdme .typo-sprite-picker-filter.svelte-1bcvdme{display:flex;flex-direction:row;gap:2rem;align-items:center;justify-content:center}.typo-sprite-picker.svelte-1bcvdme .typo-sprite-picker-filter input.svelte-1bcvdme{width:auto}.typo-sprite-picker.svelte-1bcvdme .typo-sprite-picker-list.svelte-1bcvdme{flex-grow:1;width:100%;overflow:auto;display:grid;grid-template-columns:repeat(auto-fit,8rem);gap:1rem;padding:0 2rem}.typo-sprite-picker.svelte-1bcvdme .typo-sprite-picker-list .typo-sprite-picker-sprite.svelte-1bcvdme{background-color:var(--COLOR_PANEL_BG);border-radius:5px;display:flex;flex-direction:column;gap:.1rem;padding:.1rem;align-items:center;cursor:pointer;transition:transform .1s;aspect-ratio:1}.typo-sprite-picker.svelte-1bcvdme .typo-sprite-picker-list .typo-sprite-picker-sprite.svelte-1bcvdme:hover{transform:scale(.9)}.typo-sprite-picker.svelte-1bcvdme .typo-sprite-picker-list .typo-sprite-picker-sprite .typo-sprite-picker-sprite-thumb.svelte-1bcvdme{width:5rem;aspect-ratio:1;background-size:cover}.typo-sprite-picker.svelte-1bcvdme .typo-sprite-picker-list .typo-sprite-picker-sprite span.svelte-1bcvdme{font-size:.9rem;opacity:.9;text-align:center}.typo-scene-picker.svelte-1s2xvs0.svelte-1s2xvs0{display:flex;flex-direction:column;width:100%;align-items:center;gap:2rem;margin-bottom:2rem;overflow:auto}.typo-scene-picker.svelte-1s2xvs0 .typo-scene-picker-list.svelte-1s2xvs0{flex-grow:1;width:100%;overflow:auto;display:flex;align-items:center;flex-direction:column;gap:1rem;padding:0 2rem}.typo-scene-picker.svelte-1s2xvs0 .typo-scene-picker-list .typo-scene-picker-scene.svelte-1s2xvs0{background-color:var(--COLOR_PANEL_BG);border-radius:3px;display:flex;flex-direction:column;gap:.1rem;padding:.4rem;align-items:center;cursor:pointer;transition:transform .1s}.typo-scene-picker.svelte-1s2xvs0 .typo-scene-picker-list .typo-scene-picker-scene.svelte-1s2xvs0:hover{transform:scale(.9)}.typo-scene-picker.svelte-1s2xvs0 .typo-scene-picker-list .typo-scene-picker-scene .typo-scene-picker-scene-thumb.svelte-1s2xvs0{width:20rem;max-width:90%;aspect-ratio:3;background-size:cover;border-radius:3px}.typo-scene-picker.svelte-1s2xvs0 .typo-scene-picker-list .typo-scene-picker-scene span.svelte-1s2xvs0{font-size:.9rem;opacity:.9;text-align:center}.typo-scene-picker.svelte-1s2xvs0 .typo-scene-picker-list .typo-scene-picker-scene span.id.svelte-1s2xvs0{opacity:.5}.typo-scene-picker.svelte-1s2xvs0 .typo-scene-picker-list .typo-scene-picker-scene span.name.svelte-1s2xvs0{font-weight:700}div.panel-changelog.svelte-eh7e5t.svelte-eh7e5t{display:flex;flex-direction:column;justify-content:center;padding:0 .5rem}div.panel-changelog.svelte-eh7e5t>.changelog.svelte-eh7e5t{white-space:pre;text-wrap:pretty}div.panel-changelog.svelte-eh7e5t>.changelog .change.svelte-eh7e5t{display:flex;flex-direction:column;gap:.5rem;padding:.5rem 0}div.panel-changelog.svelte-eh7e5t>.changelog .change.svelte-eh7e5t:has(.details){cursor:pointer}div.panel-changelog.svelte-eh7e5t>.changelog .change .details.svelte-eh7e5t{font-size:.8rem;opacity:.7}div.panel-changelog.svelte-eh7e5t>.changelog .change.svelte-eh7e5t:not(:last-child){border-bottom:1px solid var(--COLOR_PANEL_BORDER_FOCUS)}div.panel-changelog.svelte-eh7e5t>.changelog .change .title.svelte-eh7e5t{display:flex;justify-content:space-between;gap:1rem;align-items:center}div.panel-changelog.svelte-eh7e5t>.changelog .change .title span.svelte-eh7e5t{font-size:.8rem;opacity:.7}div.panel-changelog.svelte-eh7e5t .typo-version.svelte-eh7e5t{font-size:.8rem;opacity:.7}.details.svelte-mkybs6{padding:0 1rem}.details.svelte-mkybs6 li{margin-left:1rem}.details.svelte-mkybs6 :is(p,ul,ol){margin-bottom:1.5rem}.info.svelte-mkybs6{display:flex;gap:1.5rem;justify-content:center;font-size:.8em;opacity:.8}.typo-lobbies-discord.svelte-tkvjrc.svelte-tkvjrc.svelte-tkvjrc{display:flex;flex-direction:column;gap:.5rem;padding-bottom:1rem;padding-right:.5rem}.typo-lobbies-discord.svelte-tkvjrc .typo-lobbies-discord-buttons.svelte-tkvjrc.svelte-tkvjrc{display:flex;flex-wrap:wrap;gap:.5rem}.typo-lobbies-discovered.svelte-tkvjrc.svelte-tkvjrc.svelte-tkvjrc{padding-top:1rem;display:flex;flex-direction:column;gap:.5rem;padding-right:.5rem;border-top:1px solid var(--COLOR_PANEL_BORDER_FOCUS)}.typo-lobbies-discovered.svelte-tkvjrc .typo-lobbies-discovered-buttons.svelte-tkvjrc.svelte-tkvjrc{display:flex;flex-direction:column-reverse;gap:.5rem}.typo-lobbies-discovered.svelte-tkvjrc .typo-lobbies-discovered-buttons.svelte-tkvjrc>div.svelte-tkvjrc{display:grid;grid-template-columns:auto auto;grid-template-rows:1fr 1fr;gap:1rem;row-gap:0;place-items:center;background-color:var(--COLOR_PANEL_BG);padding:.2rem;border-radius:3px;font-size:.9rem;cursor:pointer;-webkit-user-select:none;user-select:none}.typo-lobbies-discovered.svelte-tkvjrc .typo-lobbies-discovered-buttons>div.svelte-tkvjrc b.svelte-tkvjrc{opacity:.7;justify-self:baseline}.typo-lobbies-discovered.svelte-tkvjrc .typo-lobbies-discovered-buttons>div.svelte-tkvjrc span.svelte-tkvjrc{grid-column:2/2;grid-row:1/3}div.typo-news.svelte-1x3jcfi.svelte-1x3jcfi{display:flex;flex-direction:column;justify-content:center;padding:0 .5rem}div.typo-news.svelte-1x3jcfi>.news.svelte-1x3jcfi{white-space:pre;text-wrap:pretty;display:flex;flex-direction:column}div.typo-news.svelte-1x3jcfi>.news .announcement.svelte-1x3jcfi{display:flex;flex-direction:column;gap:.5rem;padding:.5rem 0}div.typo-news.svelte-1x3jcfi>.news .announcement.svelte-1x3jcfi:not(:last-child){border-bottom:1px solid var(--COLOR_PANEL_BORDER_FOCUS)}div.typo-news.svelte-1x3jcfi>.news .announcement .title.svelte-1x3jcfi{display:flex;justify-content:space-between;gap:1rem;align-items:center}div.typo-news.svelte-1x3jcfi>.news .announcement .title span.svelte-1x3jcfi{font-size:.8rem;opacity:.7}@keyframes svelte-ffctjy-appear{0%{opacity:0;scale:0}to{opacity:1;scale:1}}.typo-tooltip.svelte-ffctjy.svelte-ffctjy{position:fixed;display:flex;z-index:10000;align-items:center;animation:svelte-ffctjy-appear .1s forwards ease-out;pointer-events:none;transform-origin:0 0}.typo-tooltip.svelte-ffctjy span.svelte-ffctjy{background-color:var(--COLOR_TOOL_TIP_BG);color:var(--COLOR_PANEL_TEXT);border-radius:var(--BORDER_RADIUS);padding:7px;text-shadow:1px 1px 0 rgba(0,0,0,.2196078431);text-align:center;font-size:13px;font-weight:700;white-space:pre}.typo-tooltip.svelte-ffctjy .typo-tooltip-arrow.svelte-ffctjy{height:0;width:0}.typo-tooltip.E.svelte-ffctjy.svelte-ffctjy{transform:translateY(-50%);flex-direction:row}.typo-tooltip.E.svelte-ffctjy .typo-tooltip-arrow.svelte-ffctjy{border-right:10px solid var(--COLOR_TOOL_TIP_BG);border-top:10px solid transparent;border-bottom:10px solid transparent}.typo-tooltip.S.svelte-ffctjy.svelte-ffctjy{transform:translate(-50%);flex-direction:column}.typo-tooltip.S.svelte-ffctjy .typo-tooltip-arrow.svelte-ffctjy{border-bottom:10px solid var(--COLOR_TOOL_TIP_BG);border-left:10px solid transparent;border-right:10px solid transparent}.typo-tooltip.N.svelte-ffctjy.svelte-ffctjy{flex-direction:column-reverse;transform:translate(-50%) translateY(-100%)}.typo-tooltip.N.svelte-ffctjy .typo-tooltip-arrow.svelte-ffctjy{border-top:10px solid var(--COLOR_TOOL_TIP_BG);border-left:10px solid transparent;border-right:10px solid transparent}.typo-tooltip.W.svelte-ffctjy.svelte-ffctjy{flex-direction:row-reverse;transform:translate(-100%) translateY(-50%)}.typo-tooltip.W.svelte-ffctjy .typo-tooltip-arrow.svelte-ffctjy{border-left:10px solid var(--COLOR_TOOL_TIP_BG);border-top:10px solid transparent;border-bottom:10px solid transparent}#home .panel.member-info.svelte-j680fu.svelte-j680fu.svelte-j680fu.svelte-j680fu{display:flex;flex-direction:column;gap:1em;padding:1em;width:100%;margin-bottom:10px;color:var(--COLOR_PANEL_TEXT)}#home .panel.member-info.svelte-j680fu img.typo-icon.svelte-j680fu.svelte-j680fu.svelte-j680fu{height:1.2em;image-rendering:auto;aspect-ratio:1;content:var(--file-img-typo-gif)}#home .panel.member-info.svelte-j680fu>.member-login.svelte-j680fu.svelte-j680fu.svelte-j680fu{display:flex;align-items:center;gap:1rem;font-weight:700;font-size:.9rem;cursor:pointer;opacity:.7}#home .panel.member-info.svelte-j680fu>.member-info-header.svelte-j680fu.svelte-j680fu.svelte-j680fu{display:flex;justify-content:space-between;align-items:center}#home .panel.member-info.svelte-j680fu>.member-info-header.svelte-j680fu>span.svelte-j680fu.svelte-j680fu,#home .panel.member-info.svelte-j680fu>.member-info-header.svelte-j680fu>a.svelte-j680fu.svelte-j680fu{display:flex;align-items:center;gap:.5em;font-weight:700;font-size:.9rem;cursor:pointer;opacity:.7;color:inherit;text-decoration:none}#home .panel.member-info.svelte-j680fu>.member-info-stats.svelte-j680fu.svelte-j680fu.svelte-j680fu{display:flex;justify-content:space-evenly}#home .panel.member-info.svelte-j680fu>.member-info-stats.svelte-j680fu>div.svelte-j680fu.svelte-j680fu{display:flex;gap:.2em}#home .panel.member-info.svelte-j680fu>.member-info-stats.svelte-j680fu>div.svelte-j680fu>div.stat-icon.svelte-j680fu{height:1.5rem;aspect-ratio:1;background-position:center;background-size:cover;background-repeat:no-repeat}#home .panel.member-info.svelte-j680fu>.member-info-stats.svelte-j680fu>div.svelte-j680fu>span.svelte-j680fu{font-weight:700}#home .panel.member-info.svelte-j680fu>.member-info-stats.svelte-j680fu>div.svelte-j680fu>span.svelte-j680fu:nth-child(2){opacity:.8}@keyframes svelte-1593rkb-iconAppear{0%{opacity:.3;transform:scale(0) translateY(30px)}50%{opacity:1}to{opacity:0;transform:scale(1) translateY(-30px)}}.typo-onboarding-emote.svelte-1593rkb{height:30px;aspect-ratio:1;animation:svelte-1593rkb-iconAppear 2.5s forwards ease-out;position:absolute;-webkit-user-select:none;user-select:none}p.svelte-115f3km.svelte-115f3km,ul.svelte-115f3km.svelte-115f3km,h3.svelte-115f3km.svelte-115f3km,h4.svelte-115f3km.svelte-115f3km{margin-bottom:1rem}p.svelte-115f3km>.svelte-115f3km,ul.svelte-115f3km>.svelte-115f3km{text-align:start}a.svelte-115f3km.svelte-115f3km{cursor:pointer;font-weight:700}p.svelte-1d2n9p6,ul.svelte-1d2n9p6,h3.svelte-1d2n9p6,h4.svelte-1d2n9p6{margin-bottom:1rem}a.svelte-1d2n9p6{cursor:pointer;font-weight:700}.typo-onboarding-wrapper.svelte-bu1e3.svelte-bu1e3{display:flex;align-items:center;flex-direction:column;margin:1rem}.typo-onboarding-hero.svelte-bu1e3.svelte-bu1e3{display:grid;place-content:center;position:relative;padding:100px 300px;margin:40px 40px 2rem;transition:padding .4s,margin-top .4s}@media (max-aspect-ratio: 1){.typo-onboarding-hero.svelte-bu1e3.svelte-bu1e3{padding:4rem 0 0}}.typo-onboarding-hero.hidden.svelte-bu1e3.svelte-bu1e3{margin-top:0;padding:0}.typo-onboarding-hero.svelte-bu1e3>div.svelte-bu1e3{text-align:center;position:relative}.typo-onboarding-hero.svelte-bu1e3:hover:not(.hidden) .beta-credits.svelte-bu1e3{opacity:.5}.typo-onboarding-hero.svelte-bu1e3 .beta-credits.svelte-bu1e3{position:absolute;bottom:0;width:100%;opacity:0;-webkit-user-select:none;user-select:none;transition:opacity .4s;transition-delay:.5s;text-align:center;font-size:.8rem;z-index:10}.onboarding-tabs.svelte-bu1e3.svelte-bu1e3{display:flex;gap:1rem;justify-content:center}.onboarding-tabs.svelte-bu1e3 h4.svelte-bu1e3{cursor:pointer;padding:1rem;opacity:.5;-webkit-user-select:none;user-select:none;text-align:center}.onboarding-tabs.svelte-bu1e3 h4.active.svelte-bu1e3{opacity:1}.typo-onboarding-presets.svelte-bu1e3.svelte-bu1e3{display:flex;flex-direction:column;gap:1rem;align-items:center}.typo-onboarding-presets.svelte-bu1e3 .typo-onboarding-preset.svelte-bu1e3{position:relative;cursor:pointer;background-color:var(--COLOR_PANEL_HI);border-radius:3px;padding:1rem;display:flex;flex-direction:column;gap:1rem;width:clamp(min(40em,100%),min(40em,100%),max(40em,100%));transition:transform .2s}.typo-onboarding-presets.svelte-bu1e3 .typo-onboarding-preset.svelte-bu1e3:hover{transform:translate(1rem)}.typo-onboarding-presets.svelte-bu1e3 .typo-onboarding-preset.svelte-bu1e3:hover:before{opacity:1}.typo-onboarding-presets.svelte-bu1e3 .typo-onboarding-preset.svelte-bu1e3:before{content:"";background-image:var(--file-img-arrow-right-gif);background-repeat:no-repeat;background-size:contain;width:2.5rem;background-position:center;position:absolute;top:0;bottom:0;left:-3.5rem;opacity:0;transition:opacity .2s;pointer-events:none}.typo-onboarding-checklist-wrapper.svelte-bu1e3.svelte-bu1e3{display:flex;flex-direction:column;align-items:stretch}.typo-onboarding-checklist-wrapper.svelte-bu1e3 .typo-onboarding-checklist.svelte-bu1e3{display:flex;flex-direction:column;gap:1rem;align-items:center;margin-top:1rem}.typo-onboarding-checklist-wrapper.svelte-bu1e3 .typo-onboarding-checklist .typo-onboarding-task.svelte-bu1e3{cursor:pointer;background-color:var(--COLOR_PANEL_HI);border-radius:3px;padding:1rem;display:flex;flex-direction:column;gap:1rem;width:clamp(min(40em,100%),min(40em,100%),max(40em,100%))}.typo-onboarding-checklist-wrapper.svelte-bu1e3 .typo-onboarding-checklist .typo-onboarding-task.done.svelte-bu1e3{cursor:auto}.typo-onboarding-checklist-wrapper.svelte-bu1e3 .typo-onboarding-checklist .typo-onboarding-task.done .description.svelte-bu1e3{opacity:.5}.typo-onboarding-checklist-wrapper.svelte-bu1e3 .typo-onboarding-checklist .typo-onboarding-task .details.svelte-bu1e3{display:flex;gap:1rem}.typo-onboarding-extras.svelte-bu1e3.svelte-bu1e3{display:flex;flex-direction:row;gap:3rem;align-self:stretch;padding:0 2rem 2rem}@media (max-aspect-ratio: 1){.typo-onboarding-extras.svelte-bu1e3.svelte-bu1e3{flex-direction:column}}.typo-onboarding-extras.svelte-bu1e3 .typo-onboarding-extras-sections.svelte-bu1e3{display:flex;flex-direction:column;gap:1rem}.typo-onboarding-extras.svelte-bu1e3 .typo-onboarding-extras-sections b.svelte-bu1e3{cursor:pointer;opacity:.5;-webkit-user-select:none;user-select:none}.typo-onboarding-extras.svelte-bu1e3 .typo-onboarding-extras-sections b.active.svelte-bu1e3{opacity:1}.typo-onboarding-extras.svelte-bu1e3 .typo-onboarding-extras-content.svelte-bu1e3{flex-grow:1;display:flex;flex-direction:column;align-items:center}.typo-profiles.svelte-16buojm.svelte-16buojm{display:flex;flex-direction:column;gap:1rem;align-items:stretch;width:fit-content}.typo-profiles.svelte-16buojm .typo-profile.svelte-16buojm{display:flex;position:relative;gap:1rem;cursor:pointer;border-radius:3px;padding:.5rem;align-items:center;background-color:var(--COLOR_PANEL_HI);transition:transform .2s;justify-content:space-between}.typo-profiles.svelte-16buojm .typo-profile.svelte-16buojm:hover{transform:translate(1rem)}.typo-profiles.svelte-16buojm .typo-profile.svelte-16buojm:hover:before{opacity:1}.typo-profiles.svelte-16buojm .typo-profile.svelte-16buojm:before{content:"";background-image:var(--file-img-arrow-right-gif);background-repeat:no-repeat;background-size:contain;width:2rem;background-position:center;position:absolute;top:0;bottom:0;left:-3rem;opacity:0;transition:opacity .2s;pointer-events:none}.typo-feature-settings-hotkey.svelte-10zlzgr.svelte-10zlzgr{background-color:var(--COLOR_PANEL_HI);display:grid;grid-template-columns:auto auto auto auto;grid-template-rows:1fr 1fr;flex-direction:column;border-radius:3px;gap:1rem;padding:1rem;align-items:center}.typo-feature-settings-hotkey.svelte-10zlzgr .inputs-disabled-hint.svelte-10zlzgr{font-size:.8rem;opacity:.7}.typo-feature-settings-hotkey.svelte-10zlzgr .button-container.svelte-10zlzgr{font-size:1em}.typo-feature-settings-command.svelte-lvvgs4.svelte-lvvgs4{background-color:var(--COLOR_PANEL_HI);display:grid;grid-template-columns:auto auto auto auto;grid-template-rows:1fr 1fr;flex-direction:column;border-radius:3px;gap:1rem;padding:1rem;align-items:center}.typo-feature-settings-command.svelte-lvvgs4 .button-container.svelte-lvvgs4{font-size:1em}.typo-feature-settings-title.svelte-1njssi3.svelte-1njssi3{width:100%;display:grid;grid-template-columns:1fr 1fr 1fr;align-items:center}.typo-feature-settings-title.svelte-1njssi3 .typo-feature-settings-hero.svelte-1njssi3{opacity:.7;font-weight:600;justify-self:start}.typo-feature-settings-title.svelte-1njssi3 .typo-feature-settings-back.svelte-1njssi3{cursor:pointer;opacity:.7;font-weight:600;justify-self:end}.typo-feature-settings-title.svelte-1njssi3 .typo-feature-settings-back.svelte-1njssi3:hover{opacity:1}.typo-feature-settings-title.svelte-1njssi3>h1.svelte-1njssi3{justify-self:center}.typo-feature-settings-summary.svelte-1njssi3.svelte-1njssi3{text-align:center}.typo-feature-settings-info.svelte-1njssi3.svelte-1njssi3,.typo-feature-settings-management.svelte-1njssi3.svelte-1njssi3,.typo-feature-settings-hotkeys.svelte-1njssi3.svelte-1njssi3,.typo-feature-settings-default.svelte-1njssi3.svelte-1njssi3{width:100%;display:flex;flex-direction:column}.typo-feature-settings-info.svelte-1njssi3 h2.svelte-1njssi3,.typo-feature-settings-management.svelte-1njssi3 h2.svelte-1njssi3,.typo-feature-settings-hotkeys.svelte-1njssi3 h2.svelte-1njssi3,.typo-feature-settings-default.svelte-1njssi3 h2.svelte-1njssi3{margin-bottom:.5em}.typo-feature-settings-default.svelte-1njssi3 .typo-feature-settings-default-list.svelte-1njssi3{display:flex;flex-direction:row;flex-wrap:wrap;gap:2rem}.typo-feature-settings-default.svelte-1njssi3 .typo-feature-settings-default-list .typo-feature-settings-default-item.svelte-1njssi3{min-width:clamp(20em,20em,100%);max-width:clamp(20em,20em,100%);background-color:var(--COLOR_PANEL_HI);border-radius:3px;display:flex;flex-direction:column;gap:1rem;padding:1rem;flex:1 1 0px;position:relative}.typo-feature-settings-hotkeys-list.svelte-1njssi3.svelte-1njssi3,.typo-feature-settings-commands-list.svelte-1njssi3.svelte-1njssi3{display:flex;flex-direction:row;gap:1rem;flex-wrap:wrap}.typo-feature-item.svelte-xje42n.svelte-xje42n{min-width:clamp(20em,20em,100%);max-width:clamp(20em,20em,100%);background-color:var(--COLOR_PANEL_HI);border-radius:3px;display:flex;flex-direction:column;gap:1rem;padding:1rem;flex:1 1 0px;position:relative}.typo-feature-item.hidden.svelte-xje42n.svelte-xje42n{display:none}.typo-feature-item.svelte-xje42n .feature-tags.svelte-xje42n{opacity:.5;font-size:.9rem;text-transform:lowercase}.typo-feature-item.devMode.svelte-xje42n .feature-id.svelte-xje42n{display:block;position:absolute;bottom:0;right:0;-webkit-user-select:none;user-select:none;opacity:.5;padding:.2rem}.typo-feature-item.svelte-xje42n .feature-id.svelte-xje42n{display:none}.typo-feature-item.svelte-xje42n .description.svelte-xje42n{flex-grow:1;display:flex;gap:1rem;align-items:center;-webkit-user-select:none;user-select:none}.typo-feature-item.svelte-xje42n .description[role=button].svelte-xje42n{cursor:pointer}.typo-feature-item.svelte-xje42n .description img.svelte-xje42n{filter:grayscale(100%);opacity:.7;width:1.5em;height:1.5em}.typo-feature-item.svelte-xje42n .description img.svelte-xje42n:hover{filter:grayscale(0%);opacity:1}.typo-feature-item.svelte-xje42n .name-toggle.svelte-xje42n{display:flex;align-items:center;gap:1rem;font-weight:700;font-size:1.2rem;cursor:pointer;-webkit-user-select:none;user-select:none}.typo-feature-item.svelte-xje42n .name-toggle.locked.svelte-xje42n{cursor:not-allowed}.typo-feature-item.svelte-xje42n .name-toggle.locked img.svelte-xje42n{filter:grayscale(100%);opacity:.7}.typo-feature-item.svelte-xje42n .name-toggle img.svelte-xje42n{width:1.5em;height:1.5em;filter:drop-shadow(3px 3px 0px rgba(0,0,0,.3))}.typo-feature-item.svelte-xje42n .name-toggle span.svelte-xje42n:last-child{font-size:1rem;opacity:.5;margin-left:auto;text-transform:uppercase}.typo-features-container.svelte-1ly2c3r.svelte-1ly2c3r{position:relative;width:100%;flex-grow:1;overflow-x:hidden}.typo-features-info.svelte-1ly2c3r.svelte-1ly2c3r{max-width:clamp(40em,40em,100%);text-align:left;padding-bottom:2em}.typo-features-filter.svelte-1ly2c3r.svelte-1ly2c3r{display:grid;gap:1rem;grid-template-columns:auto auto;padding-bottom:2em;align-items:center}.typo-features-filter.svelte-1ly2c3r .filters.svelte-1ly2c3r{display:flex;flex-wrap:wrap;gap:1rem}.typo-features-filter.svelte-1ly2c3r .filter.svelte-1ly2c3r{text-transform:lowercase;cursor:pointer;padding:.3rem;background-color:var(--COLOR_PANEL_HI);border-radius:3px;opacity:.6}.typo-features-filter.svelte-1ly2c3r .filter.selected.svelte-1ly2c3r{opacity:1}.typo-feature-settings.svelte-1ly2c3r.svelte-1ly2c3r{position:absolute;top:0;right:0;bottom:0;left:0;display:flex;flex-direction:column;gap:2rem;margin:0 2em 2em;padding:2em;overflow:auto;transform:translate(-100vw);transition:transform .1s ease-in-out;border-radius:3px}.typo-feature-settings.settingsVisible.svelte-1ly2c3r.svelte-1ly2c3r{transform:translate(0)}.typo-features.svelte-1ly2c3r.svelte-1ly2c3r{display:flex;flex-direction:column;align-items:center;position:absolute;top:0;right:0;bottom:0;left:0;transform:translate(0);transition:transform .1s ease-in-out}.typo-features.settingsVisible.svelte-1ly2c3r.svelte-1ly2c3r{transform:translate(100vw)}.typo-features.svelte-1ly2c3r .typo-features-list.svelte-1ly2c3r{width:100%;display:flex;flex-direction:row;flex-wrap:wrap;justify-content:center;gap:2rem;margin:0 2rem;padding-bottom:2rem;overflow:auto}#game-toolbar:has(.typo-brush-lab-switch.expanded){grid-template-rows:max-content}#game-toolbar:not(:has(.typo-brush-lab-switch.expanded))>.typo-brush-lab-group{display:none}.typo-brush-lab-group.svelte-p5jc91.svelte-p5jc91{display:flex;flex-direction:row;align-items:center;gap:2rem;grid-row:2}.typo-brush-lab-group.svelte-p5jc91 .typo-brush-lab-mods.svelte-p5jc91,.typo-brush-lab-group.svelte-p5jc91 .typo-brush-lab-tools.svelte-p5jc91{display:flex;flex-direction:row;gap:.5rem}.item-selection.svelte-15vhuqn.svelte-15vhuqn{display:grid;grid-template-columns:auto 1fr;flex-grow:1;width:100%;padding:1rem 2rem;gap:2rem}.item-selection.svelte-15vhuqn .item-sidebar.svelte-15vhuqn{display:flex;flex-direction:column;gap:1rem;padding-right:2rem;height:100%;border-right:1px solid var(--COLOR_PANEL_BORDER_FOCUS);overflow:auto}.item-selection.svelte-15vhuqn .item-sidebar h3.svelte-15vhuqn{opacity:.5}.item-selection.svelte-15vhuqn .item-sidebar .item-sidebar-entry.svelte-15vhuqn{display:flex;gap:.5rem;align-items:center;cursor:pointer}.item-selection.svelte-15vhuqn .item-sidebar .item-sidebar-entry img.svelte-15vhuqn{height:2rem}.item-selection.svelte-15vhuqn .item-details.svelte-15vhuqn{display:flex;flex-direction:column;gap:1rem}.item-selection.svelte-15vhuqn .item-details .item-title.svelte-15vhuqn{display:flex;align-items:center;gap:2rem}.item-selection.svelte-15vhuqn .item-details .item-title b.svelte-15vhuqn{opacity:.5}.item-selection.svelte-15vhuqn .item-details .item-details-settings-list.svelte-15vhuqn{display:flex;flex-direction:row;flex-wrap:wrap;gap:2rem}.item-selection.svelte-15vhuqn .item-details .item-details-settings-list .item-details-settings-item.svelte-15vhuqn{min-width:clamp(20em,20em,100%);max-width:clamp(20em,20em,100%);background-color:var(--COLOR_PANEL_HI);border-radius:3px;display:flex;flex-direction:column;gap:1rem;padding:1rem;flex:1 1 0px;position:relative}.typo-logs-export.svelte-oun24t.svelte-oun24t,.typo-logs-logger-list.svelte-oun24t.svelte-oun24t,.typo-logs-overwrite.svelte-oun24t.svelte-oun24t{display:flex;flex-direction:row;flex-wrap:wrap;gap:1rem;margin:1rem;align-items:center}.typo-logs-logger-list.svelte-oun24t .typo-logs-logger.svelte-oun24t{min-width:clamp(10em,auto,100%);max-width:clamp(10em,auto,100%);background-color:var(--COLOR_PANEL_HI);display:flex;flex-direction:column;border-radius:3px;gap:1rem;padding:1rem}.typo-logs-logger-list.svelte-oun24t .typo-logs-logger.hidden.svelte-oun24t{display:none}.typo-lobby-filters.svelte-lqoucf.svelte-lqoucf{display:flex;flex-direction:column;overflow:auto;height:100%;gap:1rem}.typo-lobby-filters.svelte-lqoucf .typo-lobby-filters-header.svelte-lqoucf{display:flex;justify-content:space-between;align-items:center}.typo-lobby-filters.svelte-lqoucf .typo-lobby-filters-list.svelte-lqoucf{flex-grow:1;display:flex;flex-wrap:wrap;gap:1rem;align-content:flex-start;overflow:auto}.typo-lobby-filters.svelte-lqoucf .typo-lobby-filters-list .typo-lobby-filters-item.svelte-lqoucf{display:flex;align-items:center;gap:.5rem;padding:.2rem;background-color:var(--COLOR_PANEL_HI);border-radius:3px}.typo-lobby-filters.svelte-lqoucf .typo-lobby-filters-list .typo-lobby-filters-item .typo-lobby-filters-item-remove.svelte-lqoucf{opacity:0;transition:opacity .1s}.typo-lobby-filters.svelte-lqoucf .typo-lobby-filters-list .typo-lobby-filters-item:hover .typo-lobby-filters-item-remove.svelte-lqoucf{opacity:1}.typo-filter-form.svelte-9ect24.svelte-9ect24{display:flex;flex-direction:column;gap:2rem}.typo-filter-form.svelte-9ect24 .typo-filter-form-inputs.svelte-9ect24{display:flex;flex-direction:column;gap:1rem}.typo-filter-form.svelte-9ect24 .typo-filter-form-inputs .typo-filter-form-row.svelte-9ect24{display:flex;gap:1rem;align-items:center}.typo-filter-form.svelte-9ect24 .typo-filter-form-inputs .typo-filter-form-row input[type=text].svelte-9ect24{width:auto;flex-grow:1}.typo-filter-form.svelte-9ect24 .typo-filter-form-inputs .typo-filter-form-row input[type=number].svelte-9ect24{width:5rem}.typo-filter-search.svelte-1apd7dj.svelte-1apd7dj.svelte-1apd7dj{display:flex;flex-direction:column;gap:2rem;max-width:min(50vw,100%)}.typo-filter-search.svelte-1apd7dj .typo-filter-search-list.svelte-1apd7dj.svelte-1apd7dj{display:flex;flex-direction:row;flex-wrap:wrap;gap:1rem;justify-content:center}.typo-filter-search.svelte-1apd7dj .typo-filter-search-list .typo-filter-search-list-item.svelte-1apd7dj.svelte-1apd7dj{display:flex;flex-direction:column;gap:.5rem;background-color:var(--COLOR_PANEL_HI);border-radius:3px;padding:.5rem}.typo-filter-search.svelte-1apd7dj .typo-filter-search-list .typo-filter-search-list-item.lobby.svelte-1apd7dj.svelte-1apd7dj{cursor:pointer}.typo-filter-search.svelte-1apd7dj .typo-filter-search-list .typo-filter-search-list-item.svelte-1apd7dj>b.svelte-1apd7dj{flex-grow:1;text-align:center}.typo-filter-search.svelte-1apd7dj .typo-filter-search-list .typo-filter-search-list-item .typo-filter-search-list-item-description.svelte-1apd7dj.svelte-1apd7dj{white-space:preserve}#game-players .player .player-icons .typo-awards-icon.svelte-19i0k4m{height:20px;width:20px;align-self:flex-end}@keyframes svelte-aldc0m-award-presentation{0%{opacity:0;background-size:100%}25%{opacity:1;background-size:30px}50%{opacity:1;background-size:48px}to{opacity:0;background-size:48px}}.typo-awards-icon.svelte-aldc0m{position:absolute;top:60px;right:4px}.typo-awards-presentation.svelte-aldc0m{position:absolute;top:0;right:0;bottom:0;left:0;background-position:center;background-repeat:no-repeat;pointer-events:none;animation:svelte-aldc0m-award-presentation 3s ease-out forwards}.typo-award-picker.svelte-9q5vog.svelte-9q5vog{display:flex;flex-direction:column;height:100%;width:100%;align-items:center;gap:2rem;margin-bottom:2rem;overflow:auto}.typo-award-picker.svelte-9q5vog .typo-award-picker-list.svelte-9q5vog{flex-grow:1;width:100%;overflow:auto;display:grid;grid-template-columns:repeat(auto-fit,minmax(6rem,1fr));gap:1rem;padding:0 2rem}.typo-award-picker.svelte-9q5vog .typo-award-picker-list .typo-award-picker-award.svelte-9q5vog{background-color:var(--COLOR_PANEL_BG);border-radius:5px;display:flex;flex-direction:column;gap:.1rem;padding:.1rem;align-items:center;cursor:pointer;transition:transform .1s}.typo-award-picker.svelte-9q5vog .typo-award-picker-list .typo-award-picker-award.svelte-9q5vog:hover{transform:scale(.9)}.typo-award-picker.svelte-9q5vog .typo-award-picker-list .typo-award-picker-award .typo-award-picker-award-thumb.svelte-9q5vog{width:4rem;aspect-ratio:1;background-size:cover}.typo-award-picker.svelte-9q5vog .typo-award-picker-list .typo-award-picker-award span.svelte-9q5vog{font-size:.9rem;opacity:.9;text-align:center}.typo-player-scene.svelte-eg9tl1{position:absolute;top:0;right:0;bottom:0;left:0;background-repeat:no-repeat;background-size:cover;background-position:center;z-index:-1}.sprite-slot.svelte-1uuttlm{position:absolute;left:-33%;top:-33%;width:166%;height:166%;background-repeat:no-repeat;background-size:contain}.typo-toolbar-challenges-list.svelte-wy9tne.svelte-wy9tne{display:flex;flex-direction:column;width:100%;align-items:stretch;gap:1rem}.typo-toolbar-challenges-list.svelte-wy9tne .challenge.svelte-wy9tne{display:flex;flex-direction:column}.typo-toolbar-challenges-list.svelte-wy9tne .challenge span.svelte-wy9tne{padding-left:2rem}.typo-toolbar-imagelab-actions.svelte-1tv05w9.svelte-1tv05w9{display:flex;flex-direction:column;width:100%;align-items:stretch;gap:.7rem}.typo-toolbar-imagelab-actions.svelte-1tv05w9 .lockedHint.svelte-1tv05w9{display:flex;gap:1rem;align-items:center;margin-bottom:1rem;width:100%}.typo-toolbar-imagelab-actions.svelte-1tv05w9 .lockedHint span.svelte-1tv05w9{flex-grow:1;-webkit-user-select:none;user-select:none;font-weight:600;opacity:.8}.typo-toolbar-imagelab-actions.svelte-1tv05w9 .saved-commands.svelte-1tv05w9{display:flex;gap:1rem;align-items:center}.typo-toolbar-imagelab-actions.svelte-1tv05w9 .saved-commands.locked.svelte-1tv05w9>:last-child{pointer-events:none;opacity:.5}.typo-toolbar-imagelab-actions.svelte-1tv05w9 .saved-commands.svelte-1tv05w9>:last-child{flex-grow:1}.typo-toolbar-imagelab-actions.svelte-1tv05w9 .saved-commands .remove.svelte-1tv05w9{filter:grayscale(.7);transition:filter 60ms}.typo-toolbar-imagelab-actions.svelte-1tv05w9 .saved-commands .remove.svelte-1tv05w9:hover{filter:grayscale(0)}.typo-imagelab-position-picker.svelte-zwzp7f{display:flex;flex-direction:column;gap:.5rem}.typo-image-post.svelte-f411i0.svelte-f411i0{display:flex;flex-direction:column;width:100%;align-items:stretch;gap:1em}.typo-image-post.svelte-f411i0 img.svelte-f411i0{border-radius:3px}.typo-image-post.svelte-f411i0 .navigate-image.svelte-f411i0{display:flex;justify-content:space-between;align-items:center}.typo-image-post.svelte-f411i0 .not-logged-in.svelte-f411i0,.typo-image-post.svelte-f411i0 .typo-post-info.svelte-f411i0{font-weight:600;opacity:.7}.typo-toolbar-save-actions.svelte-1xyzs78{display:flex;flex-direction:column;width:100%;align-items:stretch;gap:1em}.lobby-navigation.svelte-yw7ztm.svelte-yw7ztm{gap:1rem;display:flex;position:absolute;width:fit-content;right:50px;padding-right:1rem;height:100%;align-items:center}.lobby-navigation.svelte-yw7ztm .lobby-exit.svelte-yw7ztm,.lobby-navigation.svelte-yw7ztm .lobby-next.svelte-yw7ztm{content:var(--file-img-arrow-small-gif);cursor:pointer;height:42px;aspect-ratio:1;transition:scale .1s ease-in-out}.lobby-navigation.svelte-yw7ztm .lobby-exit.svelte-yw7ztm:hover,.lobby-navigation.svelte-yw7ztm .lobby-next.svelte-yw7ztm:hover{scale:1.1}.lobby-navigation.svelte-yw7ztm .lobby-exit.svelte-yw7ztm{filter:drop-shadow(rgba(0,0,0,.3) 3px 3px 0px) sepia(1) saturate(5) brightness(.8) hue-rotate(324deg)}.lobby-navigation.svelte-yw7ztm .lobby-next.svelte-yw7ztm{transform:rotateY(180deg);filter:drop-shadow(rgba(0,0,0,.3) -3px 3px 0px) sepia(1) saturate(5) brightness(.7) hue-rotate(56deg)}h2,h3{margin-top:0}:root{--COLOR_BUTTON_DANGER_BG: hsl(44, 81%, 51%);--COLOR_BUTTON_SUBMIT_BG: hsl(110, 75%, 55%);--COLOR_BUTTON_NORMAL_BG: hsl(208, 80%, 54%);--COLOR_BUTTON_DANGER_TEXT: hsl(0, 0%, 100%);--COLOR_BUTTON_SUBMIT_TEXT: hsl(0, 0%, 100%);--COLOR_BUTTON_NORMAL_TEXT: hsl(0, 0%, 100%)}.color-scrollbar::-webkit-scrollbar,.color-scrollbar ::-webkit-scrollbar{width:14px;border-radius:7px;background-color:var(--COLOR_PANEL_LO)}.color-scrollbar::-webkit-scrollbar-thumb,.color-scrollbar ::-webkit-scrollbar-thumb{border-radius:7px;background-color:var(--COLOR_PANEL_HI)}input.typo[type=text]{border-radius:.5rem;font-weight:600;padding:.5rem}img{display:block}.tool[data-tooltip="No Tool"]{display:none}#game-players{z-index:1}html:not([data-typo_loading_screen_disabled=true]) body>*{opacity:0;transition:opacity .2s;transition-delay:.1s}html:not([data-typo_loading_screen_disabled=true]) body[data-typo_loaded=true]>*{opacity:1}html:not([data-typo_loading_screen_disabled=true]) body:after{display:grid;place-content:center;content:"";position:fixed;top:0;left:0;width:100vw;height:100vh;opacity:1;transition:opacity .2s;background-image:var(--file-img-wand-gif);background-size:10rem;background-repeat:no-repeat;background-position:center;pointer-events:none}html:not([data-typo_loading_screen_disabled=true]) body[data-typo_loaded=true]:after{opacity:0} ');

(function () {
  'use strict';

  var __defProp = Object.defineProperty;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa, _ba, _ca, _da, _ea, _fa, _ga, _ha, _ia, _ja, _ka, _la, _ma, _na, _oa, _pa, _qa, _ra, _sa, _ta, _ua, _va, _wa, _xa, _ya, _za, _Aa, _Ba, _Ca, _Marked_instances, parseMarkdown_fn, onError_fn, _Da, _Ea, _Fa, _Ga;
  const Metadata$1 = /* @__PURE__ */ new WeakMap();
  function decorateProperty(decorators, target, propertyKey, descriptor) {
    decorators.reverse().forEach((decorator) => {
      descriptor = decorator(target, propertyKey, descriptor) || descriptor;
    });
    return descriptor;
  }
  __name(decorateProperty, "decorateProperty");
  function decorateConstructor(decorators, target) {
    decorators.reverse().forEach((decorator) => {
      const decorated = decorator(target);
      if (decorated) {
        target = decorated;
      }
    });
    return target;
  }
  __name(decorateConstructor, "decorateConstructor");
  function decorate(decorators, target, propertyKey, attributes) {
    if (!Array.isArray(decorators) || decorators.length === 0) {
      throw new TypeError();
    }
    if (propertyKey !== void 0) {
      return decorateProperty(decorators, target, propertyKey, attributes);
    }
    if (typeof target === "function") {
      return decorateConstructor(decorators, target);
    }
    return;
  }
  __name(decorate, "decorate");
  function getMetadataMap(target, propertyKey) {
    return Metadata$1.get(target) && Metadata$1.get(target).get(propertyKey);
  }
  __name(getMetadataMap, "getMetadataMap");
  function ordinaryGetOwnMetadata(metadataKey, target, propertyKey) {
    if (target === void 0) {
      throw new TypeError();
    }
    const metadataMap = getMetadataMap(target, propertyKey);
    return metadataMap && metadataMap.get(metadataKey);
  }
  __name(ordinaryGetOwnMetadata, "ordinaryGetOwnMetadata");
  function createMetadataMap(target, propertyKey) {
    const targetMetadata = Metadata$1.get(target) || /* @__PURE__ */ new Map();
    Metadata$1.set(target, targetMetadata);
    const metadataMap = targetMetadata.get(propertyKey) || /* @__PURE__ */ new Map();
    targetMetadata.set(propertyKey, metadataMap);
    return metadataMap;
  }
  __name(createMetadataMap, "createMetadataMap");
  function ordinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey) {
    if (propertyKey && !["string", "symbol"].includes(typeof propertyKey)) {
      throw new TypeError();
    }
    (getMetadataMap(target, propertyKey) || createMetadataMap(target, propertyKey)).set(metadataKey, metadataValue);
  }
  __name(ordinaryDefineOwnMetadata, "ordinaryDefineOwnMetadata");
  function ordinaryGetMetadata(metadataKey, target, propertyKey) {
    return ordinaryGetOwnMetadata(metadataKey, target, propertyKey) ? ordinaryGetOwnMetadata(metadataKey, target, propertyKey) : Object.getPrototypeOf(target) ? ordinaryGetMetadata(metadataKey, Object.getPrototypeOf(target), propertyKey) : void 0;
  }
  __name(ordinaryGetMetadata, "ordinaryGetMetadata");
  function metadata(metadataKey, metadataValue) {
    return /* @__PURE__ */ __name(function decorator(target, propertyKey) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }, "decorator");
  }
  __name(metadata, "metadata");
  function getMetadata(metadataKey, target, propertyKey) {
    return ordinaryGetMetadata(metadataKey, target, propertyKey);
  }
  __name(getMetadata, "getMetadata");
  function getOwnMetadata(metadataKey, target, propertyKey) {
    return ordinaryGetOwnMetadata(metadataKey, target, propertyKey);
  }
  __name(getOwnMetadata, "getOwnMetadata");
  function hasOwnMetadata(metadataKey, target, propertyKey) {
    return !!ordinaryGetOwnMetadata(metadataKey, target, propertyKey);
  }
  __name(hasOwnMetadata, "hasOwnMetadata");
  function hasMetadata(metadataKey, target, propertyKey) {
    return !!ordinaryGetMetadata(metadataKey, target, propertyKey);
  }
  __name(hasMetadata, "hasMetadata");
  function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
  }
  __name(defineMetadata, "defineMetadata");
  const Reflection = {
    decorate,
    defineMetadata,
    getMetadata,
    getOwnMetadata,
    hasMetadata,
    hasOwnMetadata,
    metadata
  };
  Object.assign(Reflect, Reflection);
  const _TypoProfileStore = class _TypoProfileStore {
    constructor(db, _profileListStore, _currentProfileStore, _settingsStore, _tokenStore) {
      __publicField(this, "_db");
      this._profileListStore = _profileListStore;
      this._currentProfileStore = _currentProfileStore;
      this._settingsStore = _settingsStore;
      this._tokenStore = _tokenStore;
      this._db = this.init(db);
    }
    async init(db) {
      const profile = await (await db).get(this._currentProfileStore, "current_profile");
      if (profile === void 0) {
        await (await db).put(this._currentProfileStore, "Default", "current_profile");
      }
      const profiles = await (await db).getAllKeys(this._profileListStore);
      if (profiles.length === 0) {
        await (await db).put(this._profileListStore, {}, "Default");
      }
      return db;
    }
    async getProfiles() {
      return (await (await this._db).getAllKeys(this._profileListStore)).map((key2) => key2.toString());
    }
    async getCurrentProfile() {
      return await (await this._db).get(this._currentProfileStore, "current_profile");
    }
    async createAndActivateProfile(profile) {
      const currentProfile = await this.getCurrentProfile();
      const currentProfileData = await this.exportCurrentProfile();
      await this.setSavedProfile(currentProfile, currentProfileData);
      await (await this._db).put(this._currentProfileStore, profile, "current_profile");
      await this.setSavedProfile(profile, { token: null, settings: [] });
      await this.loadProfile({ token: null, settings: [] });
    }
    async switchToProfile(profile) {
      const currentProfile = await this.getCurrentProfile();
      const currentProfileData = await this.exportCurrentProfile();
      await this.setSavedProfile(currentProfile, currentProfileData);
      await this.loadProfile(await this.getSavedProfile(profile));
      await (await this._db).put(this._currentProfileStore, profile, "current_profile");
    }
    async deleteProfile(profile) {
      const currentProfile = await this.getCurrentProfile();
      if (currentProfile === profile) {
        throw new Error("Cannot delete current profile");
      }
      await (await this._db).delete(this._profileListStore, profile);
    }
    async getSavedProfile(profile) {
      const result = await (await this._db).get(this._profileListStore, profile);
      return result ?? { token: null, settings: {} };
    }
    async setSavedProfile(profile, savedProfile) {
      await (await this._db).put(this._profileListStore, savedProfile, profile);
    }
    async exportCurrentProfile() {
      const settingKeys = await (await this._db).getAllKeys(this._settingsStore);
      const settings = /* @__PURE__ */ new Map();
      for (const key2 of settingKeys.map((k) => k.toString())) {
        const value = await (await this._db).get(this._settingsStore, key2);
        settings.set(key2, value);
      }
      return {
        token: await (await this._db).get(this._tokenStore, "token"),
        settings: Array.from(settings.entries())
      };
    }
    async loadProfile(savedProfile) {
      await (await this._db).clear(this._settingsStore);
      await (await this._db).put(this._tokenStore, savedProfile.token, "token");
      for (const [key2, value] of savedProfile.settings) {
        await (await this._db).put(this._settingsStore, value, key2);
      }
    }
  };
  __name(_TypoProfileStore, "TypoProfileStore");
  let TypoProfileStore = _TypoProfileStore;
  const instanceOfAny = /* @__PURE__ */ __name((object, constructors) => constructors.some((c) => object instanceof c), "instanceOfAny");
  let idbProxyableTypes;
  let cursorAdvanceMethods;
  function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
      IDBDatabase,
      IDBObjectStore,
      IDBIndex,
      IDBCursor,
      IDBTransaction
    ]);
  }
  __name(getIdbProxyableTypes, "getIdbProxyableTypes");
  function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey
    ]);
  }
  __name(getCursorAdvanceMethods, "getCursorAdvanceMethods");
  const transactionDoneMap = /* @__PURE__ */ new WeakMap();
  const transformCache = /* @__PURE__ */ new WeakMap();
  const reverseTransformCache = /* @__PURE__ */ new WeakMap();
  function promisifyRequest(request) {
    const promise = new Promise((resolve2, reject) => {
      const unlisten = /* @__PURE__ */ __name(() => {
        request.removeEventListener("success", success);
        request.removeEventListener("error", error);
      }, "unlisten");
      const success = /* @__PURE__ */ __name(() => {
        resolve2(wrap(request.result));
        unlisten();
      }, "success");
      const error = /* @__PURE__ */ __name(() => {
        reject(request.error);
        unlisten();
      }, "error");
      request.addEventListener("success", success);
      request.addEventListener("error", error);
    });
    reverseTransformCache.set(promise, request);
    return promise;
  }
  __name(promisifyRequest, "promisifyRequest");
  function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx))
      return;
    const done = new Promise((resolve2, reject) => {
      const unlisten = /* @__PURE__ */ __name(() => {
        tx.removeEventListener("complete", complete);
        tx.removeEventListener("error", error);
        tx.removeEventListener("abort", error);
      }, "unlisten");
      const complete = /* @__PURE__ */ __name(() => {
        resolve2();
        unlisten();
      }, "complete");
      const error = /* @__PURE__ */ __name(() => {
        reject(tx.error || new DOMException("AbortError", "AbortError"));
        unlisten();
      }, "error");
      tx.addEventListener("complete", complete);
      tx.addEventListener("error", error);
      tx.addEventListener("abort", error);
    });
    transactionDoneMap.set(tx, done);
  }
  __name(cacheDonePromiseForTransaction, "cacheDonePromiseForTransaction");
  let idbProxyTraps = {
    get(target, prop, receiver) {
      if (target instanceof IDBTransaction) {
        if (prop === "done")
          return transactionDoneMap.get(target);
        if (prop === "store") {
          return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
        }
      }
      return wrap(target[prop]);
    },
    set(target, prop, value) {
      target[prop] = value;
      return true;
    },
    has(target, prop) {
      if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
        return true;
      }
      return prop in target;
    }
  };
  function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
  }
  __name(replaceTraps, "replaceTraps");
  function wrapFunction(func2) {
    if (getCursorAdvanceMethods().includes(func2)) {
      return function(...args) {
        func2.apply(unwrap(this), args);
        return wrap(this.request);
      };
    }
    return function(...args) {
      return wrap(func2.apply(unwrap(this), args));
    };
  }
  __name(wrapFunction, "wrapFunction");
  function transformCachableValue(value) {
    if (typeof value === "function")
      return wrapFunction(value);
    if (value instanceof IDBTransaction)
      cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
      return new Proxy(value, idbProxyTraps);
    return value;
  }
  __name(transformCachableValue, "transformCachableValue");
  function wrap(value) {
    if (value instanceof IDBRequest)
      return promisifyRequest(value);
    if (transformCache.has(value))
      return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
      transformCache.set(value, newValue);
      reverseTransformCache.set(newValue, value);
    }
    return newValue;
  }
  __name(wrap, "wrap");
  const unwrap = /* @__PURE__ */ __name((value) => reverseTransformCache.get(value), "unwrap");
  function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap(request);
    if (upgrade) {
      request.addEventListener("upgradeneeded", (event) => {
        upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
      });
    }
    if (blocked) {
      request.addEventListener("blocked", (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion,
        event.newVersion,
        event
      ));
    }
    openPromise.then((db) => {
      if (terminated)
        db.addEventListener("close", () => terminated());
      if (blocking) {
        db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
      }
    }).catch(() => {
    });
    return openPromise;
  }
  __name(openDB, "openDB");
  const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
  const writeMethods = ["put", "add", "delete", "clear"];
  const cachedMethods = /* @__PURE__ */ new Map();
  function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
      return;
    }
    if (cachedMethods.get(prop))
      return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, "");
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
    ) {
      return;
    }
    const method = /* @__PURE__ */ __name(async function(storeName, ...args) {
      const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
      let target2 = tx.store;
      if (useIndex)
        target2 = target2.index(args.shift());
      return (await Promise.all([
        target2[targetFuncName](...args),
        isWrite && tx.done
      ]))[0];
    }, "method");
    cachedMethods.set(prop, method);
    return method;
  }
  __name(getMethod, "getMethod");
  replaceTraps((oldTraps) => ({
    ...oldTraps,
    get: /* @__PURE__ */ __name((target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver), "get"),
    has: /* @__PURE__ */ __name((target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop), "has")
  }));
  const advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
  const methodMap = {};
  const advanceResults = /* @__PURE__ */ new WeakMap();
  const ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
  const cursorIteratorTraps = {
    get(target, prop) {
      if (!advanceMethodProps.includes(prop))
        return target[prop];
      let cachedFunc = methodMap[prop];
      if (!cachedFunc) {
        cachedFunc = methodMap[prop] = function(...args) {
          advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
        };
      }
      return cachedFunc;
    }
  };
  async function* iterate(...args) {
    let cursor = this;
    if (!(cursor instanceof IDBCursor)) {
      cursor = await cursor.openCursor(...args);
    }
    if (!cursor)
      return;
    cursor = cursor;
    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
    reverseTransformCache.set(proxiedCursor, unwrap(cursor));
    while (cursor) {
      yield proxiedCursor;
      cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
      advanceResults.delete(proxiedCursor);
    }
  }
  __name(iterate, "iterate");
  function isIteratorProp(target, prop) {
    return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
  }
  __name(isIteratorProp, "isIteratorProp");
  replaceTraps((oldTraps) => ({
    ...oldTraps,
    get(target, prop, receiver) {
      if (isIteratorProp(target, prop))
        return iterate;
      return oldTraps.get(target, prop, receiver);
    },
    has(target, prop) {
      return isIteratorProp(target, prop) || oldTraps.has(target, prop);
    }
  }));
  const pageReleaseDetails = { version: "27.1.3", versionName: "27.1.3 beta-usc 7124cd9", runtime: "userscript" };
  const gamePatch = `((h, c, d, O) => {
  let P = 28,
    Y = 57,
    z = 51,
    a = [P, Y, z],
    B = 0,
    U = 1,
    H = 2,
    _ = 5,
    G = 0,
    K = 1,
    F = 2,
    V = 3,
    j = 4,
    Z = 5,
    X = 6,
    J = 7,
    Q = 1,
    ee = 2,
    te = {
      LANG: 0,
      SLOTS: 1,
      DRAWTIME: 2,
      ROUNDS: 3,
      WORDCOUNT: 4,
      HINTCOUNT: 5,
      WORDMODE: 6,
      CUSTOMWORDSONLY: 7
    },
    ne = {
      NORMAL: 0,
      HIDDEN: 1,
      COMBINATION: 2
    }
// TYPOMOD 
                // desc: create re-useable functions
                , typo = {
                    /* mod sequence injection for custom draw commands */
                    msi: {
              
                      reset: () => {
                        typo.msi.mod.selected = undefined;
                        typo.msi.mod.buffer = undefined;
                        typo.msi.mod.apply = undefined
                      },
              
                      /* incoming draw commands are part of an injected mod */
                      mod: {
                        selected: undefined, /* index of selected mod */
                        buffer: undefined, /* buffer to construct mod */
                        apply: undefined /* function to apply constructed mod */
                      },
              
                      modes: [
              
                        /* custom color mode */
                        (buffer) => {
                          return (command) => {
              
                            /* skip if buffer empty */
                            if(buffer.length === 0) return command;
              
                            /* if brush or fill */
                            if(command[0] <= 1) {
                              command[1] = buffer[0];
                            }
              
                            return command;
                          }
                        }
                      ],
              
                      fromSenaryDoubleDecimalBase: (senary, decimal1, decimal0) => {
                        return decimal0 + decimal1 * 10 + Number.parseInt(senary.toString(), 6) * 100;
                      },
              
                      fromOctalDoubleDecimalBase: (octal, decimal1, decimal0) => {
                        return decimal0 + decimal1 * 10 + Number.parseInt(octal.toString(), 8) * 100;
                      },
              
                      /* bases of data: width x height x width x height -> odd sdd odd sdd */
                      parseInjectedSequence: (odd1, sdd1, odd0, sdd0) => {
                        const parseDigits = (num) => {
                          const str = num.toString().padStart(3, '0');
                          return [str[0], str[1], str[2]].map(Number);
                        };
              
                        const [sdd0_s, sdd0_d1, sdd0_d0] = parseDigits(sdd0);
                        const [odd0_o, odd0_d1, odd0_d0] = parseDigits(odd0);
                        const [sdd1_s, sdd1_d1, sdd1_d0] = parseDigits(sdd1);
                        const [odd1_o, odd1_d1, odd1_d0] = parseDigits(odd1);
              
                        return typo.msi.fromSenaryDoubleDecimalBase(sdd0_s, sdd0_d1, sdd0_d0)
                          + 600 * typo.msi.fromOctalDoubleDecimalBase(odd0_o, odd0_d1, odd0_d0)
                          + 600 * 800 * typo.msi.fromSenaryDoubleDecimalBase(sdd1_s, sdd1_d1, sdd1_d0)
                          + 600 * 800 * 600 * typo.msi.fromOctalDoubleDecimalBase(odd1_o, odd1_d1, odd1_d0);
                      },
              
                      toSenaryDoubleDecimalBase: (number) => {
                        const senary = Math.floor(number / 100);
                        const decimal1 = Math.floor((number % 100) / 10);
                        const decimal0 = number % 10;
                        return [senary, decimal1, decimal0];
                      },
              
                      toOctalDoubleDecimalBase: (number) => {
                        const octal = Math.floor(number / 100);
                        const decimal1 = Math.floor((number % 100) / 10);
                        const decimal0 = number % 10;
                        return [octal, decimal1, decimal0];
                      },
              
                      toInjectedSequence: (number) => {
                        const odd1 = Math.floor(number / (600 * 800 * 600));
                        const sdd1 = Math.floor((number % (600 * 800 * 600)) / (600 * 800));
                        const odd0 = Math.floor((number % (600 * 800)) / 600);
                        const sdd0 = number % 600;
              
                        const sdd0Array = typo.msi.toSenaryDoubleDecimalBase(sdd0);
                        const odd0Array = typo.msi.toOctalDoubleDecimalBase(odd0);
                        const sdd1Array = typo.msi.toSenaryDoubleDecimalBase(sdd1);
                        const odd1Array = typo.msi.toOctalDoubleDecimalBase(odd1);
              
                        return [
                          odd1Array[0] * 100 + odd1Array[1] * 10 + odd1Array[2],
                          sdd1Array[0] * 100 + sdd1Array[1] * 10 + sdd1Array[2],
                          odd0Array[0] * 100 + odd0Array[1] * 10 + odd0Array[2],
                          sdd0Array[0] * 100 + sdd0Array[1] * 10 + sdd0Array[2]
                        ];
                      },
              
                      /* if tool = 0 (brush), color 0, size 4, and all coords 0 -> MSI init/finish signal */
                      isMSIInitSignal: (command) => {
                        return (command[0] === 0 && command[1] === 0 && command[2] === 5 && command[3] === 0 && command[4] === 0 && command[5] === 0 && command[6] === 0);
                      },
              
                      /* if tool = 0 (brush), color 0, size 40 and all coords 0 -> MSI reset signal */
                      isResetSignal: (command) => {
                        return (command[0] === 0 && command[1] === 0 && command[2] === 39 && command[3] === 0 && command[4] === 0 && command[5] === 0 && command[6] === 0);
                      },
              
                      processIncomingCommand: (command) => {
                        const msiInitSignal = typo.msi.isMSIInitSignal(command);
                        const resetSignal = typo.msi.isResetSignal(command);
                        const processingMode = typo.msi.mod.selected === undefined && Array.isArray(typo.msi.mod.buffer);
                        const processingBuffer = typo.msi.mod.selected !== undefined && typo.msi.mod.apply === undefined && Array.isArray(typo.msi.mod.buffer);
                        const mod = typo.msi.mod.apply;
              
                        if(resetSignal){
                          /*console.log("MSI reset signal received.");*/
                          typo.msi.mod.selected = undefined;
                          typo.msi.mod.buffer = undefined;
                          typo.msi.mod.apply = undefined;
                          return undefined;
                        }
              
                        if(msiInitSignal && !processingBuffer) {
                          /*console.log("MSI init signal received.");*/
                          typo.msi.mod.selected = undefined;
                          typo.msi.mod.buffer = [];
                          typo.msi.mod.apply = undefined;
                          return undefined;
                        }
              
                        if(msiInitSignal && processingBuffer) {
                          /*console.log("MSI finish signal received.");*/
                          typo.msi.mod.apply = typo.msi.mod.selected(typo.msi.mod.buffer);
                          return undefined;
                        }
              
                        if(processingMode){
                          const mode = typo.msi.parseInjectedSequence(command[3], command[4], command[5], command[6]);
                          /*console.log("MSI mode selection received.", mode);*/
                          typo.msi.mod.selected = (typo.msi.modes[mode - 1] ?? (() => c => c));
                          return undefined;
                        }
              
                        if(processingBuffer){
                          const packet = typo.msi.parseInjectedSequence(command[3], command[4], command[5], command[6]);
                          /*console.log("MSI buffer processing.", packet);*/
                          typo.msi.mod.buffer.push(packet);
                          return undefined;
                        }
              
                        if(mod){
                          /*console.log("MSI mod applying.");*/
                          return typo.msi.mod.apply(command);
                        }
              
                        return command;
                      }
                    },
              
                    msiColorSwitch: {
                      currentCode: undefined,
                      closeColors: {},
                      getClosestSkribblColor: code => {
                        const existing = typo.msiColorSwitch.closeColors[code];
                        if(existing !== undefined) return existing;

                        const rgb = typo.typoCodeToRgb(code);
                        const lab = typo.rgbToLab(rgb);
                        const distance = (c1, c2) =>
                          Math.sqrt(
                            Math.pow(c1[0] - c2[0], 2) +
                            Math.pow(c1[1] - c2[1], 2) +
                            Math.pow(c1[2] - c2[2], 2)
                          );

                        const colors = kt.map(c => typo.rgbToLab(c));
                        const color = colors.reduce((closestIndex, color, index) =>
                            distance(lab, color) < distance(lab, colors[closestIndex]) ? index : closestIndex
                          , 0);
                        typo.msiColorSwitch.closeColors[code] = color;
                        return color;
                      },
                      ensureColorSequence: command => {
                        const color = command[1];
              
                        /* sanitize color to black for non-typo users */
                        if(color > 10000){
                          command[1] = typo.msiColorSwitch.getClosestSkribblColor(color);
                        }
              
                        /* if color is typo color and not already initiated */
                        if(color > 10000 && color !== typo.msiColorSwitch.currentCode){
                          typo.msiColorSwitch.currentCode = color;
                          const codeData = typo.msi.toInjectedSequence(color);
                          const sequence = [
                            [0, 0, 5, 0,0,0,0],
                            [0, 0, 5, 0,0,0,1],
                            [0, 0, 5, ...codeData],
                            [0, 0, 5, 0,0,0,0]
                          ];
                          return sequence;
                        }
              
                        /* if color is original but typo color initiated */
                        if(color < 10000 && typo.msiColorSwitch.currentCode !== undefined){
                          typo.msiColorSwitch.currentCode = undefined;
                          return [[0, 0, 39, 0,0,0,0]];
                        }
              
                        return undefined;
                      },
                      insertColorSwitches: (commands) => {
                        inserted = [];
                        for (let i = 0; i < commands.length; i++) {
                          const command = commands[i];
                          const t = typo.msiColorSwitch.ensureColorSequence(command);
                          if(t !== undefined) inserted.push(...t);
                          inserted.push(command);
                        }
                  
                        commands.splice(0, commands.length, ...inserted);
                      }
                    },
                    messagePort: (()=>{
                      const channel = new MessageChannel();
                      window.postMessage("skribblMessagePort", "*", [channel.port2]);
                      return channel.port1;
                    })(),
                    emitPort: (()=>{
                      const channel = new MessageChannel();
                      window.postMessage("skribblEmitPort", "*", [channel.port2]);
                      return channel.port1;
                    })(),
                    joinLobby: undefined,
                    createFakeUser: (id = 0, name = "", avatar = [], score = 0, guessed = false) => {
                        // IDENTIFY x.value.split: #home .container-name-lang input -> Kn
                        // IDENTIFY x.avatar: [Math.round(100 * Math.random()) % -> l
                        return { 
                            id: id, 
                            name: name.length != 0 ? name : (Kn.value.split("#")[0] != "" ? Kn.value.split("#")[0] : "Player"), 
                            avatar: avatar.length == 0 ? l.avatar : avatar, 
                            score: score, 
                            guessed: guessed 
                        };
                    },
                    createFakeLobbyData: (
                        settings = ["PRACTISE", "en", 1, 1, 80, 3, 3, 2, 0, false],
                        id = null,
                        me = 0,
                        owner = 0,
                        users = [],
                        state = { id: 4, type: 0, time: 0, data: { id: 0, word: "Anything" } }) => {
                        if (users.length == 0) users = [typo.createFakeUser()];
                        return { 
                            settings: settings, 
                            id: id, 
                            me: me, 
                            owner: owner, 
                            round: 0, 
                            users: users, 
                            state: state 
                        };
                    },
                    disconnect: undefined,
                    skipCursorUpdate: false,
                    lastConnect: 0,
                    initListeners: (() => {
                        let abort = false; 
                        document.addEventListener("selectSkribblTool", (event) => Tt(event.detail));
                        document.addEventListener("selectSkribblSize", (event) => At(event.detail));
                        document.addEventListener("clearDrawing", () => Ft());
                        document.addEventListener("abortJoin", () => abort = true); 
                        document.addEventListener("disableCursorUpdates", e => {
                            typo.skipCursorUpdate = e.detail === true;
                            if(e.detail === false) yt(); // update cursor when updates reenabled
                        });
                        document.addEventListener("joinLobby", (e) => {
                            abort = false;
                            let timeoutdiff = Date.now() - (typo.lastConnect == 0 ? Date.now() : typo.lastConnect);
                            // Xn(true);
                            setTimeout(() => {
                                if (abort) return; 
                                typo.lastConnect = Date.now();
                                // Vn.dispatchEvent(new Event("click")); 
                                // IDENTIFY x.dispatchEvent: querySelector("#home .panel .button-play") -> BTNPLAY
                                // ##PRIVATELBBY## = !1 
                                // IDENTIFY: x:  = !1   
                                window.history.pushState({path: window.location.origin + '?' + (e.detail ?? "")}, '', window.location.origin + '?' + (e.detail ?? ""));
                                // ##JOINLOBBY##(e.detail?.join ? e.detail.join : "");
                                // IDENTIFY x(e.det..): ? "id=" + -> JOINLOBBY
                                typo.joinLobby(); 
                                window.history.pushState({path: window.location.origin}, '', window.location.origin);
                                // Jn(false); 
                                // IDENTIFY x(false): querySelector("#load").style.display -> LOADING
                                document.dispatchEvent(new Event("joinedLobby"));
                            }, timeoutdiff < 2000 ? 2000 - timeoutdiff : 0);
                        });
                        document.addEventListener("leaveLobby", () => {
                            if (typo.disconnect) typo.disconnect();
                            else ua() | document.dispatchEvent(new Event("leftLobby"));
                            // IDENTIFY x(): querySelector("#home").style.display = "" -> GOHOME
                        });
                        document.addEventListener("setColor", (e) => {
                            let rgb = e.detail.code < 10000 ? kt[e.detail.code] : typo.typoCodeToRgb(e.detail.code);
                            let match = kt.findIndex(color => color[0] == rgb[0] && color[1] == rgb[1] && color[2] == rgb[2]);
                            // IDENTIFY [0, 59, 120], -> COLORS
                            let code = match >= 0 ? match : e.detail.code;
                            if (e.detail.secondary) Wt(code); 
                            // IDENTIFY x(e.detail.code): querySelector("#color-preview-secondary").style.fill -> SECFILL
                            else Nt(code);
                            // IDENTIFY x(e.detail.code): querySelector("#color-preview-primary").style.fill -> PRIMFILL
                        });
                        document.addEventListener("performDrawCommand", (e) => {
                            v.push(e.detail); 
                            pt.push(v.length); 
                            // IDENTIFY x.push(e.detail): .getContext("2d"), x = [] -> PUSHCMD
                            Gt(jt(e.detail)); 
                            // IDENTIFY: x(y(e.detail)): bounds: AND Math.floor(Math.ceil -> PERFOUTER, PERFINNER
                        });
                        document.addEventListener("collapseUndoActions", (e) => {
                            const shrinkCount = e.detail;
                            const firstCollapsedIndex = pt.length - shrinkCount + 1;
                            const collapsed = pt.slice(0, firstCollapsedIndex);
                            const lastCollapsedIndex = collapsed.length === 0 ? 0 : collapsed.length - 1
                            collapsed[lastCollapsedIndex] = pt[pt.length - 1];
                            pt = collapsed;
                        });
                    })(),
                    rgbToXyz: (R, G, B) => {
                      let r = R / 255;
                      let g = G / 255;
                      let b = B / 255;

                      r = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : (r / 12.92);
                      g = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : (g / 12.92);
                      b = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : (b / 12.92);

                      let x = r * 0.4124 + g * 0.3576 + b * 0.1805;
                      let y = r * 0.2126 + g * 0.7152 + b * 0.0722;
                      let z = r * 0.0193 + g * 0.1192 + b * 0.9505;

                      return [x, y, z];
                    },
                    xyzToLab: (x, y, z) => {
                      const REF_X = 0.95047;
                      const REF_Y = 1.00000;
                      const REF_Z = 1.08883;
                    
                      let fx = f(x / REF_X);
                      let fy = f(y / REF_Y);
                      let fz = f(z / REF_Z);
                    
                      let L = 116 * fy - 16;
                      let a = 500 * (fx - fy);
                      let b = 200 * (fy - fz);
                    
                      return [L, a, b];
                    
                      function f(value) {
                        return (value > 0.008856)
                          ? Math.pow(value, 1 / 3)
                          : (7.787 * value) + (16 / 116);
                      }
                    },
                    rgbToLab: ([R, G, B]) => {
                      const [x, y, z] = typo.rgbToXyz(R, G, B);
                      return typo.xyzToLab(x, y, z);
                    },
                    hexToRgb: (hex) => {
                        let arrBuff = new ArrayBuffer(4);
                        let vw = new DataView(arrBuff);
                        vw.setUint32(0, parseInt(hex, 16), false);
                        let arrByte = new Uint8Array(arrBuff);
                        return [arrByte[1], arrByte[2], arrByte[3]];
                    },
                    rgbToHex: (r, g, b) => {
                        return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                    },
                    typoCodeToRgb: (code) => {
                      const decimal = code - 10000;
                      return [
                          (decimal >> 16) & 255, // Red
                          (decimal >> 8) & 255,  // Green
                          decimal & 255          // Blue
                      ];
                    }
                }
                // TYPOEND,
    ae = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  if (h.localStorageAvailable = !1, void 0 !== d) try {
    d.setItem("feature_test", "yes"), "yes" === d.getItem("feature_test") && (d.removeItem("feature_test"), h.localStorageAvailable = !0)
  } catch (e) {}
  var u = [];

  function oe(e) {
    for (var t = 0; t < u.length; t++)
      if (u[t].name == e) return u[t]
  }

  function re(e, t, n, a, o) {
    var r, i, l = t,
      s = (h.localStorageAvailable && (r = d.getItem("hotkey_" + e)) && (t = r), oe(e));
    return s ? (s.key = t, s.def = l, s.desc = n) : (s = {
      name: e,
      desc: n,
      key: t,
      def: l,
      listing: $("item"),
      changed: [],
      cb: []
    }, u.push(s), Ve(r = $("key", s.name), "text"), s.listing.appendChild(r), (i = c.createElement("input")).value = s.key, s.listing.appendChild(i), D(i, "keydown", function(e) {
      for (var t = e.key, n = 0; n < u.length; n++)
        if (u[n].key == t) return void e.preventDefault();
      i.value = t, s.key = t;
      for (n = 0; n < s.changed.length; n++) s.changed[n](s);
      return ie(), e.preventDefault(), !1
    }), g[p].querySelector("#hotkey-list").appendChild(s.listing)), a && s.cb.push(a), o && s.changed.push(o), s
  }

  function ie() {
    if (h.localStorageAvailable)
      for (var e = 0; e < u.length; e++) h.localStorage.setItem("hotkey_" + u[e].name, u[e].key)
  }
  var l = {
    avatar: [Math.round(100 * Math.random()) % P, Math.round(100 * Math.random()) % Y, Math.round(100 * Math.random()) % z, -1],
    volume: 100,
    dark: 0,
    filterChat: 1,
    pressureSensitivity: 1,
    displayLang: "en",
    undefined,
    mobileChatLayout: "bottom",
    chatBubbles: 0
  };

  function e(e, t) {
    e = d.getItem(e);
    return null == e ? t : e
  }

  function le() {
    h.localStorageAvailable ? (d.setItem("name", Kn.value), d.setItem("lang", Fn.value), d.setItem("displaylang", l.displayLang), d.setItem("volume", l.volume), d.setItem("dark", 1 == l.dark ? 1 : 0), d.setItem("filter", 1 == l.filterChat ? 1 : 0), d.setItem("pressure", 1 == l.pressureSensitivity ? 1 : 0), d.setItem("ava", JSON.stringify(l.avatar)), d.setItem("mobileChatLayout", l.mobileChatLayout), d.setItem("keyboard", Ye.value), d.setItem("keyboardlayout", ze.value), d.setItem("chatBubbles", l.chatBubbles), console.log("Settings saved.")) : console.log("Settings not saved. LocalStorage unavailable.")
  }

  function D(e, t, n) {
    for (var a, o = e, r = ("string" == typeof e ? o = c.querySelectorAll(e) : "[object Array]" !== (a = Object.prototype.toString.call(e)) && "[object NodeList]" !== a && "[object HTMLCollection]" !== a && (o = [e]), t.split(" ")), i = 0; i < o.length; i++)
      for (var l = 0; l < r.length; l++) o[i].addEventListener(r[l], n)
  }

  function $(e, t) {
    var n = c.createElement("div");
    if (void 0 !== e)
      for (var a = e.split(" "), o = 0; o < a.length; o++) n.classList.add(a[o]);
    return void 0 !== t && (n.textContent = t), n
  }

  function se(e, t, n) {
    var a = c.createElement(e);
    if (void 0 !== t)
      for (var o = t.split(" "), r = 0; r < o.length; r++) a.classList.add(o[r]);
    return void 0 !== n && (a.textContent = n), a
  }

  function ce(e) {
    for (; e.firstChild;) e.removeChild(e.firstChild)
  }

  function de(e, t) {
    var n = $("avatar"),
      a = $("color"),
      o = $("eyes"),
      r = $("mouth"),
      i = $("special"),
      l = $("owner");
    return l.style.display = t ? "block" : "none", n.appendChild(a), n.appendChild(o), n.appendChild(r), n.appendChild(i), n.appendChild(l), n.parts = [a, o, r], ue(n, e), n
  }

  function ue(e, t) {
    function n(e, t, n) {
      var a = -t % n * 100,
        t = 100 * -Math.floor(t / n);
      e.style.backgroundPosition = a + "% " + t + "%"
    }
    var a = t[0] % P,
      o = t[1] % Y,
      r = t[2] % z,
      t = t[3],
      a = (n(e.querySelector(".color"), a, 10), n(e.querySelector(".eyes"), o, 10), n(e.querySelector(".mouth"), r, 10), e.querySelector(".special"));
    0 <= t ? (a.style.display = "", n(a, t, 10)) : a.style.display = "none"
  }

  function he(e, t) {
    e.querySelector(".owner").style.display = t ? "block" : "none"
  }

  function pe(e, t) {
    e.className = "avatar";
    for (var n of t) e.classList.add("filter-" + n)
  }

  function me(e, t, n, a) {
    var o = {
      element: $("dots"),
      dots: [],
      selected: 0,
      change: a
    };
    return e.appendChild(o.element), n.push(o.element), D(n, "DOMMouseScroll wheel", function(e) {
      var t;
      1 < o.dots.length && (t = -e.deltaY || e.wheelDeltaY, t = Math.sign(t), fe(o, Math.min(o.dots.length - 1, Math.max(0, o.selected - t)), !0), e.preventDefault(), e.stopPropagation())
    }), ge(o, t), o
  }

  function ge(e, t) {
    ce(e.element), e.dots = [];
    for (var n = 0; n < t; n++) {
      var a = $("dot");
      a.index = n, a.appendChild($("inner")), D(a, "click", function() {
        fe(e, this.index, !0)
      }), e.element.appendChild(a), e.dots.push(a)
    }
    e.selected < 0 && (e.selected = 0), t <= e.selected && (e.selected = t - 1), fe(e, e.selected, !1)
  }

  function fe(e, t, n) {
    if (0 <= t && t < e.dots.length) {
      e.selected = t;
      for (var a = 0; a < e.dots.length; a++) e.dots[a].classList.remove("active");
      e.dots[t].classList.add("active"), e.change(e, t, n)
    }
  }
  let s = 0,
    ye = 1,
    ve = 2,
    be = 3,
    p = 4,
    Se = 5;
  var m = c.querySelector("#modal"),
    ke = m.querySelector(".modal-title .text"),
    we = m.querySelector(".modal-content"),
    g = [];

  function Ce(e) {
    g[s].querySelector(".buttons button.mute").textContent = E(e ? "Unmute" : "Mute")
  }

  function qe(e, t) {
    m.style.display = "block";
    for (var n = 0; n < g.length; n++) g[n].style.display = "none";
    g[e].style.display = "flex";
    var a = g[e];
    switch (e) {
      case ye:
        ke.textContent = E("Something went wrong!"), a.querySelector(".message").textContent = t;
        break;
      case ve:
        ke.textContent = E("Disconnected!"), a.querySelector(".message").textContent = t;
        break;
      case s:
        ke.textContent = t.id == x ? E("$ (You)", t.name) : t.name;
        var o = (W(x).flags & k) == k,
          r = (t.flags & k) == k,
          i = a.querySelector(".buttons"),
          r = (i.style.display = t.id == x || r ? "none" : "flex", i.querySelector(".button-pair").style.display = x == En || o ? "flex" : "none", i.querySelector("button.report").style.display = t.reported ? "none" : "", Ce(t.muted), a.querySelector(".report-menu").style.display = "none", a.querySelector(".invite").style.display = x == t.id ? "flex" : "none", we.querySelector(".player")),
          o = (r.style.display = "", ce(r), de(t.avatar))
; /*id in popup*/ r.setAttribute("playerid", t.id);;
        he(o, En == t.id), pe(o, Ya(t)), r.appendChild(o);
        break;
      case Se:
        ke.textContent = E("Rooms"), roomsUpdate(t);
        break;
      case be:
        ke.textContent = E("Invite your friends!");
        break;
      case p:
        ke.textContent = E("Settings"), a.querySelector("#select-pressure-sensitivity").value = l.pressureSensitivity
    }
  }

  function xe() {
    m.style.display = "none"
  }
  g[s] = m.querySelector(".modal-container-player"), g[ye] = m.querySelector(".modal-container-info"), g[ve] = m.querySelector(".modal-container-info"), g[be] = m.querySelector(".modal-container-room"), g[p] = m.querySelector(".modal-container-settings"), D([m.querySelector(".close"), g[ye].querySelector("button.ok")], "click", xe);
  let Me = 0,
    Le = 2,
    De = 3,
    $e = 4,
    Ee = 5,
    Ae = 6,
    Ie = 7,
    Re = ["BASE", "GUESSED", "CLOSE", "DRAWING", "JOIN", "LEAVE", "OWNER", "GUESSCHAT"];

  function f(e) {
    return "var(--COLOR_CHAT_TEXT_" + Re[e] + ")"
  }

  function Te(e, t, n, a) {
    var o = c.createElement("p"),
      r = c.createElement("b"),
      a = (r.textContent = a ? e : e + ": ", o.appendChild(r), o.style.color = n, c.createElement("span"));
    return a.textContent = t, o.appendChild(a), o
  }

  function y(e, t, n, a) {
    var o, r = Te(e, t, n, a),
      i = Gn.scrollHeight - Gn.scrollTop - Gn.clientHeight <= 20;
    if (Gn.appendChild(r), i && (Gn.scrollTop = Gn.scrollHeight + 100), 0 < l.chatDeleteQuota)
      for (; Gn.childElementCount > l.chatDeleteQuota;) Gn.firstElementChild.remove();
    return (0 == l.chatBubbles || 1 == l.chatBubbles && M != x) && (o = Te(e, t, n, a), c.querySelector("#game-canvas .bubbles").appendChild(o), setTimeout(function() {
      o.remove()
    }, 2500)), r
  }
  var i = void 0,
    Ne = void 0;

  function We(e) {
    Oe();
    for (var t = (Ne = e).dataset.tooltip, n = e.dataset.tooltipdir || "N", a = ((i = $("tooltip")).appendChild($("tooltip-arrow")), i.appendChild($("tooltip-content", E(t))), !1), o = e; o;) {
      if ("fixed" == h.getComputedStyle(o).position) {
        a = !0;
        break
      }
      o = o.parentElement
    }
    i.style.position = a ? "fixed" : "absolute";
    var t = e.getBoundingClientRect(),
      e = ("E" == (n = "W" == (n = "S" == (n = "N" == n && t.top - h.scrollY < 48 ? "S" : n) && t.bottom - h.scrollY > c.documentElement.clientHeight - 48 ? "N" : n) && t.left - h.scrollX < 48 ? "E" : n) && t.right - h.scrollX > c.documentElement.clientWidth - 48 && (n = "W"), t.left),
      r = t.top;
    "N" == n && (e = (t.left + t.right) / 2), "S" == n && (e = (t.left + t.right) / 2, r = t.bottom), "E" == n && (e = t.right, r = (t.top + t.bottom) / 2), "W" == n && (r = (t.top + t.bottom) / 2), a || (e += h.scrollX, r += h.scrollY), i.classList.add(n), i.style.left = e + "px", i.style.top = r + "px", c.body.appendChild(i)
  }

  function Oe() {
    i && (i.remove(), Ne = i = void 0)
  }
  let Pe = [{
    code: "en",
    name: "English",
    layout: [
      ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"],
      ["A", "S", "D", "F", "G", "H", "J", "K", "L"],
      ["Z", "X", "C", "V", "B", "N", "M"]
    ]
  }, {
    code: "fr",
    name: "French",
    layout: [
      ["A", "Z", "E", "R", "T", "Y", "U", "I", "O", "P"],
      ["Q", "S", "D", "F", "G", "H", "J", "K", "L", "M"],
      ["W", "X", "C", "V", "B", "N", "É", "È", "Ç", "À", "'"]
    ]
  }, {
    code: "de",
    name: "German",
    layout: [
      ["Q", "W", "E", "R", "T", "Z", "U", "I", "O", "P", "Ü"],
      ["A", "S", "D", "F", "G", "H", "J", "K", "L", "Ö", "Ä"],
      ["Y", "X", "C", "V", "B", "N", "M"]
    ]
  }, {
    code: "tr",
    name: "Turkish",
    layout: [
      ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "Ğ", "Ü"],
      ["A", "S", "D", "F", "G", "H", "J", "K", "L", "Ş", "İ"],
      ["Z", "X", "C", "V", "B", "N", "M", "Ö", "Ç"]
    ]
  }, {
    code: "ru",
    name: "Russian",
    layout: [
      ["Й", "Ц", "У", "К", "Е", "Н", "Г", "Ш", "Щ", "З", "Х", "Ъ"],
      ["Ф", "Ы", "В", "А", "П", "Р", "О", "Л", "Д", "Ж", "Э"],
      ["Я", "Ч", "С", "М", "И", "Т", "Ь", "Б", "Ю", "Ё"]
    ]
  }, {
    code: "es",
    name: "Spanish",
    layout: [
      ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"],
      ["A", "S", "D", "F", "G", "H", "J", "K", "L", "Ñ"],
      ["Z", "X", "C", "V", "B", "N", "M"]
    ]
  }];
  var Ye = c.querySelector("#select-mobile-keyboard-enabled"),
    ze = c.querySelector("#select-mobile-keyboard-layout"),
    Be = {
      elements: {
        main: c.querySelector("#game-keyboard"),
        input: c.querySelector("#game-keyboard .input"),
        rows: c.querySelector("#game-keyboard .keys"),
        caps: 0,
        keys: []
      },
      lang: 0,
      form: void 0,
      input: void 0,
      caps: !1,
      keys: [],
      rows: [],
      columns: 0,
      isOpen: !1,
      getKeyLowercase: function(e) {
        return e.toLocaleLowerCase(this.lang)
      },
      getKeyUppercase: function(e) {
        return e.toLocaleUpperCase(this.lang)
      },
      init: function(e) {
        this.lang = e.code, this.caps = !1, this.columns = 0, this.elements.keys = [], this.form = c.querySelector("#game-chat-input-mobile form"), this.input = this.form.querySelector("input"), ce(this.elements.rows);
        var t = e.layout,
          i = this;

        function n(e, t, n) {
          var a, o = se("button", "key"),
            r = "PointerEvent" in h ? "pointerdown" : "click";
          return Ue.has(t) ? (a = Ue.get(t), o.classList.add(a.class), o.appendChild(se("span", "material-icons", a.icon)), D(o, r, function(e) {
            a.callback(i), e.preventDefault()
          })) : (o.textContent = i.getKeyLowercase(t), D(o, r, function(e) {
            i.inputAdd(t), e.preventDefault()
          }), i.elements.keys.push(o)), n ? e.insertBefore(o, e.firstChild) : e.appendChild(o), o
        }
        for (var a = 0; a < t.length; a++) {
          current_row = i.addRow();
          for (var o = 0; o < t[a].length; o++) {
            var r = t[a][o];
            n(current_row, r)
          }
        }
        this.elements.caps = n(current_row, "caps", !0), n(current_row, "backspace"), current_row = i.addRow();
        for (var l = ["-", "space", ".", "enter"], o = 0; o < l.length; o++) n(current_row, l[o])
      },
      addRow: function() {
        var e = $("row");
        return this.elements.rows.appendChild(e), this.rows.push(e), e
      },
      inputChanged: function() {
        this.input.dispatchEvent(new Event("input", {
          bubbles: !0
        }))
      },
      inputAdd: function(e) {
        this.input.value += this.caps ? this.getKeyUppercase(e) : this.getKeyLowercase(e), this.inputChanged(), this.caps && this.toggleCaps()
      },
      enter: function() {
        0 < this.input.value.length && (this.form.requestSubmit(), this.input.value = "", this.inputChanged())
      },
      toggleCaps: function() {
        this.caps = !this.caps;
        for (var e = 0; e < this.elements.keys.length; e++) {
          var t = this.elements.keys[e];
          t.textContent = this.caps ? this.getKeyUppercase(t.textContent) : this.getKeyLowercase(t.textContent)
        }
        this.elements.caps.classList.toggle("enabled", this.caps)
      }
    };
  let Ue = new Map;

  function He() {
    1 == Ye.value ? (_n[1].setAttribute("readonly", ""), c.documentElement.dataset.mobileKeyboard = "") : (_n[1].removeAttribute("readonly"), delete c.documentElement.dataset.mobileKeyboard)
  }
  Ue.set("backspace", {
    class: "wide",
    icon: "backspace",
    callback: function(e) {
      0 < e.input.value.length && (e.input.value = e.input.value.slice(0, -1), e.inputChanged())
    }
  }), Ue.set("caps", {
    class: "wide",
    icon: "keyboard_capslock",
    callback: function(e) {
      e.toggleCaps()
    }
  }), Ue.set("enter", {
    class: "wide",
    icon: "keyboard_return",
    callback: function(e) {
      e.enter()
    }
  }), Ue.set("space", {
    class: "extra-wide",
    icon: "space_bar",
    callback: function(e) {
      e.input.value += " ", e.inputChanged()
    }
  });
  for (var t = 0; t < Pe.length; t++) {
    var _e = se("option");
    _e.textContent = Pe[t].name, _e.value = Pe[t].code, ze.appendChild(_e)
  }
  D(ze, "change", function(e) {
    for (var t = void 0, n = 0; n < Pe.length; n++) Pe[n].code == this.value && (t = Pe[n]);
    null != t && Be.init(t)
  }), D([Ye, ze], "change", function(e) {
    le(), He()
  }), D(Be.elements.main, "gesturestart gesturechange gestureend drag scroll", function(e) {
    return e.preventDefault(), !1
  }), Be.init(Pe[0]);
  var Ge = {},
    Ke = [];

  function Fe(e, t) {
    e = e[t];
    return null != e && "" != e ? e : t
  }

  function E(e, t) {
    var n = Fe(Ge[l.displayLang], e),
      a = "",
      o = 0;
    Array.isArray(t) || (t = [t]);
    for (var r = 0; r < n.length; r++) {
      var i = n.charAt(r);
      "$" == i ? (a += t[o], o++) : a += i
    }
    return a
  }

  function Ve(e, t) {
    if ("children" == t)
      for (var n = 0; n < e.children.length; n++) {
        var a = e.children[n].dataset.translate;
        Ve(e.children[n], null == a ? "text" : a)
      } else {
        var o = "";
        "text" == t && (o = e.textContent), 0 < (o = "placeholder" == t ? e.placeholder : o).length ? Ke.push({
          key: o,
          element: e,
          type: t
        }) : (console.log("Empty key passed to translate with!"), console.log(e))
      }
  }
  Ge.en = {}, Ge.de = {
    "You have been kicked!": "Du wurdest gekickt!",
    "You have been banned!": "Du wurdest gebannt!",
    "You muted '$'!": "Du hast '$' stummgeschalten!",
    "You unmuted '$'!": "Du hast die Stummschaltung für '$' aufgehoben!",
    "You are on a kick cooldown!": "Du bist noch in der Kick Abklingzeit!",
    "You are banned from this room!": "Du bist von diesem Raum gebannt!",
    "You need at least 2 players to start the game!": "Du brauchst mind. 2 Spieler um das Spiel zu starten!",
    "Server restarting in about $ seconds!": "Server Neustart in ungefähr $ Sekunden!",
    "Spam detected! You're sending messages too quickly.": "Spam erkannt! Du sendest Nachrichten zu schnell.",
    "You can not votekick the lobby owner!": "Du kannst den Raumbesitzer nicht kicken!",
    "The word was '$'": "Das Wort war '$'",
    "$ is drawing now!": "$ zeichnet nun!",
    "$ is now the room owner!": "$ ist nun der Raumeigentümer!",
    "$ is voting to kick $ ($/$)": "$ möchte $ kicken ($/$)!",
    "$ joined the room!": "$ ist dem Raum beigetreten!",
    "$ left the room!": "$ hat den Raum verlassen!",
    "$ has been kicked!": "$ wurde gekickt!",
    "$ has been banned!": "$ wurde gebannt!",
    "$ guessed the word!": "$ hat das Wort erraten!",
    "$ liked the drawing!": "$ mag die Zeichnung!",
    "$ disliked the drawing!": "$ mag die Zeichnung nicht!",
    "$ is close!": "$ ist nah dran!",
    "$ is choosing a word!": "$ wählt ein Wort!",
    "$ won with a score of $!": "$ hat mit einem Punktestand von $ gewonnen!",
    "$ and $ won with a score of $!": "$ und $ haben mit einem Punktestand von $ gewonnen!",
    WAITING: "WARTEN",
    "DRAW THIS": "ZEICHNE",
    "WORD HIDDEN": "WORT VERSTECKT",
    "GUESS THIS": "RATE",
    "$ (You)": "$ (Du)",
    "$ points": "$ Punkte",
    "Room not found!": "Raum nicht gefunden!",
    "Room is full!": "Raum ist voll!",
    "No rooms found!": "Keine Räume gefunden!",
    "An unknown error ('$')": "Unbekannter Fehler ('$')",
    "Something went wrong!": "Etwas ist schief gelaufen!",
    "Disconnected!": "Verbindung getrennt!",
    "Connection lost!": "Verbindung verloren!",
    "Servers are currently undergoing maintenance!": "Server werden derzeit gewartet",
    "Please try again later!": "Bitte versuch es später noch einmal!",
    "An unknown error occurred ('$')": "Ein unbekannter Fehler ist aufgetreten ('$')",
    Unmute: "Stumm. aufheben",
    Mute: "Stummschalten",
    Rooms: "Räume",
    Settings: "Einstellungen",
    "Not started": "Nicht gestartet",
    Round: "Runde",
    Rounds: "Runden",
    "Round $": "Runde $",
    "Round $ of $": "Runde $ von $",
    "Waiting for players...": "Auf Spieler warten...",
    "Game starting in a few seconds...": "Das Spiel beginnt in wenigen Sekunden...",
    "is the winner!": "hat gewonnen!",
    "are the winners!": "haben gewonnen!",
    "Nobody won!": "Niemand hat gewonnen!",
    "Choose a word": "Wähle ein Wort",
    "The word was": "Das Wort war",
    User: "Spieler",
    Play: "Spielen",
    "Create Room": "Raum erstellen",
    "View Rooms": "Räume ansehen",
    "How to play": "Wie gespielt wird",
    About: "Über",
    News: "Neuigkeiten",
    "When it's your turn, choose a word you want to draw!": "Wähle ein Wort, das du zeichnen willst, wenn du dran bist!",
    "Try to draw your choosen word! No spelling!": "Versuche nun dein Wort zu zeichnen. Kein Schreiben!",
    "Let other players try to guess your drawn word!": "Lass andere Mitspieler dein gezeichnetes Wort erraten!",
    "When it's not your turn, try to guess what other players are drawing!": "Wenn du nicht dran bist mit Zeichnen, versuche die Zeichnungen anderer zu erraten!",
    "Score the most points and be crowned the winner at the end!": "Sammel die meisten Punkte und werde zum Gewinner!",
    "is a free online multiplayer drawing and guessing pictionary game.": "ist ein kostenloses Mehrspieler-Zeichnen und Raten- / Montagsmaler-Spiel.",
    "A normal game consists of a few rounds, where every round a player has to draw their chosen word and others have to guess it to gain points!": "Ein normales Spiel besteht aus drei Runden, in welcher jeder Spieler sein gewähltes Wort zeichnen muss, während die Anderen es für Punkte erraten müssen!",
    "The person with the most points at the end of the game, will then be crowned as the winner!": "Die Person mit dem höchsten Punktestand am Ende des Spiels wird als Sieger gekrönt!",
    "Have fun!": "Viel Spaß!",
    "Invite your friends!": "Lad deine Freunde ein!",
    Copy: "Kopieren",
    "Hover over me to see the Invite link!": "Einladungslink hier anschauen!",
    "Click to copy the link to this room!": "Klicke um den Einladungslink zu kopieren!",
    Visibility: "Sichtbarkeit",
    Name: "Name",
    Players: "Spieler",
    Drawtime: "Zeit",
    Language: "Sprache",
    "Word Mode": "Wort-Modus",
    "Word Count ": "Wort-Anzahl",
    Hints: "Hinweise",
    "Custom words": "Eigene Wörter",
    "Minimum of 10 words. 1-32 characters per word! 10000 characters maximum. Separated by a , (comma)": "Minimum von 10 Wörtern. 1-32 Buchstaben pro Wort. 10000 Buchstaben maximal. Getrennt durch ein , (Komma)",
    "Use custom words only": "Nur eigene Wörter benutzen",
    "Start!": "Starten!",
    All: "Alle",
    Custom: "Benutzerdefiniert",
    Public: "Öffentlich",
    Private: "Privat",
    Mode: "Modus",
    Normal: "Normal",
    Hidden: "Versteckt",
    Combination: "Kombination",
    "Please select the reasons for your report": "Bitte wählen Sie die Gründe für Ihre Meldung",
    "Inappropriate Messages / Drawings": "Unangemessene Nachrichten / Zeichnungen",
    Spam: "Spam",
    "Botting / Cheating": "Botting / Cheating",
    "Your report for '$' has been sent!": "Deine Meldung für '$' wurde abgesendet!",
    "Enter your name": "Gib dein Namen ein",
    "Filter rooms by name here...": "Suche nach Räume hier...",
    "Type your guess here...": "Rate das gesuchte Wort hier...",
    "Everyone guessed the word!": "Jeder hat das Wort erraten!",
    "The drawer left the game!": "Der Zeichner hat das Spiel verlassen!",
    "Time is up!": "Die Zeit ist abgelaufen!",
    Kick: "Kicken",
    Ban: "Bannen",
    Votekick: "Votekicken",
    Report: "Melden",
    "Randomize your Avatar!": "Zufälliger Avatar!",
    Brush: "Stift",
    Colorpick: "Pipette",
    Fill: "Füllen",
    Undo: "Rückgängig",
    Clear: "Löschen",
    "Mute audio": "Stummschalten",
    "Unmute audio": "Stumm. aufheben",
    "Turn the lights off": "Lichter ausmachen",
    "Turn the lights on": "Lichter anmachen",
    "Hotkeys & Misc.": "Tastenkürzel & Sonstiges",
    Hotkeys: "Tastenkürzel",
    Miscellaneous: "Sonstiges",
    "Display Language": "Anzeigesprache",
    "Filter bad words in chat": "Schlechte Wörter im Chat filtern",
    "Brush Pressure Sensitivity": "Stiftdruckempfindlichkeit",
    Reset: "Zurücksetzen",
    "Reset hotkeys to default": "Tastenkürzel zurücksetzen",
    On: "An",
    Off: "Aus"
  };
  let je = 0,
    Ze = 1,
    Xe = 0,
    Je = 4,
    Qe = 40;
  var et = [4, 10, 20, 32, 40],
    tt = c.querySelector("#game-toolbar"),
    nt = tt.querySelector(".toolbar-group-tools"),
    at = tt.querySelector(".toolbar-group-actions"),
    n = c.querySelector("#game-toolbar .sizes .size-preview"),
    ot = c.querySelector("#game-toolbar .sizes .container"),
    rt = c.querySelector("#game-toolbar .colors");

  function it(e, t) {
    var n, a, o, r = $("tool clickable"),
      i = (r.appendChild($("icon")), r.appendChild($("key")), t),
      l = (i.id = e, (i.element = r).toolIndex = e, r.querySelector(".icon").style.backgroundImage = "url(/img/" + t.graphic + ")", o = t.name, a = "S", (n = r).dataset.tooltip = o, n.dataset.tooltipdir = a, D(n, "pointerenter", function(e) {
        We(e.target)
      }), D(n, "pointerleave", function(e) {
        Oe()
      }), o = t.isAction ? (r.addEventListener("click", function(e) {
        Rt(this.toolIndex)
      }), at.appendChild(r), st[e] = i, re(t.name, t.keydef, "", function() {
        Rt(e)
      }, function(e) {
        l.textContent = e.key
      })) : (r.addEventListener("click", function(e) {
        Tt(this.toolIndex)
      }), nt.appendChild(r), lt[e] = i, re(t.name, t.keydef, "", function() {
        Tt(i.id)
      }, function(e) {
        l.textContent = e.key
      })), r.querySelector(".key"));
    l.textContent = o.key, t.hide && (r.style.display = "none")
  }
  var lt = [],
    st = (it(Xe, {
      isAction: !1,
      name: "Brush",
      keydef: "B",
      graphic: "pen.gif",
      cursor: 0
    }), it(1, {
      isAction: !1,
      name: "Fill",
      keydef: "F",
      graphic: "fill.gif",
      cursor: "url(/img/fill_cur.png) 7 38, default"
    }), []),
    C = (it(0, {
      isAction: !0,
      name: "Undo",
      keydef: "U",
      graphic: "undo.gif",
      action: function() {
        {
          var e;
          M == x && 0 < pt.length && (pt.pop(), 0 < pt.length ? (Ut(e = pt[pt.length - 1]), S && S.emit("data", {
            id: Ta,
            data: e
          })) : Ft())
        }
      }
    }), it(1, {
      isAction: !0,
      name: "Clear",
      keydef: "C",
      graphic: "clear.gif",
      action: Ft
    })
/*TYPOMOD DESC: add tool for deselect*/ 
                ,
                it(-1, {
                    isAction: !1,
                    name: "No Tool",
                    graphic: "",
                    keydef: "",
                }) 
                /*TYPOEND*/, c.querySelector("#game-canvas canvas")),
    ct = C.getContext("2d", {
      willReadFrequently: !0
    }),
    v = [],
    dt = 0,
    ut = 0,
    ht = [],
    r = [0, 9999, 9999, 0, 0],
    pt = [],
    b = [0, 0],
    mt = [0, 0],
    gt = 0,
    ft = c.createElement("canvas"),
    o = (ft.width = Qe + 2, ft.height = Qe + 2, ft.getContext("2d"));

  function yt() {
    
// TYPOMOD
// desc: dont update cursor when typo updates if very frequently to avoid performance drop
if(typo.skipCursorUpdate === true) return;var e = lt[vt].cursor;
    if (L.id == j && M == x) {
      if (vt == Xe) {
        var t = ft.width,
          n = Ct;
        if (n <= 0) return;
        o.clearRect(0, 0, t, t);
// TYPOMOD
// desc: cursor with custom color
var a = bt < 10000 ? kt[bt] : typo.typoCodeToRgb(bt);
// TYPOEND 
 
          a = [(a = 1 == l.dark ? [Math.floor(.75 * a[0]), Math.floor(.75 * a[1]), Math.floor(.75 * a[2])] : a)[0], a[1], a[2], .8];
        o.fillStyle = "rgba(" + a[0] + "," + a[1] + "," + a[2] + "," + a[3] + ")", o.beginPath(), o.arc(t / 2, t / 2, n / 2 - 1, 0, 2 * Math.PI), o.fill(), o.strokeStyle = "#FFF", o.beginPath(), o.arc(t / 2, t / 2, n / 2 - 1, 0, 2 * Math.PI), o.stroke(), o.strokeStyle = "#000", o.beginPath(), o.arc(t / 2, t / 2, n / 2, 0, 2 * Math.PI), o.stroke();
        a = t / 2, e = "url(" + ft.toDataURL() + ")" + a + " " + a + ", default"
      }
    } else e = "default";
    C.style.cursor = e
  }
  var vt = 0,
    bt = 0,
    St = 0,
    kt = [
      [255, 255, 255],
      [0, 0, 0],
      [193, 193, 193],
      [80, 80, 80],
      [239, 19, 11],
      [116, 11, 7],
      [255, 113, 0],
      [194, 56, 0],
      [255, 228, 0],
      [232, 162, 0],
      [0, 204, 0],
      [0, 70, 25],
      [0, 255, 145],
      [0, 120, 93],
      [0, 178, 255],
      [0, 86, 158],
      [35, 31, 211],
      [14, 8, 101],
      [163, 0, 186],
      [85, 0, 105],
      [223, 105, 167],
      [135, 53, 84],
      [255, 172, 142],
      [204, 119, 77],
      [160, 82, 45],
      [99, 48, 13]
    ],
    wt = ["White", "Black", "Light Gray", "Gray", "Red", "Dark Red", "Orange", "Dark Orange", "Yellow", "Dark Yellow", "Green", "Dark Green", "Mint", "Dark Mint", "Skyblue", "Dark Skyblue", "Seablue", "Dark Seablue", "Purple", "Dark Purple", "Pink", "Dark Pink", "Beige", "Dark Beige", "Brown", "Dark Brown"],
    Ct = 0,
    qt = -1,
    xt = [];

  function Mt(e) {
    return 20 + (e - Je) / (Qe - Je) * 80
  }
  for (t = 0; t < et.length; t++) {
    var Lt = $("size clickable"),
      Dt = $("icon"),
      $t = (Dt.style.backgroundSize = Mt(et[t]) + "%", {
        id: t,
        size: et[t],
        element: Lt,
        elementIcon: Dt
      });
    Lt.appendChild(Dt), ot.appendChild(Lt), Lt.size = $t, xt.push($t)
  }
  for (var Et = [$("top"), $("bottom")], t = 0; t < kt.length / 2; t++) Et[0].appendChild(Yt(2 * t)), Et[1].appendChild(Yt(2 * t + 1));
  for (t = 0; t < Et.length; t++) rt.appendChild(Et[t]);

  function At(e) {
    Ct = q(e, Je, Qe);
    for (var t = xt[xt.length - 1], n = t.size, a = 0; a < xt.length; a++) {
      var o = xt[a],
        r = Math.abs(Ct - o.size);
      r <= n && (n = r, t = o, 0), o.element.classList.remove("selected")
    }
    t.element.classList.add("selected"), tt.querySelector(".size-preview .icon").style.backgroundSize = Mt(Ct) + "%",
document.dispatchEvent(new CustomEvent("skribblSizeChanged", { detail: Ct })), yt()
  }

  function It(e) {
    e.classList.remove("clicked"), e.offsetWidth, e.classList.add("clicked")
  }

  function Rt(e) {
    It(st[e].element), st[e].action()
  }

  function Tt(e, t) {
  
/*toolidtarget*/ document.dispatchEvent(new CustomEvent("skribblToolChanged", {detail: e}));  It(lt[e].element), e == vt && !t || (lt[vt].element.classList.remove("selected"), lt[e].element.classList.add("selected"), vt = e, yt())
  }

  function Nt(e) {
    var t =
e > 10000 ? zt(typo.typoCodeToRgb(e)) : zt(kt[e]);
    bt = e, c.querySelector("#color-preview-primary").style.fill = t
, document.dispatchEvent(new CustomEvent("skribblColorChanged", {detail: t})), c.querySelector("#game-toolbar .color-preview-mobile").style.backgroundColor = t, yt()
  }

  function Wt(e) {
    var t =
e > 10000 ? zt(typo.typoCodeToRgb(e)) : zt(kt[e]);
    St = e, c.querySelector("#color-preview-secondary").style.fill = t, yt()
  }

  function Ot() {
    var e = bt;
    Nt(St), Wt(e)
  }

  function Pt() {
    ot.classList.remove("open")
  }

  function Yt(e) {
    var t = $("color");
    return t.style.backgroundColor = zt(kt[e]), t.colorIndex = e, t
  }

  function zt(e) {
    return "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")"
  }

  function Bt(e) {
/*TYPOMOD   
desc: if color code > 1000 -> customcolor*/if(e < 1000)
    e = q(e, 0, kt.length), e = kt[e];
else e = typo.typoCodeToRgb(e);/* TYPOEND */
    return {
      r: e[0],
      g: e[1],
      b: e[2]
    }
  }

  function Ut(e) {
    if (v = v.slice(0, e), !(x != M && ut < e)) {
      r = _t();
      e = Math.floor(v.length / Ht);
      ht = ht.slice(0, e), Jt();
      for (var t = 0; t < ht.length; t++) {
        var n = ht[t];
        ct.putImageData(n.data, n.bounds[1], n.bounds[2])
      }
      for (t = ht.length * Ht; t < v.length; t++) Gt(jt(v[t]), v[t]);
      dt = Math.min(v.length, dt), ut = Math.min(v.length, ut)
    }
  }
  let Ht = 50;

  function _t() {
    return [0, 9999, 9999, 0, 0]
  }

  function Gt(e) {
    var t, n, a, o;
    r[0] += 1, r[1] = Math.min(r[1], e[0]), r[2] = Math.min(r[2], e[1]), r[3] = Math.max(r[3], e[2]), r[4] = Math.max(r[4], e[3]), r[0] >= Ht && (t = r[1], n = r[2], a = r[3], o = r[4], (a - t <= 0 || o - n <= 0) && (t = e[0], n = e[1], a = e[2], o = e[3]), e = ct.getImageData(t, n, a - t, o - n), ht.push({
      data: e,
      bounds: r
    }), r = _t())
  }

  function Kt(e) {
    return (e || 0 < v.length || 0 < pt.length || 0 < dt || 0 < ut) && (v = [], pt = [], dt = ut = 0, r = _t(), ht = [], Jt(), 1)
  }

  function Ft() {
    M == x && Kt() && S && S.emit("data", {
      id: Ra
    })
  }

  function Vt(e) {
    var t, n, a, o, r, i;
    ((t = e)[0] != je ? t[0] == Ze && 0 <= t[2] && t[2] < C.width && 0 <= t[3] && t[3] < C.height : (a = t[3], o = t[4], r = t[5], i = t[6], t = Math.ceil(t[2] / 2), n = (a + r) / 2, o = (o + i) / 2, r = Math.abs(r - a) / 2, a = Math.abs(i - i) / 2, (i = {
      x1: -(t + r),
      y1: -(t + r),
      x2: C.width + t + r,
      y2: C.height + t + a
    }).x1 < n && n < i.x2 && i.y1 < o && o < i.y2)) ? (v.push(e), x == M && Gt(jt(e))) : console.log("IGNORED COMMAND OUT OF CANVAS BOUNDS")
  }

  function jt(e) {
    var t = [0, 0, C.width, C.height];
    switch (e[0]) {
      case je:
        var n = q(Math.floor(e[2]), Je, Qe),
          a = Math.ceil(n / 2),
          o = q(Math.floor(e[3]), -a, C.width + a),
          r = q(Math.floor(e[4]), -a, C.height + a),
          i = q(Math.floor(e[5]), -a, C.width + a),
          a = q(Math.floor(e[6]), -a, C.height + a),
          l = Bt(e[1]);
        t[0] = q(o - n, 0, C.width), t[1] = q(r - n, 0, C.height), t[2] = q(i + n, 0, C.width), t[3] = q(a + n, 0, C.height), Xt(o, r, i, a, n, l.r, l.g, l.b);
        break;
      case Ze:
        var l = Bt(e[1]),
          o = q(Math.floor(e[2]), 0, C.width),
          r = q(Math.floor(e[3]), 0, C.height),
          i = o,
          a = r,
          s = l.r,
          c = l.g,
          d = l.b,
          u = ct.getImageData(0, 0, C.width, C.height),
          h = [
            [i, a]
          ],
          p = ((e, t, n) => 0 <= (n = 4 * (n * e.width + t)) && n < e.data.length ? [e.data[n], e.data[1 + n], e.data[2 + n]] : [0, 0, 0])(u, i, a);
        if (s != p[0] || c != p[1] || d != p[2]) {
          for (var m, g, f, y, v, b, S = function(e) {
              var t = u.data[e],
                n = u.data[e + 1],
                e = u.data[e + 2];
              return (t != s || n != c || e != d) && (t = Math.abs(t - p[0]), n = Math.abs(n - p[1]), e = Math.abs(e - p[2]), t < 3) && n < 3 && e < 3
            }, k = u.height, w = u.width; h.length;) {
            for (m = h.pop(), g = m[0], y = 4 * ((f = m[1]) * w + g); 0 <= f-- && S(y);) y -= 4 * w;
            for (y += 4 * w, ++f, b = v = !1; f++ < k - 1 && S(y);) Zt(u, y, s, c, d), 0 < g && (S(y - 4) ? v || (h.push([g - 1, f]), v = !0) : v = v && !1), g < w - 1 && (S(y + 4) ? b || (h.push([g + 1, f]), b = !0) : b = b && !1), y += 4 * w
          }
          ct.putImageData(u, 0, 0)
        }
    }
    return t
  }

  function q(e, t, n) {
    return e < t ? t : n < e ? n : e
  }

  function Zt(e, t, n, a, o) {
    0 <= t && t < e.data.length && (e.data[t] = n, e.data[t + 1] = a, e.data[t + 2] = o, e.data[t + 3] = 255)
  }

  function Xt(e, t, n, a, o, r, i, l) {
    function s(e, t) {
      for (var n = -c; n <= c; n++)
        for (var a, o = -c; o <= c; o++) n * n + o * o < d && 0 <= (a = 4 * ((t + o) * m.width + e + n)) && a < m.data.length && (m.data[a] = r, m.data[1 + a] = i, m.data[2 + a] = l, m.data[3 + a] = 255)
    }
    var c = Math.floor(o / 2),
      d = c * c,
      o = Math.min(e, n) - c,
      u = Math.min(t, a) - c,
      h = Math.max(e, n) + c,
      p = Math.max(t, a) + c,
      m = (e -= o, t -= u, n -= o, a -= u, ct.getImageData(o, u, h - o, p - u));
    if (e == n && t == a) s(e, t);
    else {
      s(e, t), s(n, a);
      var g = Math.abs(n - e),
        f = Math.abs(a - t),
        y = e < n ? 1 : -1,
        v = t < a ? 1 : -1,
        b = g - f;
      for (Math.floor(Math.max(0, c - 10) / 5); e != n || t != a;) {
        var S = b << 1; - f < S && (b -= f, e += y), S < g && (b += g, t += v), s(e, t)
      }
    }
    ct.putImageData(m, o, u)
  }

  function Jt() {
/* TYPOMOD
         desc: store data before clear */
        const data = document.querySelector("#game-canvas canvas").toDataURL();
/* TYPOEND */
    ct.fillStyle = "#FFF", ct.fillRect(0, 0, C.width, C.height)
/* TYPOMOD
         desc: dispatch clear event */
        ;document.dispatchEvent(new CustomEvent("logCanvasClear", { detail: data }));
/* TYPOEND */
  }

  function Qt(e) {
    if (L.id == j && M == x && -1 != qt) {
      var t = 0 == qt ? bt : St,
        n = null;
      if (e) {
        var e = ((e, t) => {
          for (var n = (e = ct.getImageData(e, t, 1, 1)).data[0], a = e.data[1], o = e.data[2], r = 0; r < kt.length; r++) {
            var i = kt[r];
            if (0 == i[0] - n && 0 == i[1] - a && 0 == i[2] - o) return r
          }
/* TYPOMOD
                     desc: if color is not in array, convert to custom color */
                    return r = parseInt(typo.rgbToHex(n, a, o), 16) + 10000;
                    /* TYPOEND */
          return r
        })(b[0], b[1]);
        if (1 == vt) {
          if (e == t) return;
          e = t, l = b[0], s = b[1], n = [Ze, e, l, s]
        }
      }
      vt == Xe && (e = Ct, 0 <= gt && (e = (e - Je) * q(gt, 0, 1) + Je), 
/* TYPOMOD use typo pressure */
              (() => {
                  if (0 <= gt && document.documentElement.dataset["typo_pressure_performance"]) {
                      const pressure = eval(document.documentElement.dataset["typo_pressure_performance"])(gt);
                      e = Math.max(4, Math.round(40 * pressure));
                  }
              })(),l = Math.ceil(.5 * e), s = q(Math.floor(mt[0]), -l, C.width + l), o = q(Math.floor(mt[1]), -l, C.height + l), r = q(Math.floor(b[0]), -l, C.width + l), i = q(Math.floor(b[1]), -l, C.height + l), t = t, e = e, a = s, o = o, r = r, i = i, n = [je, t, e, a, o, r, i]), null != n && Vt(n)
    }
    var a, o, r, i, l, s
  }

  function en(e, t, n, a) {
    var o = C.getBoundingClientRect(),
      e = Math.floor((e - o.left) / o.width * C.width),
      t = Math.floor((t - o.top) / o.height * C.height);
    a ? (gt = n, mt[0] = b[0] = e, mt[1] = b[1] = t) : (mt[0] = b[0], mt[1] = b[1], gt = n, b[0] = e, b[1] = t)
  }

  function tn(e) {
    return 0 == e || 2 == e || 5 == e
  }

  function nn(e) {
    var t = "Left-/Rightclick to choose a color!\\n" + wt[this.colorIndex];
    c.querySelector("#game-toolbar .colors").dataset.tooltip = t, i && (i.querySelector(".tooltip-content").textContent = E(Ne.dataset.tooltip))
  }

  function an(e) {
    var t, n;
    t = this.colorIndex, n = 0 == e.button, ((n = e.altKey ? !n : n) ? Nt : Wt)(t)
  }
  D(tt, "contextmenu", function(e) {
    return e.preventDefault(), !1
  }), D("#game-toolbar .sizes .size", "click", function(e) {
    var t;
    t = this.size.id, It((t = xt[t]).element), At(t.size), Pt()
  }), D([C], "DOMMouseScroll wheel", function(e) {
    e.preventDefault();
    e = -e.deltaY || e.wheelDeltaY, e = Math.sign(e);
    At(Ct + 2 * e)
  }), re("Swap", "S", "Swap the primary and secondary color.", Ot), D(tt.querySelector(".color-preview"), "click", function(e) {
    Ot()
  }), D(tt.querySelector(".color-preview-mobile"), "click", function(e) {
    tt.querySelector(".colors").classList.toggle("open")
  }), D(n, "click", function(e) {
    ot.classList.toggle("open")
  }), D(c, "keydown", function(e) {
    if ("Enter" == e.code) return _n[0].focus(), 0;
    if ("input" == c.activeElement.tagName.toLowerCase() || "textarea" == c.activeElement.tagName.toLowerCase() || -1 != qt) return 0;
    for (var t = e.key.toLowerCase().replace("key", ""), n = 0; n < u.length; n++)
      if (u[n].key.toLowerCase() == t) {
        for (var a = 0; a < u[n].cb.length; a++) u[n].cb[a](u[n]);
        return void e.preventDefault()
      }
  }), D(C, "contextmenu", function(e) {
    return e.preventDefault(), !1
  });
  var on = null;
  "PointerEvent" in h ? (D("#game-toolbar .colors * .color", "pointerenter", nn), D("#game-toolbar .colors * .color", "pointerdown", an), D(C, "pointerdown", function(e) {
    var t, n, a, o;
    null == on && tn(e.button) && (h.getSelection ? h.getSelection().removeAllRanges() : c.selection && c.selection.empty(), t = 1 == l.pressureSensitivity && "pen" == e.pointerType, n = e.clientX, a = e.clientY, o = -1, t && (o = (ae && e.pressure, e.pressure)), on = e.pointerId, qt = e.button, C.setPointerCapture(e.pointerId), v.length, en(n, a, o, !0), Qt(!0))
  }), D(C, "pointermove", function(e) {
    var t, n;
    on !== e.pointerId || (() => {
      var e = performance.now();
      if (
document.body.dataset.bypassFps !== 'true' &&e - ln < 1e3 / rn) return 1;
      ln = e
    })() || (t = 1 == l.pressureSensitivity && "pen" == e.pointerType, n = -1, en(e.clientX, e.clientY, n = t ? (ae && e.pressure, e.pressure) : n, !1), Qt(!1))
  }), D(C, "pointerup pointercancel", function(e) {
    on === e.pointerId && (sn != v.length && (sn = v.length, pt.push(sn)), on = null, qt = -1, C.releasePointerCapture(e.pointerId))
  })) : (D("#game-toolbar .colors * .color", "mouseenter", nn), D("#game-toolbar .colors * .color", "click", an), D(C, "mousedown", function(e) {
    tn(e.button) && (qt = e.button, v.length, en(e.clientX, e.clientY, -1, !0), Qt(!0))
  }), D(c, "mousemove", function(e) {
    en(e.clientX, e.clientY, -1, !1), Qt(!1)
  }), D(c, "mouseup", function(e) {
    -1 != qt && (sn != v.length && (sn = v.length, pt.push(sn)), qt = -1)
  }));
  let rn = 90;
  var S, ln = 0,
    sn = 0,
    cn = (setInterval(function() {
      var e, t, n;
      S && L.id == j && M == x && 0 < (e = v.length - dt) && (t = dt + 8, n = v.slice(dt, t), S.emit("data", {
        id: Ia,
        data: n
      }), dt = Math.min(t, v.length), 
false &&console.log(\`Sent \${n.length} commands. \${e} remaining.\`))
    }, 
document.body.dataset.bypassCommandRate === 'true' ? 0 :50), setInterval(function() {
      S && L.id == j && M != x && ut < v.length && (Gt(jt(v[ut]), v[ut]), ut++)
    }, 1), c.querySelector("#game-canvas .overlay")),
    dn = c.querySelector("#game-canvas .overlay-content"),
    A = c.querySelector("#game-canvas .overlay-content .text"),
    un = c.querySelector("#game-canvas .overlay-content .words"),
    hn = c.querySelector("#game-canvas .overlay-content .reveal"),
    I = c.querySelector("#game-canvas .overlay-content .result"),
    pn = c.querySelector("#game-canvas .overlay-content .room"),
    mn = -100,
    gn = 0,
    fn = void 0;

  function yn(e, a, o) {
    var r, i, l = mn,
      s = gn,
      c = e.top - l,
      d = e.opacity - s;
    Math.abs(c) < .001 && Math.abs(d) < .001 ? o && o() : (r = void 0, i = 0, fn = h.requestAnimationFrame(function e(t) {
      var n = t - (r = null == r ? t : r),
        t = (r = t, (i = Math.min(i + n, a)) / a),
        n = (n = t) < .5 ? .5 * ((e, t) => e * e * ((t + 1) * e - t))(2 * n, 1.2 * 1.5) : .5 * (((e, t) => e * e * ((t + 1) * e + t))(2 * n - 2, 1.2 * 1.5) + 2);
      mn = l + c * n, gn = s + t * t * (3 - 2 * t) * d, dn.style.top = mn + "%", cn.style.opacity = gn, i == a ? o && o() : fn = h.requestAnimationFrame(e)
    }))
  }

  function vn(e) {
    e.classList.add("show")
  }
/* TYPOMOD desc: add event handlers for typo features */
                document.addEventListener("joinPractice", () => {
                  const data = typo.createFakeLobbyData();
                  typo.messagePort.postMessage({ id: 10, data });
                  //document.dispatchEvent(new CustomEvent("practiceJoined", {detail: data}));
                  aa(data);
                
                  S = new Proxy({},{
                    emit: (...data) => typo.emitPort.postMessage(data),
                    other: (...data) => void 0,
                    get (target, prop) {
                      if(prop === "emit"){
                        return this.emit;
                      }
                      else return this.other;
                    }
                  });
                });
                /* TYPOEND */

  function bn(e) {
    for (var t = 0; t < dn.children.length; t++) dn.children[t].classList.remove("show");
    switch (e.id) {
      case J:
        vn(pn);
        break;
      case F:
        vn(A), A.textContent = E("Round $", e.data + 1);
        break;
      case G:
        vn(A), A.textContent = E("Waiting for players...");
        break;
      case K:
        vn(A), A.textContent = E("Game starting in a few seconds...");
        break;
      case Z:
        vn(hn), hn.querySelector("p span.word").textContent = e.data.word, hn.querySelector(".reason").textContent = (e => {
          switch (e) {
            case B:
              return E("Everyone guessed the word!");
            case H:
              return E("The drawer left the game!");
            case U:
              return E("Time is up!");
            case _:
              return E("Drawer got skipped!");
            default:
              return "Error!"
          }
        })(e.data.reason);
        for (var n = hn.querySelector(".player-container"), a = (ce(n), []), o = 0; o < e.data.scores.length; o += 3) {
          var r = e.data.scores[o + 0],
            i = (e.data.scores[o + 1], e.data.scores[o + 2]);
          (s = W(r)) && a.push({
            name: s.name,
            score: i
          })
        }
        a.sort(function(e, t) {
          return t.score - e.score
        });
        for (o = 0; o < Math.min(a.length, 12); o++) {
          var l = $("player"),
            s = a[o],
            c = (l.appendChild($("name", s.name)), $("score", (0 < s.score ? "+" : "") + s.score));
          s.score <= 0 && c.classList.add("zero"), l.appendChild(c), n.appendChild(l)
        }
        break;
      case X:
        vn(I);
        for (var d = [I.querySelector(".podest-1"), I.querySelector(".podest-2"), I.querySelector(".podest-3"), I.querySelector(".ranks")], o = 0; o < 4; o++) ce(d[o]);
        if (0 < e.data.length) {
          for (var u = [
              [],
              [],
              [],
              []
            ], o = 0; o < e.data.length; o++)(s = {
            player: W(r = e.data[o][0]),
            rank: e.data[o][1],
            title: e.data[o][2]
          }).player && u[Math.min(s.rank, 3)].push(s);
          for (var h = 0; h < 3; h++) {
            var p = u[h];
            if (0 < p.length) {
              var m = p.map(function(e) {
                  return e.player.name
                }).join(", "),
                g = p[0].player.score,
                f = d[h],
                l = $("avatar-container"),
                y = (f.appendChild(l), $("border"));
              y.appendChild($("rank-place", "#" + (h + 1))), y.appendChild($("rank-name", m)), y.appendChild($("rank-score", E("$ points", g))), f.appendChild(y), 0 == h && l.appendChild($("trophy"));
              for (o = 0; o < p.length; o++) pe(b = de((s = p[o]).player.avatar, 0 == h), Ya(s.player)), b.style.left = 15 * -(p.length - 1) + 30 * o + "%", 
b.setAttribute("playerid", s.player.id),0 == h && (b.classList.add("winner"), b.style.animationDelay = -2.35 * o + "s"), l.appendChild(b)
            }
          }
          for (var v = Math.min(5, u[3].length), o = 0; o < v; o++) {
            var b, s = u[3][o],
              f = $("rank");
            pe(b = de(s.player.avatar, !1), Ya(s.player)), f.appendChild(b), f.appendChild($("rank-place", "#" + (s.rank + 1))), f.appendChild($("rank-name", s.player.name)),
f.setAttribute("playerid", s.player.id), /*elemanchor*/ f.appendChild($("rank-score", E("$ points", s.player.score))), d[3].appendChild(f)
          }
          0 < u[0].length ? (L = u[0].map(function(e) {
            return e.player.name
          }).join(", "), I.querySelector(".winner-name").textContent = (0 < u[0].length ? L : "<user left>") + " ", I.querySelector(".winner-text").textContent = 1 == u[0].length ? E("is the winner!") : E("are the winners!")) : (I.querySelector(".winner-name").textContent = "", I.querySelector(".winner-text").textContent = E("Nobody won!"))
        } else I.querySelector(".winner-name").textContent = "", I.querySelector(".winner-text").textContent = E("Nobody won!");
        break;
      case V:
        if (e.data.words)
          if (vn(A), vn(un), ce(un), An[te.WORDMODE] == ne.COMBINATION) {
            A.textContent = E("Choose the first word");
            for (var S = e.data.words.length / 2, k = [], w = [], C = 0, o = 0; o < S; o++) {
              var q = $("word", e.data.words[o]),
                x = (q.index = o, $("word", e.data.words[o + S]));
              x.index = o, x.style.display = "none", x.style.animationDelay = .03 * o + "s", k.push(q), w.push(x), D(q, "click", function() {
                C = this.index;
                for (var e = 0; e < S; e++) k[e].style.display = "none", w[e].style.display = "";
                A.textContent = E("Choose the second word")
              }), D(x, "click", function() {
                ha([C, this.index])
              }), un.appendChild(q), un.appendChild(x)
            }
          } else {
            A.textContent = E("Choose a word");
            for (o = 0; o < e.data.words.length; o++) {
              var M = $("word", e.data.words[o]);
              M.index = o, D(M, "click", function() {
                ha(this.index)
              }), un.appendChild(M)
            }
          }
        else {
          vn(A);
          var L = (s = W(e.data.id)) ? s.name : E("User"),
            L = (A.textContent = "", A.appendChild(se("span", void 0, E("$ is choosing a word!", L))), de(s
&& (A.setAttribute("playerid", s.id) || true) /*overlayanchor*/ ? s.avatar : [0, 0, 0, 0], e.data.id == En));
          s && pe(L, Ya(s)), L.style.width = "2em", L.style.height = "2em", A.appendChild(L)
        }
    }
  }
  let Sn = 0,
    kn = 1,
    wn = 2,
    Cn = 3,
    qn = 4,
    xn = 5,
    Mn = 6;

  function Ln(e, t) {
    this.url = t, this.buffer = null, this.loaded = !1;
    var n = this,
      a = new XMLHttpRequest;
    a.open("GET", t, !0), a.responseType = "arraybuffer", a.onload = function() {
      e.context.decodeAudioData(a.response, function(e) {
        n.buffer = e, n.loaded = !0
      }, function(e) {
        console.log("Failed loading audio from url '" + t + "'")
      })
    }, a.send()
  }

  function Dn() {
    this.context = null, this.gain = null, this.sounds = new Map, h.addEventListener("load", this.load.bind(this), !1)
  }
  Dn.prototype.addSound = function(e, t) {
    this.sounds.set(e, new Ln(this, t))
  }, Dn.prototype.loadSounds = function() {
    this.addSound(Sn, "/audio/roundStart.ogg"), this.addSound(kn, "/audio/roundEndSuccess.ogg"), this.addSound(wn, "/audio/roundEndFailure.ogg"), this.addSound(Cn, "/audio/join.ogg"), this.addSound(qn, "/audio/leave.ogg"), this.addSound(xn, "/audio/playerGuessed.ogg"), this.addSound(Mn, "/audio/tick.ogg")
  }, Dn.prototype.playSound = function(e) {
    var t, n;
    null == this.context ? this.load() : "running" != this.context.state ? this.context.resume().then(function() {
      this.playSound(e)
    }) : null != this.context && 0 < l.volume && this.sounds.has(e) && (t = this.sounds.get(e)).loaded && ((n = this.context.createBufferSource()).buffer = t.buffer, n.connect(this.gain), n.start(0))
  }, Dn.prototype.setVolume = function(e) {
    g[p].querySelector("#volume .title .icon").classList.toggle("muted", e <= 0), g[p].querySelector("#volume .volume-value").textContent = e <= 0 ? "Muted" : e + "%", this.gain && (this.gain.gain.value = e / 100)
  }, Dn.prototype.load = function() {
    if (null == this.context) try {
      h.AudioContext = h.AudioContext || h.webkitAudioContext, this.context = new AudioContext, this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.setVolume(l.volume), console.log("AudioContext created."), this.loadSounds()
    } catch (e) {
      console.log("Error creating AudioContext.", e), this.context = null
    }
  };
  let k = 4,
    $n = location.origin + "/api/play";
  G;
  var w = [],
    x = 0,
    En = -1,
    M = -1,
    An = [],
    L = {
      id: -1,
      time: 0,
      data: 0
    },
    In = -1,
    Rn = 0,
    Tn = void 0,
    R = new Dn,
    T = void 0,
    Nn = !1,
    Wn = !1,
    On = c.querySelector("#game"),
    Pn = c.querySelector("#game-wrapper"),
    n = c.querySelector("#game-canvas .room"),
    Yn = c.querySelector("#game-players"),
    zn = c.querySelector("#game-players .players-list"),
    Bn = c.querySelector("#game-players-footer"),
    Un = (c.querySelector("#game-board"), c.querySelector("#game-bar"), c.querySelector("#game-round .text")),
    N = [c.querySelector("#game-word .description"), c.querySelector("#game-word .word"), c.querySelector("#game-word .hints .container")],
    Hn = (c.querySelector("#game-chat"), [c.querySelector("#game-chat form"), c.querySelector("#game-chat-input-mobile form")]),
    _n = [c.querySelector("#game-chat input"), c.querySelector("#game-chat-input-mobile input")],
    Gn = c.querySelector("#game-chat .chat-content"),
    Kn = c.querySelector("#home .container-name-lang input"),
    Fn = c.querySelector("#home .container-name-lang select"),
    Vn = c.querySelector("#home .panel .button-play"),
    jn = c.querySelector("#home .panel .button-create");
  let Zn = 11 == (Xn = new Date).getMonth() && 19 <= (Xn = Xn.getDate()) && Xn <= 26;
  var Xn = 9 == (Xn = new Date).getMonth() && 24 <= (Xn = Xn.getDate()) && Xn <= 31;

  function Jn(e) {
    Nn = e, c.querySelector("#load").style.display = e ? "block" : "none"
  }

  function Qn(e, t, n, a) {
    var o, r;
    e = e, t = t, o = function(e, t) {
      switch (e) {
        case 200:
          return void n({
            success: !0,
            data: t
          });
        case 503:
        case 0:
          a && qe(ye, E("Servers are currently undergoing maintenance!") + "\\n\\r" + E("Please try again later!") + "\\n\\rStatus: " + e);
          break;
        default:
          a && qe(ye, E("An unknown error occurred ('$')", e) + "\\n\\r" + E("Please try again later!"))
      }
     
document.dispatchEvent(new CustomEvent("joinLobbyFailed")) & n({
        success: !1,
        error: e
      })
    }, (r = new XMLHttpRequest).onreadystatechange = function() {
      4 == this.readyState && o(this.status, this.response)
    }, r.open("POST", e, !0), r.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), r.send(t)
  }
  Zn;
  var ea = null;
  adplayer = null;
  try {
    aiptag.cmd.player.push(function() {
      console.log("ad player loaded"), adplayer = new aipPlayer({
        AD_WIDTH: 960,
        AD_HEIGHT: 540,
        AD_FULLSCREEN: !1,
        AD_CENTERPLAYER: !0,
        LOADING_TEXT: "loading advertisement",
        PREROLL_ELEM: function() {
          return c.getElementById("preroll")
        },
        AIP_COMPLETE: function(e) {
          ea()
        },
        AIP_REMOVE: function() {}
      })
    })
  } catch (e) {
    console.log("ad push failed: "), console.log(e)
  }

  function ta(t) {
    var e, n, a = !1;
    if (h.localStorageAvailable && (n = d.getItem("lastAd"), e = new Date, d.setItem("lastAd", e.toString()), null == n ? n = e : (n = new Date(Date.parse(n)), a = 1 <= Math.abs(n - e) / 1e3 / 60)), a) try {
      aiptag && adplayer && null != adplayer && "undefined" !== adplayer ? (ea = t, aiptag.cmd.player.push(function() {
        adplayer.startPreRoll()
      })) : t()
    } catch (e) {
      console.log(e), t()
    } else t()
  }

  function na(e, t, n) {
    R.context && R.context.resume && R.context.resume(), S && ua();
    var a, o = 0,
      r = {
        transports: ["websocket", "polling"],
        closeOnBeforeunload: !1
      };
    "URL" in h && "127.0.0.1" != (a = new URL(e)).hostname && "localhost" != a.hostname && (r.path = "/" + a.port + "/", e = a.protocol + "//" + a.hostname), (S = O(e, r)).on("connect", function() {
/* TYPOMOD
                     desc: disconnect socket & leave lobby */
                document.addEventListener('socketEmit', event => 
                    S.emit('data', { id: event.detail.id, data: event.detail.data })
                );
                
                typo.disconnect = () => {
                    if (S) {
                        S.typoDisconnect = true;
                        S.on("disconnect", () => {
                            typo.disconnect = undefined;
                            document.dispatchEvent(new Event("leftLobby"));
                        });
                        S.off("data");
                        S.reconnect = false;
                        S.disconnect();
                    } else {
                        document.dispatchEvent(new Event("leftLobby"));
                    }
                }
                S.on("data", data => typo.messagePort.postMessage(data));
                typo.messagePort.onmessage = data => S.emit("data", data.data);
                
                const originalEmit = S.emit.bind(S);
                S.emit = function(...event) {
                  typo.emitPort.postMessage(event);
   
const {data, id} = event[1];
    
            if(id === Ia){
              const events = [];
              const buffer = [];
              let sent = 0; /* to calculate correct undo offset */
              
              for(const command of data){
                /* DO NOT edit reference as it's used in local cmd history */
                const commandCopy = structuredClone(command);
                const sequence = typo.msiColorSwitch.ensureColorSequence(commandCopy); 
                if(sequence === undefined) buffer.push(commandCopy);
                else {
                  if(buffer.length > 0) events.push({id: Ia, data: buffer});
                  events.push({id: Ia, data: sequence});
                  events.push({id: Ta, data: dt + sent});
                  buffer.push(commandCopy);
                }
              }
    
              if(buffer.length > 0) events.push({id: Ia, data: buffer});
    
              for(event of events){
                originalEmit("data", event);
              }
            }
    
            else {
              originalEmit(...event) /* replace recursion prevention */;
            }                
                };
                /* TYPOEND */
      Jn(!1), S.on("joinerr", function(e) {
        ua(), qe(ye, (e => {
          
document.dispatchEvent(new CustomEvent("joinLobbyFailed"));switch (e) {
            case 1:
              return E("Room not found!");
            case 2:
              return E("Room is full!");
            case 3:
              return E("You are on a kick cooldown!");
            case 4:
              return E("You are banned from this room!");
            case 5:
              return E("You are joining rooms too quickly!");
            case 100:
              return E("You are already connected to this room!");
            case 200:
              return E("Too many users from your IP are connected to this room!");
            case 300:
              return E("You have been kicked too many times!");
            default:
              return E("An unknown error ('$') occured!", e)
          }
        })(e))
      }), S.on("data", Pa);
      var e = Kn.value.split("#"),
        e = {
          join: t,
          create: n ? 1 : 0,
          name: e[0],
          lang: Fn.value,
          code: e[1],
          avatar: l.avatar
        };
      S.emit("login", e)
    }), S.on("reason", function(e) {
      o = e
    }), S.on("disconnect", function(e) {
/* TYPOMOD
                 DESC: no msg if disconnect intentionally */
 document.dispatchEvent(new CustomEvent("leftLobby"));                if(!S.typoDisconnect)
                /*TYPOEND*/
      switch (console.log("socket disconnect: " + e), o) {
        case Q:
          qe(ve, E("You have been kicked!"));
          break;
        case ee:
          qe(ve, E("You have been banned!"));
          break;
        default:
          qe(ve, E("Connection lost!") + "\\n" + e)
      }
      ua()
    }), S.on("connect_error", function(e) {
      ua(), Jn(!1), qe(ye, e.message)
    })
  }

  function aa(e) {
    R.playSound(Cn), Tt(Xe, !0), At(12), Nt(1), Wt(0), Kt(!0), ce(Gn), c.querySelector("#home").style.display = "none", c.querySelector("#game").style.display = "flex", x = e.me, In = e.type, Tn = e.id, c.querySelector("#input-invite").value = "https://skribbl.io/?" + e.id, An = e.settings, oa(), ce(zn), w = [];
    for (var t = 0; t < e.users.length; t++) za(e.users[t], !1);
    Ga(), Ka(), ia(e.round), fa(e.owner), sa(e.state, !0), Wn || (setTimeout(function() {
      try {
        (adsbygoogle = h.adsbygoogle || []).push({}), (adsbygoogle = h.adsbygoogle || []).push({})
      } catch (e) {
        console.log("google ad request failed"), console.log(e)
      }
    }, 1500), Wn = !0)
  }

  function oa() {
    ia(Rn);
    for (var e, t = 0; t < ja.length; t++) {
      var n = ja[t];
      n.index && (e = An[(n = n).index], "checkbox" == n.element.type ? n.element.checked = !!e : n.element.value = e)
    }
  }

  function ra(e, t, n) {
    An[e] = t, n && S && S.emit("data", {
      id: xa,
      data: {
        id: e,
        val: t
      }
    }), oa()
  }

  function ia(e) {
    var e = (Rn = e) + 1,
      t = An[te.ROUNDS];
    Un.textContent = E("Round $ of $", [e, t])
  }

  function la() {
    for (var e = 0; e < w.length; e++) w[e].score = 0;
    for (e = 0; e < w.length; e++) Fa(w[e], !1), Va(w[e], !1);
    Ka()
  }

  function sa(e, t) {
    var n, a;
    if (n = L = e, null != fn && (h.cancelAnimationFrame(fn), fn = void 0), n.id == j ? yn({
        top: -100,
        opacity: 0
      }, 600, function() {
        cn.classList.remove("show")
      }) : cn.classList.contains("show") ? yn({
        top: -100,
        opacity: 1
      }, 600, function() {
        bn(n), yn({
          top: 0,
          opacity: 1
        }, 600)
      }) : (cn.classList.add("show"), bn(n), yn({
        top: 0,
        opacity: 1
      }, 600)), a = e.time, oo(), ro(a), no = setInterval(function() {
        ro(Math.max(0, ao - 1));
        var e = -1;
        L.id == j && (e = Qa), L.id == V && (e = eo), to.style.animationName = ao < e ? ao % 2 == 0 ? "rot_left" : "rot_right" : "none", ao < e && R.playSound(Mn), ao <= 0 && oo()
      }, 1e3), Pn.classList.add("toolbar-hidden"), yt(), da(!1), e.id == J ? (la(), Pn.classList.add("room")) : Pn.classList.remove("room"), e.id == F && (ia(e.data), 0 == e.data) && la(), e.id == Z) {
      x != M && ga(e.data.word);
      for (var o = 0; o < e.data.scores.length; o += 3) {
        var r = e.data.scores[o + 0],
          i = e.data.scores[o + 1];
        e.data.scores[o + 2];
        (c = W(r)) && (c.score = i)
      }
      Ka();
      for (var l = !0, o = 0; o < w.length; o++)
        if (w[o].guessed) {
          l = !1;
          break
        } l ? R.playSound(wn) : R.playSound(kn), y(E("The word was '$'", e.data.word), "", f($e), !0)
    } else e.id != j && (N[0].textContent = E("WAITING"), N[0].classList.add("waiting"), N[1].style.display = "none", N[2].style.display = "none");
    if (e.id == j) {
      if (M = e.data.id, 
typo.msi.reset(),
            typo.msiColorSwitch.currentCode = undefined,R.playSound(Sn), Kt(!0), e.data.drawCommands && (v = e.data.drawCommands), y(E("$ is drawing now!", W(M).name), "", f(De), !0), !t)
        for (o = 0; o < w.length; o++) Fa(w[o], !1);
      N[0].classList.remove("waiting"), M == x ? (a = e.data.word, N[0].textContent = E("DRAW THIS"), N[1].style.display = "", N[2].style.display = "none", N[1].textContent = a, Pn.classList.remove("toolbar-hidden"), yt()) : (da(!0), pa(e.data.word, !1), ma(e.data.hints))
    } else {
      M = -1;
      for (o = 0; o < w.length; o++) Fa(w[o], !1)
    }
    if (e.id == X && 0 < e.data.length) {
      for (var s = [], i = 0, o = 0; o < e.data.length; o++) {
        var c, d = e.data[o][0],
          u = e.data[o][1];
        (c = W(d)) && 0 == u && (i = c.score, s.push(c.name))
      }
      1 == s.length ? y(E("$ won with a score of $!", [s[0], i]), "", f(Ae), !0) : 1 < s.length && y(E("$ and $ won with a score of $!", [s.slice(0, -1).join(", "), s[s.length - 1], i]), "", f(Ae), !0)
    }
    for (o = 0; o < w.length; o++) Va(w[o], w[o].id == M);
    Ga()
  }

  function ca(e) {
    S && S.connected && L.id == j && (S.emit("data", {
      id: Sa,
      data: e
    }), da(!1))
  }

  function da(e) {
    c.querySelector("#game-rate").style.display = e ? "" : "none"
  }

  function ua() {
    console.log("lobby left"), S && S.close(), Kt(!(S = void 0)), oo(), w = [], An = [], L = {
      id: M = En = -1,
      time: x = 0,
      data: 0
    }, c.querySelector("#home").style.display = "", c.querySelector("#game").style.display = "none"
  }

  function ha(e) {
    S && S.connected && L.id == V && S.emit("data", {
      id: Aa,
      data: e
    })
  }

  function pa(e, t) {
    for (var n = e.length - 1, a = 0; a < e.length; a++) n += e[a];
    var o = !t && 1 == An[te.WORDMODE];
    o && (n = 3), N[0].textContent = E(o ? "WORD HIDDEN" : "GUESS THIS"), N[1].style.display = "none", N[2].style.display = "", ce(N[2]), N[2].hints = [];
    for (a = 0; a < n; a++) N[2].hints[a] = $("hint", o ? "?" : "_"), N[2].appendChild(N[2].hints[a]);
    o || N[2].appendChild($("word-length", e.join(" ")))
  }

  function ma(e) {
    for (var t = N[2].hints, n = 0; n < e.length; n++) {
      var a = e[n][0],
        o = e[n][1];
      t[a].textContent = o, t[a].classList.add("uncover")
    }
  }

  function ga(e) {
    (!N[2].hints || N[2].hints.length < e.length) && pa([e.length], !0);
    for (var t = [], n = 0; n < e.length; n++) t.push([n, e.charAt(n)]);
    ma(t)
  }

  function fa(e) {
    En = e;
    for (var t = 0; t < w.length; t++) he(w[t].element, w[t].id == En), Ha(w[t], 0, w[t].id == En);
    var n = x != En;
    c.querySelector("#button-start-game").disabled = n;
    for (var a = 0; a < ja.length; a++) ja[a].element.disabled = n;
    e = W(En);
    e && y(E("$ is now the room owner!", e.name), "", f(Ae), !0)
  }
  let ya = 1,
    va = 2,
    ba = 5,
    Sa = 8,
    ka = 9,
    wa = 90,
    Ca = 10,
    qa = 11,
    xa = 12,
    Ma = 13,
    La = 14,
    Da = 15,
    $a = 16,
    Ea = 17,
    Aa = 18,
    Ia = 19,
    Ra = 20,
    Ta = 21,
    Na = 30,
    Wa = 31,
    Oa = 32;

  function Pa(e) {
    var t = e.id,
      n = e.data;
    switch (t) {
      case Ca:
        aa(n);
        break;
      case qa:
        sa(n);
        break;
      case xa:
        ra(n.id, n.val, !1);
        break;
      case Ma:
        ma(n);
        break;
      case La:
        ro(n);
        break;
      case ya:
        var a = za(n, !0);
        Ka(), a.joinTimeout = setTimeout(() => {
          y(E("$ joined the room!", a.name), "", f($e), !0), R.playSound(Cn), a.joinTimeout = void 0
        }, 0 == In ? 1e3 : 0);
        break;
      case ka:
        (a = W(n.id)) && (a.avatar = n.avatar, ue(a.element.avatar, a.avatar));
        break;
      case wa:
        (a = W(n.id)) && (a.name = n.name, a.element.querySelector(".player-name").textContent = n.name);
        break;
      case va:
        (a = (e => {
          for (var t = 0; t < w.length; t++) {
            var n = w[t];
            if (n.id == e) return w.splice(t, 1), n.element.remove(), Ka(), Ga(), n
          }
        })(n.id)) && (null == a.joinTimeout ? (y(((e, t) => {
          switch (e) {
            default:
              return E("$ left the room!", t);
            case Q:
              return E("$ has been kicked!", t);
            case ee:
              return E("$ has been banned!", t)
          }
        })(n.reason, a.name), "", f(Ee), !0), R.playSound(qn)) : (clearTimeout(a.joinTimeout), a.joinTimeout = void 0), n.id != M || n.reason != Q && n.reason != ee || Kt(!0));
        break;
      case ba:
        var o = W(n[0]),
          r = W(n[1]),
          i = n[2],
          l = n[3];
        o && r && y(E("$ is voting to kick $ ($/$)", [o.name, r.name, i, l]), "", f(Le), !0);
        break;
      case Da:
        (a = W(n.id)) && (y(E("$ guessed the word!", a.name), "", f($e), !0).classList.add("guessed"), Fa(a, !0), R.playSound(xn), n.id == x) && ga(n.word);
        break;
      case Sa:
        (a = W(n.id)) && (o = a, r = 0 == n.vote ? "thumbsdown.gif" : "thumbsup.gif", (i = $("icon")).style.backgroundImage = "url(/img/" + r + ")", r = Ua(o, i).getBoundingClientRect(), o = .9 * (r.bottom - r.top), i.style.width = o + "px", i.style.height = o + "px", n.vote ? y(E("$ liked the drawing!", a.name), "", f($e), !0) : y(E("$ disliked the drawing!", a.name), "", f(Ee), !0));
        break;
      case Ea:
        fa(n);
        break;
      case $a:
        y(E("$ is close!", n), "", f(Le), !0);
        break;
      case Na:
        Ba(W(n.id), n.msg);
        break;
      case Oa:
        y(E("Spam detected! You're sending messages too quickly."), "", f(Ee), !0);
        break;
      case Wa:
        switch (n.id) {
          case 0:
            y(E("You need at least 2 players to start the game!"), "", f(Ee), !0);
            break;
          case 100:
            y(E("Server restarting in about $ seconds!", n.data), "", f(Ee), !0)
        }
        break;
      case Ia:
        for (var s = 0; s < n.length; s++)
n[s] = typo.msi.processIncomingCommand(n[s]), n[s] !== undefined && Vt(n[s]);
        break;
      case Ra:
        Kt(!0);
        break;
      case Ta:
        Ut(n);
        break;
      default:
        return void console.log("Unimplemented data packed received with id " + t)
    }
  }

  function W(e) {
    for (var t = 0; t < w.length; t++) {
      var n = w[t];
      if (n.id == e) return n
    }
  }

  function Ya(e) {
    return (e.flags & k) == k ? ["glow", "hue-rotate"] : []
  }

  function za(e, t) {
    var n = {
        id: e.id,
        flags: e.flags,
        name: e.name,
        avatar: e.avatar,
        score: e.score,
        guessed: e.guessed,
        rank: 0,
        muted: !1,
        votekick: !1,
        reported: !1,
        page: 0,
        element: $("player"),
        bubble: void 0
      },
      e = (w.push(n), n.id == x ? E("$ (You)", n.name) : n.name),
      a = (n.flags & k) == k,
      o = (a && n.element.classList.add("admin"), $("player-background")),
      r = (n.element.appendChild(o), a ? 1 : -1);
    if (1 == r)
      for (var i = 0; i < 7; i++) o.appendChild($("background-bubble"));
    if (2 == r)
      for (i = 0; i < 3; i++) o.appendChild($("background-wave"));
    var r = $("player-avatar-container"),
      l = de(n.avatar),
      r = (n.element.drawing = $("drawing"), (n.element.avatar = l).appendChild(n.element.drawing), r.appendChild(l), n.element.appendChild(r), zn.appendChild(n.element), pe(l, Ya(n)), $("player-info")),
      l = $("player-name", e),
      e = (n.id == x && l.classList.add("me"), r.appendChild(l), r.appendChild($("player-rank", "#" + n.rank)), r.appendChild($("player-score", E("$ points", n.score))), a && r.appendChild($("player-tag", "ADMIN")), n.element.appendChild(r), D(n.element, "click", function() {
        T = n, qe(s, n)
      }), $("player-icons")),
      l = $("icon owner"),
      a = $("icon muted");
/* TYPOMOD
         desc: set ID to player to identify */
        n.element.setAttribute("playerid", n.id);
        /* TYPOEND */
    return e.appendChild(l), e.appendChild(a), n.element.appendChild(e), n.element.icons = [l, a], Fa(n, n.guessed), t && Ga(), n
  }

  function Ba(e, t) {
    var n, a, o;
    !e.muted && (o = ((a = W(x)).flags & k) == k, n = e.id == M || e.guessed, x == M || a.guessed || !n || o) && (a = (e.flags & k) == k, o = Me, n && (o = Ie), a && (o = Ee), Ua(e, $("text", t)), y(e.name, t, f(o), !1)
.setAttribute("playerid", e.id))
  }

  function Ua(e, t) {
    e.bubble && (clearTimeout(e.bubble.timeout), e.bubble.remove(), e.bubble = void 0);
    var n = $("player-bubble"),
      a = $("content");
    return a.appendChild(t), n.appendChild($("arrow")), n.appendChild(a), e.element.appendChild(n), e.bubble = n, e.bubble.timeout = setTimeout(function() {
      e.bubble.remove(), e.bubble = void 0
    }, 1500), n
  }

  function Ha(e, t, n) {
    n ? e.element.icons[t].classList.add("visible") : e.element.icons[t].classList.remove("visible")
  }
  var _a = void 0;

  function Ga() {
    L.id, J;
    for (var e = getComputedStyle(Pn).getPropertyValue("--PLAYERS_PER_PAGE"), t = (e <= 0 && (t = Math.max(48, Yn.clientHeight), e = Math.floor(t / 48)), Math.ceil(w.length / e)), n = 0; n < w.length; n++) w[n].page = Math.floor(n / e);
    null == _a ? _a = me(Bn, t, [Yn], function(e, t, n) {
      for (var a = [], o = 0; o < w.length; o++) {
        var r = (i = w[o]).page == t;
        i.element.style.display = r ? "" : "none", r && a.push(i.element)
      }
      if (0 < a.length) {
        for (var i, o = 0; o < a.length; o++)(i = a[o]).classList.remove("first"), i.classList.remove("last"), o % 2 == 0 ? i.classList.remove("odd") : i.classList.add("odd");
        a[0].classList.add("first"), a[a.length - 1].classList.add("last")
      }
    }) : ge(_a, t), _a.element.style.display = 1 < t ? "" : "none"
  }

  function Ka() {
    for (var e = [], t = 0; t < w.length; t++) e.push(w[t]);
    e.sort(function(e, t) {
      return t.score - e.score
    });
    for (var n, a, o = 1, t = 0; t < e.length; t++) {
      var r = e[t];
      a = o, (n = r).rank = a, n.element.querySelector(".player-score").textContent = E("$ points", n.score), (n = n.element.querySelector(".player-rank")).textContent = "#" + a, n.classList.remove("first"), n.classList.remove("second"), n.classList.remove("third"), 1 == a && n.classList.add("first"), 2 == a && n.classList.add("second"), 3 == a && n.classList.add("third"), t < e.length - 1 && r.score > e[t + 1].score && o++
    }
  }

  function Fa(e, t) {
    (e.guessed = t) ? e.element.classList.add("guessed"): e.element.classList.remove("guessed")
  }

  function Va(e, t) {
    e.element.drawing.style.display = t ? "block" : "none"
  }
  for (var ja = [], Za = n.querySelectorAll('*[id^="item-"]'), Xa = 0; Xa < Za.length; Xa++) {
    var Ja = {
      id: Za[Xa].id.replace("item-settings-", ""),
      element: Za[Xa],
      index: Za[Xa].dataset.setting
    };
    Za[Xa].item = Ja, ja.push(Ja), D(Za[Xa].item.element, "change", function() {
      var e = this.value;
      "checkbox" == this.type && (e = this.checked ? 1 : 0), null != this.item.index && ra(this.item.index, e, !0)
    })
  }
  let Qa = 10,
    eo = 4;
  var to = c.querySelector("#game-clock .text"),
    no = null,
    ao = 0;

  function oo() {
    no && (clearInterval(no), no = null)
  }

  function ro(e) {
    ao = e, to.textContent = ao
  }
  var io, lo = (n = c.querySelector("#tutorial")).querySelectorAll(".page"),
    so = me(n.querySelector(".navigation"), lo.length, [n.querySelector(".pages")], function(e, t, n) {
      n && clearInterval(co);
      for (var a = 0; a < lo.length; a++) lo[a].classList.remove("active");
      lo[t].classList.add("active")
    }),
    co = setInterval(function() {
      so.selected < 4 ? fe(so, so.selected + 1, !1) : fe(so, 0, !1)
    }, 3500),
    n = c.querySelector("#game-settings");

  function uo() {
    var e;
    e = h.visualViewport ? h.visualViewport.height : h.innerHeight, "virtualKeyboard" in navigator && (e -= navigator.virtualKeyboard.boundingRect.height), c.documentElement.style.setProperty("--vh", e + "px")
  }

  function ho() {
    uo(), Ga()
  }

  function po() {
    var e = "top" == l.mobileChatLayout;
    On.classList.toggle("mobile-input-top", e)
  }

  function mo(e, t) {
    e = e.querySelector(".characters");
    0 == (e.textContent = t) ? e.classList.remove("visible") : e.classList.add("visible")
  }
  c.querySelector("#audio"), c.querySelector("#lightbulb"), D(n, "click", function() {
    qe(p)
  }), "virtualKeyboard" in navigator && (navigator.virtualKeyboard.overlaysContent = !0, navigator.virtualKeyboard.addEventListener("geometrychange", e => {
    uo()
  })), h.visualViewport ? (D(h.visualViewport, "resize", ho), ae && D(h.visualViewport, "scroll", ho)) : D(h, "resize", ho), h.onunload = function() {
    S && ua()
  }, D(c, "PointerEvent" in h ? "pointerdown" : "click", function(e) {
    if (e.target == m) return xe(), e.preventDefault(), !1;
    Be.elements.main.contains(e.target) ? e.preventDefault() : ("1" == Ye.value && _n[1].blur(), c.querySelector("#game-toolbar .sizes").contains(e.target) || Pt(), e.target != c.querySelector("#game-toolbar .color-preview-mobile") && rt.classList.remove("open"))
  }), D([Kn, Fn], "change", le), D(Vn, "click",
typo.joinLobby = function() {
    var t, e, n, a, o;
    n = h.location.href,
typo.lastConnect = Date.now(), o = "", n = n.split("?"), t = o = 1 < n.length ? (o = "" + n[1]).substring(0, a) : o, Nn || (e = "" != t ? "id=" + t : "lang=" + Fn.value, xe(), Jn(!0), ta(function() {
      Qn($n, e, function(e) {
        Jn(!1), e.success && na(e.data, t)
      }, !0)
    }))
  }), D(jn, "click", function() {
    Nn || (xe(), Jn(!0), ta(function() {
      Qn($n, "lang=" + Fn.value, function(e) {
        e.success ? na(e.data, 0, 1) : Jn(!1)
      }, !0)
    }))
  }), D(c.querySelector("#game-rate .like"), "click", function() {
    ca(1)
  }), D(c.querySelector("#game-rate .dislike"), "click", function() {
    ca(0)
  }), D(c.querySelector("#button-start-game"), "click", function() {
    if (S) {
      var e = c.querySelector("#item-settings-customwords").value.split(","),
        t = "";
      if (5 <= e.length) {
        for (var n = 0; n < e.length; n++) e[n] = e[n].trim();
        t = e.join(",")
      }
      S.emit("data", {
        id: 22,
        data: t
      })
    }
  }), D([c.querySelector("#button-invite"), c.querySelector("#modal-player-button-invite")], "click", function() {
    y(E("Copied room link to clipboard!"), "", f(Le), !0);
    var e = "https://skribbl.io/?" + Tn;
    if (navigator.clipboard) navigator.clipboard.writeText(e).then(function() {
      console.log("Async: Copying to clipboard was successful!")
    }, function(e) {
      console.error("Async: Could not copy text: ", e)
    });
    else {
      var t = c.createElement("textarea");
      t.value = e, t.style.top = "0", t.style.left = "0", t.style.position = "fixed", c.body.appendChild(t), t.select(), t.focus();
      try {
        var n = c.execCommand("copy");
        console.log("Copying link was " + (n ? "successful" : "unsuccessful"))
      } catch (e) {
        console.log("Unable to copy link " + e)
      }
      c.body.removeChild(t)
    }
  }), D(g[s].querySelector("button.kick"), "click", function() {
    xe(), null != T && T.id != x && S && S.emit("data", {
      id: 3,
      data: T.id
    })
  }), D(g[s].querySelector("button.ban"), "click", function() {
    xe(), null != T && T.id != x && S && S.emit("data", {
      id: 4,
      data: T.id
    })
  }), D(g[s].querySelector("button.votekick"), "click", function() {
    xe(), null != T && T.id != x && S && (T.id == En ? y(E("You can not votekick the lobby owner!"), "", f(Ee), !0) : S.emit("data", {
      id: ba,
      data: T.id
    }))
  }), D(g[s].querySelector("button.mute"), "click", function() {
    null != T && T.id != x && (T.muted = !T.muted, Ha(T, 1, T.muted), T.muted ? y(E("You muted '$'!", T.name), "", f(Ee), !0) : y(E("You unmuted '$'!", T.name), "", f(Ee), !0), S && S.emit("data", {
      id: 7,
      data: T.id
    }), Ce(T.muted))
  }), D(g[s].querySelector("button.report"), "click", function() {
    g[s].querySelector(".buttons").style.display = "none", g[s].querySelector(".player").style.display = "none", g[s].querySelector(".report-menu").style.display = "";
    for (var e = g[s].querySelectorAll(".report-menu input"), t = 0; t < e.length; t++) e[t].checked = !1
  }), D(g[s].querySelector("button#report-send"), "click", function() {
    var e = 0;
    g[s].querySelector("#report-reason-toxic").checked && (e |= 1), g[s].querySelector("#report-reason-spam").checked && (e |= 2), g[s].querySelector("#report-reason-bot").checked && (e |= 4), 0 < e && (null != T && T.id != x && (T.reported = !0, S && S.emit("data", {
      id: 6,
      data: {
        id: T.id,
        reasons: e
      }
    }), y(E("Your report for '$' has been sent!", T.name), "", f(Le), !0)), xe())
  }), D(g[p].querySelector("#volume input"), "change", function(e) {
    l.volume = e.target.value, R.setVolume(l.volume), R.playSound(xn), le()
  }), D(g[p].querySelector("#select-pressure-sensitivity"), "change", function(e) {
    l.pressureSensitivity = e.target.value, le()
  }), D(g[p].querySelector("#select-mobile-chat-input"), "change", function(e) {
    l.mobileChatLayout = e.target.value, po(), le()
  }), D(g[p].querySelector("#select-chat-bubbles"), "change", function(e) {
    l.chatBubbles = e.target.value, le()
  }), D(g[p].querySelector("button.reset"), "click", function() {
    for (var e = 0; e < u.length; e++) {
      var t = u[e];
      t.key = t.def, t.listing.querySelector("input").value = t.key;
      for (var n = 0; n < t.changed.length; n++) t.changed[n](t)
    }
    ie()
  }), D(_n[1], "focus", function(e) {
    function t(e) {
      h.removeEventListener("scroll", t), h.scroll(0, 0), e.preventDefault()
    }
    uo(), On.classList.add("mobile-input-focus"), ae && (h.addEventListener("scroll", t), setTimeout(function() {
      t(e)
    }, 200), e.preventDefault())
  }), D(_n[1], "blur", function(e) {
    uo(), On.classList.remove("mobile-input-focus")
  }), D(_n, "input", function(e) {
    mo(this.parentNode, this.value.length)
  }), D(Hn, "submit", function(e) {
const input = this.querySelector("input"); let rest = input.value.substring(100);
        input.value = input.value.substring(0,100);
        if(rest.length > 0) setTimeout(()=>{input.value = rest; this.requestSubmit();},180);
    e.preventDefault();
    var e = this.querySelector("input");
    return e.value && (e = e.value, S && S.connected ? S.emit("data", {
      id: Na,
      data: e
    }) : Ba(W(x), e)), this.reset(), mo(this, 0), !1
  }), uo(), h.localStorageAvailable ? (Kn.value = e("name", ""), Fn.value = (e => {
    for (var t = c.querySelectorAll("#home .panel .container-name-lang select option"), n = 0; n < t.length; n++)
      if (t[n].value == e) return t[n].value;
    return 0
  })(e("lang", 0)), l.displayLang = e("displaylang", "en"), l.volume = parseInt(e("volume", 100)), l.filterChat = 1 == parseInt(e("filter", 1)) ? 1 : 0, l.pressureSensitivity = 1 == parseInt(e("pressure", 1)) ? 1 : 0, l.avatar = (n = "ava", Vn = l.avatar, null == (n = d.getItem(n)) ? Vn : JSON.parse(n)), l.mobileChatLayout = e("mobileChatLayout", "bottom"), l.chatBubbles = e("chatBubbles", 0), Ye.value = e("keyboard", ae ? 1 : 0), ze.value = e("keyboardlayout", "en"), He(), g[p].querySelector("#select-chat-bubbles").value = l.chatBubbles, g[p].querySelector("#select-mobile-chat-input").value = l.mobileChatLayout, g[p].querySelector("#volume input").value = l.volume, R.setVolume(l.volume), po(), console.log("Settings loaded.")) : console.log("Settings not loaded. LocalStorage unavailable.");
  for (var go = c.querySelectorAll("[data-translate]"), fo = 0; fo < go.length; fo++) {
    var yo = go[fo];
    Ve(yo, yo.dataset.translate)
  }
  for (var vo = Ge[l.displayLang], bo = 0; bo < Ke.length; bo++) {
    var So = Ke[bo],
      ko = Fe(vo, So.key);
    "text" == So.type && (So.element.textContent = ko), "placeholder" == So.type && (So.element.placeholder = ko)
  }

  function wo(e) {
    io.parts[e].classList.remove("bounce"), io.parts[e].offsetWidth, io.parts[e].classList.add("bounce")
  }
  D(jn = c.querySelectorAll("[data-tooltip]"), "pointerenter", function(e) {
    We(e.target)
  }), D(jn, "pointerleave", function(e) {
    Oe()
  }), Vn = (Hn = c.querySelector("#home .avatar-customizer")).querySelector(".container"), n = Hn.querySelectorAll(".arrows.left .arrow"), jn = Hn.querySelectorAll(".arrows.right .arrow"), Hn = Hn.querySelectorAll(".randomize"), (io = de(l.avatar)).classList.add("fit"), Vn.appendChild(io), D(n, "click", function() {
    var e = parseInt(this.dataset.avatarIndex);
    --l.avatar[e], l.avatar[e] < 0 && (l.avatar[e] = a[e] - 1), wo(e), ue(io, l.avatar), le()
  }), D(jn, "click", function() {
    var e = parseInt(this.dataset.avatarIndex);
    l.avatar[e] += 1, l.avatar[e] >= a[e] && (l.avatar[e] = 0), wo(e), ue(io, l.avatar), le()
  }), D(Hn, "click", function() {
    l.avatar[0] = Math.floor(Math.random() * a[0]), l.avatar[1] = Math.floor(Math.random() * a[1]), l.avatar[2] = Math.floor(Math.random() * a[2]), wo(1), wo(2), ue(io, l.avatar), le()
  });
  for (var Co = Math.round(8 * Math.random()), qo = c.querySelector("#home .logo-big .avatar-container"), xo = 0; xo < 8; xo++) {
    var Mo = [0, 0, 0, -1],
      Mo = (Mo[0] = xo, Mo[1] = Math.round(100 * Math.random()) % Y, Mo[2] = Math.round(100 * Math.random()) % z, 100 * Math.random() < 1 && (Mo[3] = Math.floor(20 * Math.random())), Zn && 100 * Math.random() < 35 && (Mo[3] = 96 + Math.floor(4 * Math.random())), de(Mo, Co == xo));
    Mo.index = xo, qo.appendChild(Mo), D(Mo, "click", function() {
      var e = [this.index, 0, 0, -1];
      e[1] = Math.round(100 * Math.random()) % Y, e[2] = Math.round(100 * Math.random()) % z, 1e3 * Math.random() < 10 && (e[3] = Math.floor(20 * Math.random())), ue(this, e), this.classList.remove("clicked"), this.offsetWidth, this.classList.add("clicked")
    })
  }
  Xn && (c.documentElement.dataset.halloween = "")
;document.dispatchEvent(new Event("skribblInitialized")); document.body.setAttribute("typo-skribbl-loaded", "true");
})(window, document, localStorage, io);`;
  const _PageRuntime = class _PageRuntime {
    constructor() {
      __publicField(this, "_db");
      __publicField(this, "_profileStore");
      this._db = openDB("skribbl_typo", 1, {
        upgrade: /* @__PURE__ */ __name((database) => {
          database.createObjectStore("settings");
          database.createObjectStore("token");
          database.createObjectStore("current_profile");
          database.createObjectStore("profiles");
        }, "upgrade")
      });
      this._profileStore = new TypoProfileStore(
        this._db,
        "profiles",
        "current_profile",
        "settings",
        "token"
      );
    }
    async getSetting(key2) {
      const value = await (await this._db).get("settings", key2);
      return value === void 0 ? null : value;
    }
    async writeSetting(key2, value) {
      await (await this._db).put("settings", value, key2);
    }
    async getToken() {
      const value = await (await this._db).get("token", "token");
      return value === void 0 ? null : value;
    }
    async setToken(token) {
      await (await this._db).put("token", token, "token");
    }
    getReleaseDetails() {
      return pageReleaseDetails;
    }
    getPatchUrl() {
      return URL.createObjectURL(new Blob([gamePatch], { type: "application/javascript" }));
    }
    createAndSwitchToProfile(profile) {
      return this._profileStore.createAndActivateProfile(profile);
    }
    currentProfile() {
      return this._profileStore.getCurrentProfile();
    }
    deleteProfile(profile) {
      return this._profileStore.deleteProfile(profile);
    }
    getProfiles() {
      return this._profileStore.getProfiles();
    }
    switchToProfile(profile) {
      return this._profileStore.switchToProfile(profile);
    }
    async resetTypo() {
      await (await this._db).clear("settings");
      await (await this._db).clear("token");
      await (await this._db).clear("current_profile");
      await (await this._db).clear("profiles");
    }
  };
  __name(_PageRuntime, "PageRuntime");
  let PageRuntime = _PageRuntime;
  const typoRuntime = new PageRuntime();
  const requireElement = /* @__PURE__ */ __name((selector, root = void 0) => {
    const element2 = (root ?? document).querySelector(selector);
    if (!element2) {
      throw new Error(`Required element not found for selector: ${selector}`);
    }
    return element2;
  }, "requireElement");
  const requireElements = /* @__PURE__ */ __name((selector, root = void 0) => {
    const elements2 = Array.from((root ?? document).querySelectorAll(selector));
    if (elements2.length === 0) {
      throw new Error(`Required elements not found for selector: ${selector}`);
    }
    return elements2;
  }, "requireElements");
  const element$1 = /* @__PURE__ */ __name((selector, root = void 0) => {
    return (root ?? document).querySelector(selector);
  }, "element$1");
  const elements = /* @__PURE__ */ __name((selector, root = void 0) => {
    return Array.from((root ?? document).querySelectorAll(selector));
  }, "elements");
  var extendStatics = /* @__PURE__ */ __name(function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  }, "extendStatics");
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __2() {
      this.constructor = d;
    }
    __name(__2, "__");
    d.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
  }
  __name(__extends, "__extends");
  function __awaiter$4(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    __name(adopt, "adopt");
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step");
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  __name(__awaiter$4, "__awaiter$4");
  function __generator$4(thisArg, body) {
    var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, "sent"), trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  __name(__generator$4, "__generator$4");
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: /* @__PURE__ */ __name(function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }, "next")
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  __name(__values, "__values");
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  __name(__read, "__read");
  function __spreadArray$3(to, from2, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  __name(__spreadArray$3, "__spreadArray$3");
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  __name(__await, "__await");
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function awaitReturn(f) {
      return function(v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
        if (f) i[n] = f(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  __name(__asyncGenerator, "__asyncGenerator");
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve2, reject) {
          v = o[n](v), settle(resolve2, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve2, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve2({ value: v2, done: d });
      }, reject);
    }
  }
  __name(__asyncValues, "__asyncValues");
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  function isFunction(value) {
    return typeof value === "function";
  }
  __name(isFunction, "isFunction");
  function createErrorClass(createImpl) {
    var _super = /* @__PURE__ */ __name(function(instance2) {
      Error.call(instance2);
      instance2.stack = new Error().stack;
    }, "_super");
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  __name(createErrorClass, "createErrorClass");
  var UnsubscriptionError = createErrorClass(function(_super) {
    return /* @__PURE__ */ __name(function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    }, "UnsubscriptionErrorImpl");
  });
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }
  __name(arrRemove, "arrRemove");
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    __name(Subscription2, "Subscription");
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a2, e_2, _b2;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return)) _a2.call(_parentage_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray$3(__spreadArray$3([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b2 = _finalizers_1.return)) _b2.call(_finalizers_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a2;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty2 = new Subscription2();
      empty2.closed = true;
      return empty2;
    }();
    return Subscription2;
  }();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  __name(isSubscription, "isSubscription");
  function execFinalizer(finalizer) {
    if (isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
  __name(execFinalizer, "execFinalizer");
  var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
  var timeoutProvider = {
    setTimeout: /* @__PURE__ */ __name(function(handler, timeout2) {
      var args = [];
      for (var _i2 = 2; _i2 < arguments.length; _i2++) {
        args[_i2 - 2] = arguments[_i2];
      }
      return setTimeout.apply(void 0, __spreadArray$3([handler, timeout2], __read(args)));
    }, "setTimeout"),
    clearTimeout: /* @__PURE__ */ __name(function(handle) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    }, "clearTimeout"),
    delegate: void 0
  };
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      {
        throw err;
      }
    });
  }
  __name(reportUnhandledError, "reportUnhandledError");
  function noop$1() {
  }
  __name(noop$1, "noop$1");
  function errorContext(cb) {
    {
      cb();
    }
  }
  __name(errorContext, "errorContext");
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    __name(Subscriber2, "Subscriber");
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) ;
      else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) ;
      else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) ;
      else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription);
  var _bind = Function.prototype.bind;
  function bind$1(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  __name(bind$1, "bind$1");
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    __name(ConsumerObserver2, "ConsumerObserver");
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind$1(observerOrNext.next, context_1),
            error: observerOrNext.error && bind$1(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind$1(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    __name(SafeSubscriber2, "SafeSubscriber");
    return SafeSubscriber2;
  }(Subscriber);
  function handleUnhandledError(error) {
    {
      reportUnhandledError(error);
    }
  }
  __name(handleUnhandledError, "handleUnhandledError");
  function defaultErrorHandler(err) {
    throw err;
  }
  __name(defaultErrorHandler, "defaultErrorHandler");
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop$1,
    error: defaultErrorHandler,
    complete: noop$1
  };
  var observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  function identity(x) {
    return x;
  }
  __name(identity, "identity");
  function pipe() {
    var fns = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      fns[_i2] = arguments[_i2];
    }
    return pipeFromArray(fns);
  }
  __name(pipe, "pipe");
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return /* @__PURE__ */ __name(function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    }, "piped");
  }
  __name(pipeFromArray, "pipeFromArray");
  var Observable = function() {
    function Observable2(subscribe2) {
      if (subscribe2) {
        this._subscribe = subscribe2;
      }
    }
    __name(Observable2, "Observable");
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function() {
        var _a2 = _this, operator = _a2.operator, source = _a2.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve2, reject) {
        var subscriber = new SafeSubscriber({
          next: /* @__PURE__ */ __name(function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          }, "next"),
          error: reject,
          complete: resolve2
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a2;
      return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
    };
    Observable2.prototype[observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        operations[_i2] = arguments[_i2];
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve2, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve2(value);
        });
      });
    };
    Observable2.create = function(subscribe2) {
      return new Observable2(subscribe2);
    };
    return Observable2;
  }();
  function getPromiseCtor(promiseCtor) {
    var _a2;
    return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
  }
  __name(getPromiseCtor, "getPromiseCtor");
  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  __name(isObserver, "isObserver");
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }
  __name(isSubscriber, "isSubscriber");
  function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  __name(hasLift, "hasLift");
  function operate(init2) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init2(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  __name(operate, "operate");
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  __name(createOperatorSubscriber, "createOperatorSubscriber");
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    __name(OperatorSubscriber2, "OperatorSubscriber");
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a2;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber);
  var ObjectUnsubscribedError = createErrorClass(function(_super) {
    return /* @__PURE__ */ __name(function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    }, "ObjectUnsubscribedErrorImpl");
  });
  var Subject$1 = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    __name(Subject2, "Subject");
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext(function() {
        var e_1, _a2;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b2 = __values(_this.currentObservers), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
              var observer = _c2.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c2 && !_c2.done && (_a2 = _b2.return)) _a2.call(_b2);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: /* @__PURE__ */ __name(function() {
        var _a2;
        return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
      }, "get"),
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription(function() {
        _this.currentObservers = null;
        arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    __name(AnonymousSubject2, "AnonymousSubject");
    AnonymousSubject2.prototype.next = function(value) {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a2, _b2;
      return (_b2 = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b2 !== void 0 ? _b2 : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject$1);
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    __name(BehaviorSubject2, "BehaviorSubject");
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: /* @__PURE__ */ __name(function() {
        return this.getValue();
      }, "get"),
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, _value = _a2._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject$1);
  var dateTimestampProvider = {
    now: /* @__PURE__ */ __name(function() {
      return Date.now();
    }, "now"),
    delegate: void 0
  };
  var Action = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    __name(Action2, "Action");
    Action2.prototype.schedule = function(state, delay2) {
      return this;
    };
    return Action2;
  }(Subscription);
  var intervalProvider = {
    setInterval: /* @__PURE__ */ __name(function(handler, timeout2) {
      var args = [];
      for (var _i2 = 2; _i2 < arguments.length; _i2++) {
        args[_i2 - 2] = arguments[_i2];
      }
      return setInterval.apply(void 0, __spreadArray$3([handler, timeout2], __read(args)));
    }, "setInterval"),
    clearInterval: /* @__PURE__ */ __name(function(handle) {
      return clearInterval(handle);
    }, "clearInterval"),
    delegate: void 0
  };
  var AsyncAction = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    __name(AsyncAction2, "AsyncAction");
    AsyncAction2.prototype.schedule = function(state, delay2) {
      var _a2;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id2 = this.id;
      var scheduler = this.scheduler;
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler, id2, delay2);
      }
      this.pending = true;
      this.delay = delay2;
      this.id = (_a2 = this.id) !== null && _a2 !== void 0 ? _a2 : this.requestAsyncId(scheduler, this.id, delay2);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null && this.delay === delay2 && this.pending === false) {
        return id2;
      }
      if (id2 != null) {
        intervalProvider.clearInterval(id2);
      }
      return void 0;
    };
    AsyncAction2.prototype.execute = function(state, delay2) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error = this._execute(state, delay2);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a2 = this, id2 = _a2.id, scheduler = _a2.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove(actions, this);
        if (id2 != null) {
          this.id = this.recycleAsyncId(scheduler, id2, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action);
  var Scheduler = function() {
    function Scheduler2(schedulerActionCtor, now) {
      if (now === void 0) {
        now = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    __name(Scheduler2, "Scheduler");
    Scheduler2.prototype.schedule = function(work, delay2, state) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay2);
    };
    Scheduler2.now = dateTimestampProvider.now;
    return Scheduler2;
  }();
  var AsyncScheduler = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    __name(AsyncScheduler2, "AsyncScheduler");
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error;
      this._active = true;
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler);
  var asyncScheduler = new AsyncScheduler(AsyncAction);
  var async = asyncScheduler;
  var EMPTY = new Observable(function(subscriber) {
    return subscriber.complete();
  });
  function isScheduler(value) {
    return value && isFunction(value.schedule);
  }
  __name(isScheduler, "isScheduler");
  function last(arr) {
    return arr[arr.length - 1];
  }
  __name(last, "last");
  function popResultSelector(args) {
    return isFunction(last(args)) ? args.pop() : void 0;
  }
  __name(popResultSelector, "popResultSelector");
  function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : void 0;
  }
  __name(popScheduler, "popScheduler");
  function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  }
  __name(popNumber, "popNumber");
  var isArrayLike = /* @__PURE__ */ __name(function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  }, "isArrayLike");
  function isPromise$1(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
  }
  __name(isPromise$1, "isPromise$1");
  function isInteropObservable(input) {
    return isFunction(input[observable]);
  }
  __name(isInteropObservable, "isInteropObservable");
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }
  __name(isAsyncIterable, "isAsyncIterable");
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  __name(createInvalidObservableTypeError, "createInvalidObservableTypeError");
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  __name(getSymbolIterator, "getSymbolIterator");
  var iterator = getSymbolIterator();
  function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
  }
  __name(isIterable, "isIterable");
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a2, value, done;
      return __generator$4(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            reader = readableStream.getReader();
            _b2.label = 1;
          case 1:
            _b2.trys.push([1, , 9, 10]);
            _b2.label = 2;
          case 2:
            return [4, __await(reader.read())];
          case 3:
            _a2 = _b2.sent(), value = _a2.value, done = _a2.done;
            if (!done) return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b2.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b2.sent()];
          case 7:
            _b2.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    }, "readableStreamLikeToAsyncGenerator_1"));
  }
  __name(readableStreamLikeToAsyncGenerator, "readableStreamLikeToAsyncGenerator");
  function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }
  __name(isReadableStreamLike, "isReadableStreamLike");
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise$1(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  __name(innerFrom, "innerFrom");
  function fromInteropObservable(obj) {
    return new Observable(function(subscriber) {
      var obs = obj[observable]();
      if (isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  __name(fromInteropObservable, "fromInteropObservable");
  function fromArrayLike(array) {
    return new Observable(function(subscriber) {
      for (var i = 0; i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  }
  __name(fromArrayLike, "fromArrayLike");
  function fromPromise(promise) {
    return new Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  __name(fromPromise, "fromPromise");
  function fromIterable(iterable) {
    return new Observable(function(subscriber) {
      var e_1, _a2;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a2 = iterable_1.return)) _a2.call(iterable_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  __name(fromIterable, "fromIterable");
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function(subscriber) {
      process$1(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  __name(fromAsyncIterable, "fromAsyncIterable");
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  __name(fromReadableStreamLike, "fromReadableStreamLike");
  function process$1(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a2;
    return __awaiter$4(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator$4(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            _b2.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b2.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b2.sent(), !asyncIterable_1_1.done)) return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b2.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b2.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b2.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return))) return [3, 8];
            return [4, _a2.call(asyncIterable_1)];
          case 7:
            _b2.sent();
            _b2.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2) throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }
  __name(process$1, "process$1");
  function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (repeat2 === void 0) {
      repeat2 = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat2) {
        parentSubscription.add(this.schedule(null, delay2));
      } else {
        this.unsubscribe();
      }
    }, delay2);
    parentSubscription.add(scheduleSubscription);
    if (!repeat2) {
      return scheduleSubscription;
    }
  }
  __name(executeSchedule, "executeSchedule");
  function observeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function(source, subscriber) {
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay2);
      }, function() {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay2);
      }, function(err) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay2);
      }));
    });
  }
  __name(observeOn, "observeOn");
  function subscribeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay2));
    });
  }
  __name(subscribeOn, "subscribeOn");
  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }
  __name(scheduleObservable, "scheduleObservable");
  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }
  __name(schedulePromise, "schedulePromise");
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var i = 0;
      return scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }
  __name(scheduleArray, "scheduleArray");
  function scheduleIterable(input, scheduler) {
    return new Observable(function(subscriber) {
      var iterator$1;
      executeSchedule(subscriber, scheduler, function() {
        iterator$1 = input[iterator]();
        executeSchedule(subscriber, scheduler, function() {
          var _a2;
          var value;
          var done;
          try {
            _a2 = iterator$1.next(), value = _a2.value, done = _a2.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
      };
    });
  }
  __name(scheduleIterable, "scheduleIterable");
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      executeSchedule(subscriber, scheduler, function() {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function() {
          iterator2.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }
  __name(scheduleAsyncIterable, "scheduleAsyncIterable");
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }
  __name(scheduleReadableStreamLike, "scheduleReadableStreamLike");
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }
      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }
      if (isPromise$1(input)) {
        return schedulePromise(input, scheduler);
      }
      if (isAsyncIterable(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  __name(scheduled, "scheduled");
  function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }
  __name(from, "from");
  function of() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(args);
    return from(args, scheduler);
  }
  __name(of, "of");
  var EmptyError = createErrorClass(function(_super) {
    return /* @__PURE__ */ __name(function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    }, "EmptyErrorImpl");
  });
  function firstValueFrom(source, config2) {
    return new Promise(function(resolve2, reject) {
      var subscriber = new SafeSubscriber({
        next: /* @__PURE__ */ __name(function(value) {
          resolve2(value);
          subscriber.unsubscribe();
        }, "next"),
        error: reject,
        complete: /* @__PURE__ */ __name(function() {
          {
            reject(new EmptyError());
          }
        }, "complete")
      });
      source.subscribe(subscriber);
    });
  }
  __name(firstValueFrom, "firstValueFrom");
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }
  __name(isValidDate, "isValidDate");
  var TimeoutError$1 = createErrorClass(function(_super) {
    return /* @__PURE__ */ __name(function TimeoutErrorImpl(info) {
      if (info === void 0) {
        info = null;
      }
      _super(this);
      this.message = "Timeout has occurred";
      this.name = "TimeoutError";
      this.info = info;
    }, "TimeoutErrorImpl");
  });
  function timeout(config2, schedulerArg) {
    var _a2 = isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first = _a2.first, each = _a2.each, _b2 = _a2.with, _with = _b2 === void 0 ? timeoutErrorFactory : _b2, _c2 = _a2.scheduler, scheduler = _c2 === void 0 ? asyncScheduler : _c2, _d2 = _a2.meta, meta = _d2 === void 0 ? null : _d2;
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return operate(function(source, subscriber) {
      var originalSourceSubscription;
      var timerSubscription;
      var lastValue = null;
      var seen = 0;
      var startTimer = /* @__PURE__ */ __name(function(delay2) {
        timerSubscription = executeSchedule(subscriber, scheduler, function() {
          try {
            originalSourceSubscription.unsubscribe();
            innerFrom(_with({
              meta,
              lastValue,
              seen
            })).subscribe(subscriber);
          } catch (err) {
            subscriber.error(err);
          }
        }, delay2);
      }, "startTimer");
      originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
        seen++;
        subscriber.next(lastValue = value);
        each > 0 && startTimer(each);
      }, void 0, void 0, function() {
        if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
        }
        lastValue = null;
      }));
      !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
    });
  }
  __name(timeout, "timeout");
  function timeoutErrorFactory(info) {
    throw new TimeoutError$1(info);
  }
  __name(timeoutErrorFactory, "timeoutErrorFactory");
  function map(project, thisArg) {
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }
  __name(map, "map");
  var isArray$2 = Array.isArray;
  function callOrApply(fn, args) {
    return isArray$2(args) ? fn.apply(void 0, __spreadArray$3([], __read(args))) : fn(args);
  }
  __name(callOrApply, "callOrApply");
  function mapOneOrManyArgs(fn) {
    return map(function(args) {
      return callOrApply(fn, args);
    });
  }
  __name(mapOneOrManyArgs, "mapOneOrManyArgs");
  var isArray$1 = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
  function argsArgArrayOrObject(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray$1(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key2) {
            return first_1[key2];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  }
  __name(argsArgArrayOrObject, "argsArgArrayOrObject");
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  }
  __name(isPOJO, "isPOJO");
  function createObject(keys, values) {
    return keys.reduce(function(result, key2, i) {
      return result[key2] = values[i], result;
    }, {});
  }
  __name(createObject, "createObject");
  function combineLatest$1() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(args);
    var resultSelector = popResultSelector(args);
    var _a2 = argsArgArrayOrObject(args), observables = _a2.args, keys = _a2.keys;
    if (observables.length === 0) {
      return from([], scheduler);
    }
    var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject(keys, values);
    } : identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
  }
  __name(combineLatest$1, "combineLatest$1");
  function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === void 0) {
      valueTransform = identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = /* @__PURE__ */ __name(function(i2) {
          maybeSchedule(scheduler, function() {
            var source = from(observables[i2], scheduler);
            var hasFirstValue = false;
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
              values[i2] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        }, "_loop_1");
        for (var i = 0; i < length; i++) {
          _loop_1(i);
        }
      }, subscriber);
    };
  }
  __name(combineLatestInit, "combineLatestInit");
  function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  }
  __name(maybeSchedule, "maybeSchedule");
  function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = /* @__PURE__ */ __name(function() {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    }, "checkComplete");
    var outerNext = /* @__PURE__ */ __name(function(value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    }, "outerNext");
    var doInnerSub = /* @__PURE__ */ __name(function(value) {
      active++;
      var innerComplete = false;
      innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
        {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = /* @__PURE__ */ __name(function() {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) ;
              else {
                doInnerSub(bufferedValue);
              }
            }, "_loop_1");
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    }, "doInnerSub");
    source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
    };
  }
  __name(mergeInternals, "mergeInternals");
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction(resultSelector)) {
      return mergeMap(function(a, i) {
        return map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        })(innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return operate(function(source, subscriber) {
      return mergeInternals(source, subscriber, project, concurrent);
    });
  }
  __name(mergeMap, "mergeMap");
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap(identity, concurrent);
  }
  __name(mergeAll, "mergeAll");
  function concatAll() {
    return mergeAll(1);
  }
  __name(concatAll, "concatAll");
  function concat() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return concatAll()(from(args, popScheduler(args)));
  }
  __name(concat, "concat");
  function forkJoin() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var resultSelector = popResultSelector(args);
    var _a2 = argsArgArrayOrObject(args), sources = _a2.args, keys = _a2.keys;
    var result = new Observable(function(subscriber) {
      var length = sources.length;
      if (!length) {
        subscriber.complete();
        return;
      }
      var values = new Array(length);
      var remainingCompletions = length;
      var remainingEmissions = length;
      var _loop_1 = /* @__PURE__ */ __name(function(sourceIndex2) {
        var hasValue = false;
        innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
          if (!hasValue) {
            hasValue = true;
            remainingEmissions--;
          }
          values[sourceIndex2] = value;
        }, function() {
          return remainingCompletions--;
        }, void 0, function() {
          if (!remainingCompletions || !hasValue) {
            if (!remainingEmissions) {
              subscriber.next(keys ? createObject(keys, values) : values);
            }
            subscriber.complete();
          }
        }));
      }, "_loop_1");
      for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
    });
    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
  }
  __name(forkJoin, "forkJoin");
  function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === void 0) {
      dueTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable(function(subscriber) {
      var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n++);
          if (0 <= intervalDuration) {
            this.schedule(void 0, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  }
  __name(timer, "timer");
  function interval(period, scheduler) {
    if (period === void 0) {
      period = 0;
    }
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }
    if (period < 0) {
      period = 0;
    }
    return timer(period, period, scheduler);
  }
  __name(interval, "interval");
  function merge$1() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(args);
    var concurrent = popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
  }
  __name(merge$1, "merge$1");
  var isArray = Array.isArray;
  function argsOrArgArray(args) {
    return args.length === 1 && isArray(args[0]) ? args[0] : args;
  }
  __name(argsOrArgArray, "argsOrArgArray");
  function filter(predicate, thisArg) {
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }
  __name(filter, "filter");
  function bufferTime(bufferTimeSpan) {
    var _a2, _b2;
    var otherArgs = [];
    for (var _i2 = 1; _i2 < arguments.length; _i2++) {
      otherArgs[_i2 - 1] = arguments[_i2];
    }
    var scheduler = (_a2 = popScheduler(otherArgs)) !== null && _a2 !== void 0 ? _a2 : asyncScheduler;
    var bufferCreationInterval = (_b2 = otherArgs[0]) !== null && _b2 !== void 0 ? _b2 : null;
    var maxBufferSize = otherArgs[1] || Infinity;
    return operate(function(source, subscriber) {
      var bufferRecords = [];
      var restartOnEmit = false;
      var emit = /* @__PURE__ */ __name(function(record) {
        var buffer = record.buffer, subs = record.subs;
        subs.unsubscribe();
        arrRemove(bufferRecords, record);
        subscriber.next(buffer);
        restartOnEmit && startBuffer();
      }, "emit");
      var startBuffer = /* @__PURE__ */ __name(function() {
        if (bufferRecords) {
          var subs = new Subscription();
          subscriber.add(subs);
          var buffer = [];
          var record_1 = {
            buffer,
            subs
          };
          bufferRecords.push(record_1);
          executeSchedule(subs, scheduler, function() {
            return emit(record_1);
          }, bufferTimeSpan);
        }
      }, "startBuffer");
      if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
        executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
      } else {
        restartOnEmit = true;
      }
      startBuffer();
      var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a3;
        var recordsCopy = bufferRecords.slice();
        try {
          for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
            var record = recordsCopy_1_1.value;
            var buffer = record.buffer;
            buffer.push(value);
            maxBufferSize <= buffer.length && emit(record);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a3 = recordsCopy_1.return)) _a3.call(recordsCopy_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }, function() {
        while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
          subscriber.next(bufferRecords.shift().buffer);
        }
        bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
        subscriber.complete();
        subscriber.unsubscribe();
      }, void 0, function() {
        return bufferRecords = null;
      });
      source.subscribe(bufferTimeSubscriber);
    });
  }
  __name(bufferTime, "bufferTime");
  function catchError(selector) {
    return operate(function(source, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
        handledResult = innerFrom(selector(err, catchError(selector)(source)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  }
  __name(catchError, "catchError");
  function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var i = index++;
        state = hasState ? accumulator(state, value, i) : (hasState = true, value);
        subscriber.next(state);
      }, emitBeforeComplete));
    };
  }
  __name(scanInternals, "scanInternals");
  function combineLatest() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var resultSelector = popResultSelector(args);
    return resultSelector ? pipe(combineLatest.apply(void 0, __spreadArray$3([], __read(args))), mapOneOrManyArgs(resultSelector)) : operate(function(source, subscriber) {
      combineLatestInit(__spreadArray$3([source], __read(argsOrArgArray(args))))(subscriber);
    });
  }
  __name(combineLatest, "combineLatest");
  function combineLatestWith() {
    var otherSources = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      otherSources[_i2] = arguments[_i2];
    }
    return combineLatest.apply(void 0, __spreadArray$3([], __read(otherSources)));
  }
  __name(combineLatestWith, "combineLatestWith");
  function concatMap(project, resultSelector) {
    return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
  }
  __name(concatMap, "concatMap");
  function debounce(durationSelector) {
    return operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var emit = /* @__PURE__ */ __name(function() {
        durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      }, "emit");
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
        hasValue = true;
        lastValue = value;
        durationSubscriber = createOperatorSubscriber(subscriber, emit, noop$1);
        innerFrom(durationSelector(value)).subscribe(durationSubscriber);
      }, function() {
        emit();
        subscriber.complete();
      }, void 0, function() {
        lastValue = durationSubscriber = null;
      }));
    });
  }
  __name(debounce, "debounce");
  function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }
    return operate(function(source, subscriber) {
      var activeTask = null;
      var lastValue = null;
      var lastTime = null;
      var emit = /* @__PURE__ */ __name(function() {
        if (activeTask) {
          activeTask.unsubscribe();
          activeTask = null;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      }, "emit");
      function emitWhenIdle() {
        var targetTime = lastTime + dueTime;
        var now = scheduler.now();
        if (now < targetTime) {
          activeTask = this.schedule(void 0, targetTime - now);
          subscriber.add(activeTask);
          return;
        }
        emit();
      }
      __name(emitWhenIdle, "emitWhenIdle");
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        lastValue = value;
        lastTime = scheduler.now();
        if (!activeTask) {
          activeTask = scheduler.schedule(emitWhenIdle, dueTime);
          subscriber.add(activeTask);
        }
      }, function() {
        emit();
        subscriber.complete();
      }, void 0, function() {
        lastValue = activeTask = null;
      }));
    });
  }
  __name(debounceTime, "debounceTime");
  function take(count) {
    return count <= 0 ? function() {
      return EMPTY;
    } : operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }
  __name(take, "take");
  function mapTo(value) {
    return map(function() {
      return value;
    });
  }
  __name(mapTo, "mapTo");
  function delayWhen(delayDurationSelector, subscriptionDelay) {
    return mergeMap(function(value, index) {
      return innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value));
    });
  }
  __name(delayWhen, "delayWhen");
  function delay(due, scheduler) {
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }
    var duration = timer(due, scheduler);
    return delayWhen(function() {
      return duration;
    });
  }
  __name(delay, "delay");
  function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === void 0) {
      keySelector = identity;
    }
    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
    return operate(function(source, subscriber) {
      var previousKey;
      var first = true;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var currentKey = keySelector(value);
        if (first || !comparator(previousKey, currentKey)) {
          first = false;
          previousKey = currentKey;
          subscriber.next(value);
        }
      }));
    });
  }
  __name(distinctUntilChanged, "distinctUntilChanged");
  function defaultCompare(a, b) {
    return a === b;
  }
  __name(defaultCompare, "defaultCompare");
  function exhaustMap(project, resultSelector) {
    return operate(function(source, subscriber) {
      var index = 0;
      var innerSub = null;
      var isComplete = false;
      source.subscribe(createOperatorSubscriber(subscriber, function(outerValue) {
        if (!innerSub) {
          innerSub = createOperatorSubscriber(subscriber, void 0, function() {
            innerSub = null;
            isComplete && subscriber.complete();
          });
          innerFrom(project(outerValue, index++)).subscribe(innerSub);
        }
      }, function() {
        isComplete = true;
        !innerSub && subscriber.complete();
      }));
    });
  }
  __name(exhaustMap, "exhaustMap");
  function merge() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(args);
    var concurrent = popNumber(args, Infinity);
    args = argsOrArgArray(args);
    return operate(function(source, subscriber) {
      mergeAll(concurrent)(from(__spreadArray$3([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  }
  __name(merge, "merge");
  function mergeWith() {
    var otherSources = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      otherSources[_i2] = arguments[_i2];
    }
    return merge.apply(void 0, __spreadArray$3([], __read(otherSources)));
  }
  __name(mergeWith, "mergeWith");
  function pairwise() {
    return operate(function(source, subscriber) {
      var prev;
      var hasPrev = false;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var p = prev;
        prev = value;
        hasPrev && subscriber.next([p, value]);
        hasPrev = true;
      }));
    });
  }
  __name(pairwise, "pairwise");
  function repeat(countOrConfig) {
    var _a2;
    var count = Infinity;
    var delay2;
    if (countOrConfig != null) {
      if (typeof countOrConfig === "object") {
        _a2 = countOrConfig.count, count = _a2 === void 0 ? Infinity : _a2, delay2 = countOrConfig.delay;
      } else {
        count = countOrConfig;
      }
    }
    return count <= 0 ? function() {
      return EMPTY;
    } : operate(function(source, subscriber) {
      var soFar = 0;
      var sourceSub;
      var resubscribe = /* @__PURE__ */ __name(function() {
        sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
        sourceSub = null;
        if (delay2 != null) {
          var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(soFar));
          var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
            notifierSubscriber_1.unsubscribe();
            subscribeToSource();
          });
          notifier.subscribe(notifierSubscriber_1);
        } else {
          subscribeToSource();
        }
      }, "resubscribe");
      var subscribeToSource = /* @__PURE__ */ __name(function() {
        var syncUnsub = false;
        sourceSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, function() {
          if (++soFar < count) {
            if (sourceSub) {
              resubscribe();
            } else {
              syncUnsub = true;
            }
          } else {
            subscriber.complete();
          }
        }));
        if (syncUnsub) {
          resubscribe();
        }
      }, "subscribeToSource");
      subscribeToSource();
    });
  }
  __name(repeat, "repeat");
  function scan(accumulator, seed) {
    return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
  }
  __name(scan, "scan");
  function skip(count) {
    return filter(function(_, index) {
      return count <= index;
    });
  }
  __name(skip, "skip");
  function startWith() {
    var values = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      values[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(values);
    return operate(function(source, subscriber) {
      (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
    });
  }
  __name(startWith, "startWith");
  function switchMap(project, resultSelector) {
    return operate(function(source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = /* @__PURE__ */ __name(function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      }, "checkComplete");
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  }
  __name(switchMap, "switchMap");
  function takeUntil(notifier) {
    return operate(function(source, subscriber) {
      innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop$1));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }
  __name(takeUntil, "takeUntil");
  function tap(observerOrNext, error, complete) {
    var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? operate(function(source, subscriber) {
      var _a2;
      (_a2 = tapObserver.subscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      var isUnsub = true;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var _a3;
        (_a3 = tapObserver.next) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a3;
        isUnsub = false;
        (_a3 = tapObserver.complete) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a3;
        isUnsub = false;
        (_a3 = tapObserver.error) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a3, _b2;
        if (isUnsub) {
          (_a3 = tapObserver.unsubscribe) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
        }
        (_b2 = tapObserver.finalize) === null || _b2 === void 0 ? void 0 : _b2.call(tapObserver);
      }));
    }) : identity;
  }
  __name(tap, "tap");
  function withLatestFrom() {
    var inputs = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      inputs[_i2] = arguments[_i2];
    }
    var project = popResultSelector(inputs);
    return operate(function(source, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function() {
        return false;
      });
      var ready = false;
      var _loop_1 = /* @__PURE__ */ __name(function(i2) {
        innerFrom(inputs[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
          otherValues[i2] = value;
          if (!ready && !hasValue[i2]) {
            hasValue[i2] = true;
            (ready = hasValue.every(identity)) && (hasValue = null);
          }
        }, noop$1));
      }, "_loop_1");
      for (var i = 0; i < len; i++) {
        _loop_1(i);
      }
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (ready) {
          var values = __spreadArray$3([value], __read(otherValues));
          subscriber.next(project ? project.apply(void 0, __spreadArray$3([], __read(values))) : values);
        }
      }));
    });
  }
  __name(withLatestFrom, "withLatestFrom");
  const _Interceptor = class _Interceptor {
    constructor(_debuggingEnabled = false) {
      __publicField(this, "_typoBodyLoaded$", new BehaviorSubject(false));
      __publicField(this, "_canvasFound$", new BehaviorSubject(false));
      __publicField(this, "_contentScriptLoaded$", new BehaviorSubject(false));
      __publicField(this, "_patchLoaded$", new BehaviorSubject(false));
      __publicField(this, "_canvasPrioritizedEventsReady$", new BehaviorSubject(void 0));
      __publicField(this, "_canvasEventListener", /* @__PURE__ */ new Map());
      __publicField(this, "_canvasPrioritizedEventsReady", firstValueFrom(this._canvasPrioritizedEventsReady$.pipe(
        filter((v) => v !== void 0)
      )));
      this._debuggingEnabled = _debuggingEnabled;
      this._typoBodyLoaded$.pipe(
        /* wait until typo loaded body manually - see loader.ts */
        filter((loaded2) => loaded2),
        /* trigger listeners that have to run on typo loaded body */
        tap(() => this.listenForCanvas()),
        /* wait for all prerequisites */
        combineLatestWith(this._canvasFound$, this._contentScriptLoaded$),
        filter(([, canvas, content2]) => canvas && content2)
      ).subscribe(() => {
        this.debug("All prerequisites executed, injecting patch and listening to canvas events");
        this.listenPrioritizedCanvasElements();
        this.injectPatch();
      });
      this.debug("Interceptor initialized, starting listeners for token and game.js");
      this.waitForTypoLoadedBody();
      this.patchLoaded$.subscribe(() => {
        document.body.dataset["typo_loaded"] = "true";
      });
    }
    debug(...args) {
      if (!this._debuggingEnabled) return;
      console.log("[INTERCEPTOR DEBUG]", ...args);
    }
    injectPatch() {
      this.debug("Injecting game patch");
      const patch = document.createElement("script");
      patch.src = typoRuntime.getPatchUrl();
      patch.onload = async () => {
        this.debug("Game patch loaded");
        this._patchLoaded$.next(true);
        this._patchLoaded$.complete();
      };
      document.body.appendChild(patch);
    }
    waitForTypoLoadedBody() {
      this.debug("Listening for body from typo loader");
      if (document.body.dataset["typo_loader"] === "true") {
        this.debug("Body already loaded");
        this._typoBodyLoaded$.next(true);
        this._typoBodyLoaded$.complete();
        return;
      }
      const bodyObserver = new MutationObserver(() => {
        if (document.body.dataset["typo_loader"] === "true") {
          this.debug("Typo body loaded");
          this._typoBodyLoaded$.next(true);
          this._typoBodyLoaded$.complete();
          bodyObserver.disconnect();
        }
      });
      bodyObserver.observe(document, {
        childList: true,
        subtree: true
      });
    }
    listenForCanvas() {
      this.debug("Listening on DOM buildup until canvas element is added");
      if (element$1("#game-canvas > canvas")) {
        this.debug("Canvas already present");
        this._canvasFound$.next(true);
        this._canvasFound$.complete();
        return;
      }
      const scriptObserver2 = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "childList") {
            const target = [...mutation.addedNodes].find((n) => {
              var _a2;
              return n.nodeName === "CANVAS" && ((_a2 = n.parentElement) == null ? void 0 : _a2.id) === "game-canvas";
            });
            if (target) {
              this.debug("Canvas found");
              this._canvasFound$.next(true);
              this._canvasFound$.complete();
            }
          }
        });
      });
      scriptObserver2.observe(document.body, {
        childList: true,
        subtree: true
      });
    }
    /**
     * Listen to all events on the canvas and execute prioritized listeners first
     * Makes it possible to override skribbl event bindings on the canvas
     * @private
     */
    listenPrioritizedCanvasElements() {
      const addListener = /* @__PURE__ */ __name((priority) => {
        return (type, listener) => {
          const listeners = this._canvasEventListener.get(type);
          if (listeners === void 0) {
            this._canvasEventListener.set(type, /* @__PURE__ */ new Map([[priority, /* @__PURE__ */ new Set([{ priority, handler: listener }])]]));
          } else {
            const priorityListeners = listeners.get(priority);
            if (priorityListeners === void 0) {
              listeners.set(priority, /* @__PURE__ */ new Set([{ priority, handler: listener }]));
            } else {
              priorityListeners.add({ priority, handler: listener });
            }
          }
        };
      }, "addListener");
      const removeListener = /* @__PURE__ */ __name((type, listener) => {
        const listeners = this._canvasEventListener.get(type);
        if (listeners === void 0) return;
        for (const priorityListeners of listeners.values()) {
          for (const priorityListener of priorityListeners) {
            if (priorityListener.handler === listener) {
              priorityListeners.delete(priorityListener);
            }
          }
        }
      }, "removeListener");
      const canvas = requireElement("#game-canvas > canvas");
      for (const key2 in canvas) {
        if (/^on/.test(key2)) {
          const eventType = key2.slice(2);
          canvas.addEventListener(eventType, (event) => {
            const eventListeners = this._canvasEventListener.get(eventType);
            if (eventListeners === void 0) return;
            const listeners = [
              ...eventListeners.get("preDraw") ?? [],
              ...eventListeners.get("draw") ?? [],
              ...eventListeners.get("postDraw") ?? []
            ];
            for (const listener of listeners) {
              if (listener.handler(event) === false) {
                event.stopImmediatePropagation();
                return;
              }
            }
          });
        }
      }
      this._canvasPrioritizedEventsReady$.next({
        add: addListener,
        remove: removeListener
      });
    }
    triggerPatchInjection() {
      if (this._contentScriptLoaded$.closed) throw new Error("Already triggered patch injection");
      this.debug("Content script loaded, triggering patch injection");
      this._contentScriptLoaded$.next(true);
      this._contentScriptLoaded$.complete();
    }
    enableDebugging() {
      this._debuggingEnabled = true;
    }
    get patchLoaded$() {
      return this._patchLoaded$.pipe(
        filter((v) => v),
        map(() => void 0)
      );
    }
    get canvasPrioritizedEventsReady() {
      return this._canvasPrioritizedEventsReady;
    }
  };
  __name(_Interceptor, "Interceptor");
  let Interceptor = _Interceptor;
  function noop() {
  }
  __name(noop, "noop");
  function assign(tar, src) {
    for (const k in src) tar[k] = src[k];
    return (
      /** @type {T & S} */
      tar
    );
  }
  __name(assign, "assign");
  function is_promise(value) {
    return !!value && (typeof value === "object" || typeof value === "function") && typeof /** @type {any} */
    value.then === "function";
  }
  __name(is_promise, "is_promise");
  function run(fn) {
    return fn();
  }
  __name(run, "run");
  function blank_object() {
    return /* @__PURE__ */ Object.create(null);
  }
  __name(blank_object, "blank_object");
  function run_all(fns) {
    fns.forEach(run);
  }
  __name(run_all, "run_all");
  function is_function(thing) {
    return typeof thing === "function";
  }
  __name(is_function, "is_function");
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
  }
  __name(safe_not_equal, "safe_not_equal");
  let src_url_equal_anchor;
  function src_url_equal(element_src, url) {
    if (element_src === url) return true;
    if (!src_url_equal_anchor) {
      src_url_equal_anchor = document.createElement("a");
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
  }
  __name(src_url_equal, "src_url_equal");
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }
  __name(is_empty, "is_empty");
  function subscribe(store, ...callbacks) {
    if (store == null) {
      for (const callback of callbacks) {
        callback(void 0);
      }
      return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
  }
  __name(subscribe, "subscribe");
  function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
  }
  __name(component_subscribe, "component_subscribe");
  function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
      const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
      return definition[0](slot_ctx);
    }
  }
  __name(create_slot, "create_slot");
  function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
  }
  __name(get_slot_context, "get_slot_context");
  function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
      const lets = definition[2](fn(dirty));
      if ($$scope.dirty === void 0) {
        return lets;
      }
      if (typeof lets === "object") {
        const merged = [];
        const len = Math.max($$scope.dirty.length, lets.length);
        for (let i = 0; i < len; i += 1) {
          merged[i] = $$scope.dirty[i] | lets[i];
        }
        return merged;
      }
      return $$scope.dirty | lets;
    }
    return $$scope.dirty;
  }
  __name(get_slot_changes, "get_slot_changes");
  function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
      const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
      slot.p(slot_context, slot_changes);
    }
  }
  __name(update_slot_base, "update_slot_base");
  function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
      const dirty = [];
      const length = $$scope.ctx.length / 32;
      for (let i = 0; i < length; i++) {
        dirty[i] = -1;
      }
      return dirty;
    }
    return -1;
  }
  __name(get_all_dirty_from_scope, "get_all_dirty_from_scope");
  function exclude_internal_props(props) {
    const result = {};
    for (const k in props) if (k[0] !== "$") result[k] = props[k];
    return result;
  }
  __name(exclude_internal_props, "exclude_internal_props");
  function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props) if (!keys.has(k) && k[0] !== "$") rest[k] = props[k];
    return rest;
  }
  __name(compute_rest_props, "compute_rest_props");
  function null_to_empty(value) {
    return value == null ? "" : value;
  }
  __name(null_to_empty, "null_to_empty");
  function set_store_value(store, ret, value) {
    store.set(value);
    return ret;
  }
  __name(set_store_value, "set_store_value");
  function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
  }
  __name(action_destroyer, "action_destroyer");
  function append(target, node) {
    target.appendChild(node);
  }
  __name(append, "append");
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  __name(insert, "insert");
  function detach(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  __name(detach, "detach");
  function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
      if (iterations[i]) iterations[i].d(detaching);
    }
  }
  __name(destroy_each, "destroy_each");
  function element(name) {
    return document.createElement(name);
  }
  __name(element, "element");
  function svg_element(name) {
    return document.createElementNS("http://www.w3.org/2000/svg", name);
  }
  __name(svg_element, "svg_element");
  function text(data) {
    return document.createTextNode(data);
  }
  __name(text, "text");
  function space() {
    return text(" ");
  }
  __name(space, "space");
  function empty() {
    return text("");
  }
  __name(empty, "empty");
  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
  }
  __name(listen, "listen");
  function attr(node, attribute, value) {
    if (value == null) node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
  }
  __name(attr, "attr");
  function to_number(value) {
    return value === "" ? null : +value;
  }
  __name(to_number, "to_number");
  function children(element2) {
    return Array.from(element2.childNodes);
  }
  __name(children, "children");
  function set_data(text2, data) {
    data = "" + data;
    if (text2.data === data) return;
    text2.data = /** @type {string} */
    data;
  }
  __name(set_data, "set_data");
  function set_input_value(input, value) {
    input.value = value == null ? "" : value;
  }
  __name(set_input_value, "set_input_value");
  function set_style(node, key2, value, important) {
    if (value == null) {
      node.style.removeProperty(key2);
    } else {
      node.style.setProperty(key2, value, "");
    }
  }
  __name(set_style, "set_style");
  function select_option(select, value, mounting) {
    for (let i = 0; i < select.options.length; i += 1) {
      const option = select.options[i];
      if (option.__value === value) {
        option.selected = true;
        return;
      }
    }
    if (!mounting || value !== void 0) {
      select.selectedIndex = -1;
    }
  }
  __name(select_option, "select_option");
  function select_value(select) {
    const selected_option = select.querySelector(":checked");
    return selected_option && selected_option.__value;
  }
  __name(select_value, "select_value");
  function toggle_class(element2, name, toggle) {
    element2.classList.toggle(name, !!toggle);
  }
  __name(toggle_class, "toggle_class");
  function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
    return new CustomEvent(type, { detail, bubbles, cancelable });
  }
  __name(custom_event, "custom_event");
  const _HtmlTag = class _HtmlTag {
    constructor(is_svg = false) {
      /**
       * @private
       * @default false
       */
      __publicField(this, "is_svg", false);
      /** parent for creating node */
      __publicField(this, "e");
      /** html tag nodes */
      __publicField(this, "n");
      /** target */
      __publicField(this, "t");
      /** anchor */
      __publicField(this, "a");
      this.is_svg = is_svg;
      this.e = this.n = null;
    }
    /**
     * @param {string} html
     * @returns {void}
     */
    c(html) {
      this.h(html);
    }
    /**
     * @param {string} html
     * @param {HTMLElement | SVGElement} target
     * @param {HTMLElement | SVGElement} anchor
     * @returns {void}
     */
    m(html, target, anchor = null) {
      if (!this.e) {
        if (this.is_svg)
          this.e = svg_element(
            /** @type {keyof SVGElementTagNameMap} */
            target.nodeName
          );
        else
          this.e = element(
            /** @type {keyof HTMLElementTagNameMap} */
            target.nodeType === 11 ? "TEMPLATE" : target.nodeName
          );
        this.t = target.tagName !== "TEMPLATE" ? target : (
          /** @type {HTMLTemplateElement} */
          target.content
        );
        this.c(html);
      }
      this.i(anchor);
    }
    /**
     * @param {string} html
     * @returns {void}
     */
    h(html) {
      this.e.innerHTML = html;
      this.n = Array.from(
        this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
      );
    }
    /**
     * @returns {void} */
    i(anchor) {
      for (let i = 0; i < this.n.length; i += 1) {
        insert(this.t, this.n[i], anchor);
      }
    }
    /**
     * @param {string} html
     * @returns {void}
     */
    p(html) {
      this.d();
      this.h(html);
      this.i(this.a);
    }
    /**
     * @returns {void} */
    d() {
      this.n.forEach(detach);
    }
  };
  __name(_HtmlTag, "HtmlTag");
  let HtmlTag = _HtmlTag;
  function construct_svelte_component(component, props) {
    return new component(props);
  }
  __name(construct_svelte_component, "construct_svelte_component");
  let current_component;
  function set_current_component(component) {
    current_component = component;
  }
  __name(set_current_component, "set_current_component");
  function get_current_component() {
    if (!current_component) throw new Error("Function called outside component initialization");
    return current_component;
  }
  __name(get_current_component, "get_current_component");
  function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
  }
  __name(onMount, "onMount");
  function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
  }
  __name(onDestroy, "onDestroy");
  function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail, { cancelable = false } = {}) => {
      const callbacks = component.$$.callbacks[type];
      if (callbacks) {
        const event = custom_event(
          /** @type {string} */
          type,
          detail,
          { cancelable }
        );
        callbacks.slice().forEach((fn) => {
          fn.call(component, event);
        });
        return !event.defaultPrevented;
      }
      return true;
    };
  }
  __name(createEventDispatcher, "createEventDispatcher");
  function setContext(key2, context) {
    get_current_component().$$.context.set(key2, context);
    return context;
  }
  __name(setContext, "setContext");
  function getContext(key2) {
    return get_current_component().$$.context.get(key2);
  }
  __name(getContext, "getContext");
  function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
      callbacks.slice().forEach((fn) => fn.call(this, event));
    }
  }
  __name(bubble, "bubble");
  const dirty_components = [];
  const binding_callbacks = [];
  let render_callbacks = [];
  const flush_callbacks = [];
  const resolved_promise = /* @__PURE__ */ Promise.resolve();
  let update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  __name(schedule_update, "schedule_update");
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  __name(add_render_callback, "add_render_callback");
  function add_flush_callback(fn) {
    flush_callbacks.push(fn);
  }
  __name(add_flush_callback, "add_flush_callback");
  const seen_callbacks = /* @__PURE__ */ new Set();
  let flushidx = 0;
  function flush() {
    if (flushidx !== 0) {
      return;
    }
    const saved_component = current_component;
    do {
      try {
        while (flushidx < dirty_components.length) {
          const component = dirty_components[flushidx];
          flushidx++;
          set_current_component(component);
          update(component.$$);
        }
      } catch (e) {
        dirty_components.length = 0;
        flushidx = 0;
        throw e;
      }
      set_current_component(null);
      dirty_components.length = 0;
      flushidx = 0;
      while (binding_callbacks.length) binding_callbacks.pop()();
      for (let i = 0; i < render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
  }
  __name(flush, "flush");
  function update($$) {
    if ($$.fragment !== null) {
      $$.update();
      run_all($$.before_update);
      const dirty = $$.dirty;
      $$.dirty = [-1];
      $$.fragment && $$.fragment.p($$.ctx, dirty);
      $$.after_update.forEach(add_render_callback);
    }
  }
  __name(update, "update");
  function flush_render_callbacks(fns) {
    const filtered = [];
    const targets = [];
    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
    targets.forEach((c) => c());
    render_callbacks = filtered;
  }
  __name(flush_render_callbacks, "flush_render_callbacks");
  const outroing = /* @__PURE__ */ new Set();
  let outros;
  function group_outros() {
    outros = {
      r: 0,
      c: [],
      p: outros
      // parent group
    };
  }
  __name(group_outros, "group_outros");
  function check_outros() {
    if (!outros.r) {
      run_all(outros.c);
    }
    outros = outros.p;
  }
  __name(check_outros, "check_outros");
  function transition_in(block2, local) {
    if (block2 && block2.i) {
      outroing.delete(block2);
      block2.i(local);
    }
  }
  __name(transition_in, "transition_in");
  function transition_out(block2, local, detach2, callback) {
    if (block2 && block2.o) {
      if (outroing.has(block2)) return;
      outroing.add(block2);
      outros.c.push(() => {
        outroing.delete(block2);
        if (callback) {
          if (detach2) block2.d(1);
          callback();
        }
      });
      block2.o(local);
    } else if (callback) {
      callback();
    }
  }
  __name(transition_out, "transition_out");
  function handle_promise(promise, info) {
    const token = info.token = {};
    function update2(type, index, key2, value) {
      if (info.token !== token) return;
      info.resolved = value;
      let child_ctx = info.ctx;
      if (key2 !== void 0) {
        child_ctx = child_ctx.slice();
        child_ctx[key2] = value;
      }
      const block2 = type && (info.current = type)(child_ctx);
      let needs_flush = false;
      if (info.block) {
        if (info.blocks) {
          info.blocks.forEach((block3, i) => {
            if (i !== index && block3) {
              group_outros();
              transition_out(block3, 1, 1, () => {
                if (info.blocks[i] === block3) {
                  info.blocks[i] = null;
                }
              });
              check_outros();
            }
          });
        } else {
          info.block.d(1);
        }
        block2.c();
        transition_in(block2, 1);
        block2.m(info.mount(), info.anchor);
        needs_flush = true;
      }
      info.block = block2;
      if (info.blocks) info.blocks[index] = block2;
      if (needs_flush) {
        flush();
      }
    }
    __name(update2, "update");
    if (is_promise(promise)) {
      const current_component2 = get_current_component();
      promise.then(
        (value) => {
          set_current_component(current_component2);
          update2(info.then, 1, info.value, value);
          set_current_component(null);
        },
        (error) => {
          set_current_component(current_component2);
          update2(info.catch, 2, info.error, error);
          set_current_component(null);
          if (!info.hasCatch) {
            throw error;
          }
        }
      );
      if (info.current !== info.pending) {
        update2(info.pending, 0);
        return true;
      }
    } else {
      if (info.current !== info.then) {
        update2(info.then, 1, info.value, promise);
        return true;
      }
      info.resolved = /** @type {T} */
      promise;
    }
  }
  __name(handle_promise, "handle_promise");
  function update_await_block_branch(info, ctx, dirty) {
    const child_ctx = ctx.slice();
    const { resolved } = info;
    if (info.current === info.then) {
      child_ctx[info.value] = resolved;
    }
    if (info.current === info.catch) {
      child_ctx[info.error] = resolved;
    }
    info.block.p(child_ctx, dirty);
  }
  __name(update_await_block_branch, "update_await_block_branch");
  function ensure_array_like(array_like_or_iterator) {
    return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }
  __name(ensure_array_like, "ensure_array_like");
  function get_spread_update(levels, updates) {
    const update2 = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
      const o = levels[i];
      const n = updates[i];
      if (n) {
        for (const key2 in o) {
          if (!(key2 in n)) to_null_out[key2] = 1;
        }
        for (const key2 in n) {
          if (!accounted_for[key2]) {
            update2[key2] = n[key2];
            accounted_for[key2] = 1;
          }
        }
        levels[i] = n;
      } else {
        for (const key2 in o) {
          accounted_for[key2] = 1;
        }
      }
    }
    for (const key2 in to_null_out) {
      if (!(key2 in update2)) update2[key2] = void 0;
    }
    return update2;
  }
  __name(get_spread_update, "get_spread_update");
  function get_spread_object(spread_props) {
    return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
  }
  __name(get_spread_object, "get_spread_object");
  function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== void 0) {
      component.$$.bound[index] = callback;
      callback(component.$$.ctx[index]);
    }
  }
  __name(bind, "bind");
  function create_component(block2) {
    block2 && block2.c();
  }
  __name(create_component, "create_component");
  function mount_component(component, target, anchor) {
    const { fragment, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
  }
  __name(mount_component, "mount_component");
  function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
      flush_render_callbacks($$.after_update);
      run_all($$.on_destroy);
      $$.fragment && $$.fragment.d(detaching);
      $$.on_destroy = $$.fragment = null;
      $$.ctx = [];
    }
  }
  __name(destroy_component, "destroy_component");
  function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$$.dirty.fill(0);
    }
    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
  }
  __name(make_dirty, "make_dirty");
  function init(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
      fragment: null,
      ctx: [],
      // state
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      // lifecycle
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
      // everything else
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
        if (ready) make_dirty(component, i);
      }
      return ret;
    }) : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        const nodes = children(options.target);
        $$.fragment && $$.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $$.fragment && $$.fragment.c();
      }
      if (options.intro) transition_in(component.$$.fragment);
      mount_component(component, options.target, options.anchor);
      flush();
    }
    set_current_component(parent_component);
  }
  __name(init, "init");
  const _SvelteComponent = class _SvelteComponent {
    constructor() {
      /**
       * ### PRIVATE API
       *
       * Do not use, may change at any time
       *
       * @type {any}
       */
      __publicField(this, "$$");
      /**
       * ### PRIVATE API
       *
       * Do not use, may change at any time
       *
       * @type {any}
       */
      __publicField(this, "$$set");
    }
    /** @returns {void} */
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    /**
     * @template {Extract<keyof Events, string>} K
     * @param {K} type
     * @param {((e: Events[K]) => void) | null | undefined} callback
     * @returns {() => void}
     */
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1) callbacks.splice(index, 1);
      };
    }
    /**
     * @param {Partial<Props>} props
     * @returns {void}
     */
    $set(props) {
      if (this.$$set && !is_empty(props)) {
        this.$$.skip_bound = true;
        this.$$set(props);
        this.$$.skip_bound = false;
      }
    }
  };
  __name(_SvelteComponent, "SvelteComponent");
  let SvelteComponent = _SvelteComponent;
  const PUBLIC_VERSION = "4";
  const subscriber_queue = [];
  function writable(value, start = noop) {
    let stop;
    const subscribers = /* @__PURE__ */ new Set();
    function set(new_value) {
      if (safe_not_equal(value, new_value)) {
        value = new_value;
        if (stop) {
          const run_queue = !subscriber_queue.length;
          for (const subscriber of subscribers) {
            subscriber[1]();
            subscriber_queue.push(subscriber, value);
          }
          if (run_queue) {
            for (let i = 0; i < subscriber_queue.length; i += 2) {
              subscriber_queue[i][0](subscriber_queue[i + 1]);
            }
            subscriber_queue.length = 0;
          }
        }
      }
    }
    __name(set, "set");
    function update2(fn) {
      set(fn(value));
    }
    __name(update2, "update");
    function subscribe2(run2, invalidate = noop) {
      const subscriber = [run2, invalidate];
      subscribers.add(subscriber);
      if (subscribers.size === 1) {
        stop = start(set, update2) || noop;
      }
      run2(value);
      return () => {
        subscribers.delete(subscriber);
        if (subscribers.size === 0 && stop) {
          stop();
          stop = null;
        }
      };
    }
    __name(subscribe2, "subscribe");
    return { set, update: update2, subscribe: subscribe2 };
  }
  __name(writable, "writable");
  function fromObservable(observable2, initialValue, onWrite, allowWriteBeforeEmit = true) {
    const store = writable(initialValue);
    let hasEmitted = allowWriteBeforeEmit;
    const subscription = observable2.subscribe({
      next: /* @__PURE__ */ __name((value) => {
        store.set(value);
        hasEmitted = true;
      }, "next"),
      error: /* @__PURE__ */ __name((err) => console.error("Error from observable:", err), "error")
    });
    return {
      subscribe: store.subscribe,
      unsubscribe: /* @__PURE__ */ __name(() => subscription.unsubscribe(), "unsubscribe"),
      set: /* @__PURE__ */ __name((value) => {
        store.set(value);
        if (hasEmitted) onWrite == null ? void 0 : onWrite(value);
      }, "set")
    };
  }
  __name(fromObservable, "fromObservable");
  if (typeof window !== "undefined")
    (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
  function create_if_block$M(ctx) {
    let span;
    let t;
    return {
      c() {
        span = element("span");
        t = text(
          /*description*/
          ctx[2]
        );
        attr(span, "class", "svelte-kfudwd");
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
      },
      p(ctx2, dirty) {
        if (dirty & /*description*/
        4) set_data(
          t,
          /*description*/
          ctx2[2]
        );
      },
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  __name(create_if_block$M, "create_if_block$M");
  function create_fragment$1I(ctx) {
    let div;
    let img;
    let img_src_value;
    let t;
    let mounted;
    let dispose;
    let if_block = (
      /*description*/
      ctx[2] && create_if_block$M(ctx)
    );
    return {
      c() {
        div = element("div");
        img = element("img");
        t = space();
        if (if_block) if_block.c();
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        attr(img, "alt", "icon");
        set_style(img, "content", "var(--" + /*checked*/
        (ctx[0] ? "file-img-enabled-gif" : "file-img-disabled-gif") + ")");
        attr(img, "class", "svelte-kfudwd");
        attr(div, "role", "checkbox");
        attr(div, "tabindex", "0");
        attr(
          div,
          "aria-checked",
          /*checked*/
          ctx[0]
        );
        attr(div, "class", "svelte-kfudwd");
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, img);
        append(div, t);
        if (if_block) if_block.m(div, null);
        if (!mounted) {
          dispose = [
            listen(
              div,
              "click",
              /*click_handler*/
              ctx[4]
            ),
            listen(
              div,
              "click",
              /*click_handler_1*/
              ctx[5]
            ),
            listen(
              div,
              "keypress",
              /*keypress_handler*/
              ctx[6]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*checked*/
        1) {
          set_style(img, "content", "var(--" + /*checked*/
          (ctx2[0] ? "file-img-enabled-gif" : "file-img-disabled-gif") + ")");
        }
        if (
          /*description*/
          ctx2[2]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$M(ctx2);
            if_block.c();
            if_block.m(div, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & /*checked*/
        1) {
          attr(
            div,
            "aria-checked",
            /*checked*/
            ctx2[0]
          );
        }
        if (dirty & /*disabled*/
        2) {
          toggle_class(
            div,
            "disabled",
            /*disabled*/
            ctx2[1]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if (if_block) if_block.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$1I, "create_fragment$1I");
  function instance$1y($$self, $$props, $$invalidate) {
    let { checked = false } = $$props;
    let { disabled = false } = $$props;
    let { description = "" } = $$props;
    const dispatch = createEventDispatcher();
    function click_handler2(event) {
      bubble.call(this, $$self, event);
    }
    __name(click_handler2, "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => {
      $$invalidate(0, checked = !checked);
      dispatch("change", checked);
    }, "click_handler_1");
    const keypress_handler = /* @__PURE__ */ __name((key2) => {
      key2.key === "Enter" ? $$invalidate(0, checked = !checked) : 0;
      dispatch("change", checked);
    }, "keypress_handler");
    $$self.$$set = ($$props2) => {
      if ("checked" in $$props2) $$invalidate(0, checked = $$props2.checked);
      if ("disabled" in $$props2) $$invalidate(1, disabled = $$props2.disabled);
      if ("description" in $$props2) $$invalidate(2, description = $$props2.description);
    };
    return [
      checked,
      disabled,
      description,
      dispatch,
      click_handler2,
      click_handler_1,
      keypress_handler
    ];
  }
  __name(instance$1y, "instance$1y");
  const _Checkbox = class _Checkbox extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1y, create_fragment$1I, safe_not_equal, { checked: 0, disabled: 1, description: 2 });
    }
  };
  __name(_Checkbox, "Checkbox");
  let Checkbox = _Checkbox;
  function create_if_block$L(ctx) {
    let b;
    let checkbox;
    let updating_checked;
    let t0;
    let div;
    let t1_value = (
      /*setting*/
      ctx[0].description + ""
    );
    let t1;
    let current;
    function checkbox_checked_binding(value) {
      ctx[3](value);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    let checkbox_props = { description: (
      /*setting*/
      ctx[0].name
    ) };
    if (
      /*$settingStore*/
      ctx[2] !== void 0
    ) {
      checkbox_props.checked = /*$settingStore*/
      ctx[2];
    }
    checkbox = new Checkbox({ props: checkbox_props });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
    return {
      c() {
        b = element("b");
        create_component(checkbox.$$.fragment);
        t0 = space();
        div = element("div");
        t1 = text(t1_value);
        attr(b, "class", "svelte-rvotkt");
      },
      m(target, anchor) {
        insert(target, b, anchor);
        mount_component(checkbox, b, null);
        insert(target, t0, anchor);
        insert(target, div, anchor);
        append(div, t1);
        current = true;
      },
      p(ctx2, dirty) {
        const checkbox_changes = {};
        if (dirty & /*setting*/
        1) checkbox_changes.description = /*setting*/
        ctx2[0].name;
        if (!updating_checked && dirty & /*$settingStore*/
        4) {
          updating_checked = true;
          checkbox_changes.checked = /*$settingStore*/
          ctx2[2];
          add_flush_callback(() => updating_checked = false);
        }
        checkbox.$set(checkbox_changes);
        if ((!current || dirty & /*setting*/
        1) && t1_value !== (t1_value = /*setting*/
        ctx2[0].description + "")) set_data(t1, t1_value);
      },
      i(local) {
        if (current) return;
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(b);
          detach(t0);
          detach(div);
        }
        destroy_component(checkbox);
      }
    };
  }
  __name(create_if_block$L, "create_if_block$L");
  function create_fragment$1H(ctx) {
    let if_block_anchor;
    let current;
    let if_block = (
      /*settingStore*/
      ctx[1] && create_if_block$L(ctx)
    );
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (
          /*settingStore*/
          ctx2[1]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & /*settingStore*/
            2) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block$L(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
      }
    };
  }
  __name(create_fragment$1H, "create_fragment$1H");
  function instance$1x($$self, $$props, $$invalidate) {
    let $settingStore, $$unsubscribe_settingStore = noop, $$subscribe_settingStore = /* @__PURE__ */ __name(() => ($$unsubscribe_settingStore(), $$unsubscribe_settingStore = subscribe(settingStore, ($$value) => $$invalidate(2, $settingStore = $$value)), settingStore), "$$subscribe_settingStore");
    $$self.$$.on_destroy.push(() => $$unsubscribe_settingStore());
    let { setting } = $$props;
    let settingStore;
    function checkbox_checked_binding(value) {
      $settingStore = value;
      settingStore.set($settingStore);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    $$self.$$set = ($$props2) => {
      if ("setting" in $$props2) $$invalidate(0, setting = $$props2.setting);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*setting*/
      1) {
        {
          $$subscribe_settingStore($$invalidate(1, settingStore = setting.store));
        }
      }
    };
    return [setting, settingStore, $settingStore, checkbox_checked_binding];
  }
  __name(instance$1x, "instance$1x");
  const _Boolean_setting_input = class _Boolean_setting_input extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1x, create_fragment$1H, safe_not_equal, { setting: 0 });
    }
  };
  __name(_Boolean_setting_input, "Boolean_setting_input");
  let Boolean_setting_input = _Boolean_setting_input;
  function create_if_block$K(ctx) {
    let div1;
    let b;
    let t0_value = (
      /*setting*/
      ctx[0].name + ""
    );
    let t0;
    let t1;
    let input;
    let input_min_value;
    let input_max_value;
    let t2;
    let t3;
    let div0;
    let t4_value = (
      /*setting*/
      ctx[0].description + ""
    );
    let t4;
    let mounted;
    let dispose;
    let if_block = (
      /*withSliderAndSteps*/
      ctx[2] !== void 0 && /*bounds*/
      ctx[1] && create_if_block_1$m(ctx)
    );
    return {
      c() {
        var _a2, _b2;
        div1 = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = space();
        input = element("input");
        t2 = space();
        if (if_block) if_block.c();
        t3 = space();
        div0 = element("div");
        t4 = text(t4_value);
        attr(b, "class", "svelte-i0zktq");
        attr(input, "type", "number");
        attr(input, "min", input_min_value = /*bounds*/
        (_a2 = ctx[1]) == null ? void 0 : _a2.min);
        attr(input, "max", input_max_value = /*bounds*/
        (_b2 = ctx[1]) == null ? void 0 : _b2.max);
        attr(input, "class", "svelte-i0zktq");
        attr(div1, "class", "typo-numeric-setting svelte-i0zktq");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, b);
        append(b, t0);
        append(div1, t1);
        append(div1, input);
        set_input_value(
          input,
          /*$settingStore*/
          ctx[4]
        );
        append(div1, t2);
        if (if_block) if_block.m(div1, null);
        append(div1, t3);
        append(div1, div0);
        append(div0, t4);
        if (!mounted) {
          dispose = listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[5]
          );
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        var _a2, _b2;
        if (dirty & /*setting*/
        1 && t0_value !== (t0_value = /*setting*/
        ctx2[0].name + "")) set_data(t0, t0_value);
        if (dirty & /*bounds*/
        2 && input_min_value !== (input_min_value = /*bounds*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.min)) {
          attr(input, "min", input_min_value);
        }
        if (dirty & /*bounds*/
        2 && input_max_value !== (input_max_value = /*bounds*/
        (_b2 = ctx2[1]) == null ? void 0 : _b2.max)) {
          attr(input, "max", input_max_value);
        }
        if (dirty & /*$settingStore*/
        16 && to_number(input.value) !== /*$settingStore*/
        ctx2[4]) {
          set_input_value(
            input,
            /*$settingStore*/
            ctx2[4]
          );
        }
        if (
          /*withSliderAndSteps*/
          ctx2[2] !== void 0 && /*bounds*/
          ctx2[1]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block_1$m(ctx2);
            if_block.c();
            if_block.m(div1, t3);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & /*setting*/
        1 && t4_value !== (t4_value = /*setting*/
        ctx2[0].description + "")) set_data(t4, t4_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if (if_block) if_block.d();
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block$K, "create_if_block$K");
  function create_if_block_1$m(ctx) {
    let input;
    let input_min_value;
    let input_max_value;
    let mounted;
    let dispose;
    return {
      c() {
        input = element("input");
        attr(input, "type", "range");
        attr(input, "min", input_min_value = /*bounds*/
        ctx[1].min);
        attr(input, "max", input_max_value = /*bounds*/
        ctx[1].max);
        attr(
          input,
          "step",
          /*withSliderAndSteps*/
          ctx[2]
        );
        attr(input, "class", "svelte-i0zktq");
      },
      m(target, anchor) {
        insert(target, input, anchor);
        set_input_value(
          input,
          /*$settingStore*/
          ctx[4]
        );
        if (!mounted) {
          dispose = [
            listen(
              input,
              "change",
              /*input_change_input_handler*/
              ctx[6]
            ),
            listen(
              input,
              "input",
              /*input_change_input_handler*/
              ctx[6]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*bounds*/
        2 && input_min_value !== (input_min_value = /*bounds*/
        ctx2[1].min)) {
          attr(input, "min", input_min_value);
        }
        if (dirty & /*bounds*/
        2 && input_max_value !== (input_max_value = /*bounds*/
        ctx2[1].max)) {
          attr(input, "max", input_max_value);
        }
        if (dirty & /*withSliderAndSteps*/
        4) {
          attr(
            input,
            "step",
            /*withSliderAndSteps*/
            ctx2[2]
          );
        }
        if (dirty & /*$settingStore*/
        16) {
          set_input_value(
            input,
            /*$settingStore*/
            ctx2[4]
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(input);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_if_block_1$m, "create_if_block_1$m");
  function create_fragment$1G(ctx) {
    let if_block_anchor;
    let if_block = (
      /*settingStore*/
      ctx[3] && create_if_block$K(ctx)
    );
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (
          /*settingStore*/
          ctx2[3]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$K(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
      }
    };
  }
  __name(create_fragment$1G, "create_fragment$1G");
  function instance$1w($$self, $$props, $$invalidate) {
    let $settingStore, $$unsubscribe_settingStore = noop, $$subscribe_settingStore = /* @__PURE__ */ __name(() => ($$unsubscribe_settingStore(), $$unsubscribe_settingStore = subscribe(settingStore, ($$value) => $$invalidate(4, $settingStore = $$value)), settingStore), "$$subscribe_settingStore");
    $$self.$$.on_destroy.push(() => $$unsubscribe_settingStore());
    let { setting } = $$props;
    let { bounds } = $$props;
    let { withSliderAndSteps } = $$props;
    let settingStore;
    function input_input_handler() {
      $settingStore = to_number(this.value);
      settingStore.set($settingStore);
    }
    __name(input_input_handler, "input_input_handler");
    function input_change_input_handler() {
      $settingStore = to_number(this.value);
      settingStore.set($settingStore);
    }
    __name(input_change_input_handler, "input_change_input_handler");
    $$self.$$set = ($$props2) => {
      if ("setting" in $$props2) $$invalidate(0, setting = $$props2.setting);
      if ("bounds" in $$props2) $$invalidate(1, bounds = $$props2.bounds);
      if ("withSliderAndSteps" in $$props2) $$invalidate(2, withSliderAndSteps = $$props2.withSliderAndSteps);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*setting*/
      1) {
        {
          $$subscribe_settingStore($$invalidate(3, settingStore = setting.store));
        }
      }
    };
    return [
      setting,
      bounds,
      withSliderAndSteps,
      settingStore,
      $settingStore,
      input_input_handler,
      input_change_input_handler
    ];
  }
  __name(instance$1w, "instance$1w");
  const _Numeric_setting_input = class _Numeric_setting_input extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1w, create_fragment$1G, safe_not_equal, {
        setting: 0,
        bounds: 1,
        withSliderAndSteps: 2
      });
    }
  };
  __name(_Numeric_setting_input, "Numeric_setting_input");
  let Numeric_setting_input = _Numeric_setting_input;
  function get_each_context$z(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[5] = list[i].choice;
    child_ctx[6] = list[i].name;
    return child_ctx;
  }
  __name(get_each_context$z, "get_each_context$z");
  function create_if_block$J(ctx) {
    let div1;
    let b;
    let t0_value = (
      /*setting*/
      ctx[0].name + ""
    );
    let t0;
    let t1;
    let select;
    let t2;
    let div0;
    let t3_value = (
      /*setting*/
      ctx[0].description + ""
    );
    let t3;
    let mounted;
    let dispose;
    let each_value = ensure_array_like(
      /*choices*/
      ctx[1]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$z(get_each_context$z(ctx, each_value, i));
    }
    return {
      c() {
        div1 = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = space();
        select = element("select");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t2 = space();
        div0 = element("div");
        t3 = text(t3_value);
        attr(b, "class", "svelte-zlhfg4");
        if (
          /*$settingStore*/
          ctx[3] === void 0
        ) add_render_callback(() => (
          /*select_change_handler*/
          ctx[4].call(select)
        ));
        attr(div1, "class", "typo-numeric-setting svelte-zlhfg4");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, b);
        append(b, t0);
        append(div1, t1);
        append(div1, select);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(select, null);
          }
        }
        select_option(
          select,
          /*$settingStore*/
          ctx[3],
          true
        );
        append(div1, t2);
        append(div1, div0);
        append(div0, t3);
        if (!mounted) {
          dispose = listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[4]
          );
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*setting*/
        1 && t0_value !== (t0_value = /*setting*/
        ctx2[0].name + "")) set_data(t0, t0_value);
        if (dirty & /*choices*/
        2) {
          each_value = ensure_array_like(
            /*choices*/
            ctx2[1]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$z(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$z(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(select, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
        if (dirty & /*$settingStore, choices*/
        10) {
          select_option(
            select,
            /*$settingStore*/
            ctx2[3]
          );
        }
        if (dirty & /*setting*/
        1 && t3_value !== (t3_value = /*setting*/
        ctx2[0].description + "")) set_data(t3, t3_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_each(each_blocks, detaching);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block$J, "create_if_block$J");
  function create_each_block$z(ctx) {
    let option;
    let t_value = (
      /*name*/
      ctx[6] + ""
    );
    let t;
    let option_value_value;
    return {
      c() {
        option = element("option");
        t = text(t_value);
        option.__value = option_value_value = /*choice*/
        ctx[5];
        set_input_value(option, option.__value);
      },
      m(target, anchor) {
        insert(target, option, anchor);
        append(option, t);
      },
      p(ctx2, dirty) {
        if (dirty & /*choices*/
        2 && t_value !== (t_value = /*name*/
        ctx2[6] + "")) set_data(t, t_value);
        if (dirty & /*choices*/
        2 && option_value_value !== (option_value_value = /*choice*/
        ctx2[5])) {
          option.__value = option_value_value;
          set_input_value(option, option.__value);
        }
      },
      d(detaching) {
        if (detaching) {
          detach(option);
        }
      }
    };
  }
  __name(create_each_block$z, "create_each_block$z");
  function create_fragment$1F(ctx) {
    let if_block_anchor;
    let if_block = (
      /*settingStore*/
      ctx[2] && create_if_block$J(ctx)
    );
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (
          /*settingStore*/
          ctx2[2]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$J(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
      }
    };
  }
  __name(create_fragment$1F, "create_fragment$1F");
  function instance$1v($$self, $$props, $$invalidate) {
    let $settingStore, $$unsubscribe_settingStore = noop, $$subscribe_settingStore = /* @__PURE__ */ __name(() => ($$unsubscribe_settingStore(), $$unsubscribe_settingStore = subscribe(settingStore, ($$value) => $$invalidate(3, $settingStore = $$value)), settingStore), "$$subscribe_settingStore");
    $$self.$$.on_destroy.push(() => $$unsubscribe_settingStore());
    let { setting } = $$props;
    let { choices } = $$props;
    let settingStore;
    function select_change_handler() {
      $settingStore = select_value(this);
      settingStore.set($settingStore);
      $$invalidate(1, choices);
    }
    __name(select_change_handler, "select_change_handler");
    $$self.$$set = ($$props2) => {
      if ("setting" in $$props2) $$invalidate(0, setting = $$props2.setting);
      if ("choices" in $$props2) $$invalidate(1, choices = $$props2.choices);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*setting*/
      1) {
        {
          $$subscribe_settingStore($$invalidate(2, settingStore = setting.store));
        }
      }
    };
    return [setting, choices, settingStore, $settingStore, select_change_handler];
  }
  __name(instance$1v, "instance$1v");
  const _Choice_setting_input = class _Choice_setting_input extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1v, create_fragment$1F, safe_not_equal, { setting: 0, choices: 1 });
    }
  };
  __name(_Choice_setting_input, "Choice_setting_input");
  let Choice_setting_input = _Choice_setting_input;
  function create_if_block$I(ctx) {
    let div1;
    let b;
    let t0_value = (
      /*setting*/
      ctx[0].name + ""
    );
    let t0;
    let t1;
    let input;
    let t2;
    let div0;
    let t3_value = (
      /*setting*/
      ctx[0].description + ""
    );
    let t3;
    let mounted;
    let dispose;
    return {
      c() {
        div1 = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = space();
        input = element("input");
        t2 = space();
        div0 = element("div");
        t3 = text(t3_value);
        attr(b, "class", "svelte-xq58hp");
        attr(input, "type", "text");
        attr(input, "class", "svelte-xq58hp");
        attr(div1, "class", "typo-text-setting svelte-xq58hp");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, b);
        append(b, t0);
        append(div1, t1);
        append(div1, input);
        set_input_value(
          input,
          /*$settingStore*/
          ctx[2]
        );
        append(div1, t2);
        append(div1, div0);
        append(div0, t3);
        if (!mounted) {
          dispose = listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[3]
          );
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*setting*/
        1 && t0_value !== (t0_value = /*setting*/
        ctx2[0].name + "")) set_data(t0, t0_value);
        if (dirty & /*$settingStore*/
        4 && input.value !== /*$settingStore*/
        ctx2[2]) {
          set_input_value(
            input,
            /*$settingStore*/
            ctx2[2]
          );
        }
        if (dirty & /*setting*/
        1 && t3_value !== (t3_value = /*setting*/
        ctx2[0].description + "")) set_data(t3, t3_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block$I, "create_if_block$I");
  function create_fragment$1E(ctx) {
    let if_block_anchor;
    let if_block = (
      /*settingStore*/
      ctx[1] && create_if_block$I(ctx)
    );
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (
          /*settingStore*/
          ctx2[1]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$I(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
      }
    };
  }
  __name(create_fragment$1E, "create_fragment$1E");
  function instance$1u($$self, $$props, $$invalidate) {
    let $settingStore, $$unsubscribe_settingStore = noop, $$subscribe_settingStore = /* @__PURE__ */ __name(() => ($$unsubscribe_settingStore(), $$unsubscribe_settingStore = subscribe(settingStore, ($$value) => $$invalidate(2, $settingStore = $$value)), settingStore), "$$subscribe_settingStore");
    $$self.$$.on_destroy.push(() => $$unsubscribe_settingStore());
    let { setting } = $$props;
    let settingStore;
    function input_input_handler() {
      $settingStore = this.value;
      settingStore.set($settingStore);
    }
    __name(input_input_handler, "input_input_handler");
    $$self.$$set = ($$props2) => {
      if ("setting" in $$props2) $$invalidate(0, setting = $$props2.setting);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*setting*/
      1) {
        {
          $$subscribe_settingStore($$invalidate(1, settingStore = setting.store));
        }
      }
    };
    return [setting, settingStore, $settingStore, input_input_handler];
  }
  __name(instance$1u, "instance$1u");
  const _Text_setting_input = class _Text_setting_input extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1u, create_fragment$1E, safe_not_equal, { setting: 0 });
    }
  };
  __name(_Text_setting_input, "Text_setting_input");
  let Text_setting_input = _Text_setting_input;
  const _Color = class _Color {
    constructor(_r2, _g2, _b2, _a2) {
      this._r = _r2;
      this._g = _g2;
      this._b = _b2;
      this._a = _a2;
    }
    get r() {
      return this._r;
    }
    get g() {
      return this._g;
    }
    get b() {
      return this._b;
    }
    // get the rgb string of the color
    get rgbString() {
      return "rgb(" + [this._r, this._g, this._b, this._a].filter((v) => v !== void 0).join(",") + ")";
    }
    get rgbArray() {
      return this._a ? [this._r, this._g, this._b, this._a] : [this._r, this._g, this._b];
    }
    // get the rgb values of the color
    get rgb() {
      return {
        r: this._r,
        g: this._g,
        b: this._b,
        a: this._a
      };
    }
    // get the hex string of the color
    get hex() {
      return "#" + this._r.toString(16).padStart(2, "0") + this._g.toString(16).padStart(2, "0") + this._b.toString(16).padStart(2, "0") + (this._a ? Math.floor(255 * this._a).toString(16).padStart(2, "0") : "");
    }
    set hex(hex) {
      const color = _Color.fromHex(hex);
      this._r = color._r;
      this._g = color._g;
      this._b = color._b;
      this._a = color._a;
    }
    /**
     * The atttempted skribbl color code
     * If not found, return tyopo code instead (hex val + 10000)
     */
    get skribblCode() {
      const skribblIndex = _Color.skribblColors.findIndex((c) => c[0] === this._r && c[1] === this._g && c[2] === this._b);
      if (skribblIndex !== -1) return skribblIndex;
      return this.typoCode;
    }
    /**
     * The color code for the typo color (hex val + 10000)
     */
    get typoCode() {
      const hexString = (this._r << 16 | this._g << 8 | this._b).toString(16).toUpperCase();
      return parseInt(hexString, 16) + 1e4;
    }
    //source: https://gist.github.com/mjackson/5311256
    get hsl() {
      const r = this.r / 255, g = this.g / 255, b = this.b / 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h = 0, s = 0;
      const l = (max + min) / 2;
      if (max == min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return this._a !== void 0 ? [h * 360, s * 100, l * 100, this._a] : [h * 360, s * 100, l * 100];
    }
    // Convert to HSV
    get hsv() {
      const r = this.r / 255, g = this.g / 255, b = this.b / 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      const delta = max - min;
      let h = 0, s = 0;
      const v = max;
      if (max !== 0) {
        s = delta / max;
      } else {
        h = 0;
        s = 0;
      }
      if (max !== min) {
        switch (max) {
          case r:
            h = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / delta + 2;
            break;
          case b:
            h = (r - g) / delta + 4;
            break;
        }
        h /= 6;
      }
      return [h * 360, s * 100, v * 100, this._a];
    }
    static fromRgb(r, g, b, a) {
      return new _Color(Math.round(r), Math.round(g), Math.round(b), a ? Math.round(a * 100) / 100 : void 0);
    }
    static fromHex(hex) {
      if (hex[0] == "#") hex = hex.substring(1);
      const r = Math.round(parseInt("0x" + hex.substring(0, 2)));
      const g = Math.round(parseInt("0x" + hex.substring(2, 4)));
      const b = Math.round(parseInt("0x" + hex.substring(4, 6)));
      const a = hex.length > 6 ? Math.round(parseInt("0x" + hex.substring(6, 8))) : void 0;
      return new _Color(r, g, b, a);
    }
    static fromRgbString(rgb) {
      const rgbs = rgb.trim().replace(" ", "").split(",");
      const r = parseInt(rgbs[0].replace(/[^\d]/g, ""), 10);
      const g = parseInt(rgbs[1].replace(/[^\d]/g, ""), 10);
      const b = parseInt(rgbs[2].replace(/[^\d]/g, ""), 10);
      const a = rgbs.length > 3 ? parseInt(rgbs[4].replace(/[^\d]/g, ""), 10) : void 0;
      return new _Color(r, g, b, a);
    }
    static fromSkribblCode(code) {
      if (code < 1e4) {
        const rgb = _Color.skribblColors[code];
        return _Color.fromRgb(rgb[0], rgb[1], rgb[2]);
      }
      const hex = (code - 1e4).toString(16).padStart(6, "0");
      return _Color.fromHex(hex);
    }
    // source: https://stackoverflow.com/questions/36721830/convert-hsl-to-rgb-and-hex
    static fromHsl(h, s, l, alpha) {
      s /= 100;
      l /= 100;
      const k = /* @__PURE__ */ __name((n) => (n + h / 30) % 12, "k");
      const a = s * Math.min(l, 1 - l);
      const f = /* @__PURE__ */ __name((n) => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1))), "f");
      const r = Math.round(f(0) * 255);
      const g = Math.round(f(8) * 255);
      const b = Math.round(f(4) * 255);
      return new _Color(r, g, b, alpha);
    }
    // Static factory method for HSV to RGB conversion
    static fromHsv(h, s, v, a) {
      s /= 100;
      v /= 100;
      const c = v * s;
      const x = c * (1 - Math.abs(h / 60 % 2 - 1));
      const m = v - c;
      let r = 0, g = 0, b = 0;
      if (0 <= h && h < 60) {
        r = c;
        g = x;
        b = 0;
      } else if (60 <= h && h < 120) {
        r = x;
        g = c;
        b = 0;
      } else if (120 <= h && h < 180) {
        r = 0;
        g = c;
        b = x;
      } else if (180 <= h && h < 240) {
        r = 0;
        g = x;
        b = c;
      } else if (240 <= h && h < 300) {
        r = x;
        g = 0;
        b = c;
      } else if (300 <= h && h < 360) {
        r = c;
        g = 0;
        b = x;
      }
      r = Math.round((r + m) * 255);
      g = Math.round((g + m) * 255);
      b = Math.round((b + m) * 255);
      return new _Color(r, g, b, a);
    }
    copy() {
      return new _Color(this._r, this._g, this._b, this._a);
    }
    withAlpha(a) {
      this._a = a;
      return this;
    }
  };
  __name(_Color, "Color");
  __publicField(_Color, "skribblColors", [
    [255, 255, 255],
    [0, 0, 0],
    [193, 193, 193],
    [80, 80, 80],
    [239, 19, 11],
    [116, 11, 7],
    [255, 113, 0],
    [194, 56, 0],
    [255, 228, 0],
    [232, 162, 0],
    [0, 204, 0],
    [0, 70, 25],
    [0, 255, 145],
    [0, 120, 93],
    [0, 178, 255],
    [0, 86, 158],
    [35, 31, 211],
    [14, 8, 101],
    [163, 0, 186],
    [85, 0, 105],
    [223, 105, 167],
    [135, 53, 84],
    [255, 172, 142],
    [204, 119, 77],
    [160, 82, 45],
    [99, 48, 13]
  ]);
  let Color = _Color;
  function create_if_block_1$l(ctx) {
    let p;
    let t;
    return {
      c() {
        p = element("p");
        t = text(
          /*description*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, p, anchor);
        append(p, t);
      },
      p(ctx2, dirty) {
        if (dirty & /*description*/
        4) set_data(
          t,
          /*description*/
          ctx2[2]
        );
      },
      d(detaching) {
        if (detaching) {
          detach(p);
        }
      }
    };
  }
  __name(create_if_block_1$l, "create_if_block_1$l");
  function create_if_block$H(ctx) {
    let div1;
    let div0;
    let mounted;
    let dispose;
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        attr(div0, "class", "alpha-thumb svelte-1x2m4l5");
        set_style(div0, "top", "calc(50% - .5rem)");
        set_style(div0, "left", "calc(" + /*alpha*/
        (ctx[6] ?? 1) * 100 + "% - .5rem)");
        toggle_class(
          div0,
          "listen",
          /*listenAlpha*/
          ctx[10]
        );
        attr(div1, "class", "alpha-rect svelte-1x2m4l5");
        set_style(div1, "background", "linear-gradient(to right, " + /*color*/
        ctx[0].copy().withAlpha(0).rgbString + ", " + /*color*/
        ctx[0].copy().withAlpha(1).rgbString + ")");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        if (!mounted) {
          dispose = [
            listen(
              div1,
              "mousedown",
              /*mousedown_handler_2*/
              ctx[16]
            ),
            listen(
              div1,
              "mouseup",
              /*handleAlpha*/
              ctx[13]
            ),
            listen(
              div1,
              "mouseleave",
              /*handleAlpha*/
              ctx[13]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*alpha*/
        64) {
          set_style(div0, "left", "calc(" + /*alpha*/
          (ctx2[6] ?? 1) * 100 + "% - .5rem)");
        }
        if (dirty & /*listenAlpha*/
        1024) {
          toggle_class(
            div0,
            "listen",
            /*listenAlpha*/
            ctx2[10]
          );
        }
        if (dirty & /*color*/
        1) {
          set_style(div1, "background", "linear-gradient(to right, " + /*color*/
          ctx2[0].copy().withAlpha(0).rgbString + ", " + /*color*/
          ctx2[0].copy().withAlpha(1).rgbString + ")");
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_if_block$H, "create_if_block$H");
  function create_fragment$1D(ctx) {
    let div5;
    let div0;
    let t2;
    let t3;
    let div2;
    let div1;
    let t4;
    let div4;
    let div3;
    let t5;
    let t6;
    let input;
    let mounted;
    let dispose;
    let if_block0 = (
      /*description*/
      ctx[2].length > 0 && create_if_block_1$l(ctx)
    );
    let if_block1 = (
      /*allowAlpha*/
      ctx[1] && create_if_block$H(ctx)
    );
    return {
      c() {
        div5 = element("div");
        div0 = element("div");
        div0.innerHTML = `<img src="" alt="picker icon" style="content: var(--file-img-crosshair-gif)" class="svelte-1x2m4l5"/> <h3 class="svelte-1x2m4l5">Color Picker</h3>`;
        t2 = space();
        if (if_block0) if_block0.c();
        t3 = space();
        div2 = element("div");
        div1 = element("div");
        t4 = space();
        div4 = element("div");
        div3 = element("div");
        t5 = space();
        if (if_block1) if_block1.c();
        t6 = space();
        input = element("input");
        attr(div0, "class", "picker-header svelte-1x2m4l5");
        attr(div1, "class", "color-thumb svelte-1x2m4l5");
        set_style(div1, "top", "calc(100% - " + /*value*/
        ctx[5] + "% - .5rem)");
        set_style(div1, "left", "calc(" + /*saturation*/
        ctx[4] + "% - .5rem)");
        toggle_class(
          div1,
          "listen",
          /*listenSV*/
          ctx[8]
        );
        attr(div2, "class", "color-rect svelte-1x2m4l5");
        set_style(div2, "background", "linear-gradient(to top, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0)), linear-gradient(to right, hsl(0, 0%, 100%), hsl(" + /*hue*/
        ctx[3] + ", 100%, 50%))");
        attr(div3, "class", "hue-thumb svelte-1x2m4l5");
        set_style(div3, "top", "calc(50% - .5rem)");
        set_style(div3, "left", "calc(" + /*hue*/
        ctx[3] / 3.6 + "% - .5rem)");
        toggle_class(
          div3,
          "listen",
          /*listenHue*/
          ctx[9]
        );
        attr(div4, "class", "hue-rect svelte-1x2m4l5");
        attr(input, "type", "text");
        attr(input, "placeholder", "#aabbcc");
        attr(div5, "class", "color-picker svelte-1x2m4l5");
      },
      m(target, anchor) {
        insert(target, div5, anchor);
        append(div5, div0);
        append(div5, t2);
        if (if_block0) if_block0.m(div5, null);
        append(div5, t3);
        append(div5, div2);
        append(div2, div1);
        append(div5, t4);
        append(div5, div4);
        append(div4, div3);
        append(div5, t5);
        if (if_block1) if_block1.m(div5, null);
        append(div5, t6);
        append(div5, input);
        set_input_value(
          input,
          /*inputHex*/
          ctx[7]
        );
        if (!mounted) {
          dispose = [
            listen(
              div2,
              "mousedown",
              /*mousedown_handler*/
              ctx[14]
            ),
            listen(
              div2,
              "mouseup",
              /*handleSV*/
              ctx[11]
            ),
            listen(
              div2,
              "mouseleave",
              /*handleSV*/
              ctx[11]
            ),
            listen(
              div4,
              "mousedown",
              /*mousedown_handler_1*/
              ctx[15]
            ),
            listen(
              div4,
              "mouseup",
              /*handleHue*/
              ctx[12]
            ),
            listen(
              div4,
              "mouseleave",
              /*handleHue*/
              ctx[12]
            ),
            listen(
              input,
              "input",
              /*input_input_handler*/
              ctx[17]
            ),
            listen(
              input,
              "change",
              /*change_handler*/
              ctx[18]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (
          /*description*/
          ctx2[2].length > 0
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_1$l(ctx2);
            if_block0.c();
            if_block0.m(div5, t3);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        if (dirty & /*value*/
        32) {
          set_style(div1, "top", "calc(100% - " + /*value*/
          ctx2[5] + "% - .5rem)");
        }
        if (dirty & /*saturation*/
        16) {
          set_style(div1, "left", "calc(" + /*saturation*/
          ctx2[4] + "% - .5rem)");
        }
        if (dirty & /*listenSV*/
        256) {
          toggle_class(
            div1,
            "listen",
            /*listenSV*/
            ctx2[8]
          );
        }
        if (dirty & /*hue*/
        8) {
          set_style(div2, "background", "linear-gradient(to top, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0)), linear-gradient(to right, hsl(0, 0%, 100%), hsl(" + /*hue*/
          ctx2[3] + ", 100%, 50%))");
        }
        if (dirty & /*hue*/
        8) {
          set_style(div3, "left", "calc(" + /*hue*/
          ctx2[3] / 3.6 + "% - .5rem)");
        }
        if (dirty & /*listenHue*/
        512) {
          toggle_class(
            div3,
            "listen",
            /*listenHue*/
            ctx2[9]
          );
        }
        if (
          /*allowAlpha*/
          ctx2[1]
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
          } else {
            if_block1 = create_if_block$H(ctx2);
            if_block1.c();
            if_block1.m(div5, t6);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
        if (dirty & /*inputHex*/
        128 && input.value !== /*inputHex*/
        ctx2[7]) {
          set_input_value(
            input,
            /*inputHex*/
            ctx2[7]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div5);
        }
        if (if_block0) if_block0.d();
        if (if_block1) if_block1.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$1D, "create_fragment$1D");
  function instance$1t($$self, $$props, $$invalidate) {
    let { color = Color.fromHex("#45588d") } = $$props;
    let { allowAlpha = false } = $$props;
    let { description = "" } = $$props;
    let inputHex = color.hex;
    let hue;
    let saturation;
    let value;
    let alpha;
    let listenSV = false;
    const handleSV = /* @__PURE__ */ __name((event) => {
      if (!listenSV) return;
      $$invalidate(8, listenSV = false);
      const rect = event.target.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      $$invalidate(4, saturation = Math.min(100, Math.max(0, x / rect.width * 100)));
      $$invalidate(5, value = Math.min(100, Math.max(0, 100 - y / rect.height * 100)));
      $$invalidate(0, color = Color.fromHsv(hue, saturation, value, alpha));
      $$invalidate(7, inputHex = color.hex);
    }, "handleSV");
    let listenHue = false;
    const handleHue = /* @__PURE__ */ __name((event) => {
      if (!listenHue) return;
      $$invalidate(9, listenHue = false);
      const rect = event.target.getBoundingClientRect();
      const x = event.clientX - rect.left;
      $$invalidate(3, hue = Math.min(359, Math.max(0, x / rect.width * 360)));
      $$invalidate(0, color = Color.fromHsv(hue, saturation, value, alpha));
      $$invalidate(7, inputHex = color.hex);
    }, "handleHue");
    let listenAlpha = false;
    const handleAlpha = /* @__PURE__ */ __name((event) => {
      if (!listenAlpha || !allowAlpha) return;
      $$invalidate(10, listenAlpha = false);
      const rect = event.target.getBoundingClientRect();
      const x = event.clientX - rect.left;
      $$invalidate(6, alpha = Math.min(100, Math.max(0, x / rect.width)));
      $$invalidate(0, color = Color.fromHsv(hue, saturation, value, alpha));
      $$invalidate(7, inputHex = color.hex);
    }, "handleAlpha");
    const mousedown_handler = /* @__PURE__ */ __name(() => $$invalidate(8, listenSV = true), "mousedown_handler");
    const mousedown_handler_1 = /* @__PURE__ */ __name(() => $$invalidate(9, listenHue = true), "mousedown_handler_1");
    const mousedown_handler_2 = /* @__PURE__ */ __name(() => $$invalidate(10, listenAlpha = true), "mousedown_handler_2");
    function input_input_handler() {
      inputHex = this.value;
      $$invalidate(7, inputHex);
    }
    __name(input_input_handler, "input_input_handler");
    const change_handler = /* @__PURE__ */ __name((event) => {
      $$invalidate(0, color = Color.fromHex(inputHex));
    }, "change_handler");
    $$self.$$set = ($$props2) => {
      if ("color" in $$props2) $$invalidate(0, color = $$props2.color);
      if ("allowAlpha" in $$props2) $$invalidate(1, allowAlpha = $$props2.allowAlpha);
      if ("description" in $$props2) $$invalidate(2, description = $$props2.description);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*color, hue, saturation, value, alpha, allowAlpha*/
      123) {
        {
          const newHex = color.hex;
          const oldHex = Color.fromHsv(hue, saturation, value, alpha).hex;
          console.log(newHex, oldHex);
          if (newHex !== oldHex) {
            const hsv = color.hsv;
            $$invalidate(3, hue = hsv[0] ?? 0);
            $$invalidate(4, saturation = hsv[1] ?? 100);
            $$invalidate(5, value = hsv[2] ?? 50);
            $$invalidate(6, alpha = allowAlpha ? hsv[3] : void 0);
          }
        }
      }
    };
    return [
      color,
      allowAlpha,
      description,
      hue,
      saturation,
      value,
      alpha,
      inputHex,
      listenSV,
      listenHue,
      listenAlpha,
      handleSV,
      handleHue,
      handleAlpha,
      mousedown_handler,
      mousedown_handler_1,
      mousedown_handler_2,
      input_input_handler,
      change_handler
    ];
  }
  __name(instance$1t, "instance$1t");
  const _Color_picker = class _Color_picker extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1t, create_fragment$1D, safe_not_equal, { color: 0, allowAlpha: 1, description: 2 });
    }
  };
  __name(_Color_picker, "Color_picker");
  let Color_picker = _Color_picker;
  function create_if_block$G(ctx) {
    let div;
    let colorpicker;
    let updating_color;
    let current;
    let mounted;
    let dispose;
    function colorpicker_color_binding(value) {
      ctx[10](value);
    }
    __name(colorpicker_color_binding, "colorpicker_color_binding");
    let colorpicker_props = {
      allowAlpha: (
        /*allowAlpha*/
        ctx[1]
      ),
      description: (
        /*description*/
        ctx[5]
      )
    };
    if (
      /*color*/
      ctx[0] !== void 0
    ) {
      colorpicker_props.color = /*color*/
      ctx[0];
    }
    colorpicker = new Color_picker({ props: colorpicker_props });
    binding_callbacks.push(() => bind(colorpicker, "color", colorpicker_color_binding));
    return {
      c() {
        div = element("div");
        create_component(colorpicker.$$.fragment);
        attr(div, "class", "color-picker-popout svelte-1bdf7g");
        set_style(
          div,
          "top",
          /*popupPosition*/
          ctx[6].top
        );
        set_style(
          div,
          "left",
          /*popupPosition*/
          ctx[6].left
        );
        set_style(
          div,
          "right",
          /*popupPosition*/
          ctx[6].right
        );
        set_style(
          div,
          "bottom",
          /*popupPosition*/
          ctx[6].bottom
        );
        set_style(
          div,
          "transform-origin",
          /*popupPosition*/
          ctx[6].transformOrigin
        );
        toggle_class(
          div,
          "closing",
          /*closing*/
          ctx[7]
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(colorpicker, div, null);
        current = true;
        if (!mounted) {
          dispose = listen(div, "click", click_handler);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        const colorpicker_changes = {};
        if (dirty & /*allowAlpha*/
        2) colorpicker_changes.allowAlpha = /*allowAlpha*/
        ctx2[1];
        if (dirty & /*description*/
        32) colorpicker_changes.description = /*description*/
        ctx2[5];
        if (!updating_color && dirty & /*color*/
        1) {
          updating_color = true;
          colorpicker_changes.color = /*color*/
          ctx2[0];
          add_flush_callback(() => updating_color = false);
        }
        colorpicker.$set(colorpicker_changes);
        if (!current || dirty & /*popupPosition*/
        64) {
          set_style(
            div,
            "top",
            /*popupPosition*/
            ctx2[6].top
          );
        }
        if (!current || dirty & /*popupPosition*/
        64) {
          set_style(
            div,
            "left",
            /*popupPosition*/
            ctx2[6].left
          );
        }
        if (!current || dirty & /*popupPosition*/
        64) {
          set_style(
            div,
            "right",
            /*popupPosition*/
            ctx2[6].right
          );
        }
        if (!current || dirty & /*popupPosition*/
        64) {
          set_style(
            div,
            "bottom",
            /*popupPosition*/
            ctx2[6].bottom
          );
        }
        if (!current || dirty & /*popupPosition*/
        64) {
          set_style(
            div,
            "transform-origin",
            /*popupPosition*/
            ctx2[6].transformOrigin
          );
        }
        if (!current || dirty & /*closing*/
        128) {
          toggle_class(
            div,
            "closing",
            /*closing*/
            ctx2[7]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(colorpicker.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(colorpicker.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(colorpicker);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block$G, "create_if_block$G");
  function create_fragment$1C(ctx) {
    let div1;
    let div0;
    let t;
    let div1_data_rgb_value;
    let current;
    let mounted;
    let dispose;
    let if_block = (
      /*popupPosition*/
      ctx[6] && create_if_block$G(ctx)
    );
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        t = space();
        if (if_block) if_block.c();
        attr(div0, "class", "color-picker-button-content svelte-1bdf7g");
        set_style(
          div0,
          "background-color",
          /*useBackground*/
          ctx[2] ? (
            /*color*/
            ctx[0].hex
          ) : void 0
        );
        set_style(
          div0,
          "border-radius",
          /*borderRadius*/
          ctx[4]
        );
        attr(div1, "class", "typo-color-picker-button svelte-1bdf7g");
        set_style(
          div1,
          "height",
          /*height*/
          ctx[3]
        );
        attr(div1, "data-rgb", div1_data_rgb_value = /*color*/
        ctx[0].rgbString);
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div1, t);
        if (if_block) if_block.m(div1, null);
        current = true;
        if (!mounted) {
          dispose = listen(
            div1,
            "click",
            /*openPopup*/
            ctx[8]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (!current || dirty & /*useBackground, color*/
        5) {
          set_style(
            div0,
            "background-color",
            /*useBackground*/
            ctx2[2] ? (
              /*color*/
              ctx2[0].hex
            ) : void 0
          );
        }
        if (!current || dirty & /*borderRadius*/
        16) {
          set_style(
            div0,
            "border-radius",
            /*borderRadius*/
            ctx2[4]
          );
        }
        if (
          /*popupPosition*/
          ctx2[6]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & /*popupPosition*/
            64) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block$G(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(div1, null);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
        if (!current || dirty & /*height*/
        8) {
          set_style(
            div1,
            "height",
            /*height*/
            ctx2[3]
          );
        }
        if (!current || dirty & /*color*/
        1 && div1_data_rgb_value !== (div1_data_rgb_value = /*color*/
        ctx2[0].rgbString)) {
          attr(div1, "data-rgb", div1_data_rgb_value);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if (if_block) if_block.d();
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$1C, "create_fragment$1C");
  const click_handler = /* @__PURE__ */ __name((e) => e.stopImmediatePropagation(), "click_handler");
  function instance$1s($$self, $$props, $$invalidate) {
    let { color = Color.fromHex("#45588d") } = $$props;
    let { allowAlpha = false } = $$props;
    let { useBackground = true } = $$props;
    let { height = "2rem" } = $$props;
    let { borderRadius = "3px" } = $$props;
    let { colorChanged = void 0 } = $$props;
    let { description = "" } = $$props;
    let popupPosition = void 0;
    let closing = false;
    const openPopup = /* @__PURE__ */ __name((event) => {
      $$invalidate(7, closing = false);
      const anchor = event.target;
      const rect = anchor.getBoundingClientRect();
      const handler = /* @__PURE__ */ __name((e) => {
        if (e.target === anchor) return;
        document.removeEventListener("click", handler);
        colorChanged == null ? void 0 : colorChanged(color);
        $$invalidate(7, closing = true);
        setTimeout(
          () => {
            $$invalidate(6, popupPosition = void 0);
          },
          150
        );
      }, "handler");
      document.addEventListener("click", handler);
      let left, right, bottom, top;
      let transformOrigin;
      if (rect.x > window.innerWidth / 2) {
        right = `0`;
      } else {
        left = `0`;
      }
      if (rect.y > window.innerHeight / 2) {
        bottom = `0`;
        transformOrigin = "bottom";
      } else {
        top = `0`;
        transformOrigin = "top";
      }
      $$invalidate(6, popupPosition = {
        top,
        left,
        right,
        bottom,
        transformOrigin
      });
    }, "openPopup");
    function colorpicker_color_binding(value) {
      color = value;
      $$invalidate(0, color);
    }
    __name(colorpicker_color_binding, "colorpicker_color_binding");
    $$self.$$set = ($$props2) => {
      if ("color" in $$props2) $$invalidate(0, color = $$props2.color);
      if ("allowAlpha" in $$props2) $$invalidate(1, allowAlpha = $$props2.allowAlpha);
      if ("useBackground" in $$props2) $$invalidate(2, useBackground = $$props2.useBackground);
      if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
      if ("borderRadius" in $$props2) $$invalidate(4, borderRadius = $$props2.borderRadius);
      if ("colorChanged" in $$props2) $$invalidate(9, colorChanged = $$props2.colorChanged);
      if ("description" in $$props2) $$invalidate(5, description = $$props2.description);
    };
    return [
      color,
      allowAlpha,
      useBackground,
      height,
      borderRadius,
      description,
      popupPosition,
      closing,
      openPopup,
      colorChanged,
      colorpicker_color_binding
    ];
  }
  __name(instance$1s, "instance$1s");
  const _Color_picker_button = class _Color_picker_button extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1s, create_fragment$1C, safe_not_equal, {
        color: 0,
        allowAlpha: 1,
        useBackground: 2,
        height: 3,
        borderRadius: 4,
        colorChanged: 9,
        description: 5
      });
    }
  };
  __name(_Color_picker_button, "Color_picker_button");
  let Color_picker_button = _Color_picker_button;
  function create_if_block$F(ctx) {
    let div2;
    let b;
    let t0_value = (
      /*setting*/
      ctx[0].name + ""
    );
    let t0;
    let t1;
    let div0;
    let t2_value = (
      /*setting*/
      ctx[0].description + ""
    );
    let t2;
    let t3;
    let div1;
    let colorpickerbutton;
    let updating_color;
    let current;
    function colorpickerbutton_color_binding(value) {
      ctx[3](value);
    }
    __name(colorpickerbutton_color_binding, "colorpickerbutton_color_binding");
    let colorpickerbutton_props = {};
    if (
      /*color*/
      ctx[1] !== void 0
    ) {
      colorpickerbutton_props.color = /*color*/
      ctx[1];
    }
    colorpickerbutton = new Color_picker_button({ props: colorpickerbutton_props });
    binding_callbacks.push(() => bind(colorpickerbutton, "color", colorpickerbutton_color_binding));
    return {
      c() {
        div2 = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = space();
        div0 = element("div");
        t2 = text(t2_value);
        t3 = space();
        div1 = element("div");
        create_component(colorpickerbutton.$$.fragment);
        attr(b, "class", "svelte-1pjx4sn");
        attr(div2, "class", "typo-text-setting svelte-1pjx4sn");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, b);
        append(b, t0);
        append(div2, t1);
        append(div2, div0);
        append(div0, t2);
        append(div2, t3);
        append(div2, div1);
        mount_component(colorpickerbutton, div1, null);
        current = true;
      },
      p(ctx2, dirty) {
        if ((!current || dirty & /*setting*/
        1) && t0_value !== (t0_value = /*setting*/
        ctx2[0].name + "")) set_data(t0, t0_value);
        if ((!current || dirty & /*setting*/
        1) && t2_value !== (t2_value = /*setting*/
        ctx2[0].description + "")) set_data(t2, t2_value);
        const colorpickerbutton_changes = {};
        if (!updating_color && dirty & /*color*/
        2) {
          updating_color = true;
          colorpickerbutton_changes.color = /*color*/
          ctx2[1];
          add_flush_callback(() => updating_color = false);
        }
        colorpickerbutton.$set(colorpickerbutton_changes);
      },
      i(local) {
        if (current) return;
        transition_in(colorpickerbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(colorpickerbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        destroy_component(colorpickerbutton);
      }
    };
  }
  __name(create_if_block$F, "create_if_block$F");
  function create_fragment$1B(ctx) {
    let if_block_anchor;
    let current;
    let if_block = (
      /*settingStore*/
      ctx[2] && create_if_block$F(ctx)
    );
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (
          /*settingStore*/
          ctx2[2]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & /*settingStore*/
            4) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block$F(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
      }
    };
  }
  __name(create_fragment$1B, "create_fragment$1B");
  function instance$1r($$self, $$props, $$invalidate) {
    let $settingStore, $$unsubscribe_settingStore = noop, $$subscribe_settingStore = /* @__PURE__ */ __name(() => ($$unsubscribe_settingStore(), $$unsubscribe_settingStore = subscribe(settingStore, ($$value) => $$invalidate(4, $settingStore = $$value)), settingStore), "$$subscribe_settingStore");
    $$self.$$.on_destroy.push(() => $$unsubscribe_settingStore());
    let { setting } = $$props;
    let settingStore;
    let color;
    onMount(async () => {
      $$invalidate(1, color = Color.fromHex(await setting.getValue()));
    });
    function colorpickerbutton_color_binding(value) {
      color = value;
      $$invalidate(1, color);
    }
    __name(colorpickerbutton_color_binding, "colorpickerbutton_color_binding");
    $$self.$$set = ($$props2) => {
      if ("setting" in $$props2) $$invalidate(0, setting = $$props2.setting);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*setting*/
      1) {
        {
          $$subscribe_settingStore($$invalidate(2, settingStore = setting.store));
        }
      }
      if ($$self.$$.dirty & /*color*/
      2) {
        {
          if (color) {
            set_store_value(settingStore, $settingStore = color.hex, $settingStore);
          }
        }
      }
    };
    return [setting, color, settingStore, colorpickerbutton_color_binding];
  }
  __name(instance$1r, "instance$1r");
  const _Color_hex_setting_input = class _Color_hex_setting_input extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1r, create_fragment$1B, safe_not_equal, { setting: 0 });
    }
  };
  __name(_Color_hex_setting_input, "Color_hex_setting_input");
  let Color_hex_setting_input = _Color_hex_setting_input;
  const _ExtensionSetting = class _ExtensionSetting {
    constructor(key2, defaultValue, feature) {
      __publicField(this, "_name");
      __publicField(this, "_description");
      __publicField(this, "_changes", new BehaviorSubject(null));
      this.key = key2;
      this.defaultValue = defaultValue;
      this.feature = feature;
      this.feature = feature;
    }
    get globalKey() {
      const sanitized = this.key.replace(/[^a-zA-Z0-9.]/g, "_");
      return this.feature ? `feature_${this.feature.featureId}.${sanitized}` : `global.${sanitized}`;
    }
    async getValue() {
      const string = await typoRuntime.getSetting(this.globalKey);
      if (string === void 0 || string === null) return this.defaultValue;
      const value = JSON.parse(string);
      this._changes.next(value);
      return value;
    }
    async setValue(value) {
      const json = JSON.stringify(value);
      await typoRuntime.writeSetting(this.globalKey, json);
      this._changes.next(value);
    }
    get name() {
      return this._name;
    }
    get description() {
      return this._description;
    }
    setDefaultValue(value) {
      this.defaultValue = value;
    }
    withName(name) {
      this._name = name;
      return this;
    }
    withDescription(description) {
      this._description = description;
      return this;
    }
    get changes$() {
      return this._changes.pipe(
        switchMap((data) => data === null ? from(this.getValue()) : of(data))
      );
    }
    get store() {
      return fromObservable(this.changes$, this.defaultValue, (value) => this.setValue(value), false);
    }
    get asFrozen() {
      return this;
    }
  };
  __name(_ExtensionSetting, "ExtensionSetting");
  let ExtensionSetting = _ExtensionSetting;
  const _SettingWithInput = class _SettingWithInput extends ExtensionSetting {
  };
  __name(_SettingWithInput, "SettingWithInput");
  let SettingWithInput = _SettingWithInput;
  const _BooleanExtensionSetting = class _BooleanExtensionSetting extends SettingWithInput {
    get componentData() {
      return {
        componentType: Boolean_setting_input,
        props: { setting: this }
      };
    }
  };
  __name(_BooleanExtensionSetting, "BooleanExtensionSetting");
  let BooleanExtensionSetting = _BooleanExtensionSetting;
  const _TextExtensionSetting = class _TextExtensionSetting extends SettingWithInput {
    get componentData() {
      return {
        componentType: Text_setting_input,
        props: { setting: this }
      };
    }
  };
  __name(_TextExtensionSetting, "TextExtensionSetting");
  let TextExtensionSetting = _TextExtensionSetting;
  const _HexColorExtensionSetting = class _HexColorExtensionSetting extends SettingWithInput {
    get componentData() {
      return {
        componentType: Color_hex_setting_input,
        props: { setting: this }
      };
    }
  };
  __name(_HexColorExtensionSetting, "HexColorExtensionSetting");
  let HexColorExtensionSetting = _HexColorExtensionSetting;
  const _NumericExtensionSetting = class _NumericExtensionSetting extends SettingWithInput {
    constructor() {
      super(...arguments);
      __publicField(this, "_min");
      __publicField(this, "_max");
      __publicField(this, "_sliderWithSteps");
    }
    get componentData() {
      return {
        componentType: Numeric_setting_input,
        props: {
          setting: this,
          withSliderAndSteps: this._sliderWithSteps,
          bounds: this._min !== void 0 && this._max !== void 0 ? { min: this._min, max: this._max } : void 0
        }
      };
    }
    withBounds(min, max) {
      this._min = min;
      this._max = max;
      return this;
    }
    withSlider(steps = 1) {
      this._sliderWithSteps = steps;
      return this;
    }
  };
  __name(_NumericExtensionSetting, "NumericExtensionSetting");
  let NumericExtensionSetting = _NumericExtensionSetting;
  const _ChoiceExtensionSetting = class _ChoiceExtensionSetting extends SettingWithInput {
    constructor() {
      super(...arguments);
      __publicField(this, "_choices", []);
    }
    get componentData() {
      return {
        componentType: Choice_setting_input,
        props: {
          setting: this,
          choices: this._choices
        }
      };
    }
    withChoices(choices) {
      this._choices = choices;
      return this;
    }
  };
  __name(_ChoiceExtensionSetting, "ChoiceExtensionSetting");
  let ChoiceExtensionSetting = _ChoiceExtensionSetting;
  var NAMED_TAG = "named";
  var NAME_TAG = "name";
  var UNMANAGED_TAG = "unmanaged";
  var OPTIONAL_TAG = "optional";
  var INJECT_TAG = "inject";
  var MULTI_INJECT_TAG = "multi_inject";
  var TAGGED = "inversify:tagged";
  var TAGGED_PROP = "inversify:tagged_props";
  var PARAM_TYPES = "inversify:paramtypes";
  var DESIGN_PARAM_TYPES = "design:paramtypes";
  var POST_CONSTRUCT = "post_construct";
  var PRE_DESTROY = "pre_destroy";
  function getNonCustomTagKeys() {
    return [
      INJECT_TAG,
      MULTI_INJECT_TAG,
      NAME_TAG,
      UNMANAGED_TAG,
      NAMED_TAG,
      OPTIONAL_TAG
    ];
  }
  __name(getNonCustomTagKeys, "getNonCustomTagKeys");
  var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();
  var BindingScopeEnum = {
    Request: "Request",
    Singleton: "Singleton",
    Transient: "Transient"
  };
  var BindingTypeEnum = {
    ConstantValue: "ConstantValue",
    Constructor: "Constructor",
    DynamicValue: "DynamicValue",
    Factory: "Factory",
    Function: "Function",
    Instance: "Instance",
    Invalid: "Invalid",
    Provider: "Provider"
  };
  var TargetTypeEnum = {
    ClassProperty: "ClassProperty",
    ConstructorArgument: "ConstructorArgument",
    Variable: "Variable"
  };
  var idCounter = 0;
  function id() {
    return idCounter++;
  }
  __name(id, "id");
  var Binding = function() {
    function Binding2(serviceIdentifier, scope) {
      this.id = id();
      this.activated = false;
      this.serviceIdentifier = serviceIdentifier;
      this.scope = scope;
      this.type = BindingTypeEnum.Invalid;
      this.constraint = function(request) {
        return true;
      };
      this.implementationType = null;
      this.cache = null;
      this.factory = null;
      this.provider = null;
      this.onActivation = null;
      this.onDeactivation = null;
      this.dynamicValue = null;
    }
    __name(Binding2, "Binding");
    Binding2.prototype.clone = function() {
      var clone = new Binding2(this.serviceIdentifier, this.scope);
      clone.activated = clone.scope === BindingScopeEnum.Singleton ? this.activated : false;
      clone.implementationType = this.implementationType;
      clone.dynamicValue = this.dynamicValue;
      clone.scope = this.scope;
      clone.type = this.type;
      clone.factory = this.factory;
      clone.provider = this.provider;
      clone.constraint = this.constraint;
      clone.onActivation = this.onActivation;
      clone.onDeactivation = this.onDeactivation;
      clone.cache = this.cache;
      return clone;
    };
    return Binding2;
  }();
  var DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
  var DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
  var NULL_ARGUMENT = "NULL argument";
  var KEY_NOT_FOUND = "Key Not Found";
  var AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
  var CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
  var NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
  var MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:";
  var MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:";
  var UNDEFINED_INJECT_ANNOTATION = /* @__PURE__ */ __name(function(name) {
    return "@inject called with undefined this could mean that the class " + name + " has a circular dependency problem. You can use a LazyServiceIdentifier to  overcome this limitation.";
  }, "UNDEFINED_INJECT_ANNOTATION");
  var CIRCULAR_DEPENDENCY = "Circular dependency found:";
  var INVALID_BINDING_TYPE = "Invalid binding type:";
  var NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
  var INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
  var INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
  var LAZY_IN_SYNC = /* @__PURE__ */ __name(function(key2) {
    return "You are attempting to construct '" + key2 + "' in a synchronous way\n but it has asynchronous dependencies.";
  }, "LAZY_IN_SYNC");
  var INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is used as service identifier";
  var INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
  var ARGUMENTS_LENGTH_MISMATCH = /* @__PURE__ */ __name(function() {
    var values = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      values[_i2] = arguments[_i2];
    }
    return "The number of constructor arguments in the derived class " + (values[0] + " must be >= than the number of constructor arguments of its base class.");
  }, "ARGUMENTS_LENGTH_MISMATCH");
  var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options must be an object.";
  var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must be a string ("singleton" or "transient").';
  var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must be a boolean";
  var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must be a boolean";
  var MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";
  var ASYNC_UNBIND_REQUIRED = "Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)";
  var POST_CONSTRUCT_ERROR = /* @__PURE__ */ __name(function(clazz, errorMessage) {
    return "@postConstruct error in class " + clazz + ": " + errorMessage;
  }, "POST_CONSTRUCT_ERROR");
  var PRE_DESTROY_ERROR = /* @__PURE__ */ __name(function(clazz, errorMessage) {
    return "@preDestroy error in class " + clazz + ": " + errorMessage;
  }, "PRE_DESTROY_ERROR");
  var ON_DEACTIVATION_ERROR = /* @__PURE__ */ __name(function(clazz, errorMessage) {
    return "onDeactivation() error in class " + clazz + ": " + errorMessage;
  }, "ON_DEACTIVATION_ERROR");
  var CIRCULAR_DEPENDENCY_IN_FACTORY = /* @__PURE__ */ __name(function(factoryType, serviceIdentifier) {
    return "It looks like there is a circular dependency in one of the '" + factoryType + "' bindings. Please investigate bindings with " + ("service identifier '" + serviceIdentifier + "'.");
  }, "CIRCULAR_DEPENDENCY_IN_FACTORY");
  var STACK_OVERFLOW = "Maximum call stack size exceeded";
  var MetadataReader = function() {
    function MetadataReader2() {
    }
    __name(MetadataReader2, "MetadataReader");
    MetadataReader2.prototype.getConstructorMetadata = function(constructorFunc) {
      var compilerGeneratedMetadata = Reflect.getMetadata(PARAM_TYPES, constructorFunc);
      var userGeneratedMetadata = Reflect.getMetadata(TAGGED, constructorFunc);
      return {
        compilerGeneratedMetadata,
        userGeneratedMetadata: userGeneratedMetadata || {}
      };
    };
    MetadataReader2.prototype.getPropertiesMetadata = function(constructorFunc) {
      var userGeneratedMetadata = Reflect.getMetadata(TAGGED_PROP, constructorFunc) || [];
      return userGeneratedMetadata;
    };
    return MetadataReader2;
  }();
  var BindingCount = {
    MultipleBindingsAvailable: 2,
    NoBindingsAvailable: 0,
    OnlyOneBindingAvailable: 1
  };
  function isStackOverflowExeption(error) {
    return error instanceof RangeError || error.message === STACK_OVERFLOW;
  }
  __name(isStackOverflowExeption, "isStackOverflowExeption");
  var tryAndThrowErrorIfStackOverflow = /* @__PURE__ */ __name(function(fn, errorCallback) {
    try {
      return fn();
    } catch (error) {
      if (isStackOverflowExeption(error)) {
        error = errorCallback();
      }
      throw error;
    }
  }, "tryAndThrowErrorIfStackOverflow");
  function getServiceIdentifierAsString(serviceIdentifier) {
    if (typeof serviceIdentifier === "function") {
      var _serviceIdentifier = serviceIdentifier;
      return _serviceIdentifier.name;
    } else if (typeof serviceIdentifier === "symbol") {
      return serviceIdentifier.toString();
    } else {
      var _serviceIdentifier = serviceIdentifier;
      return _serviceIdentifier;
    }
  }
  __name(getServiceIdentifierAsString, "getServiceIdentifierAsString");
  function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings2) {
    var registeredBindingsList = "";
    var registeredBindings = getBindings2(container, serviceIdentifier);
    if (registeredBindings.length !== 0) {
      registeredBindingsList = "\nRegistered bindings:";
      registeredBindings.forEach(function(binding) {
        var name = "Object";
        if (binding.implementationType !== null) {
          name = getFunctionName(binding.implementationType);
        }
        registeredBindingsList = registeredBindingsList + "\n " + name;
        if (binding.constraint.metaData) {
          registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
        }
      });
    }
    return registeredBindingsList;
  }
  __name(listRegisteredBindingsForServiceIdentifier, "listRegisteredBindingsForServiceIdentifier");
  function alreadyDependencyChain(request, serviceIdentifier) {
    if (request.parentRequest === null) {
      return false;
    } else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
      return true;
    } else {
      return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
    }
  }
  __name(alreadyDependencyChain, "alreadyDependencyChain");
  function dependencyChainToString(request) {
    function _createStringArr(req, result) {
      if (result === void 0) {
        result = [];
      }
      var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
      result.push(serviceIdentifier);
      if (req.parentRequest !== null) {
        return _createStringArr(req.parentRequest, result);
      }
      return result;
    }
    __name(_createStringArr, "_createStringArr");
    var stringArr = _createStringArr(request);
    return stringArr.reverse().join(" --> ");
  }
  __name(dependencyChainToString, "dependencyChainToString");
  function circularDependencyToException(request) {
    request.childRequests.forEach(function(childRequest) {
      if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
        var services = dependencyChainToString(childRequest);
        throw new Error(CIRCULAR_DEPENDENCY + " " + services);
      } else {
        circularDependencyToException(childRequest);
      }
    });
  }
  __name(circularDependencyToException, "circularDependencyToException");
  function listMetadataForTarget(serviceIdentifierString, target) {
    if (target.isTagged() || target.isNamed()) {
      var m_1 = "";
      var namedTag = target.getNamedTag();
      var otherTags = target.getCustomTags();
      if (namedTag !== null) {
        m_1 += namedTag.toString() + "\n";
      }
      if (otherTags !== null) {
        otherTags.forEach(function(tag) {
          m_1 += tag.toString() + "\n";
        });
      }
      return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
    } else {
      return " " + serviceIdentifierString;
    }
  }
  __name(listMetadataForTarget, "listMetadataForTarget");
  function getFunctionName(func2) {
    if (func2.name) {
      return func2.name;
    } else {
      var name_1 = func2.toString();
      var match = name_1.match(/^function\s*([^\s(]+)/);
      return match ? match[1] : "Anonymous function: " + name_1;
    }
  }
  __name(getFunctionName, "getFunctionName");
  function getSymbolDescription(symbol) {
    return symbol.toString().slice(7, -1);
  }
  __name(getSymbolDescription, "getSymbolDescription");
  var Context = function() {
    function Context2(container) {
      this.id = id();
      this.container = container;
    }
    __name(Context2, "Context");
    Context2.prototype.addPlan = function(plan2) {
      this.plan = plan2;
    };
    Context2.prototype.setCurrentRequest = function(currentRequest) {
      this.currentRequest = currentRequest;
    };
    return Context2;
  }();
  var Metadata = function() {
    function Metadata2(key2, value) {
      this.key = key2;
      this.value = value;
    }
    __name(Metadata2, "Metadata");
    Metadata2.prototype.toString = function() {
      if (this.key === NAMED_TAG) {
        return "named: " + String(this.value).toString() + " ";
      } else {
        return "tagged: { key:" + this.key.toString() + ", value: " + String(this.value) + " }";
      }
    };
    return Metadata2;
  }();
  var Plan = /* @__PURE__ */ function() {
    function Plan2(parentContext, rootRequest) {
      this.parentContext = parentContext;
      this.rootRequest = rootRequest;
    }
    __name(Plan2, "Plan");
    return Plan2;
  }();
  var LazyServiceIdentifier = function() {
    function LazyServiceIdentifier2(cb) {
      this._cb = cb;
    }
    __name(LazyServiceIdentifier2, "LazyServiceIdentifier");
    LazyServiceIdentifier2.prototype.unwrap = function() {
      return this._cb();
    };
    return LazyServiceIdentifier2;
  }();
  var QueryableString = function() {
    function QueryableString2(str) {
      this.str = str;
    }
    __name(QueryableString2, "QueryableString");
    QueryableString2.prototype.startsWith = function(searchString) {
      return this.str.indexOf(searchString) === 0;
    };
    QueryableString2.prototype.endsWith = function(searchString) {
      var reverseString = "";
      var reverseSearchString = searchString.split("").reverse().join("");
      reverseString = this.str.split("").reverse().join("");
      return this.startsWith.call({ str: reverseString }, reverseSearchString);
    };
    QueryableString2.prototype.contains = function(searchString) {
      return this.str.indexOf(searchString) !== -1;
    };
    QueryableString2.prototype.equals = function(compareString) {
      return this.str === compareString;
    };
    QueryableString2.prototype.value = function() {
      return this.str;
    };
    return QueryableString2;
  }();
  var Target = function() {
    function Target2(type, identifier, serviceIdentifier, namedOrTagged) {
      this.id = id();
      this.type = type;
      this.serviceIdentifier = serviceIdentifier;
      var queryableName = typeof identifier === "symbol" ? getSymbolDescription(identifier) : identifier;
      this.name = new QueryableString(queryableName || "");
      this.identifier = identifier;
      this.metadata = new Array();
      var metadataItem = null;
      if (typeof namedOrTagged === "string") {
        metadataItem = new Metadata(NAMED_TAG, namedOrTagged);
      } else if (namedOrTagged instanceof Metadata) {
        metadataItem = namedOrTagged;
      }
      if (metadataItem !== null) {
        this.metadata.push(metadataItem);
      }
    }
    __name(Target2, "Target");
    Target2.prototype.hasTag = function(key2) {
      for (var _i2 = 0, _a2 = this.metadata; _i2 < _a2.length; _i2++) {
        var m = _a2[_i2];
        if (m.key === key2) {
          return true;
        }
      }
      return false;
    };
    Target2.prototype.isArray = function() {
      return this.hasTag(MULTI_INJECT_TAG);
    };
    Target2.prototype.matchesArray = function(name) {
      return this.matchesTag(MULTI_INJECT_TAG)(name);
    };
    Target2.prototype.isNamed = function() {
      return this.hasTag(NAMED_TAG);
    };
    Target2.prototype.isTagged = function() {
      return this.metadata.some(function(metadata2) {
        return NON_CUSTOM_TAG_KEYS.every(function(key2) {
          return metadata2.key !== key2;
        });
      });
    };
    Target2.prototype.isOptional = function() {
      return this.matchesTag(OPTIONAL_TAG)(true);
    };
    Target2.prototype.getNamedTag = function() {
      if (this.isNamed()) {
        return this.metadata.filter(function(m) {
          return m.key === NAMED_TAG;
        })[0];
      }
      return null;
    };
    Target2.prototype.getCustomTags = function() {
      if (this.isTagged()) {
        return this.metadata.filter(function(metadata2) {
          return NON_CUSTOM_TAG_KEYS.every(function(key2) {
            return metadata2.key !== key2;
          });
        });
      } else {
        return null;
      }
    };
    Target2.prototype.matchesNamedTag = function(name) {
      return this.matchesTag(NAMED_TAG)(name);
    };
    Target2.prototype.matchesTag = function(key2) {
      var _this = this;
      return function(value) {
        for (var _i2 = 0, _a2 = _this.metadata; _i2 < _a2.length; _i2++) {
          var m = _a2[_i2];
          if (m.key === key2 && m.value === value) {
            return true;
          }
        }
        return false;
      };
    };
    return Target2;
  }();
  var __spreadArray$2 = function(to, from2, pack) {
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  };
  function getDependencies(metadataReader, func2) {
    var constructorName = getFunctionName(func2);
    return getTargets(metadataReader, constructorName, func2, false);
  }
  __name(getDependencies, "getDependencies");
  function getTargets(metadataReader, constructorName, func2, isBaseClass) {
    var metadata2 = metadataReader.getConstructorMetadata(func2);
    var serviceIdentifiers = metadata2.compilerGeneratedMetadata;
    if (serviceIdentifiers === void 0) {
      var msg = MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
      throw new Error(msg);
    }
    var constructorArgsMetadata = metadata2.userGeneratedMetadata;
    var keys = Object.keys(constructorArgsMetadata);
    var hasUserDeclaredUnknownInjections = func2.length === 0 && keys.length > 0;
    var hasOptionalParameters = keys.length > func2.length;
    var iterations = hasUserDeclaredUnknownInjections || hasOptionalParameters ? keys.length : func2.length;
    var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
    var propertyTargets = getClassPropsAsTargets(metadataReader, func2, constructorName);
    var targets = __spreadArray$2(__spreadArray$2([], constructorTargets, true), propertyTargets);
    return targets;
  }
  __name(getTargets, "getTargets");
  function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
    var targetMetadata = constructorArgsMetadata[index.toString()] || [];
    var metadata2 = formatTargetMetadata(targetMetadata);
    var isManaged = metadata2.unmanaged !== true;
    var serviceIdentifier = serviceIdentifiers[index];
    var injectIdentifier = metadata2.inject || metadata2.multiInject;
    serviceIdentifier = injectIdentifier ? injectIdentifier : serviceIdentifier;
    if (serviceIdentifier instanceof LazyServiceIdentifier) {
      serviceIdentifier = serviceIdentifier.unwrap();
    }
    if (isManaged) {
      var isObject = serviceIdentifier === Object;
      var isFunction2 = serviceIdentifier === Function;
      var isUndefined = serviceIdentifier === void 0;
      var isUnknownType = isObject || isFunction2 || isUndefined;
      if (!isBaseClass && isUnknownType) {
        var msg = MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".";
        throw new Error(msg);
      }
      var target = new Target(TargetTypeEnum.ConstructorArgument, metadata2.targetName, serviceIdentifier);
      target.metadata = targetMetadata;
      return target;
    }
    return null;
  }
  __name(getConstructorArgsAsTarget, "getConstructorArgsAsTarget");
  function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
    var targets = [];
    for (var i = 0; i < iterations; i++) {
      var index = i;
      var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
      if (target !== null) {
        targets.push(target);
      }
    }
    return targets;
  }
  __name(getConstructorArgsAsTargets, "getConstructorArgsAsTargets");
  function _getServiceIdentifierForProperty(inject2, multiInject, propertyName, className) {
    var serviceIdentifier = inject2 || multiInject;
    if (serviceIdentifier === void 0) {
      var msg = MISSING_INJECTABLE_ANNOTATION + " for property " + String(propertyName) + " in class " + className + ".";
      throw new Error(msg);
    }
    return serviceIdentifier;
  }
  __name(_getServiceIdentifierForProperty, "_getServiceIdentifierForProperty");
  function getClassPropsAsTargets(metadataReader, constructorFunc, constructorName) {
    var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
    var targets = [];
    var symbolKeys = Object.getOwnPropertySymbols(classPropsMetadata);
    var stringKeys = Object.keys(classPropsMetadata);
    var keys = stringKeys.concat(symbolKeys);
    for (var _i2 = 0, keys_1 = keys; _i2 < keys_1.length; _i2++) {
      var key2 = keys_1[_i2];
      var targetMetadata = classPropsMetadata[key2];
      var metadata2 = formatTargetMetadata(targetMetadata);
      var identifier = metadata2.targetName || key2;
      var serviceIdentifier = _getServiceIdentifierForProperty(metadata2.inject, metadata2.multiInject, key2, constructorName);
      var target = new Target(TargetTypeEnum.ClassProperty, identifier, serviceIdentifier);
      target.metadata = targetMetadata;
      targets.push(target);
    }
    var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
    if (baseConstructor !== Object) {
      var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor, constructorName);
      targets = __spreadArray$2(__spreadArray$2([], targets, true), baseTargets);
    }
    return targets;
  }
  __name(getClassPropsAsTargets, "getClassPropsAsTargets");
  function getBaseClassDependencyCount(metadataReader, func2) {
    var baseConstructor = Object.getPrototypeOf(func2.prototype).constructor;
    if (baseConstructor !== Object) {
      var baseConstructorName = getFunctionName(baseConstructor);
      var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
      var metadata2 = targets.map(function(t) {
        return t.metadata.filter(function(m) {
          return m.key === UNMANAGED_TAG;
        });
      });
      var unmanagedCount = [].concat.apply([], metadata2).length;
      var dependencyCount = targets.length - unmanagedCount;
      if (dependencyCount > 0) {
        return dependencyCount;
      } else {
        return getBaseClassDependencyCount(metadataReader, baseConstructor);
      }
    } else {
      return 0;
    }
  }
  __name(getBaseClassDependencyCount, "getBaseClassDependencyCount");
  function formatTargetMetadata(targetMetadata) {
    var targetMetadataMap = {};
    targetMetadata.forEach(function(m) {
      targetMetadataMap[m.key.toString()] = m.value;
    });
    return {
      inject: targetMetadataMap[INJECT_TAG],
      multiInject: targetMetadataMap[MULTI_INJECT_TAG],
      targetName: targetMetadataMap[NAME_TAG],
      unmanaged: targetMetadataMap[UNMANAGED_TAG]
    };
  }
  __name(formatTargetMetadata, "formatTargetMetadata");
  var Request = function() {
    function Request2(serviceIdentifier, parentContext, parentRequest, bindings, target) {
      this.id = id();
      this.serviceIdentifier = serviceIdentifier;
      this.parentContext = parentContext;
      this.parentRequest = parentRequest;
      this.target = target;
      this.childRequests = [];
      this.bindings = Array.isArray(bindings) ? bindings : [bindings];
      this.requestScope = parentRequest === null ? /* @__PURE__ */ new Map() : null;
    }
    __name(Request2, "Request");
    Request2.prototype.addChildRequest = function(serviceIdentifier, bindings, target) {
      var child = new Request2(serviceIdentifier, this.parentContext, this, bindings, target);
      this.childRequests.push(child);
      return child;
    };
    return Request2;
  }();
  function getBindingDictionary(cntnr) {
    return cntnr._bindingDictionary;
  }
  __name(getBindingDictionary, "getBindingDictionary");
  function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key2, value) {
    var metadataKey = isMultiInject ? MULTI_INJECT_TAG : INJECT_TAG;
    var injectMetadata = new Metadata(metadataKey, serviceIdentifier);
    var target = new Target(targetType, name, serviceIdentifier, injectMetadata);
    if (key2 !== void 0) {
      var tagMetadata = new Metadata(key2, value);
      target.metadata.push(tagMetadata);
    }
    return target;
  }
  __name(_createTarget, "_createTarget");
  function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
    var bindings = getBindings(context.container, target.serviceIdentifier);
    var activeBindings = [];
    if (bindings.length === BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable && typeof target.serviceIdentifier === "function" && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
      context.container.bind(target.serviceIdentifier).toSelf();
      bindings = getBindings(context.container, target.serviceIdentifier);
    }
    if (!avoidConstraints) {
      activeBindings = bindings.filter(function(binding) {
        var request = new Request(binding.serviceIdentifier, context, parentRequest, binding, target);
        return binding.constraint(request);
      });
    } else {
      activeBindings = bindings;
    }
    _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);
    return activeBindings;
  }
  __name(_getActiveBindings, "_getActiveBindings");
  function _validateActiveBindingCount(serviceIdentifier, bindings, target, container) {
    switch (bindings.length) {
      case BindingCount.NoBindingsAvailable:
        if (target.isOptional()) {
          return bindings;
        } else {
          var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier);
          var msg = NOT_REGISTERED;
          msg += listMetadataForTarget(serviceIdentifierString, target);
          msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
          throw new Error(msg);
        }
      case BindingCount.OnlyOneBindingAvailable:
        return bindings;
      case BindingCount.MultipleBindingsAvailable:
      default:
        if (!target.isArray()) {
          var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier);
          var msg = AMBIGUOUS_MATCH + " " + serviceIdentifierString;
          msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
          throw new Error(msg);
        } else {
          return bindings;
        }
    }
  }
  __name(_validateActiveBindingCount, "_validateActiveBindingCount");
  function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
    var activeBindings;
    var childRequest;
    if (parentRequest === null) {
      activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
      childRequest = new Request(serviceIdentifier, context, null, activeBindings, target);
      var thePlan = new Plan(context, childRequest);
      context.addPlan(thePlan);
    } else {
      activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
      childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
    }
    activeBindings.forEach(function(binding) {
      var subChildRequest = null;
      if (target.isArray()) {
        subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
      } else {
        if (binding.cache) {
          return;
        }
        subChildRequest = childRequest;
      }
      if (binding.type === BindingTypeEnum.Instance && binding.implementationType !== null) {
        var dependencies = getDependencies(metadataReader, binding.implementationType);
        if (!context.container.options.skipBaseClassChecks) {
          var baseClassDependencyCount = getBaseClassDependencyCount(metadataReader, binding.implementationType);
          if (dependencies.length < baseClassDependencyCount) {
            var error = ARGUMENTS_LENGTH_MISMATCH(getFunctionName(binding.implementationType));
            throw new Error(error);
          }
        }
        dependencies.forEach(function(dependency) {
          _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
        });
      }
    });
  }
  __name(_createSubRequests, "_createSubRequests");
  function getBindings(container, serviceIdentifier) {
    var bindings = [];
    var bindingDictionary = getBindingDictionary(container);
    if (bindingDictionary.hasKey(serviceIdentifier)) {
      bindings = bindingDictionary.get(serviceIdentifier);
    } else if (container.parent !== null) {
      bindings = getBindings(container.parent, serviceIdentifier);
    }
    return bindings;
  }
  __name(getBindings, "getBindings");
  function plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key2, value, avoidConstraints) {
    if (avoidConstraints === void 0) {
      avoidConstraints = false;
    }
    var context = new Context(container);
    var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key2, value);
    try {
      _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
      return context;
    } catch (error) {
      if (isStackOverflowExeption(error)) {
        circularDependencyToException(context.plan.rootRequest);
      }
      throw error;
    }
  }
  __name(plan, "plan");
  function createMockRequest(container, serviceIdentifier, key2, value) {
    var target = new Target(TargetTypeEnum.Variable, "", serviceIdentifier, new Metadata(key2, value));
    var context = new Context(container);
    var request = new Request(serviceIdentifier, context, null, [], target);
    return request;
  }
  __name(createMockRequest, "createMockRequest");
  function isPromise(object) {
    var isObjectOrFunction = typeof object === "object" && object !== null || typeof object === "function";
    return isObjectOrFunction && typeof object.then === "function";
  }
  __name(isPromise, "isPromise");
  function isPromiseOrContainsPromise(object) {
    if (isPromise(object)) {
      return true;
    }
    return Array.isArray(object) && object.some(isPromise);
  }
  __name(isPromiseOrContainsPromise, "isPromiseOrContainsPromise");
  var __awaiter$3 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    __name(adopt, "adopt");
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step");
      step((generator = generator.apply(thisArg, [])).next());
    });
  };
  var __generator$3 = function(thisArg, body) {
    var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, "sent"), trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var tryGetFromScope = /* @__PURE__ */ __name(function(requestScope, binding) {
    if (binding.scope === BindingScopeEnum.Singleton && binding.activated) {
      return binding.cache;
    }
    if (binding.scope === BindingScopeEnum.Request && requestScope.has(binding.id)) {
      return requestScope.get(binding.id);
    }
    return null;
  }, "tryGetFromScope");
  var saveToScope = /* @__PURE__ */ __name(function(requestScope, binding, result) {
    if (binding.scope === BindingScopeEnum.Singleton) {
      _saveToSingletonScope(binding, result);
    }
    if (binding.scope === BindingScopeEnum.Request) {
      _saveToRequestScope(requestScope, binding, result);
    }
  }, "saveToScope");
  var _saveToRequestScope = /* @__PURE__ */ __name(function(requestScope, binding, result) {
    if (!requestScope.has(binding.id)) {
      requestScope.set(binding.id, result);
    }
  }, "_saveToRequestScope");
  var _saveToSingletonScope = /* @__PURE__ */ __name(function(binding, result) {
    binding.cache = result;
    binding.activated = true;
    if (isPromise(result)) {
      void _saveAsyncResultToSingletonScope(binding, result);
    }
  }, "_saveToSingletonScope");
  var _saveAsyncResultToSingletonScope = /* @__PURE__ */ __name(function(binding, asyncResult) {
    return __awaiter$3(void 0, void 0, void 0, function() {
      var result, ex_1;
      return __generator$3(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, asyncResult];
          case 1:
            result = _a2.sent();
            binding.cache = result;
            return [3, 3];
          case 2:
            ex_1 = _a2.sent();
            binding.cache = null;
            binding.activated = false;
            throw ex_1;
          case 3:
            return [2];
        }
      });
    });
  }, "_saveAsyncResultToSingletonScope");
  var FactoryType;
  (function(FactoryType2) {
    FactoryType2["DynamicValue"] = "toDynamicValue";
    FactoryType2["Factory"] = "toFactory";
    FactoryType2["Provider"] = "toProvider";
  })(FactoryType || (FactoryType = {}));
  var ensureFullyBound = /* @__PURE__ */ __name(function(binding) {
    var boundValue = null;
    switch (binding.type) {
      case BindingTypeEnum.ConstantValue:
      case BindingTypeEnum.Function:
        boundValue = binding.cache;
        break;
      case BindingTypeEnum.Constructor:
      case BindingTypeEnum.Instance:
        boundValue = binding.implementationType;
        break;
      case BindingTypeEnum.DynamicValue:
        boundValue = binding.dynamicValue;
        break;
      case BindingTypeEnum.Provider:
        boundValue = binding.provider;
        break;
      case BindingTypeEnum.Factory:
        boundValue = binding.factory;
        break;
    }
    if (boundValue === null) {
      var serviceIdentifierAsString = getServiceIdentifierAsString(binding.serviceIdentifier);
      throw new Error(INVALID_BINDING_TYPE + " " + serviceIdentifierAsString);
    }
  }, "ensureFullyBound");
  var getFactoryDetails = /* @__PURE__ */ __name(function(binding) {
    switch (binding.type) {
      case BindingTypeEnum.Factory:
        return { factory: binding.factory, factoryType: FactoryType.Factory };
      case BindingTypeEnum.Provider:
        return { factory: binding.provider, factoryType: FactoryType.Provider };
      case BindingTypeEnum.DynamicValue:
        return { factory: binding.dynamicValue, factoryType: FactoryType.DynamicValue };
      default:
        throw new Error("Unexpected factory type " + binding.type);
    }
  }, "getFactoryDetails");
  var __assign$1 = function() {
    __assign$1 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
      return t;
    };
    return __assign$1.apply(this, arguments);
  };
  var __awaiter$2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    __name(adopt, "adopt");
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step");
      step((generator = generator.apply(thisArg, [])).next());
    });
  };
  var __generator$2 = function(thisArg, body) {
    var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, "sent"), trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var __spreadArray$1 = function(to, from2, pack) {
    if (arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  };
  function _resolveRequests(childRequests, resolveRequest) {
    return childRequests.reduce(function(resolvedRequests, childRequest) {
      var injection = resolveRequest(childRequest);
      var targetType = childRequest.target.type;
      if (targetType === TargetTypeEnum.ConstructorArgument) {
        resolvedRequests.constructorInjections.push(injection);
      } else {
        resolvedRequests.propertyRequests.push(childRequest);
        resolvedRequests.propertyInjections.push(injection);
      }
      if (!resolvedRequests.isAsync) {
        resolvedRequests.isAsync = isPromiseOrContainsPromise(injection);
      }
      return resolvedRequests;
    }, { constructorInjections: [], propertyInjections: [], propertyRequests: [], isAsync: false });
  }
  __name(_resolveRequests, "_resolveRequests");
  function _createInstance(constr, childRequests, resolveRequest) {
    var result;
    if (childRequests.length > 0) {
      var resolved = _resolveRequests(childRequests, resolveRequest);
      var createInstanceWithInjectionsArg = __assign$1(__assign$1({}, resolved), { constr });
      if (resolved.isAsync) {
        result = createInstanceWithInjectionsAsync(createInstanceWithInjectionsArg);
      } else {
        result = createInstanceWithInjections(createInstanceWithInjectionsArg);
      }
    } else {
      result = new constr();
    }
    return result;
  }
  __name(_createInstance, "_createInstance");
  function createInstanceWithInjections(args) {
    var _a2;
    var instance2 = new ((_a2 = args.constr).bind.apply(_a2, __spreadArray$1([void 0], args.constructorInjections, false)))();
    args.propertyRequests.forEach(function(r, index) {
      var property = r.target.identifier;
      var injection = args.propertyInjections[index];
      if (!r.target.isOptional() || injection !== void 0) {
        instance2[property] = injection;
      }
    });
    return instance2;
  }
  __name(createInstanceWithInjections, "createInstanceWithInjections");
  function createInstanceWithInjectionsAsync(args) {
    return __awaiter$2(this, void 0, void 0, function() {
      var constructorInjections, propertyInjections;
      return __generator$2(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, possiblyWaitInjections(args.constructorInjections)];
          case 1:
            constructorInjections = _a2.sent();
            return [4, possiblyWaitInjections(args.propertyInjections)];
          case 2:
            propertyInjections = _a2.sent();
            return [2, createInstanceWithInjections(__assign$1(__assign$1({}, args), { constructorInjections, propertyInjections }))];
        }
      });
    });
  }
  __name(createInstanceWithInjectionsAsync, "createInstanceWithInjectionsAsync");
  function possiblyWaitInjections(possiblePromiseinjections) {
    return __awaiter$2(this, void 0, void 0, function() {
      var injections, _i2, possiblePromiseinjections_1, injection;
      return __generator$2(this, function(_a2) {
        injections = [];
        for (_i2 = 0, possiblePromiseinjections_1 = possiblePromiseinjections; _i2 < possiblePromiseinjections_1.length; _i2++) {
          injection = possiblePromiseinjections_1[_i2];
          if (Array.isArray(injection)) {
            injections.push(Promise.all(injection));
          } else {
            injections.push(injection);
          }
        }
        return [2, Promise.all(injections)];
      });
    });
  }
  __name(possiblyWaitInjections, "possiblyWaitInjections");
  function _getInstanceAfterPostConstruct(constr, result) {
    var postConstructResult = _postConstruct(constr, result);
    if (isPromise(postConstructResult)) {
      return postConstructResult.then(function() {
        return result;
      });
    } else {
      return result;
    }
  }
  __name(_getInstanceAfterPostConstruct, "_getInstanceAfterPostConstruct");
  function _postConstruct(constr, instance2) {
    var _a2, _b2;
    if (Reflect.hasMetadata(POST_CONSTRUCT, constr)) {
      var data = Reflect.getMetadata(POST_CONSTRUCT, constr);
      try {
        return (_b2 = (_a2 = instance2)[data.value]) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      } catch (e) {
        if (e instanceof Error) {
          throw new Error(POST_CONSTRUCT_ERROR(constr.name, e.message));
        }
      }
    }
  }
  __name(_postConstruct, "_postConstruct");
  function _validateInstanceResolution(binding, constr) {
    if (binding.scope !== BindingScopeEnum.Singleton) {
      _throwIfHandlingDeactivation(binding, constr);
    }
  }
  __name(_validateInstanceResolution, "_validateInstanceResolution");
  function _throwIfHandlingDeactivation(binding, constr) {
    var scopeErrorMessage = "Class cannot be instantiated in " + (binding.scope === BindingScopeEnum.Request ? "request" : "transient") + " scope.";
    if (typeof binding.onDeactivation === "function") {
      throw new Error(ON_DEACTIVATION_ERROR(constr.name, scopeErrorMessage));
    }
    if (Reflect.hasMetadata(PRE_DESTROY, constr)) {
      throw new Error(PRE_DESTROY_ERROR(constr.name, scopeErrorMessage));
    }
  }
  __name(_throwIfHandlingDeactivation, "_throwIfHandlingDeactivation");
  function resolveInstance(binding, constr, childRequests, resolveRequest) {
    _validateInstanceResolution(binding, constr);
    var result = _createInstance(constr, childRequests, resolveRequest);
    if (isPromise(result)) {
      return result.then(function(resolvedResult) {
        return _getInstanceAfterPostConstruct(constr, resolvedResult);
      });
    } else {
      return _getInstanceAfterPostConstruct(constr, result);
    }
  }
  __name(resolveInstance, "resolveInstance");
  var __awaiter$1 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    __name(adopt, "adopt");
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step");
      step((generator = generator.apply(thisArg, [])).next());
    });
  };
  var __generator$1 = function(thisArg, body) {
    var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, "sent"), trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var _resolveRequest = /* @__PURE__ */ __name(function(requestScope) {
    return function(request) {
      request.parentContext.setCurrentRequest(request);
      var bindings = request.bindings;
      var childRequests = request.childRequests;
      var targetIsAnArray = request.target && request.target.isArray();
      var targetParentIsNotAnArray = !request.parentRequest || !request.parentRequest.target || !request.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
      if (targetIsAnArray && targetParentIsNotAnArray) {
        return childRequests.map(function(childRequest) {
          var _f2 = _resolveRequest(requestScope);
          return _f2(childRequest);
        });
      } else {
        if (request.target.isOptional() && bindings.length === 0) {
          return void 0;
        }
        var binding = bindings[0];
        return _resolveBinding(requestScope, request, binding);
      }
    };
  }, "_resolveRequest");
  var _resolveFactoryFromBinding = /* @__PURE__ */ __name(function(binding, context) {
    var factoryDetails = getFactoryDetails(binding);
    return tryAndThrowErrorIfStackOverflow(function() {
      return factoryDetails.factory.bind(binding)(context);
    }, function() {
      return new Error(CIRCULAR_DEPENDENCY_IN_FACTORY(factoryDetails.factoryType, context.currentRequest.serviceIdentifier.toString()));
    });
  }, "_resolveFactoryFromBinding");
  var _getResolvedFromBinding = /* @__PURE__ */ __name(function(requestScope, request, binding) {
    var result;
    var childRequests = request.childRequests;
    ensureFullyBound(binding);
    switch (binding.type) {
      case BindingTypeEnum.ConstantValue:
      case BindingTypeEnum.Function:
        result = binding.cache;
        break;
      case BindingTypeEnum.Constructor:
        result = binding.implementationType;
        break;
      case BindingTypeEnum.Instance:
        result = resolveInstance(binding, binding.implementationType, childRequests, _resolveRequest(requestScope));
        break;
      default:
        result = _resolveFactoryFromBinding(binding, request.parentContext);
    }
    return result;
  }, "_getResolvedFromBinding");
  var _resolveInScope = /* @__PURE__ */ __name(function(requestScope, binding, resolveFromBinding) {
    var result = tryGetFromScope(requestScope, binding);
    if (result !== null) {
      return result;
    }
    result = resolveFromBinding();
    saveToScope(requestScope, binding, result);
    return result;
  }, "_resolveInScope");
  var _resolveBinding = /* @__PURE__ */ __name(function(requestScope, request, binding) {
    return _resolveInScope(requestScope, binding, function() {
      var result = _getResolvedFromBinding(requestScope, request, binding);
      if (isPromise(result)) {
        result = result.then(function(resolved) {
          return _onActivation(request, binding, resolved);
        });
      } else {
        result = _onActivation(request, binding, result);
      }
      return result;
    });
  }, "_resolveBinding");
  function _onActivation(request, binding, resolved) {
    var result = _bindingActivation(request.parentContext, binding, resolved);
    var containersIterator = _getContainersIterator(request.parentContext.container);
    var container;
    var containersIteratorResult = containersIterator.next();
    do {
      container = containersIteratorResult.value;
      var context_1 = request.parentContext;
      var serviceIdentifier = request.serviceIdentifier;
      var activationsIterator = _getContainerActivationsForService(container, serviceIdentifier);
      if (isPromise(result)) {
        result = _activateContainerAsync(activationsIterator, context_1, result);
      } else {
        result = _activateContainer(activationsIterator, context_1, result);
      }
      containersIteratorResult = containersIterator.next();
    } while (containersIteratorResult.done !== true && !getBindingDictionary(container).hasKey(request.serviceIdentifier));
    return result;
  }
  __name(_onActivation, "_onActivation");
  var _bindingActivation = /* @__PURE__ */ __name(function(context, binding, previousResult) {
    var result;
    if (typeof binding.onActivation === "function") {
      result = binding.onActivation(context, previousResult);
    } else {
      result = previousResult;
    }
    return result;
  }, "_bindingActivation");
  var _activateContainer = /* @__PURE__ */ __name(function(activationsIterator, context, result) {
    var activation = activationsIterator.next();
    while (!activation.done) {
      result = activation.value(context, result);
      if (isPromise(result)) {
        return _activateContainerAsync(activationsIterator, context, result);
      }
      activation = activationsIterator.next();
    }
    return result;
  }, "_activateContainer");
  var _activateContainerAsync = /* @__PURE__ */ __name(function(activationsIterator, context, resultPromise) {
    return __awaiter$1(void 0, void 0, void 0, function() {
      var result, activation;
      return __generator$1(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, resultPromise];
          case 1:
            result = _a2.sent();
            activation = activationsIterator.next();
            _a2.label = 2;
          case 2:
            if (!!activation.done) return [3, 4];
            return [4, activation.value(context, result)];
          case 3:
            result = _a2.sent();
            activation = activationsIterator.next();
            return [3, 2];
          case 4:
            return [2, result];
        }
      });
    });
  }, "_activateContainerAsync");
  var _getContainerActivationsForService = /* @__PURE__ */ __name(function(container, serviceIdentifier) {
    var activations = container._activations;
    return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();
  }, "_getContainerActivationsForService");
  var _getContainersIterator = /* @__PURE__ */ __name(function(container) {
    var containersStack = [container];
    var parent = container.parent;
    while (parent !== null) {
      containersStack.push(parent);
      parent = parent.parent;
    }
    var getNextContainer = /* @__PURE__ */ __name(function() {
      var nextContainer = containersStack.pop();
      if (nextContainer !== void 0) {
        return { done: false, value: nextContainer };
      } else {
        return { done: true, value: void 0 };
      }
    }, "getNextContainer");
    var containersIterator = {
      next: getNextContainer
    };
    return containersIterator;
  }, "_getContainersIterator");
  function resolve(context) {
    var _f2 = _resolveRequest(context.plan.rootRequest.requestScope);
    return _f2(context.plan.rootRequest);
  }
  __name(resolve, "resolve");
  var traverseAncerstors = /* @__PURE__ */ __name(function(request, constraint) {
    var parent = request.parentRequest;
    if (parent !== null) {
      return constraint(parent) ? true : traverseAncerstors(parent, constraint);
    } else {
      return false;
    }
  }, "traverseAncerstors");
  var taggedConstraint = /* @__PURE__ */ __name(function(key2) {
    return function(value) {
      var constraint = /* @__PURE__ */ __name(function(request) {
        return request !== null && request.target !== null && request.target.matchesTag(key2)(value);
      }, "constraint");
      constraint.metaData = new Metadata(key2, value);
      return constraint;
    };
  }, "taggedConstraint");
  var namedConstraint = taggedConstraint(NAMED_TAG);
  var typeConstraint = /* @__PURE__ */ __name(function(type) {
    return function(request) {
      var binding = null;
      if (request !== null) {
        binding = request.bindings[0];
        if (typeof type === "string") {
          var serviceIdentifier = binding.serviceIdentifier;
          return serviceIdentifier === type;
        } else {
          var constructor = request.bindings[0].implementationType;
          return type === constructor;
        }
      }
      return false;
    };
  }, "typeConstraint");
  var BindingWhenSyntax = function() {
    function BindingWhenSyntax2(binding) {
      this._binding = binding;
    }
    __name(BindingWhenSyntax2, "BindingWhenSyntax");
    BindingWhenSyntax2.prototype.when = function(constraint) {
      this._binding.constraint = constraint;
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenTargetNamed = function(name) {
      this._binding.constraint = namedConstraint(name);
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenTargetIsDefault = function() {
      this._binding.constraint = function(request) {
        if (request === null) {
          return false;
        }
        var targetIsDefault = request.target !== null && !request.target.isNamed() && !request.target.isTagged();
        return targetIsDefault;
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenTargetTagged = function(tag, value) {
      this._binding.constraint = taggedConstraint(tag)(value);
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenInjectedInto = function(parent) {
      this._binding.constraint = function(request) {
        return request !== null && typeConstraint(parent)(request.parentRequest);
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenParentNamed = function(name) {
      this._binding.constraint = function(request) {
        return request !== null && namedConstraint(name)(request.parentRequest);
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenParentTagged = function(tag, value) {
      this._binding.constraint = function(request) {
        return request !== null && taggedConstraint(tag)(value)(request.parentRequest);
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
      this._binding.constraint = function(request) {
        return request !== null && traverseAncerstors(request, typeConstraint(ancestor));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
      this._binding.constraint = function(request) {
        return request !== null && !traverseAncerstors(request, typeConstraint(ancestor));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenAnyAncestorNamed = function(name) {
      this._binding.constraint = function(request) {
        return request !== null && traverseAncerstors(request, namedConstraint(name));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenNoAncestorNamed = function(name) {
      this._binding.constraint = function(request) {
        return request !== null && !traverseAncerstors(request, namedConstraint(name));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
      this._binding.constraint = function(request) {
        return request !== null && traverseAncerstors(request, taggedConstraint(tag)(value));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
      this._binding.constraint = function(request) {
        return request !== null && !traverseAncerstors(request, taggedConstraint(tag)(value));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
      this._binding.constraint = function(request) {
        return request !== null && traverseAncerstors(request, constraint);
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
      this._binding.constraint = function(request) {
        return request !== null && !traverseAncerstors(request, constraint);
      };
      return new BindingOnSyntax(this._binding);
    };
    return BindingWhenSyntax2;
  }();
  var BindingOnSyntax = function() {
    function BindingOnSyntax2(binding) {
      this._binding = binding;
    }
    __name(BindingOnSyntax2, "BindingOnSyntax");
    BindingOnSyntax2.prototype.onActivation = function(handler) {
      this._binding.onActivation = handler;
      return new BindingWhenSyntax(this._binding);
    };
    BindingOnSyntax2.prototype.onDeactivation = function(handler) {
      this._binding.onDeactivation = handler;
      return new BindingWhenSyntax(this._binding);
    };
    return BindingOnSyntax2;
  }();
  var BindingWhenOnSyntax = function() {
    function BindingWhenOnSyntax2(binding) {
      this._binding = binding;
      this._bindingWhenSyntax = new BindingWhenSyntax(this._binding);
      this._bindingOnSyntax = new BindingOnSyntax(this._binding);
    }
    __name(BindingWhenOnSyntax2, "BindingWhenOnSyntax");
    BindingWhenOnSyntax2.prototype.when = function(constraint) {
      return this._bindingWhenSyntax.when(constraint);
    };
    BindingWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
      return this._bindingWhenSyntax.whenTargetNamed(name);
    };
    BindingWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
      return this._bindingWhenSyntax.whenTargetIsDefault();
    };
    BindingWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
      return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    };
    BindingWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
      return this._bindingWhenSyntax.whenInjectedInto(parent);
    };
    BindingWhenOnSyntax2.prototype.whenParentNamed = function(name) {
      return this._bindingWhenSyntax.whenParentNamed(name);
    };
    BindingWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
      return this._bindingWhenSyntax.whenParentTagged(tag, value);
    };
    BindingWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
      return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    };
    BindingWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
      return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    };
    BindingWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
      return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    };
    BindingWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
      return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    };
    BindingWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
      return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    };
    BindingWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
      return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    };
    BindingWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
      return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    };
    BindingWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
      return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    };
    BindingWhenOnSyntax2.prototype.onActivation = function(handler) {
      return this._bindingOnSyntax.onActivation(handler);
    };
    BindingWhenOnSyntax2.prototype.onDeactivation = function(handler) {
      return this._bindingOnSyntax.onDeactivation(handler);
    };
    return BindingWhenOnSyntax2;
  }();
  var BindingInSyntax = function() {
    function BindingInSyntax2(binding) {
      this._binding = binding;
    }
    __name(BindingInSyntax2, "BindingInSyntax");
    BindingInSyntax2.prototype.inRequestScope = function() {
      this._binding.scope = BindingScopeEnum.Request;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingInSyntax2.prototype.inSingletonScope = function() {
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingInSyntax2.prototype.inTransientScope = function() {
      this._binding.scope = BindingScopeEnum.Transient;
      return new BindingWhenOnSyntax(this._binding);
    };
    return BindingInSyntax2;
  }();
  var BindingInWhenOnSyntax = function() {
    function BindingInWhenOnSyntax2(binding) {
      this._binding = binding;
      this._bindingWhenSyntax = new BindingWhenSyntax(this._binding);
      this._bindingOnSyntax = new BindingOnSyntax(this._binding);
      this._bindingInSyntax = new BindingInSyntax(binding);
    }
    __name(BindingInWhenOnSyntax2, "BindingInWhenOnSyntax");
    BindingInWhenOnSyntax2.prototype.inRequestScope = function() {
      return this._bindingInSyntax.inRequestScope();
    };
    BindingInWhenOnSyntax2.prototype.inSingletonScope = function() {
      return this._bindingInSyntax.inSingletonScope();
    };
    BindingInWhenOnSyntax2.prototype.inTransientScope = function() {
      return this._bindingInSyntax.inTransientScope();
    };
    BindingInWhenOnSyntax2.prototype.when = function(constraint) {
      return this._bindingWhenSyntax.when(constraint);
    };
    BindingInWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
      return this._bindingWhenSyntax.whenTargetNamed(name);
    };
    BindingInWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
      return this._bindingWhenSyntax.whenTargetIsDefault();
    };
    BindingInWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
      return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    };
    BindingInWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
      return this._bindingWhenSyntax.whenInjectedInto(parent);
    };
    BindingInWhenOnSyntax2.prototype.whenParentNamed = function(name) {
      return this._bindingWhenSyntax.whenParentNamed(name);
    };
    BindingInWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
      return this._bindingWhenSyntax.whenParentTagged(tag, value);
    };
    BindingInWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
      return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    };
    BindingInWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
      return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    };
    BindingInWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
      return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    };
    BindingInWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
      return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    };
    BindingInWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
      return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    };
    BindingInWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
      return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    };
    BindingInWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
      return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    };
    BindingInWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
      return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    };
    BindingInWhenOnSyntax2.prototype.onActivation = function(handler) {
      return this._bindingOnSyntax.onActivation(handler);
    };
    BindingInWhenOnSyntax2.prototype.onDeactivation = function(handler) {
      return this._bindingOnSyntax.onDeactivation(handler);
    };
    return BindingInWhenOnSyntax2;
  }();
  var BindingToSyntax = function() {
    function BindingToSyntax2(binding) {
      this._binding = binding;
    }
    __name(BindingToSyntax2, "BindingToSyntax");
    BindingToSyntax2.prototype.to = function(constructor) {
      this._binding.type = BindingTypeEnum.Instance;
      this._binding.implementationType = constructor;
      return new BindingInWhenOnSyntax(this._binding);
    };
    BindingToSyntax2.prototype.toSelf = function() {
      if (typeof this._binding.serviceIdentifier !== "function") {
        throw new Error("" + INVALID_TO_SELF_VALUE);
      }
      var self2 = this._binding.serviceIdentifier;
      return this.to(self2);
    };
    BindingToSyntax2.prototype.toConstantValue = function(value) {
      this._binding.type = BindingTypeEnum.ConstantValue;
      this._binding.cache = value;
      this._binding.dynamicValue = null;
      this._binding.implementationType = null;
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax2.prototype.toDynamicValue = function(func2) {
      this._binding.type = BindingTypeEnum.DynamicValue;
      this._binding.cache = null;
      this._binding.dynamicValue = func2;
      this._binding.implementationType = null;
      return new BindingInWhenOnSyntax(this._binding);
    };
    BindingToSyntax2.prototype.toConstructor = function(constructor) {
      this._binding.type = BindingTypeEnum.Constructor;
      this._binding.implementationType = constructor;
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax2.prototype.toFactory = function(factory) {
      this._binding.type = BindingTypeEnum.Factory;
      this._binding.factory = factory;
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax2.prototype.toFunction = function(func2) {
      if (typeof func2 !== "function") {
        throw new Error(INVALID_FUNCTION_BINDING);
      }
      var bindingWhenOnSyntax = this.toConstantValue(func2);
      this._binding.type = BindingTypeEnum.Function;
      this._binding.scope = BindingScopeEnum.Singleton;
      return bindingWhenOnSyntax;
    };
    BindingToSyntax2.prototype.toAutoFactory = function(serviceIdentifier) {
      this._binding.type = BindingTypeEnum.Factory;
      this._binding.factory = function(context) {
        var autofactory = /* @__PURE__ */ __name(function() {
          return context.container.get(serviceIdentifier);
        }, "autofactory");
        return autofactory;
      };
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax2.prototype.toAutoNamedFactory = function(serviceIdentifier) {
      this._binding.type = BindingTypeEnum.Factory;
      this._binding.factory = function(context) {
        return function(named) {
          return context.container.getNamed(serviceIdentifier, named);
        };
      };
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax2.prototype.toProvider = function(provider) {
      this._binding.type = BindingTypeEnum.Provider;
      this._binding.provider = provider;
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax2.prototype.toService = function(service) {
      this.toDynamicValue(function(context) {
        return context.container.get(service);
      });
    };
    return BindingToSyntax2;
  }();
  var ContainerSnapshot = function() {
    function ContainerSnapshot2() {
    }
    __name(ContainerSnapshot2, "ContainerSnapshot");
    ContainerSnapshot2.of = function(bindings, middleware, activations, deactivations, moduleActivationStore) {
      var snapshot = new ContainerSnapshot2();
      snapshot.bindings = bindings;
      snapshot.middleware = middleware;
      snapshot.deactivations = deactivations;
      snapshot.activations = activations;
      snapshot.moduleActivationStore = moduleActivationStore;
      return snapshot;
    };
    return ContainerSnapshot2;
  }();
  function isClonable(obj) {
    return typeof obj === "object" && obj !== null && "clone" in obj && typeof obj.clone === "function";
  }
  __name(isClonable, "isClonable");
  var Lookup = function() {
    function Lookup2() {
      this._map = /* @__PURE__ */ new Map();
    }
    __name(Lookup2, "Lookup");
    Lookup2.prototype.getMap = function() {
      return this._map;
    };
    Lookup2.prototype.add = function(serviceIdentifier, value) {
      if (serviceIdentifier === null || serviceIdentifier === void 0) {
        throw new Error(NULL_ARGUMENT);
      }
      if (value === null || value === void 0) {
        throw new Error(NULL_ARGUMENT);
      }
      var entry = this._map.get(serviceIdentifier);
      if (entry !== void 0) {
        entry.push(value);
      } else {
        this._map.set(serviceIdentifier, [value]);
      }
    };
    Lookup2.prototype.get = function(serviceIdentifier) {
      if (serviceIdentifier === null || serviceIdentifier === void 0) {
        throw new Error(NULL_ARGUMENT);
      }
      var entry = this._map.get(serviceIdentifier);
      if (entry !== void 0) {
        return entry;
      } else {
        throw new Error(KEY_NOT_FOUND);
      }
    };
    Lookup2.prototype.remove = function(serviceIdentifier) {
      if (serviceIdentifier === null || serviceIdentifier === void 0) {
        throw new Error(NULL_ARGUMENT);
      }
      if (!this._map.delete(serviceIdentifier)) {
        throw new Error(KEY_NOT_FOUND);
      }
    };
    Lookup2.prototype.removeIntersection = function(lookup) {
      var _this = this;
      this.traverse(function(serviceIdentifier, value) {
        var lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : void 0;
        if (lookupActivations !== void 0) {
          var filteredValues = value.filter(function(lookupValue) {
            return !lookupActivations.some(function(moduleActivation) {
              return lookupValue === moduleActivation;
            });
          });
          _this._setValue(serviceIdentifier, filteredValues);
        }
      });
    };
    Lookup2.prototype.removeByCondition = function(condition) {
      var _this = this;
      var removals = [];
      this._map.forEach(function(entries, key2) {
        var updatedEntries = [];
        for (var _i2 = 0, entries_1 = entries; _i2 < entries_1.length; _i2++) {
          var entry = entries_1[_i2];
          var remove = condition(entry);
          if (remove) {
            removals.push(entry);
          } else {
            updatedEntries.push(entry);
          }
        }
        _this._setValue(key2, updatedEntries);
      });
      return removals;
    };
    Lookup2.prototype.hasKey = function(serviceIdentifier) {
      if (serviceIdentifier === null || serviceIdentifier === void 0) {
        throw new Error(NULL_ARGUMENT);
      }
      return this._map.has(serviceIdentifier);
    };
    Lookup2.prototype.clone = function() {
      var copy = new Lookup2();
      this._map.forEach(function(value, key2) {
        value.forEach(function(b) {
          return copy.add(key2, isClonable(b) ? b.clone() : b);
        });
      });
      return copy;
    };
    Lookup2.prototype.traverse = function(func2) {
      this._map.forEach(function(value, key2) {
        func2(key2, value);
      });
    };
    Lookup2.prototype._setValue = function(serviceIdentifier, value) {
      if (value.length > 0) {
        this._map.set(serviceIdentifier, value);
      } else {
        this._map.delete(serviceIdentifier);
      }
    };
    return Lookup2;
  }();
  var ModuleActivationStore = function() {
    function ModuleActivationStore2() {
      this._map = /* @__PURE__ */ new Map();
    }
    __name(ModuleActivationStore2, "ModuleActivationStore");
    ModuleActivationStore2.prototype.remove = function(moduleId) {
      if (this._map.has(moduleId)) {
        var handlers = this._map.get(moduleId);
        this._map.delete(moduleId);
        return handlers;
      }
      return this._getEmptyHandlersStore();
    };
    ModuleActivationStore2.prototype.addDeactivation = function(moduleId, serviceIdentifier, onDeactivation) {
      this._getModuleActivationHandlers(moduleId).onDeactivations.add(serviceIdentifier, onDeactivation);
    };
    ModuleActivationStore2.prototype.addActivation = function(moduleId, serviceIdentifier, onActivation) {
      this._getModuleActivationHandlers(moduleId).onActivations.add(serviceIdentifier, onActivation);
    };
    ModuleActivationStore2.prototype.clone = function() {
      var clone = new ModuleActivationStore2();
      this._map.forEach(function(handlersStore, moduleId) {
        clone._map.set(moduleId, {
          onActivations: handlersStore.onActivations.clone(),
          onDeactivations: handlersStore.onDeactivations.clone()
        });
      });
      return clone;
    };
    ModuleActivationStore2.prototype._getModuleActivationHandlers = function(moduleId) {
      var moduleActivationHandlers = this._map.get(moduleId);
      if (moduleActivationHandlers === void 0) {
        moduleActivationHandlers = this._getEmptyHandlersStore();
        this._map.set(moduleId, moduleActivationHandlers);
      }
      return moduleActivationHandlers;
    };
    ModuleActivationStore2.prototype._getEmptyHandlersStore = function() {
      var handlersStore = {
        onActivations: new Lookup(),
        onDeactivations: new Lookup()
      };
      return handlersStore;
    };
    return ModuleActivationStore2;
  }();
  var __assign = function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    __name(adopt, "adopt");
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step");
      step((generator = generator.apply(thisArg, [])).next());
    });
  };
  var __generator = function(thisArg, body) {
    var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, "sent"), trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var __spreadArray = function(to, from2, pack) {
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  };
  var Container = function() {
    function Container2(containerOptions) {
      var options = containerOptions || {};
      if (typeof options !== "object") {
        throw new Error("" + CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
      }
      if (options.defaultScope === void 0) {
        options.defaultScope = BindingScopeEnum.Transient;
      } else if (options.defaultScope !== BindingScopeEnum.Singleton && options.defaultScope !== BindingScopeEnum.Transient && options.defaultScope !== BindingScopeEnum.Request) {
        throw new Error("" + CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
      }
      if (options.autoBindInjectable === void 0) {
        options.autoBindInjectable = false;
      } else if (typeof options.autoBindInjectable !== "boolean") {
        throw new Error("" + CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
      }
      if (options.skipBaseClassChecks === void 0) {
        options.skipBaseClassChecks = false;
      } else if (typeof options.skipBaseClassChecks !== "boolean") {
        throw new Error("" + CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
      }
      this.options = {
        autoBindInjectable: options.autoBindInjectable,
        defaultScope: options.defaultScope,
        skipBaseClassChecks: options.skipBaseClassChecks
      };
      this.id = id();
      this._bindingDictionary = new Lookup();
      this._snapshots = [];
      this._middleware = null;
      this._activations = new Lookup();
      this._deactivations = new Lookup();
      this.parent = null;
      this._metadataReader = new MetadataReader();
      this._moduleActivationStore = new ModuleActivationStore();
    }
    __name(Container2, "Container");
    Container2.merge = function(container1, container2) {
      var containers = [];
      for (var _i2 = 2; _i2 < arguments.length; _i2++) {
        containers[_i2 - 2] = arguments[_i2];
      }
      var container = new Container2();
      var targetContainers = __spreadArray([container1, container2], containers).map(function(targetContainer) {
        return getBindingDictionary(targetContainer);
      });
      var bindingDictionary = getBindingDictionary(container);
      function copyDictionary(origin, destination) {
        origin.traverse(function(_key, value) {
          value.forEach(function(binding) {
            destination.add(binding.serviceIdentifier, binding.clone());
          });
        });
      }
      __name(copyDictionary, "copyDictionary");
      targetContainers.forEach(function(targetBindingDictionary) {
        copyDictionary(targetBindingDictionary, bindingDictionary);
      });
      return container;
    };
    Container2.prototype.load = function() {
      var modules = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        modules[_i2] = arguments[_i2];
      }
      var getHelpers = this._getContainerModuleHelpersFactory();
      for (var _a2 = 0, modules_1 = modules; _a2 < modules_1.length; _a2++) {
        var currentModule = modules_1[_a2];
        var containerModuleHelpers = getHelpers(currentModule.id);
        currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
      }
    };
    Container2.prototype.loadAsync = function() {
      var modules = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        modules[_i2] = arguments[_i2];
      }
      return __awaiter(this, void 0, void 0, function() {
        var getHelpers, _a2, modules_2, currentModule, containerModuleHelpers;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              getHelpers = this._getContainerModuleHelpersFactory();
              _a2 = 0, modules_2 = modules;
              _b2.label = 1;
            case 1:
              if (!(_a2 < modules_2.length)) return [3, 4];
              currentModule = modules_2[_a2];
              containerModuleHelpers = getHelpers(currentModule.id);
              return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction)];
            case 2:
              _b2.sent();
              _b2.label = 3;
            case 3:
              _a2++;
              return [3, 1];
            case 4:
              return [2];
          }
        });
      });
    };
    Container2.prototype.unload = function() {
      var _this = this;
      var modules = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        modules[_i2] = arguments[_i2];
      }
      modules.forEach(function(module) {
        var deactivations = _this._removeModuleBindings(module.id);
        _this._deactivateSingletons(deactivations);
        _this._removeModuleHandlers(module.id);
      });
    };
    Container2.prototype.unloadAsync = function() {
      var modules = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        modules[_i2] = arguments[_i2];
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a2, modules_3, module_1, deactivations;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              _a2 = 0, modules_3 = modules;
              _b2.label = 1;
            case 1:
              if (!(_a2 < modules_3.length)) return [3, 4];
              module_1 = modules_3[_a2];
              deactivations = this._removeModuleBindings(module_1.id);
              return [4, this._deactivateSingletonsAsync(deactivations)];
            case 2:
              _b2.sent();
              this._removeModuleHandlers(module_1.id);
              _b2.label = 3;
            case 3:
              _a2++;
              return [3, 1];
            case 4:
              return [2];
          }
        });
      });
    };
    Container2.prototype.bind = function(serviceIdentifier) {
      var scope = this.options.defaultScope || BindingScopeEnum.Transient;
      var binding = new Binding(serviceIdentifier, scope);
      this._bindingDictionary.add(serviceIdentifier, binding);
      return new BindingToSyntax(binding);
    };
    Container2.prototype.rebind = function(serviceIdentifier) {
      this.unbind(serviceIdentifier);
      return this.bind(serviceIdentifier);
    };
    Container2.prototype.rebindAsync = function(serviceIdentifier) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.unbindAsync(serviceIdentifier)];
            case 1:
              _a2.sent();
              return [2, this.bind(serviceIdentifier)];
          }
        });
      });
    };
    Container2.prototype.unbind = function(serviceIdentifier) {
      if (this._bindingDictionary.hasKey(serviceIdentifier)) {
        var bindings = this._bindingDictionary.get(serviceIdentifier);
        this._deactivateSingletons(bindings);
      }
      this._removeServiceFromDictionary(serviceIdentifier);
    };
    Container2.prototype.unbindAsync = function(serviceIdentifier) {
      return __awaiter(this, void 0, void 0, function() {
        var bindings;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!this._bindingDictionary.hasKey(serviceIdentifier)) return [3, 2];
              bindings = this._bindingDictionary.get(serviceIdentifier);
              return [4, this._deactivateSingletonsAsync(bindings)];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              this._removeServiceFromDictionary(serviceIdentifier);
              return [2];
          }
        });
      });
    };
    Container2.prototype.unbindAll = function() {
      var _this = this;
      this._bindingDictionary.traverse(function(_key, value) {
        _this._deactivateSingletons(value);
      });
      this._bindingDictionary = new Lookup();
    };
    Container2.prototype.unbindAllAsync = function() {
      return __awaiter(this, void 0, void 0, function() {
        var promises;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              promises = [];
              this._bindingDictionary.traverse(function(_key, value) {
                promises.push(_this._deactivateSingletonsAsync(value));
              });
              return [4, Promise.all(promises)];
            case 1:
              _a2.sent();
              this._bindingDictionary = new Lookup();
              return [2];
          }
        });
      });
    };
    Container2.prototype.onActivation = function(serviceIdentifier, onActivation) {
      this._activations.add(serviceIdentifier, onActivation);
    };
    Container2.prototype.onDeactivation = function(serviceIdentifier, onDeactivation) {
      this._deactivations.add(serviceIdentifier, onDeactivation);
    };
    Container2.prototype.isBound = function(serviceIdentifier) {
      var bound = this._bindingDictionary.hasKey(serviceIdentifier);
      if (!bound && this.parent) {
        bound = this.parent.isBound(serviceIdentifier);
      }
      return bound;
    };
    Container2.prototype.isCurrentBound = function(serviceIdentifier) {
      return this._bindingDictionary.hasKey(serviceIdentifier);
    };
    Container2.prototype.isBoundNamed = function(serviceIdentifier, named) {
      return this.isBoundTagged(serviceIdentifier, NAMED_TAG, named);
    };
    Container2.prototype.isBoundTagged = function(serviceIdentifier, key2, value) {
      var bound = false;
      if (this._bindingDictionary.hasKey(serviceIdentifier)) {
        var bindings = this._bindingDictionary.get(serviceIdentifier);
        var request_1 = createMockRequest(this, serviceIdentifier, key2, value);
        bound = bindings.some(function(b) {
          return b.constraint(request_1);
        });
      }
      if (!bound && this.parent) {
        bound = this.parent.isBoundTagged(serviceIdentifier, key2, value);
      }
      return bound;
    };
    Container2.prototype.snapshot = function() {
      this._snapshots.push(ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
    };
    Container2.prototype.restore = function() {
      var snapshot = this._snapshots.pop();
      if (snapshot === void 0) {
        throw new Error(NO_MORE_SNAPSHOTS_AVAILABLE);
      }
      this._bindingDictionary = snapshot.bindings;
      this._activations = snapshot.activations;
      this._deactivations = snapshot.deactivations;
      this._middleware = snapshot.middleware;
      this._moduleActivationStore = snapshot.moduleActivationStore;
    };
    Container2.prototype.createChild = function(containerOptions) {
      var child = new Container2(containerOptions || this.options);
      child.parent = this;
      return child;
    };
    Container2.prototype.applyMiddleware = function() {
      var middlewares = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        middlewares[_i2] = arguments[_i2];
      }
      var initial = this._middleware ? this._middleware : this._planAndResolve();
      this._middleware = middlewares.reduce(function(prev, curr) {
        return curr(prev);
      }, initial);
    };
    Container2.prototype.applyCustomMetadataReader = function(metadataReader) {
      this._metadataReader = metadataReader;
    };
    Container2.prototype.get = function(serviceIdentifier) {
      var getArgs = this._getNotAllArgs(serviceIdentifier, false);
      return this._getButThrowIfAsync(getArgs);
    };
    Container2.prototype.getAsync = function(serviceIdentifier) {
      return __awaiter(this, void 0, void 0, function() {
        var getArgs;
        return __generator(this, function(_a2) {
          getArgs = this._getNotAllArgs(serviceIdentifier, false);
          return [2, this._get(getArgs)];
        });
      });
    };
    Container2.prototype.getTagged = function(serviceIdentifier, key2, value) {
      var getArgs = this._getNotAllArgs(serviceIdentifier, false, key2, value);
      return this._getButThrowIfAsync(getArgs);
    };
    Container2.prototype.getTaggedAsync = function(serviceIdentifier, key2, value) {
      return __awaiter(this, void 0, void 0, function() {
        var getArgs;
        return __generator(this, function(_a2) {
          getArgs = this._getNotAllArgs(serviceIdentifier, false, key2, value);
          return [2, this._get(getArgs)];
        });
      });
    };
    Container2.prototype.getNamed = function(serviceIdentifier, named) {
      return this.getTagged(serviceIdentifier, NAMED_TAG, named);
    };
    Container2.prototype.getNamedAsync = function(serviceIdentifier, named) {
      return this.getTaggedAsync(serviceIdentifier, NAMED_TAG, named);
    };
    Container2.prototype.getAll = function(serviceIdentifier) {
      var getArgs = this._getAllArgs(serviceIdentifier);
      return this._getButThrowIfAsync(getArgs);
    };
    Container2.prototype.getAllAsync = function(serviceIdentifier) {
      var getArgs = this._getAllArgs(serviceIdentifier);
      return this._getAll(getArgs);
    };
    Container2.prototype.getAllTagged = function(serviceIdentifier, key2, value) {
      var getArgs = this._getNotAllArgs(serviceIdentifier, true, key2, value);
      return this._getButThrowIfAsync(getArgs);
    };
    Container2.prototype.getAllTaggedAsync = function(serviceIdentifier, key2, value) {
      var getArgs = this._getNotAllArgs(serviceIdentifier, true, key2, value);
      return this._getAll(getArgs);
    };
    Container2.prototype.getAllNamed = function(serviceIdentifier, named) {
      return this.getAllTagged(serviceIdentifier, NAMED_TAG, named);
    };
    Container2.prototype.getAllNamedAsync = function(serviceIdentifier, named) {
      return this.getAllTaggedAsync(serviceIdentifier, NAMED_TAG, named);
    };
    Container2.prototype.resolve = function(constructorFunction) {
      var isBound = this.isBound(constructorFunction);
      if (!isBound) {
        this.bind(constructorFunction).toSelf();
      }
      var resolved = this.get(constructorFunction);
      if (!isBound) {
        this.unbind(constructorFunction);
      }
      return resolved;
    };
    Container2.prototype._preDestroy = function(constructor, instance2) {
      var _a2, _b2;
      if (Reflect.hasMetadata(PRE_DESTROY, constructor)) {
        var data = Reflect.getMetadata(PRE_DESTROY, constructor);
        return (_b2 = (_a2 = instance2)[data.value]) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
    };
    Container2.prototype._removeModuleHandlers = function(moduleId) {
      var moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);
      this._activations.removeIntersection(moduleActivationsHandlers.onActivations);
      this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);
    };
    Container2.prototype._removeModuleBindings = function(moduleId) {
      return this._bindingDictionary.removeByCondition(function(binding) {
        return binding.moduleId === moduleId;
      });
    };
    Container2.prototype._deactivate = function(binding, instance2) {
      var _this = this;
      var constructor = Object.getPrototypeOf(instance2).constructor;
      try {
        if (this._deactivations.hasKey(binding.serviceIdentifier)) {
          var result = this._deactivateContainer(instance2, this._deactivations.get(binding.serviceIdentifier).values());
          if (isPromise(result)) {
            return this._handleDeactivationError(result.then(function() {
              return _this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance2, constructor);
            }), constructor);
          }
        }
        var propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance2, constructor);
        if (isPromise(propagateDeactivationResult)) {
          return this._handleDeactivationError(propagateDeactivationResult, constructor);
        }
      } catch (ex) {
        if (ex instanceof Error) {
          throw new Error(ON_DEACTIVATION_ERROR(constructor.name, ex.message));
        }
      }
    };
    Container2.prototype._handleDeactivationError = function(asyncResult, constructor) {
      return __awaiter(this, void 0, void 0, function() {
        var ex_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 2, , 3]);
              return [4, asyncResult];
            case 1:
              _a2.sent();
              return [3, 3];
            case 2:
              ex_1 = _a2.sent();
              if (ex_1 instanceof Error) {
                throw new Error(ON_DEACTIVATION_ERROR(constructor.name, ex_1.message));
              }
              return [3, 3];
            case 3:
              return [2];
          }
        });
      });
    };
    Container2.prototype._deactivateContainer = function(instance2, deactivationsIterator) {
      var _this = this;
      var deactivation = deactivationsIterator.next();
      while (deactivation.value) {
        var result = deactivation.value(instance2);
        if (isPromise(result)) {
          return result.then(function() {
            return _this._deactivateContainerAsync(instance2, deactivationsIterator);
          });
        }
        deactivation = deactivationsIterator.next();
      }
    };
    Container2.prototype._deactivateContainerAsync = function(instance2, deactivationsIterator) {
      return __awaiter(this, void 0, void 0, function() {
        var deactivation;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              deactivation = deactivationsIterator.next();
              _a2.label = 1;
            case 1:
              if (!deactivation.value) return [3, 3];
              return [4, deactivation.value(instance2)];
            case 2:
              _a2.sent();
              deactivation = deactivationsIterator.next();
              return [3, 1];
            case 3:
              return [2];
          }
        });
      });
    };
    Container2.prototype._getContainerModuleHelpersFactory = function() {
      var _this = this;
      var setModuleId = /* @__PURE__ */ __name(function(bindingToSyntax, moduleId) {
        bindingToSyntax._binding.moduleId = moduleId;
      }, "setModuleId");
      var getBindFunction = /* @__PURE__ */ __name(function(moduleId) {
        return function(serviceIdentifier) {
          var bindingToSyntax = _this.bind(serviceIdentifier);
          setModuleId(bindingToSyntax, moduleId);
          return bindingToSyntax;
        };
      }, "getBindFunction");
      var getUnbindFunction = /* @__PURE__ */ __name(function() {
        return function(serviceIdentifier) {
          return _this.unbind(serviceIdentifier);
        };
      }, "getUnbindFunction");
      var getUnbindAsyncFunction = /* @__PURE__ */ __name(function() {
        return function(serviceIdentifier) {
          return _this.unbindAsync(serviceIdentifier);
        };
      }, "getUnbindAsyncFunction");
      var getIsboundFunction = /* @__PURE__ */ __name(function() {
        return function(serviceIdentifier) {
          return _this.isBound(serviceIdentifier);
        };
      }, "getIsboundFunction");
      var getRebindFunction = /* @__PURE__ */ __name(function(moduleId) {
        return function(serviceIdentifier) {
          var bindingToSyntax = _this.rebind(serviceIdentifier);
          setModuleId(bindingToSyntax, moduleId);
          return bindingToSyntax;
        };
      }, "getRebindFunction");
      var getOnActivationFunction = /* @__PURE__ */ __name(function(moduleId) {
        return function(serviceIdentifier, onActivation) {
          _this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation);
          _this.onActivation(serviceIdentifier, onActivation);
        };
      }, "getOnActivationFunction");
      var getOnDeactivationFunction = /* @__PURE__ */ __name(function(moduleId) {
        return function(serviceIdentifier, onDeactivation) {
          _this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation);
          _this.onDeactivation(serviceIdentifier, onDeactivation);
        };
      }, "getOnDeactivationFunction");
      return function(mId) {
        return {
          bindFunction: getBindFunction(mId),
          isboundFunction: getIsboundFunction(),
          onActivationFunction: getOnActivationFunction(mId),
          onDeactivationFunction: getOnDeactivationFunction(mId),
          rebindFunction: getRebindFunction(mId),
          unbindFunction: getUnbindFunction(),
          unbindAsyncFunction: getUnbindAsyncFunction()
        };
      };
    };
    Container2.prototype._getAll = function(getArgs) {
      return Promise.all(this._get(getArgs));
    };
    Container2.prototype._get = function(getArgs) {
      var planAndResolveArgs = __assign(__assign({}, getArgs), { contextInterceptor: /* @__PURE__ */ __name(function(context) {
        return context;
      }, "contextInterceptor"), targetType: TargetTypeEnum.Variable });
      if (this._middleware) {
        var middlewareResult = this._middleware(planAndResolveArgs);
        if (middlewareResult === void 0 || middlewareResult === null) {
          throw new Error(INVALID_MIDDLEWARE_RETURN);
        }
        return middlewareResult;
      }
      return this._planAndResolve()(planAndResolveArgs);
    };
    Container2.prototype._getButThrowIfAsync = function(getArgs) {
      var result = this._get(getArgs);
      if (isPromiseOrContainsPromise(result)) {
        throw new Error(LAZY_IN_SYNC(getArgs.serviceIdentifier));
      }
      return result;
    };
    Container2.prototype._getAllArgs = function(serviceIdentifier) {
      var getAllArgs = {
        avoidConstraints: true,
        isMultiInject: true,
        serviceIdentifier
      };
      return getAllArgs;
    };
    Container2.prototype._getNotAllArgs = function(serviceIdentifier, isMultiInject, key2, value) {
      var getNotAllArgs = {
        avoidConstraints: false,
        isMultiInject,
        serviceIdentifier,
        key: key2,
        value
      };
      return getNotAllArgs;
    };
    Container2.prototype._planAndResolve = function() {
      var _this = this;
      return function(args) {
        var context = plan(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
        context = args.contextInterceptor(context);
        var result = resolve(context);
        return result;
      };
    };
    Container2.prototype._deactivateIfSingleton = function(binding) {
      var _this = this;
      if (!binding.activated) {
        return;
      }
      if (isPromise(binding.cache)) {
        return binding.cache.then(function(resolved) {
          return _this._deactivate(binding, resolved);
        });
      }
      return this._deactivate(binding, binding.cache);
    };
    Container2.prototype._deactivateSingletons = function(bindings) {
      for (var _i2 = 0, bindings_1 = bindings; _i2 < bindings_1.length; _i2++) {
        var binding = bindings_1[_i2];
        var result = this._deactivateIfSingleton(binding);
        if (isPromise(result)) {
          throw new Error(ASYNC_UNBIND_REQUIRED);
        }
      }
    };
    Container2.prototype._deactivateSingletonsAsync = function(bindings) {
      return __awaiter(this, void 0, void 0, function() {
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, Promise.all(bindings.map(function(b) {
                return _this._deactivateIfSingleton(b);
              }))];
            case 1:
              _a2.sent();
              return [2];
          }
        });
      });
    };
    Container2.prototype._propagateContainerDeactivationThenBindingAndPreDestroy = function(binding, instance2, constructor) {
      if (this.parent) {
        return this._deactivate.bind(this.parent)(binding, instance2);
      } else {
        return this._bindingDeactivationAndPreDestroy(binding, instance2, constructor);
      }
    };
    Container2.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync = function(binding, instance2, constructor) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!this.parent) return [3, 2];
              return [4, this._deactivate.bind(this.parent)(binding, instance2)];
            case 1:
              _a2.sent();
              return [3, 4];
            case 2:
              return [4, this._bindingDeactivationAndPreDestroyAsync(binding, instance2, constructor)];
            case 3:
              _a2.sent();
              _a2.label = 4;
            case 4:
              return [2];
          }
        });
      });
    };
    Container2.prototype._removeServiceFromDictionary = function(serviceIdentifier) {
      try {
        this._bindingDictionary.remove(serviceIdentifier);
      } catch (e) {
        throw new Error(CANNOT_UNBIND + " " + getServiceIdentifierAsString(serviceIdentifier));
      }
    };
    Container2.prototype._bindingDeactivationAndPreDestroy = function(binding, instance2, constructor) {
      var _this = this;
      if (typeof binding.onDeactivation === "function") {
        var result = binding.onDeactivation(instance2);
        if (isPromise(result)) {
          return result.then(function() {
            return _this._preDestroy(constructor, instance2);
          });
        }
      }
      return this._preDestroy(constructor, instance2);
    };
    Container2.prototype._bindingDeactivationAndPreDestroyAsync = function(binding, instance2, constructor) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!(typeof binding.onDeactivation === "function")) return [3, 2];
              return [4, binding.onDeactivation(instance2)];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              return [4, this._preDestroy(constructor, instance2)];
            case 3:
              _a2.sent();
              return [2];
          }
        });
      });
    };
    return Container2;
  }();
  function getFirstArrayDuplicate(array) {
    var seenValues = /* @__PURE__ */ new Set();
    for (var _i2 = 0, array_1 = array; _i2 < array_1.length; _i2++) {
      var entry = array_1[_i2];
      if (seenValues.has(entry)) {
        return entry;
      } else {
        seenValues.add(entry);
      }
    }
    return void 0;
  }
  __name(getFirstArrayDuplicate, "getFirstArrayDuplicate");
  function targetIsConstructorFunction(target) {
    return target.prototype !== void 0;
  }
  __name(targetIsConstructorFunction, "targetIsConstructorFunction");
  function _throwIfMethodParameter(parameterName) {
    if (parameterName !== void 0) {
      throw new Error(INVALID_DECORATOR_OPERATION);
    }
  }
  __name(_throwIfMethodParameter, "_throwIfMethodParameter");
  function tagParameter(annotationTarget, parameterName, parameterIndex, metadata2) {
    _throwIfMethodParameter(parameterName);
    _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata2);
  }
  __name(tagParameter, "tagParameter");
  function tagProperty(annotationTarget, propertyName, metadata2) {
    if (targetIsConstructorFunction(annotationTarget)) {
      throw new Error(INVALID_DECORATOR_OPERATION);
    }
    _tagParameterOrProperty(TAGGED_PROP, annotationTarget.constructor, propertyName, metadata2);
  }
  __name(tagProperty, "tagProperty");
  function _ensureNoMetadataKeyDuplicates(metadata2) {
    var metadatas = [];
    if (Array.isArray(metadata2)) {
      metadatas = metadata2;
      var duplicate = getFirstArrayDuplicate(metadatas.map(function(md) {
        return md.key;
      }));
      if (duplicate !== void 0) {
        throw new Error(DUPLICATED_METADATA + " " + duplicate.toString());
      }
    } else {
      metadatas = [metadata2];
    }
    return metadatas;
  }
  __name(_ensureNoMetadataKeyDuplicates, "_ensureNoMetadataKeyDuplicates");
  function _tagParameterOrProperty(metadataKey, annotationTarget, key2, metadata2) {
    var metadatas = _ensureNoMetadataKeyDuplicates(metadata2);
    var paramsOrPropertiesMetadata = {};
    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
      paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
    }
    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key2];
    if (paramOrPropertyMetadata === void 0) {
      paramOrPropertyMetadata = [];
    } else {
      var _loop_1 = /* @__PURE__ */ __name(function(m2) {
        if (metadatas.some(function(md) {
          return md.key === m2.key;
        })) {
          throw new Error(DUPLICATED_METADATA + " " + m2.key.toString());
        }
      }, "_loop_1");
      for (var _i2 = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i2 < paramOrPropertyMetadata_1.length; _i2++) {
        var m = paramOrPropertyMetadata_1[_i2];
        _loop_1(m);
      }
    }
    paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas);
    paramsOrPropertiesMetadata[key2] = paramOrPropertyMetadata;
    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
  }
  __name(_tagParameterOrProperty, "_tagParameterOrProperty");
  function createTaggedDecorator(metadata2) {
    return function(target, targetKey, indexOrPropertyDescriptor) {
      if (typeof indexOrPropertyDescriptor === "number") {
        tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata2);
      } else {
        tagProperty(target, targetKey, metadata2);
      }
    };
  }
  __name(createTaggedDecorator, "createTaggedDecorator");
  function injectable() {
    return function(target) {
      if (Reflect.hasOwnMetadata(PARAM_TYPES, target)) {
        throw new Error(DUPLICATED_INJECTABLE_DECORATOR);
      }
      var types = Reflect.getMetadata(DESIGN_PARAM_TYPES, target) || [];
      Reflect.defineMetadata(PARAM_TYPES, types, target);
      return target;
    };
  }
  __name(injectable, "injectable");
  function injectBase(metadataKey) {
    return function(serviceIdentifier) {
      return function(target, targetKey, indexOrPropertyDescriptor) {
        if (serviceIdentifier === void 0) {
          var className = typeof target === "function" ? target.name : target.constructor.name;
          throw new Error(UNDEFINED_INJECT_ANNOTATION(className));
        }
        return createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
      };
    };
  }
  __name(injectBase, "injectBase");
  var inject = injectBase(INJECT_TAG);
  function propertyEventDecorator(eventKey, errorMessage) {
    return function() {
      return function(target, propertyKey) {
        var metadata2 = new Metadata(eventKey, propertyKey);
        if (Reflect.hasOwnMetadata(eventKey, target.constructor)) {
          throw new Error(errorMessage);
        }
        Reflect.defineMetadata(eventKey, metadata2, target.constructor);
      };
    };
  }
  __name(propertyEventDecorator, "propertyEventDecorator");
  var postConstruct = propertyEventDecorator(POST_CONSTRUCT, MULTIPLE_POST_CONSTRUCT_METHODS);
  var __defProp$20 = Object.defineProperty;
  var __getOwnPropDesc$Z = Object.getOwnPropertyDescriptor;
  var __defNormalProp2 = /* @__PURE__ */ __name((obj, key2, value) => key2 in obj ? __defProp$20(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value, "__defNormalProp");
  var __decorateClass$20 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$Z(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$20(target, key2, result);
    return result;
  }, "__decorateClass$20");
  var __publicField2 = /* @__PURE__ */ __name((obj, key2, value) => __defNormalProp2(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value), "__publicField");
  let LoggingService = (_a = class {
    constructor() {
      __publicField(this, "_prefix", "skribbltypo");
      __publicField(this, "_printEnabledSetting", new BooleanExtensionSetting("logging.printLogEnabled", true).withName("Print Logs").withDescription("Print extension event logs to the browser console"));
      __publicField(this, "_loggers", []);
      __publicField(this, "_logLevelSettings", /* @__PURE__ */ new Map());
      __publicField(this, "_events$", new Subject$1());
      __publicField(this, "_recordedEvents", []);
      this._events$.subscribe((event) => {
        this.printEvent(event);
        this._recordedEvents.push(event);
      });
    }
    trackLoggerInstance(logger) {
      const setting = new ExtensionSetting(`logging.logLevel.${logger.boundTo}`, LoggingService.defaultLogLevel).withName(`Log level for ${logger.boundTo}`).withDescription(`The minimum log level filter for the logger bound to ${logger.boundTo}`);
      setting.changes$.subscribe((level) => logger.level = level);
      this._logLevelSettings.set(logger, setting);
      this._loggers.push(logger);
      logger.events$.pipe(
        withLatestFrom(this._printEnabledSetting.changes$)
      ).subscribe(([event, printEnabled]) => {
        if (printEnabled) this._events$.next(event);
      });
    }
    getTimestamp(date) {
      return `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}.${date.getMilliseconds()}`;
    }
    getLevelString(level) {
      switch (level) {
        case "debug":
          return "DEB ";
        case "info":
          return "INFO";
        case "warn":
          return "WARN";
        case "error":
          return "ERR ";
      }
    }
    printEvent(event) {
      console.log(
        `%c ${this.getTimestamp(event.date)} %c[${this._prefix}] [${this.getLevelString(event.logLevel)}]  (${event.bindingName})`,
        LoggingService.styles.date,
        LoggingService.styles[event.logLevel],
        event.message,
        ...event.data
      );
    }
    get recordedEvents() {
      return this._recordedEvents;
    }
    get loggers() {
      return this._loggers;
    }
    get printEnabledSetting() {
      return this._printEnabledSetting;
    }
    getLogLevelSetting(logger) {
      const setting = this._logLevelSettings.get(logger);
      if (!setting) throw new Error(`Logger settings for ${logger.boundTo} not found`);
      return setting.asFrozen;
    }
  }, __name(_a, "LoggingService"), _a);
  __publicField2(LoggingService, "defaultLogLevel", "debug");
  __publicField2(LoggingService, "styles", {
    debug: "color: lightGray; font-weight: bold;",
    info: "color: lightBlue; font-weight: bold;",
    warn: "color: orange; font-weight: bold;",
    error: "color: red; font-weight: bold;",
    date: "color: darkGrey; font-weight: light;"
  });
  LoggingService = __decorateClass$20([
    injectable()
  ], LoggingService);
  const _ApplicationEvent = class _ApplicationEvent {
  };
  __name(_ApplicationEvent, "ApplicationEvent");
  let ApplicationEvent = _ApplicationEvent;
  const loggerFactory = Symbol("loggerFactory");
  var __defProp$1$ = Object.defineProperty;
  var __getOwnPropDesc$Y = Object.getOwnPropertyDescriptor;
  var __decorateClass$1$ = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$Y(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1$(target, key2, result);
    return result;
  }, "__decorateClass$1$");
  var __decorateParam$u = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$u");
  let EventsService = (_b = class {
    constructor(loggerFactory2) {
      __publicField(this, "_logger");
      /**
       * Subject that contains all application events
       * @private
       */
      __publicField(this, "_events$", new Subject$1());
      this._logger = loggerFactory2(this);
    }
    /**
     * Observable that emits all application events that are recognized by registered event processors
     */
    get events$() {
      return this._events$.asObservable();
    }
    /**
     * Publishes an event to the central application event stream
     * @param event
     */
    publishEvent(event) {
      this._events$.next(event);
    }
  }, __name(_b, "EventsService"), _b);
  EventsService = __decorateClass$1$([
    injectable(),
    __decorateParam$u(0, inject(loggerFactory))
  ], EventsService);
  var __defProp$1_ = Object.defineProperty;
  var __getOwnPropDesc$X = Object.getOwnPropertyDescriptor;
  var __decorateClass$1_ = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$X(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1_(target, key2, result);
    return result;
  }, "__decorateClass$1_");
  var __decorateParam$t = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$t");
  let EventProcessor = (_c = class {
    constructor(loggerFactory2, _eventsService) {
      __publicField(this, "_logger");
      this._eventsService = _eventsService;
      this._logger = loggerFactory2(this);
    }
    start() {
      this._logger.info("Starting event processor");
      const events = this.streamEvents();
      if (events instanceof Promise) {
        events.then((stream) => this.publishEvents(stream));
      } else {
        this.publishEvents(events);
      }
    }
    publishEvents(events$) {
      events$.subscribe((event) => {
        this._eventsService.publishEvent(event);
      });
    }
    /**
     * Check if an event is of the type this processor emits
     * @param event
     */
    isProcessorEvent(event) {
      return event instanceof this.eventType;
    }
  }, __name(_c, "EventProcessor"), _c);
  __decorateClass$1_([
    postConstruct()
  ], EventProcessor.prototype, "start", 1);
  EventProcessor = __decorateClass$1_([
    injectable(),
    __decorateParam$t(0, inject(loggerFactory)),
    __decorateParam$t(1, inject(EventsService))
  ], EventProcessor);
  var __defProp$1Z = Object.defineProperty;
  var __getOwnPropDesc$W = Object.getOwnPropertyDescriptor;
  var __decorateClass$1Z = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$W(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1Z(target, key2, result);
    return result;
  }, "__decorateClass$1Z");
  var __decorateParam$s = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$s");
  let EventListener = (_d = class {
    constructor(_eventsService, loggerFactory2) {
      /**
       * Reference to the event observable that filters all events from the event service that are of this type
       * @private
       */
      __publicField(this, "_events$");
      __publicField(this, "_logger");
      this._eventsService = _eventsService;
      this._logger = loggerFactory2(this);
      this._events$ = _eventsService.events$.pipe(
        filter((event) => this._processor.isProcessorEvent(event))
      );
    }
    /**
     * Observable that emits all events of this type
     */
    get events$() {
      return this._events$;
    }
  }, __name(_d, "EventListener"), _d);
  EventListener = __decorateClass$1Z([
    injectable(),
    __decorateParam$s(0, inject(EventsService)),
    __decorateParam$s(1, inject(loggerFactory))
  ], EventListener);
  var __defProp$1Y = Object.defineProperty;
  var __getOwnPropDesc$V = Object.getOwnPropertyDescriptor;
  var __decorateClass$1Y = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$V(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1Y(target, key2, result);
    return result;
  }, "__decorateClass$1Y");
  const _CanvasClearedEvent = class _CanvasClearedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_CanvasClearedEvent, "CanvasClearedEvent");
  let CanvasClearedEvent = _CanvasClearedEvent;
  let CanvasClearedEventProcessor = (_e = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "eventType", CanvasClearedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      document.addEventListener("logCanvasClear", (event) => {
        const data = event.detail;
        events.next(new CanvasClearedEvent(data));
      });
      return events;
    }
  }, __name(_e, "CanvasClearedEventProcessor"), _e);
  CanvasClearedEventProcessor = __decorateClass$1Y([
    injectable()
  ], CanvasClearedEventProcessor);
  let CanvasClearedEventListener = (_f = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_f, "CanvasClearedEventListener"), _f);
  __decorateClass$1Y([
    inject(CanvasClearedEventProcessor)
  ], CanvasClearedEventListener.prototype, "_processor", 2);
  CanvasClearedEventListener = __decorateClass$1Y([
    injectable()
  ], CanvasClearedEventListener);
  const canvasClearedEventRegistration = {
    listenerType: CanvasClearedEventListener,
    processorType: CanvasClearedEventProcessor
  };
  const _Chat_controls = class _Chat_controls extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, null, safe_not_equal, {});
    }
  };
  __name(_Chat_controls, "Chat_controls");
  let Chat_controls = _Chat_controls;
  const _InterpretableResult = class _InterpretableResult {
    constructor(interpretable, message) {
      this.interpretable = interpretable;
      this.message = message;
    }
  };
  __name(_InterpretableResult, "InterpretableResult");
  let InterpretableResult = _InterpretableResult;
  const _InterpretableSuccess = class _InterpretableSuccess extends InterpretableResult {
  };
  __name(_InterpretableSuccess, "InterpretableSuccess");
  let InterpretableSuccess = _InterpretableSuccess;
  const _DeferredInterpretableBuilder = class _DeferredInterpretableBuilder {
    /**
     * Create a new interpretable chain builder
     * @param _interpretableBuilder factory for an interpretable which provides a execution context that can be set later in the builder
     */
    constructor(_interpretableBuilder) {
      __publicField(this, "_execute");
      __publicField(this, "_builtInterpretable");
      this._interpretableBuilder = _interpretableBuilder;
    }
    /**
     * Set the execution function of the interpretable to a new interpretable
     * and return the new builder
     * @param nextInterpretableBuilder
     */
    chainInterpretable(nextInterpretableBuilder) {
      const builder = new _DeferredInterpretableBuilder(nextInterpretableBuilder);
      this.setExecute(async (result, context) => {
        return { next: builder.build(), result: new InterpretableSuccess(this.interpretable) };
      });
      return builder;
    }
    /**
     * Set the execution function of the interpretable to a final function
     * @param execute
     */
    setExecute(execute) {
      this._execute = execute;
      return this;
    }
    /**
     * Build the current deferred interpretable and return it
     */
    build() {
      if (!this._execute || !this._interpretableBuilder) throw new Error("Cannot build interpretable without execute function");
      const execute = this._execute;
      this._builtInterpretable = this._interpretableBuilder((result, context) => execute(result, context));
      return this._builtInterpretable;
    }
    /**
     * The built interpretable, if built, else undefined
     */
    get interpretable() {
      if (!this._builtInterpretable) throw new Error("Interpretable has not yet been built");
      return this._builtInterpretable;
    }
  };
  __name(_DeferredInterpretableBuilder, "DeferredInterpretableBuilder");
  let DeferredInterpretableBuilder = _DeferredInterpretableBuilder;
  const _InterpretableDeferResult = class _InterpretableDeferResult extends InterpretableSuccess {
    constructor(interpretable, message, run2) {
      super(interpretable, message);
      this.run = run2;
    }
  };
  __name(_InterpretableDeferResult, "InterpretableDeferResult");
  let InterpretableDeferResult = _InterpretableDeferResult;
  const _CommandParamsBuilder = class _CommandParamsBuilder {
    constructor(_interpretableDeferred, _precedingParams = []) {
      this._interpretableDeferred = _interpretableDeferred;
      this._precedingParams = _precedingParams;
    }
    /**
     * Create a interpretable chain root for a command
     * @param command
     */
    static forCommand(command) {
      const deferredBuilder = new DeferredInterpretableBuilder((execute) => command.setExecute(execute));
      return new _CommandParamsBuilder(deferredBuilder);
    }
    /**
     * Add a parameter to the chain and return the builder to append to the new param
     * @param param
     */
    addParam(param) {
      const nextDeferredBuilder = this._interpretableDeferred.chainInterpretable((execute) => {
        return param.withAction(execute);
      });
      return new _CommandParamsBuilder(
        nextDeferredBuilder,
        [...this._precedingParams, param]
      );
    }
    /**
     * Set the execution of the chain end
     * @param run
     */
    run(run2) {
      this._interpretableDeferred.setExecute(async (result) => {
        const interpretable = this._interpretableDeferred.interpretable;
        const response = new InterpretableDeferResult(interpretable, void 0, () => run2(result, interpretable));
        return { result: response };
      });
      return this._precedingParams;
    }
    /**
     * Build the current chain end or beginning
     * Can only be used after the whole chain up to this point has been initialized
     * Returns all arguments in the chain in correct order
     */
    build() {
      this._interpretableDeferred.build();
    }
  };
  __name(_CommandParamsBuilder, "CommandParamsBuilder");
  let CommandParamsBuilder = _CommandParamsBuilder;
  const _InterpretableError = class _InterpretableError extends InterpretableResult {
  };
  __name(_InterpretableError, "InterpretableError");
  let InterpretableError = _InterpretableError;
  const _InterpretableCommandPartialMatch = class _InterpretableCommandPartialMatch extends InterpretableError {
  };
  __name(_InterpretableCommandPartialMatch, "InterpretableCommandPartialMatch");
  let InterpretableCommandPartialMatch = _InterpretableCommandPartialMatch;
  const _ExtensionCommand = class _ExtensionCommand {
    constructor(_defaultId, _feature, _name, _description, _defaultEnabled = true) {
      __publicField(this, "_id");
      __publicField(this, "_enabledSetting");
      __publicField(this, "_execute");
      __publicField(this, "_params", []);
      this._defaultId = _defaultId;
      this._feature = _feature;
      this._name = _name;
      this._description = _description;
      this._defaultEnabled = _defaultEnabled;
      this._id = new ExtensionSetting(`command.${this._defaultId}.name`, this._defaultId, this._feature);
      this._enabledSetting = new ExtensionSetting(
        `command.${this._defaultId}.enabled`,
        this._defaultEnabled,
        this._feature
      );
    }
    /**
     * The human-readable name of the command
     */
    get name() {
      return this._name;
    }
    /**
     * The default ID of the command
     */
    get defaultId() {
      return this._defaultId;
    }
    /**
     * The description of the command
     */
    get description() {
      return this._description;
    }
    /**
     * The command ID setting, which stores the command interpreter name
     */
    get idSetting() {
      return this._id.asFrozen;
    }
    /**
     * The enabled setting, which stores whether the command is enabled for interpretation
     */
    get enabledSetting() {
      return this._enabledSetting.asFrozen;
    }
    /**
     * The parameters of the command
     */
    get params() {
      return this._params;
    }
    /**
     * Interpret the command by parsing its name and passing down the source context
     * @param args
     * @param source
     * @param context
     */
    async interpret(args, source, context) {
      const interpreterName = await firstValueFrom(this._id.changes$);
      if (args.startsWith(interpreterName)) {
        const remainder = args.substring(interpreterName.length);
        return { context, remainder, result: {} };
      }
      if (args.length > 0 && interpreterName.startsWith(args)) {
        throw new InterpretableCommandPartialMatch(this);
      }
      return null;
    }
    /**
     * Execute the bound action on the result of the interpretation
     * @param result
     * @param context
     */
    execute(result, context) {
      var _a2;
      return ((_a2 = this._execute) == null ? void 0 : _a2.call(this, result, context)) ?? Promise.resolve({ result: new InterpretableSuccess(this) });
    }
    /**
     * Set the action for the following interpretation chain
     * @param execute
     */
    setExecute(execute) {
      this._execute = execute;
      return this;
    }
    /**
     * Set an action for immediate execution without further interpretation
     * @param run
     */
    run(run2) {
      this.setExecute(async () => {
        const response = new InterpretableDeferResult(this, void 0, () => run2(this));
        return { result: response };
      });
      return this;
    }
    /**
     * Add arguments to the command interpretation chain using a builder
     * @param builderAction
     */
    withParameters(builderAction) {
      const builder = CommandParamsBuilder.forCommand(this);
      this._params = builderAction(builder);
      builder.build();
      return this;
    }
  };
  __name(_ExtensionCommand, "ExtensionCommand");
  let ExtensionCommand = _ExtensionCommand;
  var __defProp$1X = Object.defineProperty;
  var __getOwnPropDesc$U = Object.getOwnPropertyDescriptor;
  var __decorateClass$1X = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$U(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1X(target, key2, result);
    return result;
  }, "__decorateClass$1X");
  var __decorateParam$r = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$r");
  let CommandsService = (_g = class {
    constructor(loggerFactory2) {
      __publicField(this, "_logger");
      __publicField(this, "_registeredCommands", []);
      __publicField(this, "_activeCommands$", new BehaviorSubject([]));
      this._logger = loggerFactory2(this);
    }
    /**
     * Register a command to the service
     * @param command
     */
    registerCommand(command) {
      this._registeredCommands.push(command);
      this._activeCommands$.next(this._registeredCommands);
    }
    /**
     * Remove a command from the service
     * @param command
     */
    removeCommand(command) {
      this._registeredCommands = this._registeredCommands.filter((c) => c !== command);
      this._activeCommands$.next(this._registeredCommands);
    }
    /**
     * Get an observable containing all registered and active commands
     */
    get commands$() {
      return this._activeCommands$.pipe(
        switchMap((commands) => {
          const values = commands.map(
            (command) => command.enabledSetting.changes$.pipe(map((enabled) => ({ command, enabled })))
          );
          return combineLatest$1(...values);
        }),
        map((commands) => commands.filter((c) => c.enabled).map((command) => command.command))
      );
    }
    /**
     * Execute a command with given args as interpretable chain and return with resulting command context
     * @param command
     * @param args
     */
    async executeCommand(command, args) {
      const context = {
        parameters: command.params,
        command
      };
      return { result: await this.executeInterpretable(command, args, {}, context), context };
    }
    /**
     * Execute an interpretable chain on given args and context
     * @param interpretable
     * @param args
     * @param source
     * @param context
     */
    async executeInterpretable(interpretable, args, source, context) {
      let interpretation;
      try {
        interpretation = await interpretable.interpret(args, source, context);
      } catch (e) {
        if (e instanceof InterpretableError) return e;
        else throw e;
      }
      if (interpretation === null) {
        return null;
      }
      let result;
      try {
        result = await interpretable.execute(interpretation.result, context);
      } catch (e) {
        if (e instanceof InterpretableError) return e;
        else throw e;
      }
      this._logger.debug("Interpretable execution result", interpretable, result);
      if (result.next !== void 0) {
        return await this.executeInterpretable(
          result.next,
          interpretation.remainder,
          interpretation.result,
          context
        );
      } else return result.result;
    }
  }, __name(_g, "CommandsService"), _g);
  CommandsService = __decorateClass$1X([
    injectable(),
    __decorateParam$r(0, inject(loggerFactory))
  ], CommandsService);
  var __defProp$1W = Object.defineProperty;
  var __getOwnPropDesc$T = Object.getOwnPropertyDescriptor;
  var __decorateClass$1W = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$T(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1W(target, key2, result);
    return result;
  }, "__decorateClass$1W");
  var __decorateParam$q = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$q");
  let HotkeysService = (_h = class {
    constructor(loggerFactory2) {
      __publicField(this, "_logger");
      __publicField(this, "_registeredHotkeys", []);
      this._logger = loggerFactory2(this);
    }
    /**
     * Register a hotkey to be executed when the combo is pressed
     * @param hotkey
     */
    registerHotkey(hotkey) {
      if (this._registeredHotkeys.includes(hotkey)) {
        this._logger.warn("Attempted to register a hotkey that was already registered", hotkey);
        return;
      }
      this._registeredHotkeys.push(hotkey);
      this._logger.debug("Registered hotkey", hotkey);
    }
    /**
     * Remove a hotkey from the registered hotkeys; will no longer be listened for
     * @param hotkey
     */
    removeHotkey(hotkey) {
      const lengthBefore = this._registeredHotkeys.length;
      this._registeredHotkeys = this._registeredHotkeys.filter((h) => h !== hotkey);
      if (lengthBefore === this._registeredHotkeys.length) {
        this._logger.warn("Attempted to remove a hotkey that was not registered", hotkey);
      }
      this._logger.debug("Removed hotkey", hotkey);
    }
    get registeredHotkeys() {
      return [...this._registeredHotkeys];
    }
    /**
     * Set the hotkey combo for a hotkey action
     * @param hotkey
     * @param value
     */
    async setHotkeyCombo(hotkey, value) {
      try {
        if (value.length === 0) {
          this._logger.debug("Saving empty hotkey combo; disabling hotkey");
          await hotkey.enabledSetting.setValue(false);
        }
        await hotkey.comboSetting.setValue(value);
      } catch (e) {
        this._logger.error("Error updating hotkey combo", e);
        throw e;
      }
      this._logger.info("Updated hotkey combo", hotkey.name, value);
    }
    /**
     * Resets the hotkey combo to the default value
     * @param hotkey
     */
    async resetHotkeyCombo(hotkey) {
      try {
        await hotkey.comboSetting.setValue([...hotkey.defaultCombo ?? []]);
        if (hotkey.defaultCombo === void 0 || hotkey.defaultCombo.length === 0) {
          this._logger.debug("Resetting hotkey combo to empty; disabling hotkey");
          await hotkey.enabledSetting.setValue(false);
        }
      } catch (e) {
        this._logger.error("Error updating hotkey combo", e);
        throw e;
      }
      this._logger.info("Reset hotkey combo", hotkey.name);
      return [...hotkey.defaultCombo ?? []];
    }
  }, __name(_h, "HotkeysService"), _h);
  HotkeysService = __decorateClass$1W([
    injectable(),
    __decorateParam$q(0, inject(loggerFactory))
  ], HotkeysService);
  var __defProp$1V = Object.defineProperty;
  var __getOwnPropDesc$S = Object.getOwnPropertyDescriptor;
  var __decorateClass$1V = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$S(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1V(target, key2, result);
    return result;
  }, "__decorateClass$1V");
  var __decorateParam$p = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$p");
  let TooltipsService = (_i = class {
    constructor(loggerFactory2) {
      __publicField(this, "_logger");
      __publicField(this, "_registeredTooltips", /* @__PURE__ */ new Map());
      __publicField(this, "_changes", new Subject$1());
      __publicField(this, "_tooltipClass", "typo-tooltip-registered");
      /**
       * When elements are removed from the DOM, check if they or their children were registered as tooltips, and remove them
       * @private
       */
      __publicField(this, "_observer", new MutationObserver((mutations) => {
        let removed = false;
        mutations.forEach((mutation) => {
          if (mutation.type === "childList") {
            mutation.removedNodes.forEach((node) => {
              if (node instanceof HTMLElement) {
                const tooltips = this.getTooltipsOfElement(node);
                tooltips.forEach((element2) => {
                  if (element2 instanceof HTMLElement) {
                    this._logger.debug("Removing tooltip from element", element2);
                    this._registeredTooltips.delete(element2);
                    removed = true;
                  }
                });
              }
            });
          }
        });
        if (removed) this._changes.next();
      }));
      this._logger = loggerFactory2(this);
      this._observer.observe(document.body, { childList: true, subtree: true });
    }
    /**
     * Register a tooltip for an element
     * If this element has already a tooltip registered, it will be overwritten
     * @param element
     * @param params
     * @param feature
     */
    registerTooltip(element2, params, feature) {
      if (this._registeredTooltips.has(element2)) {
        this._logger.debug("Overriding tooltip for element", element2, params, feature);
      }
      const tooltip = { target: element2, ...params, feature };
      this._registeredTooltips.set(element2, tooltip);
      element2.classList.toggle(this._tooltipClass, true);
      this._changes.next();
      this._logger.debug("Registered tooltip", tooltip);
    }
    get tooltips$() {
      return this._changes.pipe(
        startWith(null),
        map(() => Array.from(this._registeredTooltips.values()))
      );
    }
    /**
     * Searches for tooltips in the given element and its children
     * @param element
     */
    getTooltipsOfElement(element2) {
      const isTooltip = element2.classList.contains(this._tooltipClass);
      const childTooltips = [...element2.querySelectorAll(`.${this._tooltipClass}`)].filter((e) => e instanceof HTMLElement);
      return isTooltip ? [element2, ...childTooltips] : childTooltips;
    }
    /**
     * Searches for tooltips in the given element and its parents
     * @param element
     */
    getTooltipsUntilElement(element2) {
      const tooltips = [];
      let currentTooltip = element2.closest(`.${this._tooltipClass}`);
      while (currentTooltip != null && currentTooltip.parentElement instanceof HTMLElement) {
        tooltips.push(currentTooltip);
        currentTooltip = currentTooltip.parentElement.closest(`.${this._tooltipClass}`);
      }
      return tooltips;
    }
  }, __name(_i, "TooltipsService"), _i);
  TooltipsService = __decorateClass$1V([
    injectable(),
    __decorateParam$p(0, inject(loggerFactory))
  ], TooltipsService);
  var __defProp$1U = Object.defineProperty;
  var __getOwnPropDesc$R = Object.getOwnPropertyDescriptor;
  var __decorateClass$1U = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$R(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1U(target, key2, result);
    return result;
  }, "__decorateClass$1U");
  var __decorateParam$o = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$o");
  let OnboardingService = (_j = class {
    constructor(loggerFactory2) {
      __publicField(this, "_logger");
      __publicField(this, "_completedTasks", new ExtensionSetting("completed_onboarding_tasks", []));
      __publicField(this, "_tasks", []);
      __publicField(this, "_taskCompleted$", new Subject$1());
      this._logger = loggerFactory2(this);
    }
    registerTask(registration) {
      var _a2;
      const taskId = `${((_a2 = registration.feature) == null ? void 0 : _a2.name) ?? "global"}_${registration.key}`;
      const task = {
        name: registration.name,
        description: registration.description,
        key: taskId,
        start: registration.start,
        priority: registration.priority ?? Number.MAX_SAFE_INTEGER
      };
      this._tasks.push(task);
      return {
        complete: /* @__PURE__ */ __name(() => this._completedTasks.changes$.pipe(
          take(1)
        ).subscribe((tasks) => {
          if (!tasks.includes(taskId)) {
            tasks.push(taskId);
            this._completedTasks.setValue(tasks);
            this._taskCompleted$.next(task);
          }
        }), "complete"),
        clear: /* @__PURE__ */ __name(() => this._completedTasks.changes$.pipe(
          take(1)
        ).subscribe((tasks) => {
          if (tasks.includes(taskId)) {
            tasks.splice(tasks.indexOf(taskId), 1);
            this._completedTasks.setValue(tasks);
          }
        }), "clear"),
        completed: /* @__PURE__ */ __name(async () => {
          const tasks = await this._completedTasks.getValue();
          return tasks.includes(taskId);
        }, "completed"),
        task
      };
    }
    async getOnboardingTasks() {
      const completedTasks = await this._completedTasks.getValue();
      return Promise.all(this._tasks.map(async (task) => {
        return {
          ...task,
          completed: completedTasks.includes(task.key)
        };
      }));
    }
    get taskCompleted$() {
      return this._taskCompleted$.asObservable();
    }
  }, __name(_j, "OnboardingService"), _j);
  OnboardingService = __decorateClass$1U([
    injectable(),
    __decorateParam$o(0, inject(loggerFactory))
  ], OnboardingService);
  var __defProp$1T = Object.defineProperty;
  var __getOwnPropDesc$Q = Object.getOwnPropertyDescriptor;
  var __decorateClass$1T = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$Q(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1T(target, key2, result);
    return result;
  }, "__decorateClass$1T");
  var __decorateParam$n = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$n");
  let TypoFeature = (_k = class {
    constructor(loggerFactory2, _hotkeysService, _tooltipsService, _commandsService, _onboardingService) {
      __publicField(this, "featureEnabledDefault", true);
      __publicField(this, "_isActivated", false);
      __publicField(this, "_hotkeys", []);
      __publicField(this, "_settings", []);
      __publicField(this, "_commands", []);
      __publicField(this, "onboardingTaskFactories", []);
      __publicField(this, "toggleEnabled", true);
      __publicField(this, "developerFeature", false);
      __publicField(this, "_isActivatedSetting", new BooleanExtensionSetting("isActivated", this.featureEnabledDefault, this).withName("Activated").withDescription("Enable or disable the feature. Disabled features will reset and remove every functionality, mods and hotkeys."));
      __publicField(this, "_logger");
      this._hotkeysService = _hotkeysService;
      this._tooltipsService = _tooltipsService;
      this._commandsService = _commandsService;
      this._onboardingService = _onboardingService;
      this._logger = loggerFactory2(this);
    }
    /**
     * Services that are bound to the lifecycle of the feature with init/reset methods
     * @protected
     */
    get boundServices() {
      return [];
    }
    /**
     * Add a hotkey to the user accessible hotkey configuration
     * @param action
     * @protected
     */
    useHotkey(action) {
      this._hotkeys.push(action);
      return action;
    }
    useOnboardingTask(registration) {
      return new Promise((resolve2) => {
        const factory = /* @__PURE__ */ __name(() => {
          const startWithActivation = /* @__PURE__ */ __name(async () => {
            if (!this._isActivated) {
              this._logger.debug("Activating feature for onboarding task", registration.key);
              await this.activate();
            }
            return await registration.start() ?? true;
          }, "startWithActivation");
          const handle = this._onboardingService.registerTask({ ...registration, feature: this, start: startWithActivation });
          resolve2(handle);
        }, "factory");
        this.onboardingTaskFactories.push(factory);
      });
    }
    /**
     * Add a command to the feature command configuration
     * @param command
     * @protected
     */
    useCommand(command) {
      this._commands.push(command);
      return command;
    }
    /**
     * Add a setting to the user accessible setting configuration
     * @param setting
     * @protected
     */
    useSetting(setting) {
      this._settings.push(setting);
      return setting;
    }
    /**
     * All configured hotkeys for this feature
     */
    get hotkeys() {
      return this._hotkeys;
    }
    get settings() {
      return this._settings;
    }
    get commands() {
      return this._commands;
    }
    get featureTags() {
      return this.tags;
    }
    get activated() {
      return this._isActivated;
    }
    /**
     * A component to display feature customization settings
     */
    get featureManagementComponent() {
      return void 0;
    }
    /**
     * A component to display feature information or tutorial
     */
    get featureInfoComponent() {
      return void 0;
    }
    get hasDetailComponents() {
      return this.hotkeys.length > 0 || this.commands.length > 0 || this.featureManagementComponent !== void 0 || this.featureInfoComponent !== void 0 || this._settings.length > 0;
    }
    postConstruct() {
      this._logger.debug("onConstruct not implemented");
    }
    onActivate() {
      this._logger.debug("onActivate not implemented");
    }
    onDestroy() {
      this._logger.debug("onDestroy not implemented");
    }
    init() {
      this._isActivatedSetting.setDefaultValue(this.featureEnabledDefault);
      const loadActivation = /* @__PURE__ */ __name(() => {
        this._isActivatedSetting.getValue().then((value) => {
          this._logger.debug("Feature loaded with activation state", value);
          if (value) this.activate();
        });
      }, "loadActivation");
      const postConstruct2 = this.postConstruct();
      if (postConstruct2 instanceof Promise) postConstruct2.then(loadActivation);
      else loadActivation();
      for (const factory of this.onboardingTaskFactories) {
        factory();
      }
    }
    /**
     * Activate the feature.
     * The feature will be activated and run.
     */
    async activate() {
      if (this._isActivated) {
        this._logger.warn("Attempted to activate feature while already activated");
        throw new Error("Feature is already activated");
      }
      this._logger.info("Activating feature");
      await Promise.all(this.boundServices.map((service) => service.onFeatureActivate()));
      const activate = this.onActivate();
      if (activate instanceof Promise) await activate;
      this._isActivated = true;
      await this._isActivatedSetting.setValue(true);
      if (this._hotkeys.length !== 0) {
        this._logger.debug("Registering feature hotkeys", this._hotkeys);
        this._hotkeys.forEach((hotkey) => this._hotkeysService.registerHotkey(hotkey));
      }
      for (const command of this._commands) {
        this._commandsService.registerCommand(command);
      }
    }
    /**
     * Destroy the feature.
     * The feature will be frozen and destroyed.
     * To re-run the feature, it needs to be activated again.
     */
    async destroy() {
      if (!this._isActivated) {
        this._logger.warn("Attempted to destroy feature without activation");
        throw new Error("Feature is not activated");
      }
      this._logger.info("Destroying feature");
      const destroy = this.onDestroy();
      if (destroy instanceof Promise) await destroy;
      this._isActivated = false;
      await this._isActivatedSetting.setValue(false);
      await Promise.all(this.boundServices.map((service) => service.onFeatureDestroy()));
      if (this._hotkeys.length !== 0) {
        this._logger.debug("Removing feature hotkeys", this._hotkeys);
        this._hotkeys.forEach((hotkey) => this._hotkeysService.removeHotkey(hotkey));
      }
      for (const command of this._commands) {
        this._commandsService.removeCommand(command);
      }
    }
    get activated$() {
      return this._isActivatedSetting.changes$;
    }
    registerTooltip(node, params) {
      this._logger.debug("Registering tooltip", node, params);
      this._tooltipsService.registerTooltip(node, params, this);
    }
    get createTooltip() {
      return (node, params) => {
        this.registerTooltip(node, params);
        return {
          update: /* @__PURE__ */ __name((params2) => {
            this.registerTooltip(node, params2);
          }, "update")
        };
      };
    }
  }, __name(_k, "TypoFeature"), _k);
  __decorateClass$1T([
    postConstruct()
  ], TypoFeature.prototype, "init", 1);
  TypoFeature = __decorateClass$1T([
    injectable(),
    __decorateParam$n(0, inject(loggerFactory)),
    __decorateParam$n(1, inject(HotkeysService)),
    __decorateParam$n(2, inject(TooltipsService)),
    __decorateParam$n(3, inject(CommandsService)),
    __decorateParam$n(4, inject(OnboardingService))
  ], TypoFeature);
  var __defProp$1S = Object.defineProperty;
  var __getOwnPropDesc$P = Object.getOwnPropertyDescriptor;
  var __decorateClass$1S = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$P(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1S(target, key2, result);
    return result;
  }, "__decorateClass$1S");
  let LoggerService = (_l = class {
    constructor() {
      __publicField(this, "_level", "debug");
      __publicField(this, "_levels", {
        "debug": 1,
        "info": 2,
        "warn": 3,
        "error": 4
      });
      __publicField(this, "_boundTo");
      __publicField(this, "_events$", new Subject$1());
    }
    set level(level) {
      this._level = level;
    }
    get level() {
      return this._level;
    }
    bindTo(value) {
      this._boundTo = value;
      return this;
    }
    get boundTo() {
      var _a2;
      return ((_a2 = this._boundTo) == null ? void 0 : _a2.constructor.name) ?? " / ";
    }
    get boundType() {
      return this._boundTo instanceof TypoFeature ? "feature" : "other";
    }
    get events$() {
      return this._events$.asObservable();
    }
    /**
     * Logs a message to the console.
     * @param message The message to log.
     * @param data Additional data that will be inspectable in the console.
     */
    debug(message, ...data) {
      if (this._levels[this.level] > this._levels["debug"]) return;
      this._events$.next({
        logLevel: "debug",
        message,
        data,
        date: /* @__PURE__ */ new Date(),
        bindingName: this.boundTo
      });
    }
    /**
     * Logs a message to the console.
     * @param message The message to log.
     * @param data Additional data that will be inspectable in the console.
     */
    info(message, ...data) {
      if (this._levels[this.level] > this._levels["info"]) return;
      this._events$.next({
        logLevel: "info",
        message,
        data,
        date: /* @__PURE__ */ new Date(),
        bindingName: this.boundTo
      });
    }
    /**
     * Logs a warning to the console.
     * @param message The warning to log.
     * @param data Additional data that will be inspectable in the console.
     */
    warn(message, ...data) {
      if (this._levels[this.level] > this._levels["warn"]) return;
      this._events$.next({
        logLevel: "warn",
        message,
        data,
        date: /* @__PURE__ */ new Date(),
        bindingName: this.boundTo
      });
    }
    /**
     * Logs an error to the console.
     * @param message The error to log.
     * @param data Additional data that will be inspectable in the console.
     */
    error(message, ...data) {
      if (this._levels[this.level] > this._levels["error"]) return;
      this._events$.next({
        logLevel: "error",
        message,
        data,
        date: /* @__PURE__ */ new Date(),
        bindingName: this.boundTo
      });
    }
  }, __name(_l, "LoggerService"), _l);
  LoggerService = __decorateClass$1S([
    injectable()
  ], LoggerService);
  var __defProp$1R = Object.defineProperty;
  var __getOwnPropDesc$O = Object.getOwnPropertyDescriptor;
  var __decorateClass$1R = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$O(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1R(target, key2, result);
    return result;
  }, "__decorateClass$1R");
  var __decorateParam$m = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$m");
  let Setup = (_m = class {
    constructor(loggerFactory2) {
      __publicField(this, "_logger");
      __publicField(this, "_setupPromise");
      this._logger = loggerFactory2(this);
    }
    complete() {
      if (this._setupPromise === void 0) {
        this._logger.info("Running setup");
        this._setupPromise = this.runSetup();
        this._setupPromise.then(() => {
          this._logger.info("Setup completed");
        });
      }
      return this._setupPromise;
    }
  }, __name(_m, "Setup"), _m);
  Setup = __decorateClass$1R([
    injectable(),
    __decorateParam$m(0, inject(loggerFactory))
  ], Setup);
  const appendElement = /* @__PURE__ */ __name((sourceElement, position, parentElement) => {
    parentElement.insertAdjacentElement(position, sourceElement);
    return sourceElement;
  }, "appendElement");
  const createElement = /* @__PURE__ */ __name((htmlString) => {
    const template = document.createElement("template");
    template.innerHTML = htmlString.trim();
    return template.content.firstChild;
  }, "createElement");
  const decoratorSymbol = Symbol("earlySetup");
  function earlySetup() {
    return function(target) {
      Reflect.defineMetadata(decoratorSymbol, true, target);
    };
  }
  __name(earlySetup, "earlySetup");
  function isEarlySetup(target) {
    return Reflect.getMetadata(decoratorSymbol, target);
  }
  __name(isEarlySetup, "isEarlySetup");
  var __defProp$1Q = Object.defineProperty;
  var __getOwnPropDesc$N = Object.getOwnPropertyDescriptor;
  var __decorateClass$1Q = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$N(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1Q(target, key2, result);
    return result;
  }, "__decorateClass$1Q");
  let GamePatchReadySetup = (_n = class extends Setup {
    constructor() {
      super(...arguments);
      __publicField(this, "_interceptor");
    }
    async runSetup() {
      return firstValueFrom(this._interceptor.patchLoaded$);
    }
  }, __name(_n, "GamePatchReadySetup"), _n);
  __decorateClass$1Q([
    inject(Interceptor)
  ], GamePatchReadySetup.prototype, "_interceptor", 2);
  GamePatchReadySetup = __decorateClass$1Q([
    earlySetup()
  ], GamePatchReadySetup);
  var __defProp$1P = Object.defineProperty;
  var __decorateClass$1P = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$1P(target, key2, result);
    return result;
  }, "__decorateClass$1P");
  const _ChatControlsSetup = class _ChatControlsSetup extends Setup {
    constructor() {
      super(...arguments);
      __publicField(this, "_gameReadySetup");
    }
    async runSetup() {
      await this._gameReadySetup.complete();
      const chatControls = appendElement(createElement("<div class='typo-chat-controls'></div>"), "afterbegin", requireElement("#game-wrapper"));
      new Chat_controls({
        target: chatControls
      });
      return chatControls;
    }
  };
  __name(_ChatControlsSetup, "ChatControlsSetup");
  let ChatControlsSetup = _ChatControlsSetup;
  __decorateClass$1P([
    inject(GamePatchReadySetup)
  ], ChatControlsSetup.prototype, "_gameReadySetup");
  const _HotkeyAction = class _HotkeyAction {
    constructor(_key, _name, _description, _feature, _action, defaultEnabled, _defaultCombo, _releaseAction, _preventWhenInputActive = true) {
      __publicField(this, "_enabledSetting");
      __publicField(this, "_comboSetting");
      __publicField(this, "_onceListeners", []);
      this._key = _key;
      this._name = _name;
      this._description = _description;
      this._feature = _feature;
      this._action = _action;
      this._defaultCombo = _defaultCombo;
      this._releaseAction = _releaseAction;
      this._preventWhenInputActive = _preventWhenInputActive;
      this._enabledSetting = new ExtensionSetting(
        `hotkey.${this._key}.enabled`,
        defaultEnabled === true && this._defaultCombo !== void 0 && this._defaultCombo.length > 0,
        this._feature
      );
      this._comboSetting = new ExtensionSetting(
        `hotkey.${this._key}.combo`,
        this._defaultCombo ?? [],
        this._feature
      );
    }
    get disabledOnInputs() {
      return this._preventWhenInputActive;
    }
    get name() {
      return this._name;
    }
    get description() {
      return this._description;
    }
    get enabledSetting() {
      return this._enabledSetting.asFrozen;
    }
    get comboSetting() {
      return this._comboSetting.asFrozen;
    }
    get defaultCombo() {
      return this._defaultCombo;
    }
    once(action) {
      this._onceListeners.push(action);
    }
    /**
     * checks if a key combination is active and matches, and executes if positive
     * return observable holds the result, if executed or not
     * @param keys a combination of key codes, see https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_code_values
     * @param inputActive
     */
    executeIfMatches(keys, inputActive) {
      return this._enabledSetting.changes$.pipe(
        take(1),
        switchMap((enabled) => {
          if (!enabled) return of(false);
          return this._comboSetting.changes$.pipe(
            take(1),
            map((combo) => !(this._preventWhenInputActive && inputActive) && combo.length > 0 ? combo : null),
            map((combo) => combo ? combo.length === keys.length && combo.every((key2) => keys.includes(key2)) : false)
          );
        }),
        switchMap((matches) => {
          if (!matches) return of(false);
          const result = this._action();
          const onceListeners = [...this._onceListeners];
          this._onceListeners = [];
          const results = onceListeners.map((listener) => listener());
          results.push(result);
          return Promise.all(results);
        })
      );
    }
    /**
     * Release the hotkey action if the current combo does not match the given keys
     * will also release if the hotkey is disabled
     * @param keys
     */
    releaseIfNotMatches(keys) {
      return this._comboSetting.changes$.pipe(
        take(1),
        map((combo) => combo ? combo.length === keys.length && combo.every((key2) => keys.includes(key2)) : false),
        switchMap((matches) => {
          if (matches) return of(false);
          if (this._releaseAction) {
            const result = this._releaseAction();
            return result instanceof Promise ? fromPromise(result).pipe(map(() => true)) : of(true);
          }
          return of(true);
        })
      );
    }
  };
  __name(_HotkeyAction, "HotkeyAction");
  let HotkeyAction = _HotkeyAction;
  var __defProp$1O = Object.defineProperty;
  var __getOwnPropDesc$M = Object.getOwnPropertyDescriptor;
  var __decorateClass$1O = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$M(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1O(target, key2, result);
    return result;
  }, "__decorateClass$1O");
  var __decorateParam$l = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$l");
  let GlobalSettingsService = (_o = class {
    constructor(loggerFactory2) {
      __publicField(this, "_globalHotkeysList", {
        exitModal: new HotkeyAction(
          "modal_close",
          "Close Modal",
          "Close open modals using a hotkey",
          void 0,
          () => {
            return void 0;
          },
          true,
          ["Escape"]
        )
      });
      __publicField(this, "_settings", {
        devMode: new BooleanExtensionSetting("devMode", false).withName("Developer Mode").withDescription("Enable some developer features & settings"),
        controlsPosition: new ChoiceExtensionSetting("controlsPosition", "topleft").withName("Control Icons Position").withDescription("The position where the typo controls are displayed").withChoices([
          { name: "Top Right", choice: "topright" },
          { name: "Top Left", choice: "topleft" },
          { name: "Bottom Right", choice: "bottomright" },
          { name: "Bottom Left", choice: "bottomleft" }
        ]),
        controlsDirection: new ChoiceExtensionSetting("controlsDirection", "vertical").withName("Control Icons Direction").withDescription("The direction where the typo controls are lined up").withChoices([
          { name: "Horizontal", choice: "horizontal" },
          { name: "Vertical", choice: "vertical" }
        ]),
        showLandingOutfit: new BooleanExtensionSetting("showLandingOutfit", true).withName("Customizer Outfit").withDescription("Show your current outfit on the avatar customizer")
      });
      __publicField(this, "_logger");
      this._logger = loggerFactory2(this);
    }
    get globalHotkeys() {
      return this._globalHotkeysList;
    }
    get globalHotkeysList() {
      return Object.values(this._globalHotkeysList);
    }
    get settings() {
      return this._settings;
    }
    get settingsList() {
      return Object.values(this._settings);
    }
  }, __name(_o, "GlobalSettingsService"), _o);
  GlobalSettingsService = __decorateClass$1O([
    injectable(),
    __decorateParam$l(0, inject(loggerFactory))
  ], GlobalSettingsService);
  function create_fragment$1A(ctx) {
    let div1;
    let div0;
    let div1_class_value;
    let mounted;
    let dispose;
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        attr(div0, "class", "typo-controls-mobile-expand svelte-1c97t9h");
        set_style(div0, "background-image", "var(--file-img-typo-gif)");
        attr(div1, "class", div1_class_value = "typo-controls " + /*$position*/
        ctx[2] + " " + /*$direction*/
        ctx[3] + " svelte-1c97t9h");
        toggle_class(
          div1,
          "expanded",
          /*mobileExpanded*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        ctx[9](div1);
        if (!mounted) {
          dispose = listen(
            div0,
            "click",
            /*click_handler*/
            ctx[8]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*$position, $direction*/
        12 && div1_class_value !== (div1_class_value = "typo-controls " + /*$position*/
        ctx2[2] + " " + /*$direction*/
        ctx2[3] + " svelte-1c97t9h")) {
          attr(div1, "class", div1_class_value);
        }
        if (dirty & /*$position, $direction, mobileExpanded*/
        14) {
          toggle_class(
            div1,
            "expanded",
            /*mobileExpanded*/
            ctx2[1]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        ctx[9](null);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$1A, "create_fragment$1A");
  function instance$1q($$self, $$props, $$invalidate) {
    let $position;
    let $direction;
    let elem;
    let resolve2;
    let { globalSettings } = $$props;
    const element2 = new Promise((res) => {
      resolve2 = res;
    });
    onMount(() => {
      resolve2(elem);
    });
    const position = globalSettings.settings.controlsPosition.store;
    component_subscribe($$self, position, (value) => $$invalidate(2, $position = value));
    const direction = globalSettings.settings.controlsDirection.store;
    component_subscribe($$self, direction, (value) => $$invalidate(3, $direction = value));
    let mobileExpanded = false;
    const click_handler2 = /* @__PURE__ */ __name(() => $$invalidate(1, mobileExpanded = !mobileExpanded), "click_handler");
    function div1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        elem = $$value;
        $$invalidate(0, elem);
      });
    }
    __name(div1_binding, "div1_binding");
    $$self.$$set = ($$props2) => {
      if ("globalSettings" in $$props2) $$invalidate(6, globalSettings = $$props2.globalSettings);
    };
    return [
      elem,
      mobileExpanded,
      $position,
      $direction,
      position,
      direction,
      globalSettings,
      element2,
      click_handler2,
      div1_binding
    ];
  }
  __name(instance$1q, "instance$1q");
  const _Controls = class _Controls extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1q, create_fragment$1A, safe_not_equal, { globalSettings: 6, element: 7 });
    }
    get element() {
      return this.$$.ctx[7];
    }
  };
  __name(_Controls, "Controls");
  let Controls = _Controls;
  var __defProp$1N = Object.defineProperty;
  var __decorateClass$1N = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$1N(target, key2, result);
    return result;
  }, "__decorateClass$1N");
  const _ControlsSetup = class _ControlsSetup extends Setup {
    constructor() {
      super(...arguments);
      __publicField(this, "_gameReadySetup");
      __publicField(this, "_settingsService");
    }
    async runSetup() {
      await this._gameReadySetup.complete();
      const component = new Controls({
        target: document.body,
        props: {
          globalSettings: this._settingsService
        }
      });
      return await component.element;
    }
  };
  __name(_ControlsSetup, "ControlsSetup");
  let ControlsSetup = _ControlsSetup;
  __decorateClass$1N([
    inject(GamePatchReadySetup)
  ], ControlsSetup.prototype, "_gameReadySetup");
  __decorateClass$1N([
    inject(GlobalSettingsService)
  ], ControlsSetup.prototype, "_settingsService");
  function create_fragment$1z(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        attr(div, "class", "typo-customizer-actions svelte-2foe7d");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        ctx[2](div);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        ctx[2](null);
      }
    };
  }
  __name(create_fragment$1z, "create_fragment$1z");
  function instance$1p($$self, $$props, $$invalidate) {
    let elem;
    let resolve2;
    const element2 = new Promise((res) => {
      resolve2 = res;
    });
    onMount(() => {
      resolve2(elem);
    });
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        elem = $$value;
        $$invalidate(0, elem);
      });
    }
    __name(div_binding, "div_binding");
    return [elem, element2, div_binding];
  }
  __name(instance$1p, "instance$1p");
  const _Customizer_actions = class _Customizer_actions extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1p, create_fragment$1z, safe_not_equal, { element: 1 });
    }
    get element() {
      return this.$$.ctx[1];
    }
  };
  __name(_Customizer_actions, "Customizer_actions");
  let Customizer_actions = _Customizer_actions;
  const _CustomizerActionsSetup = class _CustomizerActionsSetup extends Setup {
    async runSetup() {
      const component = new Customizer_actions({
        target: requireElement(".avatar-customizer")
      });
      return await component.element;
    }
  };
  __name(_CustomizerActionsSetup, "CustomizerActionsSetup");
  let CustomizerActionsSetup = _CustomizerActionsSetup;
  var __defProp$1M = Object.defineProperty;
  var __getOwnPropDesc$L = Object.getOwnPropertyDescriptor;
  var __decorateClass$1M = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$L(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1M(target, key2, result);
    return result;
  }, "__decorateClass$1M");
  let SkribblInitializedSetup = (_p = class extends Setup {
    async runSetup() {
      return new Promise((resolve2) => {
        if (document.body.getAttribute("typo-skribbl-loaded") !== null) resolve2();
        else document.addEventListener("skribblInitialized", () => resolve2());
      });
    }
  }, __name(_p, "SkribblInitializedSetup"), _p);
  SkribblInitializedSetup = __decorateClass$1M([
    earlySetup()
  ], SkribblInitializedSetup);
  const _Toast_container = class _Toast_container extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, null, safe_not_equal, {});
    }
  };
  __name(_Toast_container, "Toast_container");
  let Toast_container = _Toast_container;
  var __defProp$1L = Object.defineProperty;
  var __decorateClass$1L = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$1L(target, key2, result);
    return result;
  }, "__decorateClass$1L");
  const _ToastSetup = class _ToastSetup extends Setup {
    constructor() {
      super(...arguments);
      __publicField(this, "_gameReadySetup");
    }
    async runSetup() {
      await this._gameReadySetup.complete();
      const controls = appendElement(createElement("<div class='typo-toast-container'></div>"), "afterbegin", document.body);
      new Toast_container({
        target: controls
      });
      return controls;
    }
  };
  __name(_ToastSetup, "ToastSetup");
  let ToastSetup = _ToastSetup;
  __decorateClass$1L([
    inject(GamePatchReadySetup)
  ], ToastSetup.prototype, "_gameReadySetup");
  function get_each_context$y(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[4] = list[i];
    return child_ctx;
  }
  __name(get_each_context$y, "get_each_context$y");
  function get_each_context_1$d(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[4] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1$d, "get_each_context_1$d");
  function create_each_block_1$d(ctx) {
    let h2;
    let t_value = (
      /*tab*/
      ctx[4].name + ""
    );
    let t;
    let mounted;
    let dispose;
    function keydown_handler2() {
      return (
        /*keydown_handler*/
        ctx[2](
          /*tab*/
          ctx[4]
        )
      );
    }
    __name(keydown_handler2, "keydown_handler");
    function click_handler2() {
      return (
        /*click_handler*/
        ctx[3](
          /*tab*/
          ctx[4]
        )
      );
    }
    __name(click_handler2, "click_handler");
    return {
      c() {
        h2 = element("h2");
        t = text(t_value);
        attr(h2, "tabindex", "0");
        attr(h2, "role", "button");
        attr(h2, "class", "svelte-14yq9xv");
        toggle_class(
          h2,
          "inactive",
          /*tab*/
          ctx[4] !== /*activeTab*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, h2, anchor);
        append(h2, t);
        if (!mounted) {
          dispose = [
            listen(h2, "keydown", keydown_handler2),
            listen(h2, "click", click_handler2)
          ];
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*tabs*/
        1 && t_value !== (t_value = /*tab*/
        ctx[4].name + "")) set_data(t, t_value);
        if (dirty & /*tabs, activeTab*/
        3) {
          toggle_class(
            h2,
            "inactive",
            /*tab*/
            ctx[4] !== /*activeTab*/
            ctx[1]
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(h2);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_each_block_1$d, "create_each_block_1$d");
  function create_each_block$y(ctx) {
    let div;
    let div_class_value;
    let div_hidden_value;
    return {
      c() {
        div = element("div");
        attr(div, "class", div_class_value = "typo-panel-tab color-scrollbar panel-tab-" + /*tab*/
        ctx[4].id + " svelte-14yq9xv");
        div.hidden = div_hidden_value = /*tab*/
        ctx[4] !== /*activeTab*/
        ctx[1];
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*tabs*/
        1 && div_class_value !== (div_class_value = "typo-panel-tab color-scrollbar panel-tab-" + /*tab*/
        ctx2[4].id + " svelte-14yq9xv")) {
          attr(div, "class", div_class_value);
        }
        if (dirty & /*tabs, activeTab*/
        3 && div_hidden_value !== (div_hidden_value = /*tab*/
        ctx2[4] !== /*activeTab*/
        ctx2[1])) {
          div.hidden = div_hidden_value;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_each_block$y, "create_each_block$y");
  function create_fragment$1y(ctx) {
    let div;
    let t;
    let each1_anchor;
    let each_value_1 = ensure_array_like(
      /*tabs*/
      ctx[0]
    );
    let each_blocks_1 = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks_1[i] = create_each_block_1$d(get_each_context_1$d(ctx, each_value_1, i));
    }
    let each_value = ensure_array_like(
      /*tabs*/
      ctx[0]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$y(get_each_context$y(ctx, each_value, i));
    }
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].c();
        }
        t = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each1_anchor = empty();
        attr(div, "class", "panel-header svelte-14yq9xv");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          if (each_blocks_1[i]) {
            each_blocks_1[i].m(div, null);
          }
        }
        insert(target, t, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each1_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*tabs, activeTab*/
        3) {
          each_value_1 = ensure_array_like(
            /*tabs*/
            ctx2[0]
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$d(ctx2, each_value_1, i);
            if (each_blocks_1[i]) {
              each_blocks_1[i].p(child_ctx, dirty);
            } else {
              each_blocks_1[i] = create_each_block_1$d(child_ctx);
              each_blocks_1[i].c();
              each_blocks_1[i].m(div, null);
            }
          }
          for (; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d(1);
          }
          each_blocks_1.length = each_value_1.length;
        }
        if (dirty & /*tabs, activeTab*/
        3) {
          each_value = ensure_array_like(
            /*tabs*/
            ctx2[0]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$y(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$y(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each1_anchor.parentNode, each1_anchor);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
          detach(t);
          detach(each1_anchor);
        }
        destroy_each(each_blocks_1, detaching);
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_fragment$1y, "create_fragment$1y");
  function instance$1o($$self, $$props, $$invalidate) {
    let { tabs = [] } = $$props;
    let activeTab = tabs[0];
    const keydown_handler2 = /* @__PURE__ */ __name((tab) => $$invalidate(1, activeTab = tab), "keydown_handler");
    const click_handler2 = /* @__PURE__ */ __name((tab) => $$invalidate(1, activeTab = tab), "click_handler");
    $$self.$$set = ($$props2) => {
      if ("tabs" in $$props2) $$invalidate(0, tabs = $$props2.tabs);
    };
    return [tabs, activeTab, keydown_handler2, click_handler2];
  }
  __name(instance$1o, "instance$1o");
  const _Panel_tabs = class _Panel_tabs extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1o, create_fragment$1y, safe_not_equal, { tabs: 0 });
    }
  };
  __name(_Panel_tabs, "Panel_tabs");
  let Panel_tabs = _Panel_tabs;
  var __defProp$1K = Object.defineProperty;
  var __decorateClass$1K = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$1K(target, key2, result);
    return result;
  }, "__decorateClass$1K");
  const _PanelSetup = class _PanelSetup extends Setup {
    constructor() {
      super(...arguments);
      __publicField(this, "_gameReadySetup");
    }
    async runSetup() {
      await this._gameReadySetup.complete();
      const panels = {
        rightPanel: appendElement(createElement("<div class='panel panel-right typo-panel'></div>"), "afterend", requireElement(".panel")),
        leftPanel: appendElement(createElement("<div class='panel panel-left typo-panel'></div>"), "beforebegin", requireElement(".panel"))
      };
      new Panel_tabs({
        target: panels.leftPanel,
        props: {
          tabs: [{ name: "Typo News", id: "news" }, { name: "Changelog", id: "changelog" }]
        }
      });
      new Panel_tabs({
        target: panels.rightPanel,
        props: {
          tabs: [{ name: "Lobbies", id: "lobbies" }, { name: "Filters", id: "filter" }, { name: "Outfit", id: "cabin" }]
        }
      });
      return panels;
    }
  };
  __name(_PanelSetup, "PanelSetup");
  let PanelSetup = _PanelSetup;
  __decorateClass$1K([
    inject(GamePatchReadySetup)
  ], PanelSetup.prototype, "_gameReadySetup");
  const _Toolbar = class _Toolbar extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, null, safe_not_equal, {});
    }
  };
  __name(_Toolbar, "Toolbar");
  let Toolbar = _Toolbar;
  var __defProp$1J = Object.defineProperty;
  var __decorateClass$1J = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$1J(target, key2, result);
    return result;
  }, "__decorateClass$1J");
  const _ToolbarSetup = class _ToolbarSetup extends Setup {
    constructor() {
      super(...arguments);
      __publicField(this, "_gameReadySetup");
    }
    async runSetup() {
      await this._gameReadySetup.complete();
      const toolbar = appendElement(createElement("<div class='typo-toolbar'></div>"), "afterbegin", requireElement("#game-wrapper"));
      new Toolbar({
        target: toolbar
      });
      return toolbar;
    }
  };
  __name(_ToolbarSetup, "ToolbarSetup");
  let ToolbarSetup = _ToolbarSetup;
  __decorateClass$1J([
    inject(GamePatchReadySetup)
  ], ToolbarSetup.prototype, "_gameReadySetup");
  var __defProp$1I = Object.defineProperty;
  var __decorateClass$1I = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$1I(target, key2, result);
    return result;
  }, "__decorateClass$1I");
  function getElements$1(panels, toolbar, controls, toastContainer, chatControls, customizerActions) {
    return {
      panelContainer: requireElement(".panels"),
      avatarPanel: requireElement(".panel:not(.typo-panel)"),
      newsTab: requireElement(".panel-tab-news"),
      changelogTab: requireElement(".panel-tab-changelog"),
      lobbiesTab: requireElement(".panel-tab-lobbies"),
      cabinTab: requireElement(".panel-tab-cabin"),
      filterTab: requireElement(".panel-tab-filter"),
      playButton: requireElement(".panel:not(.typo-panel) .button-play"),
      gameBar: requireElement("#game-bar"),
      gameSettings: requireElement("#game-settings"),
      home: requireElement("#home"),
      game: requireElement("#game"),
      gameWrapper: requireElement("#game-wrapper"),
      load: requireElement("#load"),
      chatInput: requireElement("#game-chat form.chat-form input"),
      chatForm: requireElement("#game-chat form.chat-form"),
      chatArea: requireElement("#game-chat"),
      chatContent: requireElement("#game-chat .chat-content"),
      hints: requireElement("#game-word .hints"),
      canvasWrapper: requireElement("#game-canvas"),
      canvas: requireElement("#game-canvas canvas"),
      landingAvatar: requireElement(".avatar-customizer .avatar"),
      landingCustomizeContainer: requireElement(".avatar-customizer"),
      landingAvatarContainer: requireElement(".avatar-customizer .container"),
      skribblTools: requireElement(".toolbar-group-tools"),
      skribblActions: requireElement(".toolbar-group-actions"),
      skribblToolbar: requireElement("#game-toolbar"),
      skribblBrushTools: requireElement('.toolbar-group-tools .tool[data-tooltip="Brush"]'),
      colorContainer: requireElement("#game-toolbar .colors"),
      scoreboardResults: requireElement("#game-canvas .overlay-content .result"),
      playerPopup: requireElement("#modal .modal-content .modal-container-player"),
      skribblModal: requireElement("#modal"),
      canvasOverlay: requireElement("#game-canvas .overlay-content"),
      textOverlay: requireElement("#game-canvas .overlay-content > .text"),
      gameRate: requireElement("#game-rate"),
      inputName: requireElement("input.input-name"),
      logoIngame: requireElement("#game-logo img"),
      chatControls,
      ...panels,
      toolbar,
      controls,
      toastContainer,
      customizerActions
    };
  }
  __name(getElements$1, "getElements$1");
  const _ElementsSetup = class _ElementsSetup extends Setup {
    constructor() {
      super(...arguments);
      __publicField(this, "_panelSetup");
      __publicField(this, "_toolbarSetup");
      __publicField(this, "_controlsSetup");
      __publicField(this, "_chatControlsSetup");
      __publicField(this, "_toastSetup");
      __publicField(this, "_gameReadySetup");
      __publicField(this, "_customizerIconsSetup");
    }
    async runSetup() {
      await this._gameReadySetup.complete();
      const panels = await this._panelSetup.complete();
      const toolbar = await this._toolbarSetup.complete();
      const controls = await this._controlsSetup.complete();
      const chatControls = await this._chatControlsSetup.complete();
      const toastContainer = await this._toastSetup.complete();
      const customizerActions = await this._customizerIconsSetup.complete();
      return getElements$1(panels, toolbar, controls, toastContainer, chatControls, customizerActions);
    }
  };
  __name(_ElementsSetup, "ElementsSetup");
  let ElementsSetup = _ElementsSetup;
  __decorateClass$1I([
    inject(PanelSetup)
  ], ElementsSetup.prototype, "_panelSetup");
  __decorateClass$1I([
    inject(ToolbarSetup)
  ], ElementsSetup.prototype, "_toolbarSetup");
  __decorateClass$1I([
    inject(ControlsSetup)
  ], ElementsSetup.prototype, "_controlsSetup");
  __decorateClass$1I([
    inject(ChatControlsSetup)
  ], ElementsSetup.prototype, "_chatControlsSetup");
  __decorateClass$1I([
    inject(ToastSetup)
  ], ElementsSetup.prototype, "_toastSetup");
  __decorateClass$1I([
    inject(SkribblInitializedSetup)
  ], ElementsSetup.prototype, "_gameReadySetup");
  __decorateClass$1I([
    inject(CustomizerActionsSetup)
  ], ElementsSetup.prototype, "_customizerIconsSetup");
  var __defProp$1H = Object.defineProperty;
  var __getOwnPropDesc$K = Object.getOwnPropertyDescriptor;
  var __decorateClass$1H = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$K(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1H(target, key2, result);
    return result;
  }, "__decorateClass$1H");
  const _ChatTypedEvent = class _ChatTypedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_ChatTypedEvent, "ChatTypedEvent");
  let ChatTypedEvent = _ChatTypedEvent;
  let ChatTypedEventProcessor = (_q = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "eventType", ChatTypedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const { chatInput, chatForm } = await this._elementsSetup.complete();
      chatInput.addEventListener("input", () => {
        const value = chatInput.value;
        events.next(new ChatTypedEvent(value));
      });
      chatForm.addEventListener("submit", () => {
        events.next(new ChatTypedEvent(""));
      });
      return events.pipe(
        distinctUntilChanged((a, b) => a.data === b.data),
        tap((data) => this._logger.debug("Chat typed event", data))
      );
    }
  }, __name(_q, "ChatTypedEventProcessor"), _q);
  __decorateClass$1H([
    inject(ElementsSetup)
  ], ChatTypedEventProcessor.prototype, "_elementsSetup", 2);
  ChatTypedEventProcessor = __decorateClass$1H([
    injectable()
  ], ChatTypedEventProcessor);
  let ChatTypedEventListener = (_r = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_r, "ChatTypedEventListener"), _r);
  __decorateClass$1H([
    inject(ChatTypedEventProcessor)
  ], ChatTypedEventListener.prototype, "_processor", 2);
  ChatTypedEventListener = __decorateClass$1H([
    injectable()
  ], ChatTypedEventListener);
  const chatTypedEventRegistration = {
    listenerType: ChatTypedEventListener,
    processorType: ChatTypedEventProcessor
  };
  var __defProp$1G = Object.defineProperty;
  var __getOwnPropDesc$J = Object.getOwnPropertyDescriptor;
  var __decorateClass$1G = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$J(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1G(target, key2, result);
    return result;
  }, "__decorateClass$1G");
  const _ColorChangedEvent = class _ColorChangedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_ColorChangedEvent, "ColorChangedEvent");
  let ColorChangedEvent = _ColorChangedEvent;
  let ColorChangedEventProcessor = (_s = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "eventType", ColorChangedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      document.addEventListener("skribblColorChanged", (event) => {
        const rgb = event.detail;
        const color = Color.fromRgbString(rgb);
        events.next(new ColorChangedEvent(color));
        this._logger.info("Color changed", color);
      });
      return events;
    }
  }, __name(_s, "ColorChangedEventProcessor"), _s);
  ColorChangedEventProcessor = __decorateClass$1G([
    injectable()
  ], ColorChangedEventProcessor);
  let ColorChangedEventListener = (_t = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_t, "ColorChangedEventListener"), _t);
  __decorateClass$1G([
    inject(ColorChangedEventProcessor)
  ], ColorChangedEventListener.prototype, "_processor", 2);
  ColorChangedEventListener = __decorateClass$1G([
    injectable()
  ], ColorChangedEventListener);
  const colorChangedEventRegistration = {
    listenerType: ColorChangedEventListener,
    processorType: ColorChangedEventProcessor
  };
  var __defProp$1F = Object.defineProperty;
  var __getOwnPropDesc$I = Object.getOwnPropertyDescriptor;
  var __decorateClass$1F = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$I(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1F(target, key2, result);
    return result;
  }, "__decorateClass$1F");
  let SkribblEmitRelaySetup = (_u = class extends Setup {
    // eslint-disable-line @typescript-eslint/no-explicit-any
    async runSetup() {
      return new Promise((resolve2) => {
        window.addEventListener("message", (data) => {
          if (data.data === "skribblEmitPort") {
            const ports = data.ports;
            if (ports.length === 0) return;
            const observable2 = new Subject$1();
            ports[0].onmessage = (message) => {
              observable2.next({ event: message.data[0], data: message.data[1] });
            };
            resolve2(observable2);
          }
        });
      });
    }
  }, __name(_u, "SkribblEmitRelaySetup"), _u);
  SkribblEmitRelaySetup = __decorateClass$1F([
    earlySetup()
  ], SkribblEmitRelaySetup);
  var __defProp$1E = Object.defineProperty;
  var __getOwnPropDesc$H = Object.getOwnPropertyDescriptor;
  var __decorateClass$1E = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$H(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1E(target, key2, result);
    return result;
  }, "__decorateClass$1E");
  let SkribblMessageRelaySetup = (_v = class extends Setup {
    async runSetup() {
      return new Promise((resolve2) => {
        window.addEventListener("message", (data) => {
          if (data.data === "skribblMessagePort") {
            const ports = data.ports;
            if (ports.length === 0) return;
            const observable2 = new Subject$1();
            document.addEventListener("insertSkribblEmit", (e) => {
              this._logger.debug("insertSkribblEmit", e.detail);
              ports[0].postMessage(e.detail);
            });
            ports[0].onmessage = (message) => {
              if (message.data.id !== 19) {
                this._logger.debug("Received message", message.data);
              }
              observable2.next(message.data);
            };
            resolve2({
              serverMessages$: observable2,
              insertMessage: /* @__PURE__ */ __name((message) => ports[0].postMessage(message), "insertMessage")
            });
          }
        });
      });
    }
  }, __name(_v, "SkribblMessageRelaySetup"), _v);
  SkribblMessageRelaySetup = __decorateClass$1E([
    earlySetup()
  ], SkribblMessageRelaySetup);
  var __defProp$1D = Object.defineProperty;
  var __getOwnPropDesc$G = Object.getOwnPropertyDescriptor;
  var __decorateClass$1D = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$G(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1D(target, key2, result);
    return result;
  }, "__decorateClass$1D");
  const _DrawEvent = class _DrawEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_DrawEvent, "DrawEvent");
  let DrawEvent = _DrawEvent;
  let DrawEventProcessor = (_w = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "_skribblEmitRelaySetup");
      __publicField(this, "eventType", DrawEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const skribblMessages = await this._skribblMessageRelaySetup.complete();
      const skribblEmit = await this._skribblEmitRelaySetup.complete();
      merge$1(
        skribblEmit.pipe(
          filter((data) => data.event === "data"),
          map((data) => data.data)
        ),
        skribblMessages.serverMessages$
      ).pipe(
        map((event) => {
          if (event.id === 19) {
            if (typeof event.data[0] === "number") {
              return [event.data];
            } else return event.data;
          }
          if (event.id === 10 && event.data.state.id === 4 && event.data.state.data.drawCommands) {
            return event.data.state.data.drawCommands;
          }
          return null;
        }),
        filter((data) => data !== null),
        bufferTime(100),
        /* debounce to prevent excessive observable spam */
        filter((data) => data.length > 0)
      ).subscribe((data) => {
        const flat = data.flat(1);
        events.next(new DrawEvent(flat));
      });
      return events;
    }
  }, __name(_w, "DrawEventProcessor"), _w);
  __decorateClass$1D([
    inject(SkribblMessageRelaySetup)
  ], DrawEventProcessor.prototype, "_skribblMessageRelaySetup", 2);
  __decorateClass$1D([
    inject(SkribblEmitRelaySetup)
  ], DrawEventProcessor.prototype, "_skribblEmitRelaySetup", 2);
  DrawEventProcessor = __decorateClass$1D([
    injectable()
  ], DrawEventProcessor);
  let DrawEventListener = (_x = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_x, "DrawEventListener"), _x);
  __decorateClass$1D([
    inject(DrawEventProcessor)
  ], DrawEventListener.prototype, "_processor", 2);
  DrawEventListener = __decorateClass$1D([
    injectable()
  ], DrawEventListener);
  const drawEventRegistration = {
    listenerType: DrawEventListener,
    processorType: DrawEventProcessor
  };
  var __defProp$1C = Object.defineProperty;
  var __getOwnPropDesc$F = Object.getOwnPropertyDescriptor;
  var __decorateClass$1C = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$F(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1C(target, key2, result);
    return result;
  }, "__decorateClass$1C");
  const _HintsAddedEvent = class _HintsAddedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_HintsAddedEvent, "HintsAddedEvent");
  let HintsAddedEvent = _HintsAddedEvent;
  let HintsAddedEventProcessor = (_y = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "eventType", HintsAddedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const skribblMessages = await this._skribblMessageRelaySetup.complete();
      skribblMessages.serverMessages$.subscribe((event) => {
        if (event.id === 10 && event.data.state.id === 4 && event.data.state.data.hints) {
          const hints = event.data.state.data.hints;
          this._logger.info("Lobby joined", hints);
          events.next(new HintsAddedEvent(hints));
        } else if (event.id === 13) {
          const hints = event.data ?? [];
          this._logger.info("Hints added", hints);
          events.next(new HintsAddedEvent(hints));
        }
      });
      return events;
    }
  }, __name(_y, "HintsAddedEventProcessor"), _y);
  __decorateClass$1C([
    inject(SkribblMessageRelaySetup)
  ], HintsAddedEventProcessor.prototype, "_skribblMessageRelaySetup", 2);
  HintsAddedEventProcessor = __decorateClass$1C([
    injectable()
  ], HintsAddedEventProcessor);
  let HintsAddedEventListener = (_z = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_z, "HintsAddedEventListener"), _z);
  __decorateClass$1C([
    inject(HintsAddedEventProcessor)
  ], HintsAddedEventListener.prototype, "_processor", 2);
  HintsAddedEventListener = __decorateClass$1C([
    injectable()
  ], HintsAddedEventListener);
  const hintsAddedEventRegistration = {
    listenerType: HintsAddedEventListener,
    processorType: HintsAddedEventProcessor
  };
  var __defProp$1B = Object.defineProperty;
  var __getOwnPropDesc$E = Object.getOwnPropertyDescriptor;
  var __decorateClass$1B = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$E(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1B(target, key2, result);
    return result;
  }, "__decorateClass$1B");
  const _ImageResetEvent = class _ImageResetEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_ImageResetEvent, "ImageResetEvent");
  let ImageResetEvent = _ImageResetEvent;
  let ImageResetEventProcessor = (_A = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "_skribblEmitRelaySetup");
      __publicField(this, "eventType", ImageResetEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const skribblMessages = await this._skribblMessageRelaySetup.complete();
      const skribblEmit = await this._skribblEmitRelaySetup.complete();
      merge$1(
        skribblEmit.pipe(
          filter((data) => data.event === "data"),
          map((data) => data.data)
        ),
        skribblMessages.serverMessages$
      ).subscribe((event) => {
        if (event.id === 20) {
          this._logger.info("Image cleared");
          events.next(new ImageResetEvent(0));
        }
        if (event.id === 21) {
          this._logger.info("Undo action", event.data);
          events.next(new ImageResetEvent(event.data));
        }
      });
      return events;
    }
  }, __name(_A, "ImageResetEventProcessor"), _A);
  __decorateClass$1B([
    inject(SkribblMessageRelaySetup)
  ], ImageResetEventProcessor.prototype, "_skribblMessageRelaySetup", 2);
  __decorateClass$1B([
    inject(SkribblEmitRelaySetup)
  ], ImageResetEventProcessor.prototype, "_skribblEmitRelaySetup", 2);
  ImageResetEventProcessor = __decorateClass$1B([
    injectable()
  ], ImageResetEventProcessor);
  let ImageResetEventListener = (_B = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_B, "ImageResetEventListener"), _B);
  __decorateClass$1B([
    inject(ImageResetEventProcessor)
  ], ImageResetEventListener.prototype, "_processor", 2);
  ImageResetEventListener = __decorateClass$1B([
    injectable()
  ], ImageResetEventListener);
  const imageResetEventRegistration = {
    listenerType: ImageResetEventListener,
    processorType: ImageResetEventProcessor
  };
  const parseSkribblLobbyInteractedEvent = /* @__PURE__ */ __name((data) => {
    switch (data.id) {
      case 8:
        if (data.data.vote === 1) return {
          likeInteraction: {
            sourcePlayerId: data.data.id
          }
        };
        else return {
          dislikeInteraction: {
            sourcePlayerId: data.data.id
          }
        };
      case 5:
        return {
          votekickInteraction: {
            targetPlayerId: data.data[1],
            sourcePlayerId: data.data[0],
            totalVotes: data.data[2],
            requiredVotes: data.data[3]
          }
        };
    }
  }, "parseSkribblLobbyInteractedEvent");
  var __defProp$1A = Object.defineProperty;
  var __getOwnPropDesc$D = Object.getOwnPropertyDescriptor;
  var __decorateClass$1A = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$D(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1A(target, key2, result);
    return result;
  }, "__decorateClass$1A");
  const _LobbyInteractedEvent = class _LobbyInteractedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_LobbyInteractedEvent, "LobbyInteractedEvent");
  let LobbyInteractedEvent = _LobbyInteractedEvent;
  let LobbyInteractedEventProcessor = (_C = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "eventType", LobbyInteractedEvent);
    }
    async streamEvents() {
      const skribblMessages = await this._skribblMessageRelaySetup.complete();
      return skribblMessages.serverMessages$.pipe(
        map((message) => parseSkribblLobbyInteractedEvent(message)),
        filter((event) => event !== void 0),
        map((event) => new LobbyInteractedEvent(event)),
        tap((data) => this._logger.debug("Lobby interacted", data))
      );
    }
  }, __name(_C, "LobbyInteractedEventProcessor"), _C);
  __decorateClass$1A([
    inject(SkribblMessageRelaySetup)
  ], LobbyInteractedEventProcessor.prototype, "_skribblMessageRelaySetup", 2);
  LobbyInteractedEventProcessor = __decorateClass$1A([
    injectable()
  ], LobbyInteractedEventProcessor);
  let LobbyInteractedEventListener = (_D = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_D, "LobbyInteractedEventListener"), _D);
  __decorateClass$1A([
    inject(LobbyInteractedEventProcessor)
  ], LobbyInteractedEventListener.prototype, "_processor", 2);
  LobbyInteractedEventListener = __decorateClass$1A([
    injectable()
  ], LobbyInteractedEventListener);
  const lobbyInteractedEventRegistration = {
    listenerType: LobbyInteractedEventListener,
    processorType: LobbyInteractedEventProcessor
  };
  function getElements() {
    return {
      languageSettings: new Map(requireElements("#home .container-name-lang > select option").map((item) => [Number(item.value), item.textContent ?? ""]))
    };
  }
  __name(getElements, "getElements");
  const _GameSettingsSetup = class _GameSettingsSetup extends Setup {
    async runSetup() {
      return getElements();
    }
  };
  __name(_GameSettingsSetup, "GameSettingsSetup");
  let GameSettingsSetup = _GameSettingsSetup;
  var __defProp$1z = Object.defineProperty;
  var __getOwnPropDesc$C = Object.getOwnPropertyDescriptor;
  var __decorateClass$1z = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$C(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1z(target, key2, result);
    return result;
  }, "__decorateClass$1z");
  const _LobbyJoinFailedEvent = class _LobbyJoinFailedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_LobbyJoinFailedEvent, "LobbyJoinFailedEvent");
  let LobbyJoinFailedEvent = _LobbyJoinFailedEvent;
  let LobbyJoinFailedEventProcessor = (_E = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_gameSettingsSetup");
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "eventType", LobbyJoinFailedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      document.addEventListener("joinLobbyFailed", () => {
        events.next(new LobbyJoinFailedEvent(null));
      });
      return events;
    }
  }, __name(_E, "LobbyJoinFailedEventProcessor"), _E);
  __decorateClass$1z([
    inject(GameSettingsSetup)
  ], LobbyJoinFailedEventProcessor.prototype, "_gameSettingsSetup", 2);
  __decorateClass$1z([
    inject(SkribblMessageRelaySetup)
  ], LobbyJoinFailedEventProcessor.prototype, "_skribblMessageRelaySetup", 2);
  LobbyJoinFailedEventProcessor = __decorateClass$1z([
    injectable()
  ], LobbyJoinFailedEventProcessor);
  let LobbyJoinFailedListener = (_F = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_F, "LobbyJoinFailedListener"), _F);
  __decorateClass$1z([
    inject(LobbyJoinFailedEventProcessor)
  ], LobbyJoinFailedListener.prototype, "_processor", 2);
  LobbyJoinFailedListener = __decorateClass$1z([
    injectable()
  ], LobbyJoinFailedListener);
  const lobbyJoinFailedEventRegistration = {
    listenerType: LobbyJoinFailedListener,
    processorType: LobbyJoinFailedEventProcessor
  };
  var __defProp$1y = Object.defineProperty;
  var __getOwnPropDesc$B = Object.getOwnPropertyDescriptor;
  var __decorateClass$1y = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$B(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1y(target, key2, result);
    return result;
  }, "__decorateClass$1y");
  const _LobbyPlayerChangedEvent = class _LobbyPlayerChangedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_LobbyPlayerChangedEvent, "LobbyPlayerChangedEvent");
  let LobbyPlayerChangedEvent = _LobbyPlayerChangedEvent;
  let LobbyPlayerChangedEventProcessor = (_G = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "eventType", LobbyPlayerChangedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const skribblMessages = await this._skribblMessageRelaySetup.complete();
      skribblMessages.serverMessages$.subscribe((event) => {
        if (event.id === 1) {
          const data = {
            joined: event.data
          };
          this._logger.info("Player joined", data);
          events.next(new LobbyPlayerChangedEvent(data));
        } else if (event.id === 2) {
          const data = {
            left: {
              id: event.data.id,
              reason: event.data.id === 1 ? "left" : "kicked"
            }
          };
          this._logger.info("Player left", data);
          events.next(new LobbyPlayerChangedEvent(data));
        }
      });
      return events;
    }
  }, __name(_G, "LobbyPlayerChangedEventProcessor"), _G);
  __decorateClass$1y([
    inject(SkribblMessageRelaySetup)
  ], LobbyPlayerChangedEventProcessor.prototype, "_skribblMessageRelaySetup", 2);
  LobbyPlayerChangedEventProcessor = __decorateClass$1y([
    injectable()
  ], LobbyPlayerChangedEventProcessor);
  let LobbyPlayerChangedEventListener = (_H = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_H, "LobbyPlayerChangedEventListener"), _H);
  __decorateClass$1y([
    inject(LobbyPlayerChangedEventProcessor)
  ], LobbyPlayerChangedEventListener.prototype, "_processor", 2);
  LobbyPlayerChangedEventListener = __decorateClass$1y([
    injectable()
  ], LobbyPlayerChangedEventListener);
  const lobbyPlayerChangedEventRegistration = {
    listenerType: LobbyPlayerChangedEventListener,
    processorType: LobbyPlayerChangedEventProcessor
  };
  function arrayChunk(array, size) {
    return array.reduce((acc, _, i) => i % size ? acc : [...acc, array.slice(i, i + size)], []);
  }
  __name(arrayChunk, "arrayChunk");
  const parseLobbyStateUpdate = /* @__PURE__ */ __name((data) => {
    switch (data.id) {
      case 2:
        return {
          roundStarted: {
            round: data.data,
            startsIn: data.time
          }
        };
      case 3:
        return {
          drawerChoosingWord: {
            maxTime: data.time,
            drawerId: data.data.id
          }
        };
      case 4: {
        return {
          drawingStarted: {
            word: typeof data.data.word === "string" ? data.data.word : void 0,
            characters: typeof data.data.word === "string" ? data.data.word.length : data.data.word,
            maxTime: data.time,
            drawerId: data.data.id
          }
          /*initialDrawerId: data.data.id as number | undefined*/
        };
      }
      case 5: {
        return {
          drawingRevealed: {
            reason: data.data.reason === 1 ? "outOfTime" : "allGuessed",
            word: data.data.word,
            time: data.time,
            scores: arrayChunk(data.data.scores, 3).map(([playerId, score, rewarded]) => ({ playerId, score, rewarded }))
          }
        };
      }
      case 6: {
        return {
          gameEnded: {
            ranking: data.data.map(([playerId, rank]) => ({ playerId, rank })),
            displayTime: data.time
          }
        };
      }
      case 7: {
        return {
          timerSet: {
            time: data.time
          }
        };
      }
      default: {
        return void 0;
      }
    }
  }, "parseLobbyStateUpdate");
  var __defProp$1x = Object.defineProperty;
  var __getOwnPropDesc$A = Object.getOwnPropertyDescriptor;
  var __decorateClass$1x = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$A(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1x(target, key2, result);
    return result;
  }, "__decorateClass$1x");
  const _LobbyStateChangedEvent = class _LobbyStateChangedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_LobbyStateChangedEvent, "LobbyStateChangedEvent");
  let LobbyStateChangedEvent = _LobbyStateChangedEvent;
  let LobbyStateChangedEventProcessor = (_I = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_gameSettingsSetup");
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "eventType", LobbyStateChangedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const skribblMessages = await this._skribblMessageRelaySetup.complete();
      skribblMessages.serverMessages$.subscribe((event) => {
        if (event.id === 11) {
          const update2 = parseLobbyStateUpdate(event.data);
          if (update2 === void 0) {
            this._logger.warn("Unknown event", event.data);
            return;
          }
          this._logger.info("Lobby updated", update2);
          events.next(new LobbyStateChangedEvent(update2));
        }
        if (event.id === 10) {
          const update2 = parseLobbyStateUpdate(event.data.state);
          if (update2 === void 0) {
            this._logger.warn("Unknown event", event.data.state);
            return;
          }
          this._logger.info("Lobby joined", update2);
          events.next(new LobbyStateChangedEvent(update2));
        }
        if (event.id === 14) {
          this._logger.info("Lobby timer set", event.data);
          events.next(new LobbyStateChangedEvent({ timerSet: { time: event.data } }));
        }
      });
      return events;
    }
  }, __name(_I, "LobbyStateChangedEventProcessor"), _I);
  __decorateClass$1x([
    inject(GameSettingsSetup)
  ], LobbyStateChangedEventProcessor.prototype, "_gameSettingsSetup", 2);
  __decorateClass$1x([
    inject(SkribblMessageRelaySetup)
  ], LobbyStateChangedEventProcessor.prototype, "_skribblMessageRelaySetup", 2);
  LobbyStateChangedEventProcessor = __decorateClass$1x([
    injectable()
  ], LobbyStateChangedEventProcessor);
  let LobbyStateChangedEventListener = (_J = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_J, "LobbyStateChangedEventListener"), _J);
  __decorateClass$1x([
    inject(LobbyStateChangedEventProcessor)
  ], LobbyStateChangedEventListener.prototype, "_processor", 2);
  LobbyStateChangedEventListener = __decorateClass$1x([
    injectable()
  ], LobbyStateChangedEventListener);
  const lobbyStateChangedEventRegistration = {
    listenerType: LobbyStateChangedEventListener,
    processorType: LobbyStateChangedEventProcessor
  };
  var __defProp$1w = Object.defineProperty;
  var __getOwnPropDesc$z = Object.getOwnPropertyDescriptor;
  var __decorateClass$1w = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$z(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1w(target, key2, result);
    return result;
  }, "__decorateClass$1w");
  const _MessageReceivedEvent = class _MessageReceivedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_MessageReceivedEvent, "MessageReceivedEvent");
  let MessageReceivedEvent = _MessageReceivedEvent;
  let MessageReceivedEventProcessor = (_K = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "eventType", MessageReceivedEvent);
    }
    async streamEvents() {
      const skribblMessages = await this._skribblMessageRelaySetup.complete();
      return skribblMessages.serverMessages$.pipe(
        filter((event) => event.id == 30),
        map((event) => new MessageReceivedEvent({ message: event.data.msg, senderId: event.data.id })),
        tap((data) => this._logger.debug("Message received", data))
      );
    }
  }, __name(_K, "MessageReceivedEventProcessor"), _K);
  __decorateClass$1w([
    inject(SkribblMessageRelaySetup)
  ], MessageReceivedEventProcessor.prototype, "_skribblMessageRelaySetup", 2);
  MessageReceivedEventProcessor = __decorateClass$1w([
    injectable()
  ], MessageReceivedEventProcessor);
  let MessageReceivedEventListener = (_L = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_L, "MessageReceivedEventListener"), _L);
  __decorateClass$1w([
    inject(MessageReceivedEventProcessor)
  ], MessageReceivedEventListener.prototype, "_processor", 2);
  MessageReceivedEventListener = __decorateClass$1w([
    injectable()
  ], MessageReceivedEventListener);
  const messageReceivedEventRegistration = {
    listenerType: MessageReceivedEventListener,
    processorType: MessageReceivedEventProcessor
  };
  var __defProp$1v = Object.defineProperty;
  var __getOwnPropDesc$y = Object.getOwnPropertyDescriptor;
  var __decorateClass$1v = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$y(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1v(target, key2, result);
    return result;
  }, "__decorateClass$1v");
  const _MessageSentEvent = class _MessageSentEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_MessageSentEvent, "MessageSentEvent");
  let MessageSentEvent = _MessageSentEvent;
  let MessageSentEventProcessor = (_M = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_skribblEmitRelaySetup");
      __publicField(this, "eventType", MessageSentEvent);
    }
    async streamEvents() {
      const skribblEmit = await this._skribblEmitRelaySetup.complete();
      return skribblEmit.pipe(
        filter((event) => event.event === "data" && event.data.id == 30),
        map((emit) => new MessageSentEvent(emit.data.data))
      );
    }
  }, __name(_M, "MessageSentEventProcessor"), _M);
  __decorateClass$1v([
    inject(SkribblEmitRelaySetup)
  ], MessageSentEventProcessor.prototype, "_skribblEmitRelaySetup", 2);
  MessageSentEventProcessor = __decorateClass$1v([
    injectable()
  ], MessageSentEventProcessor);
  let MessageSentEventListener = (_N = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_N, "MessageSentEventListener"), _N);
  __decorateClass$1v([
    inject(MessageSentEventProcessor)
  ], MessageSentEventListener.prototype, "_processor", 2);
  MessageSentEventListener = __decorateClass$1v([
    injectable()
  ], MessageSentEventListener);
  const messageSentEventRegistration = {
    listenerType: MessageSentEventListener,
    processorType: MessageSentEventProcessor
  };
  var __defProp$1u = Object.defineProperty;
  var __getOwnPropDesc$x = Object.getOwnPropertyDescriptor;
  var __decorateClass$1u = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$x(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1u(target, key2, result);
    return result;
  }, "__decorateClass$1u");
  const _PlayerPopupVisibilityChangedEvent = class _PlayerPopupVisibilityChangedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_PlayerPopupVisibilityChangedEvent, "PlayerPopupVisibilityChangedEvent");
  let PlayerPopupVisibilityChangedEvent = _PlayerPopupVisibilityChangedEvent;
  let PlayerPopupVisibilityChangedEventProcessor = (_O = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "eventType", PlayerPopupVisibilityChangedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const elements2 = await this._elementsSetup.complete();
      const observer = new MutationObserver(() => {
        if (elements2.skribblModal.style.display !== "none" && elements2.playerPopup.style.display === "flex") {
          events.next(new PlayerPopupVisibilityChangedEvent(true));
        } else events.next(new PlayerPopupVisibilityChangedEvent(false));
      });
      observer.observe(elements2.playerPopup, { attributes: true });
      return events.pipe(
        distinctUntilChanged(),
        debounceTime(50)
      );
    }
  }, __name(_O, "PlayerPopupVisibilityChangedEventProcessor"), _O);
  __decorateClass$1u([
    inject(ElementsSetup)
  ], PlayerPopupVisibilityChangedEventProcessor.prototype, "_elementsSetup", 2);
  PlayerPopupVisibilityChangedEventProcessor = __decorateClass$1u([
    injectable()
  ], PlayerPopupVisibilityChangedEventProcessor);
  let PlayerPopupVisibilityChangedEventListener = (_P = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_P, "PlayerPopupVisibilityChangedEventListener"), _P);
  __decorateClass$1u([
    inject(PlayerPopupVisibilityChangedEventProcessor)
  ], PlayerPopupVisibilityChangedEventListener.prototype, "_processor", 2);
  PlayerPopupVisibilityChangedEventListener = __decorateClass$1u([
    injectable()
  ], PlayerPopupVisibilityChangedEventListener);
  const playerPopupVisibilityChangedEventRegistration = {
    listenerType: PlayerPopupVisibilityChangedEventListener,
    processorType: PlayerPopupVisibilityChangedEventProcessor
  };
  var __defProp$1t = Object.defineProperty;
  var __getOwnPropDesc$w = Object.getOwnPropertyDescriptor;
  var __decorateClass$1t = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$w(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1t(target, key2, result);
    return result;
  }, "__decorateClass$1t");
  const _RoundStartedEvent = class _RoundStartedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_RoundStartedEvent, "RoundStartedEvent");
  let RoundStartedEvent = _RoundStartedEvent;
  let RoundStartedEventProcessor = (_Q = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "eventType", RoundStartedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const skribblMessages = await this._skribblMessageRelaySetup.complete();
      skribblMessages.serverMessages$.subscribe((event) => {
        if (event.id === 11 && event.data.id == 2) {
          const round = event.data.data + 1;
          this._logger.info("Round started", round);
          events.next(new RoundStartedEvent(round));
        }
      });
      return events;
    }
  }, __name(_Q, "RoundStartedEventProcessor"), _Q);
  __decorateClass$1t([
    inject(SkribblMessageRelaySetup)
  ], RoundStartedEventProcessor.prototype, "_skribblMessageRelaySetup", 2);
  RoundStartedEventProcessor = __decorateClass$1t([
    injectable()
  ], RoundStartedEventProcessor);
  let RoundStartedEventListener = (_R = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_R, "RoundStartedEventListener"), _R);
  __decorateClass$1t([
    inject(RoundStartedEventProcessor)
  ], RoundStartedEventListener.prototype, "_processor", 2);
  RoundStartedEventListener = __decorateClass$1t([
    injectable()
  ], RoundStartedEventListener);
  const roundStartedEventRegistration = {
    listenerType: RoundStartedEventListener,
    processorType: RoundStartedEventProcessor
  };
  var __defProp$1s = Object.defineProperty;
  var __getOwnPropDesc$v = Object.getOwnPropertyDescriptor;
  var __decorateClass$1s = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$v(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1s(target, key2, result);
    return result;
  }, "__decorateClass$1s");
  const _ScoreboardVisibilityChangedEvent = class _ScoreboardVisibilityChangedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_ScoreboardVisibilityChangedEvent, "ScoreboardVisibilityChangedEvent");
  let ScoreboardVisibilityChangedEvent = _ScoreboardVisibilityChangedEvent;
  let ScoreboardVisibilityChangedEventProcessor = (_S = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "eventType", ScoreboardVisibilityChangedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const elements2 = await this._elementsSetup.complete();
      const observer = new MutationObserver(() => {
        if (elements2.scoreboardResults.classList.contains("show")) events.next(new ScoreboardVisibilityChangedEvent(true));
        else events.next(new ScoreboardVisibilityChangedEvent(false));
      });
      observer.observe(elements2.scoreboardResults, { attributes: true });
      return events.pipe(
        distinctUntilChanged(),
        debounceTime(50)
      );
    }
  }, __name(_S, "ScoreboardVisibilityChangedEventProcessor"), _S);
  __decorateClass$1s([
    inject(ElementsSetup)
  ], ScoreboardVisibilityChangedEventProcessor.prototype, "_elementsSetup", 2);
  ScoreboardVisibilityChangedEventProcessor = __decorateClass$1s([
    injectable()
  ], ScoreboardVisibilityChangedEventProcessor);
  let ScoreboardVisibilityChangedEventListener = (_T = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_T, "ScoreboardVisibilityChangedEventListener"), _T);
  __decorateClass$1s([
    inject(ScoreboardVisibilityChangedEventProcessor)
  ], ScoreboardVisibilityChangedEventListener.prototype, "_processor", 2);
  ScoreboardVisibilityChangedEventListener = __decorateClass$1s([
    injectable()
  ], ScoreboardVisibilityChangedEventListener);
  const scoreboardVisibilityChangedEventRegistration = {
    listenerType: ScoreboardVisibilityChangedEventListener,
    processorType: ScoreboardVisibilityChangedEventProcessor
  };
  var __defProp$1r = Object.defineProperty;
  var __getOwnPropDesc$u = Object.getOwnPropertyDescriptor;
  var __decorateClass$1r = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$u(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1r(target, key2, result);
    return result;
  }, "__decorateClass$1r");
  const _SizeChangedEvent = class _SizeChangedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_SizeChangedEvent, "SizeChangedEvent");
  let SizeChangedEvent = _SizeChangedEvent;
  let SizeChangedEventProcessor = (_U = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "eventType", SizeChangedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      document.addEventListener("skribblSizeChanged", (event) => {
        const size = Number(event.detail);
        events.next(new SizeChangedEvent(size));
        this._logger.info("Size changed", size);
      });
      return events;
    }
  }, __name(_U, "SizeChangedEventProcessor"), _U);
  SizeChangedEventProcessor = __decorateClass$1r([
    injectable()
  ], SizeChangedEventProcessor);
  let SizeChangedEventListener = (_V = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_V, "SizeChangedEventListener"), _V);
  __decorateClass$1r([
    inject(SizeChangedEventProcessor)
  ], SizeChangedEventListener.prototype, "_processor", 2);
  SizeChangedEventListener = __decorateClass$1r([
    injectable()
  ], SizeChangedEventListener);
  const sizeChangedEventRegistration = {
    listenerType: SizeChangedEventListener,
    processorType: SizeChangedEventProcessor
  };
  var __defProp$1q = Object.defineProperty;
  var __getOwnPropDesc$t = Object.getOwnPropertyDescriptor;
  var __decorateClass$1q = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$t(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1q(target, key2, result);
    return result;
  }, "__decorateClass$1q");
  const _TextOverlayVisibilityChangedEvent = class _TextOverlayVisibilityChangedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_TextOverlayVisibilityChangedEvent, "TextOverlayVisibilityChangedEvent");
  let TextOverlayVisibilityChangedEvent = _TextOverlayVisibilityChangedEvent;
  let TextOverlayVisibilityChangedEventProcessor = (_W = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "eventType", TextOverlayVisibilityChangedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const elements2 = await this._elementsSetup.complete();
      const observer = new MutationObserver(() => {
        if (elements2.canvasOverlay.style.top !== "100%" && elements2.textOverlay.classList.contains("show")) {
          events.next(new TextOverlayVisibilityChangedEvent(true));
        } else events.next(new TextOverlayVisibilityChangedEvent(false));
      });
      observer.observe(elements2.textOverlay, { attributes: true });
      return events.pipe(
        distinctUntilChanged(),
        debounceTime(50)
      );
    }
  }, __name(_W, "TextOverlayVisibilityChangedEventProcessor"), _W);
  __decorateClass$1q([
    inject(ElementsSetup)
  ], TextOverlayVisibilityChangedEventProcessor.prototype, "_elementsSetup", 2);
  TextOverlayVisibilityChangedEventProcessor = __decorateClass$1q([
    injectable()
  ], TextOverlayVisibilityChangedEventProcessor);
  let TextOverlayVisibilityChangedEventListener = (_X = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_X, "TextOverlayVisibilityChangedEventListener"), _X);
  __decorateClass$1q([
    inject(TextOverlayVisibilityChangedEventProcessor)
  ], TextOverlayVisibilityChangedEventListener.prototype, "_processor", 2);
  TextOverlayVisibilityChangedEventListener = __decorateClass$1q([
    injectable()
  ], TextOverlayVisibilityChangedEventListener);
  const textOverlayVisibilityChangedEventRegistration = {
    listenerType: TextOverlayVisibilityChangedEventListener,
    processorType: TextOverlayVisibilityChangedEventProcessor
  };
  var __defProp$1p = Object.defineProperty;
  var __getOwnPropDesc$s = Object.getOwnPropertyDescriptor;
  var __decorateClass$1p = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$s(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1p(target, key2, result);
    return result;
  }, "__decorateClass$1p");
  var skribblTool = /* @__PURE__ */ ((skribblTool2) => {
    skribblTool2[skribblTool2["brush"] = 0] = "brush";
    skribblTool2[skribblTool2["fill"] = 1] = "fill";
    skribblTool2[skribblTool2["deselected"] = -1] = "deselected";
    skribblTool2[skribblTool2["other"] = 2] = "other";
    return skribblTool2;
  })(skribblTool || {});
  const _ToolChangedEvent = class _ToolChangedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_ToolChangedEvent, "ToolChangedEvent");
  let ToolChangedEvent = _ToolChangedEvent;
  let ToolChangedEventProcessor = (_Y = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "eventType", ToolChangedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      document.addEventListener("skribblToolChanged", (event) => {
        const tool = event.detail;
        const toolEnum = tool > 2 ? 2 : tool;
        events.next(new ToolChangedEvent(toolEnum));
        this._logger.info("Tool changed", toolEnum);
      });
      return events;
    }
  }, __name(_Y, "ToolChangedEventProcessor"), _Y);
  ToolChangedEventProcessor = __decorateClass$1p([
    injectable()
  ], ToolChangedEventProcessor);
  let ToolChangedEventListener = (_Z = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_Z, "ToolChangedEventListener"), _Z);
  __decorateClass$1p([
    inject(ToolChangedEventProcessor)
  ], ToolChangedEventListener.prototype, "_processor", 2);
  ToolChangedEventListener = __decorateClass$1p([
    injectable()
  ], ToolChangedEventListener);
  const toolChangedEventRegistration = {
    listenerType: ToolChangedEventListener,
    processorType: ToolChangedEventProcessor
  };
  var __defProp$1o = Object.defineProperty;
  var __getOwnPropDesc$r = Object.getOwnPropertyDescriptor;
  var __decorateClass$1o = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$r(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1o(target, key2, result);
    return result;
  }, "__decorateClass$1o");
  const _WordGuessedEvent = class _WordGuessedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_WordGuessedEvent, "WordGuessedEvent");
  let WordGuessedEvent = _WordGuessedEvent;
  let WordGuessedEventProcessor = (__ = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "eventType", WordGuessedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const skribblMessages = await this._skribblMessageRelaySetup.complete();
      skribblMessages.serverMessages$.subscribe((event) => {
        if (event.id === 15) {
          const guessed = {
            playerId: event.data.id,
            word: event.data.word ?? void 0
          };
          this._logger.info("Word guessed", guessed);
          events.next(new WordGuessedEvent(guessed));
        }
      });
      return events;
    }
  }, __name(__, "WordGuessedEventProcessor"), __);
  __decorateClass$1o([
    inject(SkribblMessageRelaySetup)
  ], WordGuessedEventProcessor.prototype, "_skribblMessageRelaySetup", 2);
  WordGuessedEventProcessor = __decorateClass$1o([
    injectable()
  ], WordGuessedEventProcessor);
  let WordGuessedEventListener = (_$ = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_$, "WordGuessedEventListener"), _$);
  __decorateClass$1o([
    inject(WordGuessedEventProcessor)
  ], WordGuessedEventListener.prototype, "_processor", 2);
  WordGuessedEventListener = __decorateClass$1o([
    injectable()
  ], WordGuessedEventListener);
  const wordGuessedEventRegistration = {
    listenerType: WordGuessedEventListener,
    processorType: WordGuessedEventProcessor
  };
  var FeatureTag = /* @__PURE__ */ ((FeatureTag2) => {
    FeatureTag2["DRAWING"] = "drawing";
    FeatureTag2["INTERFACE"] = "interface";
    FeatureTag2["INFORMATION"] = "info";
    FeatureTag2["GAMEPLAY"] = "gameplay";
    FeatureTag2["SOCIAL"] = "social";
    FeatureTag2["PALANTIR"] = "palantir";
    FeatureTag2["DEVELOPMENT"] = "dev";
    return FeatureTag2;
  })(FeatureTag || {});
  const featureTags = Object.values(FeatureTag);
  const _Canvas_rate_icons = class _Canvas_rate_icons extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, null, safe_not_equal, {});
    }
  };
  __name(_Canvas_rate_icons, "Canvas_rate_icons");
  let Canvas_rate_icons = _Canvas_rate_icons;
  var __defProp$1n = Object.defineProperty;
  var __decorateClass$1n = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$1n(target, key2, result);
    return result;
  }, "__decorateClass$1n");
  const _CanvasRateIconsFeature = class _CanvasRateIconsFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "name", "Improved Like Icons");
      __publicField(this, "description", "Sets new like/dislike icons which better fit the skribbl style.");
      __publicField(this, "tags", [
        FeatureTag.INTERFACE
      ]);
      __publicField(this, "featureId", 46);
      __publicField(this, "_component");
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      elements2.gameRate.classList.add("typo-icons");
      this._component = new Canvas_rate_icons({
        target: document.body
      });
    }
    async onDestroy() {
      var _a2;
      const elements2 = await this._elementsSetup.complete();
      elements2.gameRate.classList.remove("typo-icons");
      (_a2 = this._component) == null ? void 0 : _a2.$destroy();
      this._component = void 0;
    }
  };
  __name(_CanvasRateIconsFeature, "CanvasRateIconsFeature");
  let CanvasRateIconsFeature = _CanvasRateIconsFeature;
  __decorateClass$1n([
    inject(ElementsSetup)
  ], CanvasRateIconsFeature.prototype, "_elementsSetup");
  var __defProp$1m = Object.defineProperty;
  var __getOwnPropDesc$q = Object.getOwnPropertyDescriptor;
  var __decorateClass$1m = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$q(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1m(target, key2, result);
    return result;
  }, "__decorateClass$1m");
  const _LobbyLeftEvent = class _LobbyLeftEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_LobbyLeftEvent, "LobbyLeftEvent");
  let LobbyLeftEvent = _LobbyLeftEvent;
  let LobbyLeftEventProcessor = (_aa = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "eventType", LobbyLeftEvent);
    }
    streamEvents() {
      const events = new Subject$1();
      document.addEventListener("leftLobby", async () => {
        this._logger.info("Lobby left");
        events.next(new LobbyLeftEvent(null));
      });
      return events;
    }
  }, __name(_aa, "LobbyLeftEventProcessor"), _aa);
  LobbyLeftEventProcessor = __decorateClass$1m([
    injectable()
  ], LobbyLeftEventProcessor);
  let LobbyLeftEventListener = (_ba = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_ba, "LobbyLeftEventListener"), _ba);
  __decorateClass$1m([
    inject(LobbyLeftEventProcessor)
  ], LobbyLeftEventListener.prototype, "_processor", 2);
  LobbyLeftEventListener = __decorateClass$1m([
    injectable()
  ], LobbyLeftEventListener);
  const lobbyLeftEventRegistration = {
    listenerType: LobbyLeftEventListener,
    processorType: LobbyLeftEventProcessor
  };
  const parseSkribblLobbyDataEvent = /* @__PURE__ */ __name((data, languages) => {
    return {
      id: data.id ?? null,
      private: data.type === 1,
      meId: data.me,
      ownerId: data.owner == -1 ? null : data.owner,
      drawerId: null,
      round: data.round + 1,
      settings: {
        language: languages.get(data.settings[0]) ?? "Unknown",
        players: data.settings[1],
        drawTime: data.settings[2],
        rounds: data.settings[3]
      },
      players: data.users
    };
  }, "parseSkribblLobbyDataEvent");
  var __defProp$1l = Object.defineProperty;
  var __getOwnPropDesc$p = Object.getOwnPropertyDescriptor;
  var __decorateClass$1l = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$p(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1l(target, key2, result);
    return result;
  }, "__decorateClass$1l");
  const _LobbyJoinedEvent = class _LobbyJoinedEvent extends ApplicationEvent {
    constructor(data) {
      super();
      this.data = data;
    }
  };
  __name(_LobbyJoinedEvent, "LobbyJoinedEvent");
  let LobbyJoinedEvent = _LobbyJoinedEvent;
  let LobbyJoinedEventProcessor = (_ca = class extends EventProcessor {
    constructor() {
      super(...arguments);
      __publicField(this, "_gameSettingsSetup");
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "eventType", LobbyJoinedEvent);
    }
    async streamEvents() {
      const events = new Subject$1();
      const skribblMessages = await this._skribblMessageRelaySetup.complete();
      const gameSettings = await this._gameSettingsSetup.complete();
      skribblMessages.serverMessages$.subscribe((event) => {
        var _a2;
        if (event.id === 10) {
          const lobby = parseSkribblLobbyDataEvent(event.data, gameSettings.languageSettings);
          const initialUpdate = parseLobbyStateUpdate(event.data.state);
          lobby.drawerId = ((_a2 = initialUpdate == null ? void 0 : initialUpdate.drawingStarted) == null ? void 0 : _a2.drawerId) ?? null;
          this._logger.info("Lobby joined", lobby);
          events.next(new LobbyJoinedEvent(lobby));
        }
      });
      document.addEventListener("practiceJoined", async (data) => {
        const gameSettings2 = await this._gameSettingsSetup.complete();
        const lobby = parseSkribblLobbyDataEvent(data.detail, gameSettings2.languageSettings);
        this._logger.info("Practice lobby joined", lobby);
        events.next(new LobbyJoinedEvent(lobby));
      });
      return events;
    }
  }, __name(_ca, "LobbyJoinedEventProcessor"), _ca);
  __decorateClass$1l([
    inject(GameSettingsSetup)
  ], LobbyJoinedEventProcessor.prototype, "_gameSettingsSetup", 2);
  __decorateClass$1l([
    inject(SkribblMessageRelaySetup)
  ], LobbyJoinedEventProcessor.prototype, "_skribblMessageRelaySetup", 2);
  LobbyJoinedEventProcessor = __decorateClass$1l([
    injectable()
  ], LobbyJoinedEventProcessor);
  let LobbyJoinedEventListener = (_da = class extends EventListener {
    constructor() {
      super(...arguments);
      __publicField(this, "_processor");
    }
  }, __name(_da, "LobbyJoinedEventListener"), _da);
  __decorateClass$1l([
    inject(LobbyJoinedEventProcessor)
  ], LobbyJoinedEventListener.prototype, "_processor", 2);
  LobbyJoinedEventListener = __decorateClass$1l([
    injectable()
  ], LobbyJoinedEventListener);
  const lobbyJoinedEventRegistration = {
    listenerType: LobbyJoinedEventListener,
    processorType: LobbyJoinedEventProcessor
  };
  var __defProp$1k = Object.defineProperty;
  var __getOwnPropDesc$o = Object.getOwnPropertyDescriptor;
  var __decorateClass$1k = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$o(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1k(target, key2, result);
    return result;
  }, "__decorateClass$1k");
  var __decorateParam$k = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$k");
  let LobbyService = (_ea = class {
    constructor(loggerFactory2, lobbyJoined, lobbyLeft, lobbyPlayerChanged, lobbyStateChanged, roundStarted, wordGuessed, elementsSetup, lobbyJoinFailedListener) {
      __publicField(this, "_logger");
      __publicField(this, "_currentLobby$", new BehaviorSubject(null));
      __publicField(this, "_currentLobbyDebounced$", new BehaviorSubject(null));
      __publicField(this, "_discoveredLobbies$", new BehaviorSubject(/* @__PURE__ */ new Map()));
      this.lobbyJoined = lobbyJoined;
      this.lobbyLeft = lobbyLeft;
      this.lobbyPlayerChanged = lobbyPlayerChanged;
      this.lobbyStateChanged = lobbyStateChanged;
      this.roundStarted = roundStarted;
      this.wordGuessed = wordGuessed;
      this.elementsSetup = elementsSetup;
      this.lobbyJoinFailedListener = lobbyJoinFailedListener;
      this._logger = loggerFactory2(this);
      merge$1(
        lobbyLeft.events$,
        lobbyJoined.events$,
        lobbyPlayerChanged.events$,
        lobbyStateChanged.events$,
        roundStarted.events$,
        wordGuessed.events$
      ).pipe(
        withLatestFrom(this._currentLobby$),
        /* compare updates with current lobby */
        map((data) => ({ update: data[0], currentLobby: data[1] })),
        map(({ update: update2, currentLobby }) => {
          this._logger.debug("Lobby update", update2, currentLobby);
          currentLobby = currentLobby === null ? null : structuredClone(currentLobby);
          if (update2 instanceof LobbyLeftEvent) {
            currentLobby = null;
          } else if (update2 instanceof LobbyJoinedEvent) {
            currentLobby = update2.data;
          } else if (currentLobby !== null && update2 instanceof RoundStartedEvent) {
            currentLobby.round = update2.data;
          } else if (currentLobby !== null && update2 instanceof WordGuessedEvent) {
            const guessed = update2.data;
            currentLobby.players.forEach((player) => {
              if (player.id === guessed.playerId) {
                player.guessed = true;
              }
            });
          } else if (currentLobby !== null && update2 instanceof LobbyStateChangedEvent) {
            const data = update2.data;
            if (data.drawingRevealed) {
              const scores = new Map(data.drawingRevealed.scores.map((score) => [score.playerId, score.score]));
              currentLobby.players.forEach((player) => {
                player.guessed = false;
                player.score = scores.get(player.id) ?? player.score;
              });
              currentLobby.drawerId = null;
            }
            if (data.drawingStarted !== void 0) {
              currentLobby.drawerId = data.drawingStarted.drawerId;
            }
          } else if (currentLobby !== null && update2 instanceof LobbyPlayerChangedEvent) {
            const data = update2.data;
            if (data.left) {
              const left = data.left;
              currentLobby.players = currentLobby.players.filter((user) => user.id !== left.id);
            } else if (data.joined) {
              currentLobby.players.push(data.joined);
            }
          }
          this._logger.debug("Lobby update processed", currentLobby);
          return currentLobby;
        }),
        /* emit to processing stream */
        tap((lobby) => this._currentLobby$.next(lobby)),
        /* emit debounced to publishing stream */
        debounceTime(100),
        /* debounce to prevent spamming */
        distinctUntilChanged((curr, prev) => JSON.stringify(curr) === JSON.stringify(prev))
        /* if join-leave spam debounced, take only changes */
      ).subscribe((data) => this._currentLobbyDebounced$.next(data));
      this.lobby$.subscribe((data) => {
        this._logger.info("Lobby changed", data);
        const map2 = this._discoveredLobbies$.value;
        if (data !== null && data.id !== null) map2.set(data.id, { ...data, seenAt: Date.now() });
        this._discoveredLobbies$.next(map2);
      });
    }
    async joinLobby(id2) {
      if (this._currentLobby$.value !== null) {
        this._logger.warn("Attempted to join a lobby while already in one");
        throw new Error("Already in a lobby");
      }
      const elements2 = await this.elementsSetup.complete();
      elements2.load.style.display = "block";
      elements2.home.style.display = "none";
      const result = firstValueFrom(this.lobbyJoinFailedListener.events$.pipe(
        mergeWith(this.lobbyJoined.events$),
        map((event) => event instanceof LobbyJoinedEvent)
      ));
      document.dispatchEvent(new CustomEvent("joinLobby", { detail: id2 }));
      return result;
    }
    leaveLobby() {
      if (this._currentLobby$.value === null) {
        this._logger.warn("Attempted to leave a lobby while not in one");
        throw new Error("Not in a lobby");
      }
      document.dispatchEvent(new CustomEvent("leaveLobby"));
    }
    get lobby$() {
      return this._currentLobbyDebounced$.asObservable();
    }
    get discoveredLobbies$() {
      return this._discoveredLobbies$.pipe(
        map((map2) => Array.from(map2.values()))
      );
    }
  }, __name(_ea, "LobbyService"), _ea);
  LobbyService = __decorateClass$1k([
    injectable(),
    __decorateParam$k(0, inject(loggerFactory)),
    __decorateParam$k(1, inject(LobbyJoinedEventListener)),
    __decorateParam$k(2, inject(LobbyLeftEventListener)),
    __decorateParam$k(3, inject(LobbyPlayerChangedEventListener)),
    __decorateParam$k(4, inject(LobbyStateChangedEventListener)),
    __decorateParam$k(5, inject(RoundStartedEventListener)),
    __decorateParam$k(6, inject(WordGuessedEventListener)),
    __decorateParam$k(7, inject(ElementsSetup)),
    __decorateParam$k(8, inject(LobbyJoinFailedListener))
  ], LobbyService);
  function create_fragment$1x(ctx) {
    let div1;
    let div0;
    let t0;
    let span;
    let t1;
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        t0 = space();
        span = element("span");
        t1 = text(
          /*content*/
          ctx[0]
        );
        attr(div0, "class", "icon svelte-c1csua");
        attr(span, "class", "svelte-c1csua");
        attr(div1, "class", "svelte-c1csua");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div1, t0);
        append(div1, span);
        append(span, t1);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*content*/
        1) set_data(
          t1,
          /*content*/
          ctx2[0]
        );
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
      }
    };
  }
  __name(create_fragment$1x, "create_fragment$1x");
  function instance$1n($$self, $$props, $$invalidate) {
    let { content: content2 = "Loading..." } = $$props;
    $$self.$$set = ($$props2) => {
      if ("content" in $$props2) $$invalidate(0, content2 = $$props2.content);
    };
    return [content2];
  }
  __name(instance$1n, "instance$1n");
  const _Bounceload = class _Bounceload extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1n, create_fragment$1x, safe_not_equal, { content: 0 });
    }
  };
  __name(_Bounceload, "Bounceload");
  let Bounceload = _Bounceload;
  function create_fragment$1w(ctx) {
    let div;
    let img;
    let img_src_value;
    let tooltipAction_action;
    let mounted;
    let dispose;
    return {
      c() {
        div = element("div");
        img = element("img");
        attr(img, "class", "typo-icon-button-graphic svelte-b0w31n");
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        set_style(img, "content", "var(--" + /*icon*/
        ctx[1] + ")");
        set_style(
          img,
          "width",
          /*size*/
          ctx[5]
        );
        attr(
          img,
          "alt",
          /*name*/
          ctx[2]
        );
        toggle_class(
          img,
          "effect",
          /*hoverMove*/
          ctx[3]
        );
        attr(div, "class", "typo-icon-button svelte-b0w31n");
        set_style(
          div,
          "order",
          /*order*/
          ctx[6] ?? "auto"
        );
        attr(div, "role", "button");
        attr(
          div,
          "data-name",
          /*name*/
          ctx[2]
        );
        attr(div, "tabindex", "0");
        toggle_class(
          div,
          "greyscale",
          /*greyscaleInactive*/
          ctx[4]
        );
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx[0]
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, img);
        if (!mounted) {
          dispose = [
            action_destroyer(tooltipAction_action = /*tooltipAction*/
            ctx[7].call(null, div, {
              title: (
                /*name*/
                ctx[2]
              ),
              lock: (
                /*lockTooltip*/
                ctx[8]
              )
            })),
            listen(
              div,
              "click",
              /*click_handler*/
              ctx[11]
            ),
            listen(
              div,
              "click",
              /*click_handler_1*/
              ctx[12]
            ),
            listen(
              div,
              "keypress",
              /*keypress_handler*/
              ctx[13]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*icon*/
        2) {
          set_style(img, "content", "var(--" + /*icon*/
          ctx2[1] + ")");
        }
        if (dirty & /*size*/
        32) {
          set_style(
            img,
            "width",
            /*size*/
            ctx2[5]
          );
        }
        if (dirty & /*name*/
        4) {
          attr(
            img,
            "alt",
            /*name*/
            ctx2[2]
          );
        }
        if (dirty & /*hoverMove*/
        8) {
          toggle_class(
            img,
            "effect",
            /*hoverMove*/
            ctx2[3]
          );
        }
        if (dirty & /*order*/
        64) {
          set_style(
            div,
            "order",
            /*order*/
            ctx2[6] ?? "auto"
          );
        }
        if (dirty & /*name*/
        4) {
          attr(
            div,
            "data-name",
            /*name*/
            ctx2[2]
          );
        }
        if (tooltipAction_action && is_function(tooltipAction_action.update) && dirty & /*name, lockTooltip*/
        260) tooltipAction_action.update.call(null, {
          title: (
            /*name*/
            ctx2[2]
          ),
          lock: (
            /*lockTooltip*/
            ctx2[8]
          )
        });
        if (dirty & /*greyscaleInactive*/
        16) {
          toggle_class(
            div,
            "greyscale",
            /*greyscaleInactive*/
            ctx2[4]
          );
        }
        if (dirty & /*disabled*/
        1) {
          toggle_class(
            div,
            "disabled",
            /*disabled*/
            ctx2[0]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$1w, "create_fragment$1w");
  function instance$1m($$self, $$props, $$invalidate) {
    let { disabled = false } = $$props;
    let { icon } = $$props;
    let { name } = $$props;
    let { hoverMove = true } = $$props;
    let { greyscaleInactive = false } = $$props;
    let { size = "37px" } = $$props;
    let { order = void 0 } = $$props;
    let { tooltipAction = /* @__PURE__ */ __name(() => {
    }, "tooltipAction") } = $$props;
    let { lockTooltip = void 0 } = $$props;
    const click = new Subject$1();
    const click$ = click.asObservable();
    function click_handler2(event) {
      bubble.call(this, $$self, event);
    }
    __name(click_handler2, "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => click.next(void 0), "click_handler_1");
    const keypress_handler = /* @__PURE__ */ __name((evt) => evt.code === "Enter" && click.next(void 0), "keypress_handler");
    $$self.$$set = ($$props2) => {
      if ("disabled" in $$props2) $$invalidate(0, disabled = $$props2.disabled);
      if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
      if ("name" in $$props2) $$invalidate(2, name = $$props2.name);
      if ("hoverMove" in $$props2) $$invalidate(3, hoverMove = $$props2.hoverMove);
      if ("greyscaleInactive" in $$props2) $$invalidate(4, greyscaleInactive = $$props2.greyscaleInactive);
      if ("size" in $$props2) $$invalidate(5, size = $$props2.size);
      if ("order" in $$props2) $$invalidate(6, order = $$props2.order);
      if ("tooltipAction" in $$props2) $$invalidate(7, tooltipAction = $$props2.tooltipAction);
      if ("lockTooltip" in $$props2) $$invalidate(8, lockTooltip = $$props2.lockTooltip);
    };
    return [
      disabled,
      icon,
      name,
      hoverMove,
      greyscaleInactive,
      size,
      order,
      tooltipAction,
      lockTooltip,
      click,
      click$,
      click_handler2,
      click_handler_1,
      keypress_handler
    ];
  }
  __name(instance$1m, "instance$1m");
  const _Icon_button = class _Icon_button extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1m, create_fragment$1w, safe_not_equal, {
        disabled: 0,
        icon: 1,
        name: 2,
        hoverMove: 3,
        greyscaleInactive: 4,
        size: 5,
        order: 6,
        tooltipAction: 7,
        lockTooltip: 8,
        click$: 10
      });
    }
    get click$() {
      return this.$$.ctx[10];
    }
  };
  __name(_Icon_button, "Icon_button");
  let Icon_button = _Icon_button;
  function create_if_block_5$6(ctx) {
    let h3;
    let t;
    return {
      c() {
        h3 = element("h3");
        t = text(
          /*title*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, h3, anchor);
        append(h3, t);
      },
      p(ctx2, dirty) {
        if (dirty & /*title*/
        2) set_data(
          t,
          /*title*/
          ctx2[1]
        );
      },
      d(detaching) {
        if (detaching) {
          detach(h3);
        }
      }
    };
  }
  __name(create_if_block_5$6, "create_if_block_5$6");
  function create_else_block$l(ctx) {
    let t0;
    let t1;
    let t2;
    let if_block3_anchor;
    let current;
    let if_block0 = (
      /*allowClose*/
      ctx[5] && create_if_block_4$a(ctx)
    );
    let if_block1 = (
      /*content*/
      ctx[0] !== void 0 && /*promptHandler*/
      ctx[3] === void 0 && create_if_block_3$a(ctx)
    );
    let if_block2 = (
      /*promptHandler*/
      ctx[3] !== void 0 && create_if_block_2$g(ctx)
    );
    let if_block3 = (
      /*confirmHandler*/
      ctx[2] !== void 0 && create_if_block_1$k(ctx)
    );
    return {
      c() {
        if (if_block0) if_block0.c();
        t0 = space();
        if (if_block1) if_block1.c();
        t1 = space();
        if (if_block2) if_block2.c();
        t2 = space();
        if (if_block3) if_block3.c();
        if_block3_anchor = empty();
      },
      m(target, anchor) {
        if (if_block0) if_block0.m(target, anchor);
        insert(target, t0, anchor);
        if (if_block1) if_block1.m(target, anchor);
        insert(target, t1, anchor);
        if (if_block2) if_block2.m(target, anchor);
        insert(target, t2, anchor);
        if (if_block3) if_block3.m(target, anchor);
        insert(target, if_block3_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (
          /*allowClose*/
          ctx2[5]
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_4$a(ctx2);
            if_block0.c();
            if_block0.m(t0.parentNode, t0);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        if (
          /*content*/
          ctx2[0] !== void 0 && /*promptHandler*/
          ctx2[3] === void 0
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
          } else {
            if_block1 = create_if_block_3$a(ctx2);
            if_block1.c();
            if_block1.m(t1.parentNode, t1);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
        if (
          /*promptHandler*/
          ctx2[3] !== void 0
        ) {
          if (if_block2) {
            if_block2.p(ctx2, dirty);
          } else {
            if_block2 = create_if_block_2$g(ctx2);
            if_block2.c();
            if_block2.m(t2.parentNode, t2);
          }
        } else if (if_block2) {
          if_block2.d(1);
          if_block2 = null;
        }
        if (
          /*confirmHandler*/
          ctx2[2] !== void 0
        ) {
          if (if_block3) {
            if_block3.p(ctx2, dirty);
            if (dirty & /*confirmHandler*/
            4) {
              transition_in(if_block3, 1);
            }
          } else {
            if_block3 = create_if_block_1$k(ctx2);
            if_block3.c();
            transition_in(if_block3, 1);
            if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
          }
        } else if (if_block3) {
          group_outros();
          transition_out(if_block3, 1, 1, () => {
            if_block3 = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block3);
        current = true;
      },
      o(local) {
        transition_out(if_block3);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(t1);
          detach(t2);
          detach(if_block3_anchor);
        }
        if (if_block0) if_block0.d(detaching);
        if (if_block1) if_block1.d(detaching);
        if (if_block2) if_block2.d(detaching);
        if (if_block3) if_block3.d(detaching);
      }
    };
  }
  __name(create_else_block$l, "create_else_block$l");
  function create_if_block$E(ctx) {
    let bounceload;
    let current;
    bounceload = new Bounceload({ props: { content: (
      /*content*/
      ctx[0]
    ) } });
    return {
      c() {
        create_component(bounceload.$$.fragment);
      },
      m(target, anchor) {
        mount_component(bounceload, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const bounceload_changes = {};
        if (dirty & /*content*/
        1) bounceload_changes.content = /*content*/
        ctx2[0];
        bounceload.$set(bounceload_changes);
      },
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(bounceload, detaching);
      }
    };
  }
  __name(create_if_block$E, "create_if_block$E");
  function create_if_block_4$a(ctx) {
    let span;
    let mounted;
    let dispose;
    return {
      c() {
        span = element("span");
        span.textContent = "×";
        attr(span, "class", "close-toast svelte-12e6hb5");
      },
      m(target, anchor) {
        insert(target, span, anchor);
        if (!mounted) {
          dispose = listen(
            span,
            "click",
            /*click_handler*/
            ctx[12]
          );
          mounted = true;
        }
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(span);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block_4$a, "create_if_block_4$a");
  function create_if_block_3$a(ctx) {
    let span;
    let t;
    return {
      c() {
        span = element("span");
        t = text(
          /*content*/
          ctx[0]
        );
        attr(span, "class", "svelte-12e6hb5");
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
      },
      p(ctx2, dirty) {
        if (dirty & /*content*/
        1) set_data(
          t,
          /*content*/
          ctx2[0]
        );
      },
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  __name(create_if_block_3$a, "create_if_block_3$a");
  function create_if_block_2$g(ctx) {
    let form;
    let input0;
    let t;
    let input1;
    let mounted;
    let dispose;
    return {
      c() {
        form = element("form");
        input0 = element("input");
        t = space();
        input1 = element("input");
        attr(input0, "type", "submit");
        input0.hidden = true;
        attr(input0, "class", "svelte-12e6hb5");
        attr(input1, "name", "typo-toast-input");
        input1.autofocus = true;
        attr(input1, "type", "text");
        attr(
          input1,
          "placeholder",
          /*content*/
          ctx[0]
        );
        attr(form, "class", "svelte-12e6hb5");
      },
      m(target, anchor) {
        insert(target, form, anchor);
        append(form, input0);
        append(form, t);
        append(form, input1);
        set_input_value(
          input1,
          /*promptContent*/
          ctx[9]
        );
        input1.focus();
        if (!mounted) {
          dispose = [
            listen(
              input1,
              "input",
              /*input1_input_handler*/
              ctx[13]
            ),
            listen(input1, "keydown", keydown_handler),
            listen(
              form,
              "submit",
              /*submit_handler*/
              ctx[14]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*content*/
        1) {
          attr(
            input1,
            "placeholder",
            /*content*/
            ctx2[0]
          );
        }
        if (dirty & /*promptContent*/
        512 && input1.value !== /*promptContent*/
        ctx2[9]) {
          set_input_value(
            input1,
            /*promptContent*/
            ctx2[9]
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(form);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_if_block_2$g, "create_if_block_2$g");
  function create_if_block_1$k(ctx) {
    let div;
    let span0;
    let iconbutton0;
    let t0;
    let t1_value = (
      /*confirmNaming*/
      (ctx[6] ?? "") + ""
    );
    let t1;
    let t2;
    let span1;
    let iconbutton1;
    let t3;
    let t4_value = (
      /*cancelNaming*/
      (ctx[7] ?? "") + ""
    );
    let t4;
    let current;
    let mounted;
    let dispose;
    iconbutton0 = new Icon_button({
      props: {
        icon: "file-img-enabled-gif",
        name: "Confirm",
        hoverMove: false,
        size: "1.5rem"
      }
    });
    iconbutton1 = new Icon_button({
      props: {
        icon: "file-img-disabled-gif",
        name: "Abort",
        hoverMove: false,
        size: "1.5rem"
      }
    });
    return {
      c() {
        div = element("div");
        span0 = element("span");
        create_component(iconbutton0.$$.fragment);
        t0 = space();
        t1 = text(t1_value);
        t2 = space();
        span1 = element("span");
        create_component(iconbutton1.$$.fragment);
        t3 = space();
        t4 = text(t4_value);
        attr(span0, "class", "svelte-12e6hb5");
        attr(span1, "class", "svelte-12e6hb5");
        attr(div, "class", "typo-toast-confirm svelte-12e6hb5");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, span0);
        mount_component(iconbutton0, span0, null);
        append(span0, t0);
        append(span0, t1);
        append(div, t2);
        append(div, span1);
        mount_component(iconbutton1, span1, null);
        append(span1, t3);
        append(span1, t4);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              span0,
              "click",
              /*click_handler_1*/
              ctx[15]
            ),
            listen(
              span1,
              "click",
              /*click_handler_2*/
              ctx[16]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if ((!current || dirty & /*confirmNaming*/
        64) && t1_value !== (t1_value = /*confirmNaming*/
        (ctx2[6] ?? "") + "")) set_data(t1, t1_value);
        if ((!current || dirty & /*cancelNaming*/
        128) && t4_value !== (t4_value = /*cancelNaming*/
        (ctx2[7] ?? "") + "")) set_data(t4, t4_value);
      },
      i(local) {
        if (current) return;
        transition_in(iconbutton0.$$.fragment, local);
        transition_in(iconbutton1.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(iconbutton0.$$.fragment, local);
        transition_out(iconbutton1.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(iconbutton0);
        destroy_component(iconbutton1);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_if_block_1$k, "create_if_block_1$k");
  function create_fragment$1v(ctx) {
    let div;
    let t;
    let current_block_type_index;
    let if_block1;
    let current;
    let if_block0 = (
      /*title*/
      ctx[1] !== void 0 && create_if_block_5$6(ctx)
    );
    const if_block_creators = [create_if_block$E, create_else_block$l];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*showLoading*/
        ctx2[4]
      ) return 0;
      return 1;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div = element("div");
        if (if_block0) if_block0.c();
        t = space();
        if_block1.c();
        attr(div, "class", "typo-toast svelte-12e6hb5");
        toggle_class(
          div,
          "closing",
          /*closing*/
          ctx[10]
        );
        toggle_class(
          div,
          "loading",
          /*showLoading*/
          ctx[4]
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if (if_block0) if_block0.m(div, null);
        append(div, t);
        if_blocks[current_block_type_index].m(div, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (
          /*title*/
          ctx2[1] !== void 0
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_5$6(ctx2);
            if_block0.c();
            if_block0.m(div, t);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
        if (!current || dirty & /*closing*/
        1024) {
          toggle_class(
            div,
            "closing",
            /*closing*/
            ctx2[10]
          );
        }
        if (!current || dirty & /*showLoading*/
        16) {
          toggle_class(
            div,
            "loading",
            /*showLoading*/
            ctx2[4]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block1);
        current = true;
      },
      o(local) {
        transition_out(if_block1);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if (if_block0) if_block0.d();
        if_blocks[current_block_type_index].d();
      }
    };
  }
  __name(create_fragment$1v, "create_fragment$1v");
  const keydown_handler = /* @__PURE__ */ __name((e) => e.stopPropagation(), "keydown_handler");
  function instance$1l($$self, $$props, $$invalidate) {
    let { content: content2 } = $$props;
    let { title } = $$props;
    let { closeHandler } = $$props;
    let { confirmHandler = void 0 } = $$props;
    let { promptHandler = void 0 } = $$props;
    let { showLoading = false } = $$props;
    let { allowClose = true } = $$props;
    let { confirmNaming = void 0 } = $$props;
    let { cancelNaming = void 0 } = $$props;
    let promptContent = "";
    let closing = false;
    const close = /* @__PURE__ */ __name(() => {
      setTimeout(() => closeHandler(), 150);
      $$invalidate(10, closing = true);
    }, "close");
    const click_handler2 = /* @__PURE__ */ __name(() => close(), "click_handler");
    function input1_input_handler() {
      promptContent = this.value;
      $$invalidate(9, promptContent);
    }
    __name(input1_input_handler, "input1_input_handler");
    const submit_handler2 = /* @__PURE__ */ __name((e) => {
      e.preventDefault();
      promptHandler(promptContent);
    }, "submit_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => confirmHandler(true), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(() => confirmHandler(false), "click_handler_2");
    $$self.$$set = ($$props2) => {
      if ("content" in $$props2) $$invalidate(0, content2 = $$props2.content);
      if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
      if ("closeHandler" in $$props2) $$invalidate(11, closeHandler = $$props2.closeHandler);
      if ("confirmHandler" in $$props2) $$invalidate(2, confirmHandler = $$props2.confirmHandler);
      if ("promptHandler" in $$props2) $$invalidate(3, promptHandler = $$props2.promptHandler);
      if ("showLoading" in $$props2) $$invalidate(4, showLoading = $$props2.showLoading);
      if ("allowClose" in $$props2) $$invalidate(5, allowClose = $$props2.allowClose);
      if ("confirmNaming" in $$props2) $$invalidate(6, confirmNaming = $$props2.confirmNaming);
      if ("cancelNaming" in $$props2) $$invalidate(7, cancelNaming = $$props2.cancelNaming);
    };
    return [
      content2,
      title,
      confirmHandler,
      promptHandler,
      showLoading,
      allowClose,
      confirmNaming,
      cancelNaming,
      close,
      promptContent,
      closing,
      closeHandler,
      click_handler2,
      input1_input_handler,
      submit_handler2,
      click_handler_1,
      click_handler_2
    ];
  }
  __name(instance$1l, "instance$1l");
  const _Toast = class _Toast extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1l, create_fragment$1v, safe_not_equal, {
        content: 0,
        title: 1,
        closeHandler: 11,
        confirmHandler: 2,
        promptHandler: 3,
        showLoading: 4,
        allowClose: 5,
        confirmNaming: 6,
        cancelNaming: 7,
        close: 8
      });
    }
    get close() {
      return this.$$.ctx[8];
    }
  };
  __name(_Toast, "Toast");
  let Toast = _Toast;
  var __defProp$1j = Object.defineProperty;
  var __getOwnPropDesc$n = Object.getOwnPropertyDescriptor;
  var __decorateClass$1j = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$n(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1j(target, key2, result);
    return result;
  }, "__decorateClass$1j");
  var __decorateParam$j = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$j");
  let ToastService = (_fa = class {
    constructor(loggerFactory2, _elementsSetup) {
      __publicField(this, "_logger");
      this._elementsSetup = _elementsSetup;
      this._logger = loggerFactory2(this);
    }
    /**
     * Show a toast with a title and message for a timespan
     * @param title
     * @param content
     * @param timeout
     */
    async showToast(title, content2, timeout2) {
      const elements2 = await this._elementsSetup.complete();
      const toast = new Toast({
        target: elements2.toastContainer,
        props: {
          closeHandler: /* @__PURE__ */ __name(() => {
            toast.$destroy();
          }, "closeHandler"),
          title,
          content: content2,
          showLoading: false
        }
      });
      setTimeout(() => toast.close(), timeout2 ?? 3e3);
    }
    /**
     * Show a sticky toast with a title and message
     * Will be kept open until manually closed
     * @param title
     * @param content
     * @param allowClose
     */
    async showStickyToast(title, content2, allowClose) {
      const elements2 = await this._elementsSetup.complete();
      const closed = new Subject$1();
      const toast = new Toast({
        target: elements2.toastContainer,
        props: {
          closeHandler: /* @__PURE__ */ __name(() => {
            toast.$destroy();
            closed.next();
          }, "closeHandler"),
          title,
          content: content2,
          showLoading: false,
          allowClose: allowClose === void 0 ? false : allowClose
        }
      });
      return {
        close: /* @__PURE__ */ __name(() => toast.close(), "close"),
        update: /* @__PURE__ */ __name((title2, content22) => {
          toast.$set({ title: title2, content: content22 });
        }, "update"),
        closed$: closed.asObservable(),
        resolve: /* @__PURE__ */ __name((message, timeout2) => {
          toast.$set({ showLoading: false, title: message ?? "Done" });
          setTimeout(() => toast.close(), timeout2 ?? 3e3);
        }, "resolve")
      };
    }
    /**
     * Show a toast with a loading spinner and message
     * Returns a handler object which can be used to resolve the toast to a normal toast
     * with title/content, or an error toast with title/content, or defaults for error/success.
     * @param content
     */
    async showLoadingToast(content2) {
      const elements2 = await this._elementsSetup.complete();
      const toast = new Toast({
        target: elements2.toastContainer,
        props: {
          closeHandler: /* @__PURE__ */ __name(() => {
            toast.$destroy();
          }, "closeHandler"),
          title: void 0,
          content: content2,
          showLoading: true
        }
      });
      return {
        close: /* @__PURE__ */ __name(() => toast.close(), "close"),
        resolve: /* @__PURE__ */ __name((message, timeout2) => {
          toast.$set({ showLoading: false, title: message ?? "Done" });
          setTimeout(() => toast.close(), timeout2 ?? 3e3);
        }, "resolve"),
        reject: /* @__PURE__ */ __name((message, title, timeout2) => {
          toast.$set({ showLoading: false, title: title ?? "Error" });
          if (message !== void 0) toast.$set({ content: message });
          setTimeout(() => toast.close(), timeout2 ?? 3e3);
        }, "reject")
      };
    }
    async showPromptToast(title, content2 = void 0, timeout2 = 1e4) {
      const elements2 = await this._elementsSetup.complete();
      const result = new Subject$1();
      const toast = new Toast({
        target: elements2.toastContainer,
        props: {
          closeHandler: /* @__PURE__ */ __name(() => {
            toast.$destroy();
            if (!result.closed) result.next(null);
            result.complete();
          }, "closeHandler"),
          promptHandler: /* @__PURE__ */ __name((value) => {
            result.next(value);
            toast.close();
          }, "promptHandler"),
          title,
          content: content2,
          showLoading: false
        }
      });
      if (timeout2) {
        setTimeout(() => {
          toast.close();
        }, timeout2);
      }
      return {
        close: /* @__PURE__ */ __name(() => toast.close(), "close"),
        result: firstValueFrom(result)
      };
    }
    async showConfirmToast(title, content2 = void 0, timeout2 = 3e4, naming) {
      const elements2 = await this._elementsSetup.complete();
      const result = new Subject$1();
      const toast = new Toast({
        target: elements2.toastContainer,
        props: {
          closeHandler: /* @__PURE__ */ __name(() => {
            toast.$destroy();
            if (!result.closed) result.next(false);
            result.complete();
          }, "closeHandler"),
          confirmHandler: /* @__PURE__ */ __name((value) => {
            result.next(value);
            toast.close();
          }, "confirmHandler"),
          title,
          content: content2,
          showLoading: false,
          confirmNaming: naming == null ? void 0 : naming.confirm,
          cancelNaming: naming == null ? void 0 : naming.cancel
        }
      });
      if (timeout2) {
        setTimeout(() => {
          toast.close();
        }, timeout2);
      }
      return {
        close: /* @__PURE__ */ __name(() => toast.close(), "close"),
        result: firstValueFrom(result)
      };
    }
  }, __name(_fa, "ToastService"), _fa);
  ToastService = __decorateClass$1j([
    injectable(),
    __decorateParam$j(0, inject(loggerFactory)),
    __decorateParam$j(1, inject(ElementsSetup))
  ], ToastService);
  var __defProp$1i = Object.defineProperty;
  var __getOwnPropDesc$m = Object.getOwnPropertyDescriptor;
  var __decorateClass$1i = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$m(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1i(target, key2, result);
    return result;
  }, "__decorateClass$1i");
  let PrioritizedCanvasEventsSetup = (_ga = class extends Setup {
    constructor() {
      super(...arguments);
      __publicField(this, "_interceptor");
    }
    async runSetup() {
      return this._interceptor.canvasPrioritizedEventsReady;
    }
  }, __name(_ga, "PrioritizedCanvasEventsSetup"), _ga);
  __decorateClass$1i([
    inject(Interceptor)
  ], PrioritizedCanvasEventsSetup.prototype, "_interceptor", 2);
  PrioritizedCanvasEventsSetup = __decorateClass$1i([
    earlySetup()
  ], PrioritizedCanvasEventsSetup);
  const createStylesheet = /* @__PURE__ */ __name(() => {
    const style2 = document.createElement("style");
    document.head.append(style2);
    if (style2.sheet === null) {
      style2.remove();
      throw new Error("Unable to create stylesheet");
    }
    const handle = {
      sheet: style2.sheet,
      remove: style2.remove.bind(style2),
      clear: /* @__PURE__ */ __name(() => {
        style2.innerText = "";
      }, "clear"),
      replace: /* @__PURE__ */ __name((cssText) => {
        style2.innerText = cssText;
      }, "replace")
    };
    return handle;
  }, "createStylesheet");
  function create_fragment$1u(ctx) {
    let t0;
    let br0;
    let t1;
    let br1;
    let t2;
    let br2;
    let br3;
    let t3;
    let br4;
    let t4;
    let br5;
    return {
      c() {
        t0 = text("Canvas Zoom lets you zoom the drawing canvas, so you can work on details more easily. ");
        br0 = element("br");
        t1 = text('\nTo start zooming, press the "Zoom Toggle" hotkey.');
        br1 = element("br");
        t2 = text("\nThe center of the zoomed area will be at your last mouse position. The mouse has to be on the canvas when you enable zoom. ");
        br2 = element("br");
        br3 = element("br");
        t3 = text("\nTo adjust the zoom level, you can press the Zoom Level hotkeys.");
        br4 = element("br");
        t4 = text('\nYou can exit the zoom by pressing the "Zoom Toggle" hotkey again. ');
        br5 = element("br");
      },
      m(target, anchor) {
        insert(target, t0, anchor);
        insert(target, br0, anchor);
        insert(target, t1, anchor);
        insert(target, br1, anchor);
        insert(target, t2, anchor);
        insert(target, br2, anchor);
        insert(target, br3, anchor);
        insert(target, t3, anchor);
        insert(target, br4, anchor);
        insert(target, t4, anchor);
        insert(target, br5, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(br0);
          detach(t1);
          detach(br1);
          detach(t2);
          detach(br2);
          detach(br3);
          detach(t3);
          detach(br4);
          detach(t4);
          detach(br5);
        }
      }
    };
  }
  __name(create_fragment$1u, "create_fragment$1u");
  const _Canvas_zoom_info = class _Canvas_zoom_info extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment$1u, safe_not_equal, {});
    }
  };
  __name(_Canvas_zoom_info, "Canvas_zoom_info");
  let Canvas_zoom_info = _Canvas_zoom_info;
  var __defProp$1h = Object.defineProperty;
  var __decorateClass$1h = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$1h(target, key2, result);
    return result;
  }, "__decorateClass$1h");
  const _CanvasZoomFeature = class _CanvasZoomFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_toastService");
      __publicField(this, "_prioritizedCanvasEventsSetup");
      __publicField(this, "_lobbyStateChangedEventListener");
      __publicField(this, "_lobbyLeftEventListener");
      __publicField(this, "_imageResetEventListener");
      __publicField(this, "_lobbyService");
      __publicField(this, "name", "Canvas Zoom");
      __publicField(this, "description", "Lets you zoom a section of the canvas when you're drawing");
      __publicField(this, "tags", [
        FeatureTag.DRAWING
      ]);
      __publicField(this, "featureId", 26);
      __publicField(this, "_enableOnlyWhenDrawingSetting", this.useSetting(new BooleanExtensionSetting("trigger_require_drawing", true, this).withName("Zoom Only When Drawing").withDescription("Only allow start zooming with the hotkey when you're currently drawing")));
      __publicField(this, "_toggleZoomHotkey", this.useHotkey(new HotkeyAction(
        "toggle_zoom",
        "Toggle Zoom",
        "Toggles canvas zooming on or off",
        this,
        () => {
          this._currentMouseoverCoordinates$.pipe(
            combineLatestWith(this._zoomActive$, this._enableOnlyWhenDrawingSetting.changes$, this._lobbyService.lobby$),
            take(1)
          ).subscribe(([coords, active, onlyWhenDrawing, lobby]) => {
            if (onlyWhenDrawing && (lobby === null || lobby.drawerId !== lobby.meId)) {
              this._zoomActive$.next(false);
            } else {
              this._zoomActive$.next(active !== false || coords === null ? false : coords);
            }
          });
        },
        true,
        ["ControlLeft"]
      )));
      __publicField(this, "_zoomLevelHotkeys", [1, 2, 3, 4, 5].map((level) => this.useHotkey(new HotkeyAction(
        `zoom_level_${level}`,
        `Zoom Level ${level}`,
        `Set the zoom level to ${level}`,
        this,
        () => this._zoomLevel$.next(level),
        true,
        [`Digit${level}`]
      ))));
      __publicField(this, "_currentMouseoverCoordinates$", new BehaviorSubject(null));
      __publicField(this, "_zoomActive$", new BehaviorSubject(false));
      __publicField(this, "_zoomLevel$", new BehaviorSubject(1));
      __publicField(this, "_toastHandle");
      __publicField(this, "_zoomStateSubscription");
      __publicField(this, "_zoomResetSubscription");
      __publicField(this, "_zoomStyle");
      __publicField(this, "_canvasPointermoveListener", this.onCanvasPointermove.bind(this));
      __publicField(this, "_canvasPointeroutListener", this.onCanvasPointerout.bind(this));
    }
    get featureInfoComponent() {
      return { componentType: Canvas_zoom_info, props: {} };
    }
    async onActivate() {
      const { add } = await this._prioritizedCanvasEventsSetup.complete();
      add("postDraw")("pointermove", this._canvasPointermoveListener);
      add("postDraw")("pointerout", this._canvasPointeroutListener);
      this._zoomStyle = createStylesheet();
      this._zoomResetSubscription = this._imageResetEventListener.events$.pipe(
        /* on image clear */
        mergeWith(
          this._lobbyStateChangedEventListener.events$.pipe(
            /* when drawing revealed or started */
            filter(
              (event) => event.data.drawingRevealed !== void 0 || event.data.drawingStarted !== void 0
            )
          ),
          this._lobbyLeftEventListener.events$
          /* when leaving the lobby */
        )
      ).subscribe(() => {
        this._zoomActive$.next(false);
      });
      this._zoomStateSubscription = this._zoomActive$.pipe(
        distinctUntilChanged(),
        combineLatestWith(this._zoomLevel$),
        pairwise()
      ).subscribe((state) => this.processZoomStateUpdate(state));
    }
    async onDestroy() {
      var _a2, _b2, _c2, _d2;
      const { remove } = await this._prioritizedCanvasEventsSetup.complete();
      remove("pointermove", this._canvasPointermoveListener);
      remove("pointerout", this._canvasPointeroutListener);
      (_a2 = this._zoomStyle) == null ? void 0 : _a2.remove();
      this._zoomStyle = void 0;
      (_b2 = this._toastHandle) == null ? void 0 : _b2.close();
      (_c2 = this._zoomStateSubscription) == null ? void 0 : _c2.unsubscribe();
      (_d2 = this._zoomResetSubscription) == null ? void 0 : _d2.unsubscribe();
      this._zoomStateSubscription = void 0;
      this._zoomResetSubscription = void 0;
      this._toastHandle = void 0;
      this._zoomActive$.next(false);
      this._currentMouseoverCoordinates$.next(null);
    }
    async setZoom(level, position) {
      this._logger.debug("Setting zoom level", level);
      const sheet = this._zoomStyle;
      if (!sheet) {
        this._logger.error("Zoom style element not found");
        return;
      }
      if (level === void 0 || position === void 0) {
        sheet.clear();
        return;
      }
      sheet.replace(`
      #game-canvas {
        width: 800px;
        aspect-ratio: 8/6;
      }
   
      #game-canvas canvas {
        position: absolute;
        width: calc(${level * 2} * 100%);
        top: calc(-100% * (${position[1]} / 600 * ${level * 2 - 1}));
        left: calc(-100% * (${position[0]} / 800 * ${level * 2 - 1}));
      }
    `);
    }
    onCanvasPointermove(event) {
      if (this._zoomActive$.value === false) this._currentMouseoverCoordinates$.next([event.offsetX, event.offsetY]);
    }
    onCanvasPointerout() {
      this._currentMouseoverCoordinates$.next(null);
    }
    async processZoomStateUpdate([[prevState, prevLevel], [state, level]]) {
      var _a2;
      this._logger.debug("Zoom state processing", { prevState, prevLevel }, { state, level }, this._toastHandle);
      await this.setZoom(state !== false ? level : void 0, state !== false ? state : void 0);
      if (state !== false && prevState === false) {
        if (this._toastHandle !== void 0) {
          this._logger.warn("Toast handle unexpected existing when just triggered");
          this._toastHandle.close();
        }
        this._toastHandle = await this._toastService.showStickyToast("Canvas zoom", "Click one of the zoom level hotkeys to set the zoom level");
      }
      if (state === false && prevState !== false) {
        if (this._toastHandle === void 0) {
          this._logger.warn("Toast handle unexpected not existing when just stopped");
        }
        (_a2 = this._toastHandle) == null ? void 0 : _a2.close();
        this._toastHandle = void 0;
      }
      return;
    }
    get onlyWhenDrawingStore() {
      return this._enableOnlyWhenDrawingSetting.store;
    }
  };
  __name(_CanvasZoomFeature, "CanvasZoomFeature");
  let CanvasZoomFeature = _CanvasZoomFeature;
  __decorateClass$1h([
    inject(ToastService)
  ], CanvasZoomFeature.prototype, "_toastService");
  __decorateClass$1h([
    inject(PrioritizedCanvasEventsSetup)
  ], CanvasZoomFeature.prototype, "_prioritizedCanvasEventsSetup");
  __decorateClass$1h([
    inject(LobbyStateChangedEventListener)
  ], CanvasZoomFeature.prototype, "_lobbyStateChangedEventListener");
  __decorateClass$1h([
    inject(LobbyLeftEventListener)
  ], CanvasZoomFeature.prototype, "_lobbyLeftEventListener");
  __decorateClass$1h([
    inject(ImageResetEventListener)
  ], CanvasZoomFeature.prototype, "_imageResetEventListener");
  __decorateClass$1h([
    inject(LobbyService)
  ], CanvasZoomFeature.prototype, "_lobbyService");
  const replaceOrAddCssRule = /* @__PURE__ */ __name((styleSheet, cssText, index) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    if (cssText === void 0) {
      if (index !== void 0) {
        const rule = (_a2 = styleSheet.sheet) == null ? void 0 : _a2.cssRules[index];
        if (rule) {
          (_b2 = styleSheet.sheet) == null ? void 0 : _b2.deleteRule(index);
          (_c2 = styleSheet.sheet) == null ? void 0 : _c2.insertRule(".placeholder-empty-rule:not(*) {color: unset;}", index);
        }
      }
      return index;
    }
    if (index !== void 0) {
      const rule = (_d2 = styleSheet.sheet) == null ? void 0 : _d2.cssRules[index];
      if (rule) {
        (_e2 = styleSheet.sheet) == null ? void 0 : _e2.deleteRule(index);
        (_f2 = styleSheet.sheet) == null ? void 0 : _f2.insertRule(cssText, index);
      }
      return index;
    }
    return (_h2 = styleSheet.sheet) == null ? void 0 : _h2.insertRule(cssText, (_g2 = styleSheet.sheet) == null ? void 0 : _g2.cssRules.length);
  }, "replaceOrAddCssRule");
  const _SkribblLandingPlayer = class _SkribblLandingPlayer {
    constructor(_login, _customizerContainer, _avatarContainer) {
      __publicField(this, "_playerHideAvatarRuleIndex");
      __publicField(this, "_playerStyle");
      __publicField(this, "_containerId", "typo-customize-player-display");
      __publicField(this, "iconsContainer", null);
      this._login = _login;
      this._customizerContainer = _customizerContainer;
      this._avatarContainer = _avatarContainer;
      this._customizerContainer.classList.add(this._containerId);
      this._playerStyle = document.createElement("style");
      this._customizerContainer.appendChild(this._playerStyle);
    }
    destroy() {
      this._playerStyle.remove();
      this._customizerContainer.classList.remove(this._containerId);
    }
    get typoId() {
      return { login: this._login };
    }
    get avatarContainer() {
      return this._avatarContainer;
    }
    get backgroundContainer() {
      return this._customizerContainer;
    }
    get container() {
      return this._customizerContainer;
    }
    set useBackground(value) {
      this._customizerContainer.style.backgroundColor = value ? "" : "transparent";
      this._customizerContainer.style.zIndex = value ? "" : "1";
    }
    set useSafeColor(value) {
    }
    set adjustToContainSprites(value) {
    }
    set viewPlayerId(value) {
    }
    set hideAvatar(value) {
      this._playerHideAvatarRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        value ? `
      .${this._containerId} .avatar > :is(.eyes, .mouth, .color) { display: ${value ? "none" : "block"}
      }` : void 0,
        this._playerHideAvatarRuleIndex
      );
    }
  };
  __name(_SkribblLandingPlayer, "SkribblLandingPlayer");
  let SkribblLandingPlayer = _SkribblLandingPlayer;
  const _SkribblLobbyPlayer = class _SkribblLobbyPlayer {
    constructor(_player, _lobbyKey, _playerLogin) {
      __publicField(this, "_elementId");
      __publicField(this, "_playerContainer");
      __publicField(this, "_avatarContainer");
      __publicField(this, "_backgroundContainer");
      __publicField(this, "_iconsContainer");
      __publicField(this, "_playerStyle");
      __publicField(this, "_backgroundRuleIndex");
      __publicField(this, "_fontColorRuleIndex");
      __publicField(this, "_fontColorGuessedRuleIndex");
      __publicField(this, "_fontShadowRuleIndex");
      __publicField(this, "_resizeRuleIndex");
      __publicField(this, "_elevateDrawingRuleIndex");
      __publicField(this, "_alignRuleIndex");
      __publicField(this, "_playerIdRuleIndex");
      __publicField(this, "_playerInfoRuleIndex");
      __publicField(this, "_playerHideAvatarRuleIndex");
      __publicField(this, "_zLayerRuleIndex");
      this._player = _player;
      this._lobbyKey = _lobbyKey;
      this._playerLogin = _playerLogin;
      if (_lobbyKey === void 0 && _playerLogin === void 0)
        throw new Error("No identification provided");
      this._playerContainer = requireElement(`#game-players .player[playerid='${this._player.id}']`);
      this._avatarContainer = requireElement(".avatar", this._playerContainer);
      this._backgroundContainer = requireElement(".player-background", this._playerContainer);
      this._iconsContainer = requireElement(".player-icons", this._playerContainer);
      this._elementId = "typo-lobby-player-" + _SkribblLobbyPlayer.idCounter++;
      this._playerStyle = document.createElement("style");
      this._playerContainer.classList.add(this._elementId);
      this._playerContainer.appendChild(this._playerStyle);
      replaceOrAddCssRule(
        this._playerStyle,
        `.${this._elementId} { z-index: ${_player.id}; }`,
        this._zLayerRuleIndex
      );
    }
    destroy() {
      this._playerContainer.classList.remove(this._elementId);
      this._playerStyle.remove();
    }
    get typoId() {
      if (this._playerLogin !== void 0) return { login: this._playerLogin };
      if (this._lobbyKey !== void 0)
        return { lobbyKey: this._lobbyKey, lobbyPlayerId: this._player.id };
      throw new Error("No identification provided");
    }
    get player() {
      return this._player;
    }
    get lobbyPlayerId() {
      return this._player.id;
    }
    get name() {
      return this._player.name;
    }
    get container() {
      return this._playerContainer;
    }
    get avatarContainer() {
      return this._avatarContainer;
    }
    get backgroundContainer() {
      return this._backgroundContainer;
    }
    get iconsContainer() {
      return this._iconsContainer;
    }
    set useBackground(value) {
      this._backgroundRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        !value ? `.${this._elementId} .player-background { background-color: transparent !important; }` : void 0,
        this._backgroundRuleIndex
      );
    }
    set useSafeColor(value) {
      this._fontColorRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        value ? `
      .${this._elementId}:not(.guessed) > :not(.player-bubble) *, .${this._elementId}:not(.guessed) .player-info:after { 
        color: White !important; 
      }` : void 0,
        this._fontColorRuleIndex
      );
      this._fontColorGuessedRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        value ? `
      .${this._elementId}:is(.guessed) > :not(.player-bubble) *, .${this._elementId}:is(.guessed) .player-info:after { 
        color: #56ce27 !important;
      }` : void 0,
        this._fontColorGuessedRuleIndex
      );
      this._fontShadowRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        value ? `
      .${this._elementId} > :not(.player-bubble) *, .${this._elementId} .player-info:after { 
        text-shadow: 0px 0px 25px black, 0px 0px 10px black, 0px 0px 5px black !important;
      }` : void 0,
        this._fontShadowRuleIndex
      );
    }
    set adjustToContainSprites(value) {
      this._resizeRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        value ? `.${this._elementId} { height: 56px !important; }` : void 0,
        this._resizeRuleIndex
      );
      this._alignRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        value ? `.${this._elementId} .player-avatar-container { top: calc((100% - var(--UNIT)) / 2) !important; }` : void 0,
        this._alignRuleIndex
      );
      this._elevateDrawingRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        value ? `#game-players .${this._elementId} .player-avatar-container .avatar .drawing { z-index: 100; }` : void 0,
        this._elevateDrawingRuleIndex
      );
    }
    set viewPlayerId(value) {
      this._playerIdRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        value ? `
       .${this._elementId} .player-score { 
          display: none; 
       }` : void 0,
        this._playerIdRuleIndex
      );
      this._playerInfoRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        value ? `
       .${this._elementId} .player-info:after { 
          content: "#${this._player.id}"; 
       }` : void 0,
        this._playerInfoRuleIndex
      );
    }
    set hideAvatar(value) {
      this._playerHideAvatarRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        value ? `
      .${this._elementId} .avatar > :is(.eyes, .mouth, .color) { display: ${value ? "none" : "block"}
      }` : void 0,
        this._playerHideAvatarRuleIndex
      );
    }
  };
  __name(_SkribblLobbyPlayer, "SkribblLobbyPlayer");
  __publicField(_SkribblLobbyPlayer, "idCounter", 0);
  let SkribblLobbyPlayer = _SkribblLobbyPlayer;
  const _OidcLogin = class _OidcLogin {
    constructor() {
      __publicField(this, "config", {
        issuer: "https://api.typo.rip/openid",
        redirectUri: "https://skribbl.io",
        clientId: "1"
      });
    }
    async getOidcConfig() {
      if (_OidcLogin._oidcConfig) return _OidcLogin._oidcConfig;
      const response = await fetch(this.config.issuer + "/.well-known/openid-configuration");
      if (!response.ok) throw new Error("Failed to fetch OIDC configuration");
      _OidcLogin._oidcConfig = await response.json();
      return _OidcLogin._oidcConfig;
    }
    async loginRedirect() {
      const oidcConfig = await this.getOidcConfig();
      const authUrl = new URL(oidcConfig.authorization_endpoint);
      authUrl.searchParams.append("client_id", this.config.clientId);
      authUrl.searchParams.append("redirect_uri", this.config.redirectUri);
      authUrl.searchParams.append("response_type", "code");
      window.location.href = authUrl.toString();
    }
    hasRedirectCallback() {
      const state = new URLSearchParams(window.location.search);
      return state.has("code");
    }
    async exchangeAuthCode() {
      const oidcConfig = await this.getOidcConfig();
      const state = new URLSearchParams(window.location.search);
      const code = state.get("code");
      if (!code) throw new Error("No code found in URL");
      const tokenResponse = await fetch(oidcConfig.token_endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          grant_type: "authorization_code",
          code,
          redirect_uri: this.config.redirectUri,
          client_id: this.config.clientId
        })
      });
      if (!tokenResponse.ok) throw new Error("Failed to exchange code for token");
      this.clearUrlParams();
      const tokenData = await tokenResponse.json();
      return tokenData.access_token;
    }
    clearUrlParams() {
      const url = new URL(window.location.href);
      url.searchParams.delete("code");
      url.searchParams.delete("state");
      window.history.replaceState({}, document.title, url.toString());
    }
    async exchangeLegacyToken(token) {
      const oidcConfig = await this.getOidcConfig();
      const tokenResponse = await fetch(oidcConfig.token_endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          grant_type: "typo-legacy-token",
          subject_token: token,
          client_id: this.config.clientId
        })
      });
      if (!tokenResponse.ok) throw new Error("Failed to exchange code for token");
      this.clearUrlParams();
      const tokenData = await tokenResponse.json();
      return tokenData.access_token;
    }
  };
  __name(_OidcLogin, "OidcLogin");
  __publicField(_OidcLogin, "_oidcConfig");
  let OidcLogin = _OidcLogin;
  const BASE_PATH = "http://localhost".replace(/\/+$/, "");
  const _Configuration = class _Configuration {
    constructor(configuration = {}) {
      this.configuration = configuration;
    }
    set config(configuration) {
      this.configuration = configuration;
    }
    get basePath() {
      return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }
    get fetchApi() {
      return this.configuration.fetchApi;
    }
    get middleware() {
      return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
      return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
      return this.configuration.username;
    }
    get password() {
      return this.configuration.password;
    }
    get apiKey() {
      const apiKey = this.configuration.apiKey;
      if (apiKey) {
        return typeof apiKey === "function" ? apiKey : () => apiKey;
      }
      return void 0;
    }
    get accessToken() {
      const accessToken = this.configuration.accessToken;
      if (accessToken) {
        return typeof accessToken === "function" ? accessToken : async () => accessToken;
      }
      return void 0;
    }
    get headers() {
      return this.configuration.headers;
    }
    get credentials() {
      return this.configuration.credentials;
    }
  };
  __name(_Configuration, "Configuration");
  let Configuration = _Configuration;
  const DefaultConfig = new Configuration();
  const _BaseAPI = class _BaseAPI {
    constructor(configuration = DefaultConfig) {
      __publicField(this, "middleware");
      __publicField(this, "fetchApi", /* @__PURE__ */ __name(async (url, init2) => {
        let fetchParams = { url, init: init2 };
        for (const middleware of this.middleware) {
          if (middleware.pre) {
            fetchParams = await middleware.pre({
              fetch: this.fetchApi,
              ...fetchParams
            }) || fetchParams;
          }
        }
        let response = void 0;
        try {
          response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
          for (const middleware of this.middleware) {
            if (middleware.onError) {
              response = await middleware.onError({
                fetch: this.fetchApi,
                url: fetchParams.url,
                init: fetchParams.init,
                error: e,
                response: response ? response.clone() : void 0
              }) || response;
            }
          }
          if (response === void 0) {
            if (e instanceof Error) {
              throw new FetchError(e, "The request failed and the interceptors did not return an alternative response");
            } else {
              throw e;
            }
          }
        }
        for (const middleware of this.middleware) {
          if (middleware.post) {
            response = await middleware.post({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              response: response.clone()
            }) || response;
          }
        }
        return response;
      }, "fetchApi"));
      this.configuration = configuration;
      this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
      const next = this.clone();
      next.middleware = next.middleware.concat(...middlewares);
      return next;
    }
    withPreMiddleware(...preMiddlewares) {
      const middlewares = preMiddlewares.map((pre) => ({ pre }));
      return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
      const middlewares = postMiddlewares.map((post) => ({ post }));
      return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
      if (!mime) {
        return false;
      }
      return _BaseAPI.jsonRegex.test(mime);
    }
    async request(context, initOverrides) {
      const { url, init: init2 } = await this.createFetchParams(context, initOverrides);
      const response = await this.fetchApi(url, init2);
      if (response && (response.status >= 200 && response.status < 300)) {
        return response;
      }
      throw new ResponseError(response, "Response returned an error code");
    }
    async createFetchParams(context, initOverrides) {
      let url = this.configuration.basePath + context.path;
      if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
        url += "?" + this.configuration.queryParamsStringify(context.query);
      }
      const headers = Object.assign({}, this.configuration.headers, context.headers);
      Object.keys(headers).forEach((key2) => headers[key2] === void 0 ? delete headers[key2] : {});
      const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
      const initParams = {
        method: context.method,
        headers,
        body: context.body,
        credentials: this.configuration.credentials
      };
      const overriddenInit = {
        ...initParams,
        ...await initOverrideFn({
          init: initParams,
          context
        })
      };
      let body;
      if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
        body = overriddenInit.body;
      } else if (this.isJsonMime(headers["Content-Type"])) {
        body = JSON.stringify(overriddenInit.body);
      } else {
        body = overriddenInit.body;
      }
      const init2 = {
        ...overriddenInit,
        body
      };
      return { url, init: init2 };
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    clone() {
      const constructor = this.constructor;
      const next = new constructor(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    }
  };
  __name(_BaseAPI, "BaseAPI");
  __publicField(_BaseAPI, "jsonRegex", new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$", "i"));
  let BaseAPI = _BaseAPI;
  function isBlob(value) {
    return typeof Blob !== "undefined" && value instanceof Blob;
  }
  __name(isBlob, "isBlob");
  function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
  }
  __name(isFormData, "isFormData");
  const _ResponseError = class _ResponseError extends Error {
    constructor(response, msg) {
      super(msg);
      __publicField(this, "name", "ResponseError");
      this.response = response;
    }
  };
  __name(_ResponseError, "ResponseError");
  let ResponseError = _ResponseError;
  const _FetchError = class _FetchError extends Error {
    constructor(cause, msg) {
      super(msg);
      __publicField(this, "name", "FetchError");
      this.cause = cause;
    }
  };
  __name(_FetchError, "FetchError");
  let FetchError = _FetchError;
  const _RequiredError = class _RequiredError extends Error {
    constructor(field, msg) {
      super(msg);
      __publicField(this, "name", "RequiredError");
      this.field = field;
    }
  };
  __name(_RequiredError, "RequiredError");
  let RequiredError = _RequiredError;
  function querystring(params, prefix = "") {
    return Object.keys(params).map((key2) => querystringSingleKey(key2, params[key2], prefix)).filter((part) => part.length > 0).join("&");
  }
  __name(querystring, "querystring");
  function querystringSingleKey(key2, value, keyPrefix = "") {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key2}]` : key2);
    if (value instanceof Array) {
      const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
      return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
      const valueAsArray = Array.from(value);
      return querystringSingleKey(key2, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
      return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
      return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
  }
  __name(querystringSingleKey, "querystringSingleKey");
  const _JSONApiResponse = class _JSONApiResponse {
    constructor(raw, transformer = (jsonValue) => jsonValue) {
      this.raw = raw;
      this.transformer = transformer;
    }
    async value() {
      return this.transformer(await this.raw.json());
    }
  };
  __name(_JSONApiResponse, "JSONApiResponse");
  let JSONApiResponse = _JSONApiResponse;
  const _VoidApiResponse = class _VoidApiResponse {
    constructor(raw) {
      this.raw = raw;
    }
    async value() {
      return void 0;
    }
  };
  __name(_VoidApiResponse, "VoidApiResponse");
  let VoidApiResponse = _VoidApiResponse;
  function AccessTokenDtoFromJSON(json) {
    return AccessTokenDtoFromJSONTyped(json);
  }
  __name(AccessTokenDtoFromJSON, "AccessTokenDtoFromJSON");
  function AccessTokenDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "token": json["Token"]
    };
  }
  __name(AccessTokenDtoFromJSONTyped, "AccessTokenDtoFromJSONTyped");
  const AnnouncementDtoTypeEnum = {
    Announcement: "Announcement",
    Changelog: "Changelog"
  };
  function AnnouncementDtoFromJSON(json) {
    return AnnouncementDtoFromJSONTyped(json);
  }
  __name(AnnouncementDtoFromJSON, "AnnouncementDtoFromJSON");
  function AnnouncementDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "title": json["title"],
      "content": json["content"],
      "affectedTypoVersion": json["affectedTypoVersion"] == null ? void 0 : json["affectedTypoVersion"],
      "date": json["date"],
      "type": json["type"],
      "details": json["details"] == null ? void 0 : json["details"]
    };
  }
  __name(AnnouncementDtoFromJSONTyped, "AnnouncementDtoFromJSONTyped");
  function AwardDtoFromJSON(json) {
    return AwardDtoFromJSONTyped(json);
  }
  __name(AwardDtoFromJSON, "AwardDtoFromJSON");
  function AwardDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "name": json["name"],
      "id": json["id"],
      "description": json["description"],
      "url": json["url"],
      "rarity": json["rarity"]
    };
  }
  __name(AwardDtoFromJSONTyped, "AwardDtoFromJSONTyped");
  function AwardInventoryDtoFromJSON(json) {
    return AwardInventoryDtoFromJSONTyped(json);
  }
  __name(AwardInventoryDtoFromJSON, "AwardInventoryDtoFromJSON");
  function AwardInventoryDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "award": AwardDtoFromJSON(json["award"]),
      "inventoryIds": json["inventoryIds"]
    };
  }
  __name(AwardInventoryDtoFromJSONTyped, "AwardInventoryDtoFromJSONTyped");
  function CloudDeleteDtoToJSON(json) {
    return CloudDeleteDtoToJSONTyped(json, false);
  }
  __name(CloudDeleteDtoToJSON, "CloudDeleteDtoToJSON");
  function CloudDeleteDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "ids": value["ids"]
    };
  }
  __name(CloudDeleteDtoToJSONTyped, "CloudDeleteDtoToJSONTyped");
  function CloudImageDtoFromJSON(json) {
    return CloudImageDtoFromJSONTyped(json);
  }
  __name(CloudImageDtoFromJSON, "CloudImageDtoFromJSON");
  function CloudImageDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "name": json["name"],
      "author": json["author"],
      "createdAt": json["createdAt"],
      "id": json["id"],
      "metaUrl": json["metaUrl"],
      "commandsUrl": json["commandsUrl"],
      "imageUrl": json["imageUrl"]
    };
  }
  __name(CloudImageDtoFromJSONTyped, "CloudImageDtoFromJSONTyped");
  function CloudSearchDtoToJSON(json) {
    return CloudSearchDtoToJSONTyped(json, false);
  }
  __name(CloudSearchDtoToJSON, "CloudSearchDtoToJSON");
  function CloudSearchDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "pageSize": value["pageSize"],
      "page": value["page"],
      "authorQuery": value["authorQuery"],
      "languageQuery": value["languageQuery"],
      "createdBeforeQuery": value["createdBeforeQuery"],
      "createdAfterQuery": value["createdAfterQuery"],
      "createdInPrivateLobbyQuery": value["createdInPrivateLobbyQuery"],
      "isOwnQuery": value["isOwnQuery"],
      "titleQuery": value["titleQuery"]
    };
  }
  __name(CloudSearchDtoToJSONTyped, "CloudSearchDtoToJSONTyped");
  function CloudUploadDtoToJSON(json) {
    return CloudUploadDtoToJSONTyped(json, false);
  }
  __name(CloudUploadDtoToJSON, "CloudUploadDtoToJSON");
  function CloudUploadDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "name": value["name"],
      "author": value["author"],
      "inPrivate": value["inPrivate"],
      "isOwn": value["isOwn"],
      "language": value["language"],
      "commands": value["commands"],
      "imageBase64": value["imageBase64"]
    };
  }
  __name(CloudUploadDtoToJSONTyped, "CloudUploadDtoToJSONTyped");
  function CloudUploadedDtoFromJSON(json) {
    return CloudUploadedDtoFromJSONTyped(json);
  }
  __name(CloudUploadedDtoFromJSON, "CloudUploadedDtoFromJSON");
  function CloudUploadedDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "id": json["id"]
    };
  }
  __name(CloudUploadedDtoFromJSONTyped, "CloudUploadedDtoFromJSONTyped");
  function EmojiCandidateDtoToJSON(json) {
    return EmojiCandidateDtoToJSONTyped(json, false);
  }
  __name(EmojiCandidateDtoToJSON, "EmojiCandidateDtoToJSON");
  function EmojiCandidateDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "name": value["name"],
      "url": value["url"],
      "animated": value["animated"]
    };
  }
  __name(EmojiCandidateDtoToJSONTyped, "EmojiCandidateDtoToJSONTyped");
  function EmojiDtoFromJSON(json) {
    return EmojiDtoFromJSONTyped(json);
  }
  __name(EmojiDtoFromJSON, "EmojiDtoFromJSON");
  function EmojiDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "name": json["name"],
      "url": json["url"],
      "animated": json["animated"],
      "nameId": json["nameId"]
    };
  }
  __name(EmojiDtoFromJSONTyped, "EmojiDtoFromJSONTyped");
  function EventDtoFromJSON(json) {
    return EventDtoFromJSONTyped(json);
  }
  __name(EventDtoFromJSON, "EventDtoFromJSON");
  function EventDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "name": json["name"],
      "id": json["id"],
      "description": json["description"],
      "eventStart": json["eventStart"],
      "eventLength": json["eventLength"]
    };
  }
  __name(EventDtoFromJSONTyped, "EventDtoFromJSONTyped");
  function EventDropDtoFromJSON(json) {
    return EventDropDtoFromJSONTyped(json);
  }
  __name(EventDropDtoFromJSON, "EventDropDtoFromJSON");
  function EventDropDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "id": json["id"],
      "name": json["name"],
      "url": json["url"],
      "event": EventDtoFromJSON(json["event"])
    };
  }
  __name(EventDropDtoFromJSONTyped, "EventDropDtoFromJSONTyped");
  function GuildDtoFromJSON(json) {
    return GuildDtoFromJSONTyped(json);
  }
  __name(GuildDtoFromJSON, "GuildDtoFromJSON");
  function GuildDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "guildID": json["GuildID"],
      "invite": json["Invite"],
      "guildName": json["GuildName"]
    };
  }
  __name(GuildDtoFromJSONTyped, "GuildDtoFromJSONTyped");
  function GuildInviteDtoFromJSON(json) {
    return GuildInviteDtoFromJSONTyped(json);
  }
  __name(GuildInviteDtoFromJSON, "GuildInviteDtoFromJSON");
  function GuildInviteDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "name": json["name"],
      "token": json["token"],
      "iconUrl": json["iconUrl"],
      "connectedMembers": json["connectedMembers"]
    };
  }
  __name(GuildInviteDtoFromJSONTyped, "GuildInviteDtoFromJSONTyped");
  function MemberDtoFromJSON(json) {
    return MemberDtoFromJSONTyped(json);
  }
  __name(MemberDtoFromJSON, "MemberDtoFromJSON");
  function MemberDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "bubbles": json["bubbles"],
      "drops": json["drops"],
      "sprites": json["sprites"],
      "scenes": json["scenes"],
      "flags": json["flags"],
      "rainbowSprites": json["rainbowSprites"],
      "discordID": json["discordID"],
      "userName": json["userName"],
      "userLogin": json["userLogin"],
      "guilds": json["guilds"].map(GuildDtoFromJSON),
      "rawMember": json["rawMember"],
      "memberFlags": json["memberFlags"]
    };
  }
  __name(MemberDtoFromJSONTyped, "MemberDtoFromJSONTyped");
  function MemberSearchDtoFromJSON(json) {
    return MemberSearchDtoFromJSONTyped(json);
  }
  __name(MemberSearchDtoFromJSON, "MemberSearchDtoFromJSON");
  function MemberSearchDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "userName": json["userName"],
      "userLogin": json["userLogin"],
      "rawMember": json["rawMember"]
    };
  }
  __name(MemberSearchDtoFromJSONTyped, "MemberSearchDtoFromJSONTyped");
  function MemberWebhookDtoFromJSON(json) {
    return MemberWebhookDtoFromJSONTyped(json);
  }
  __name(MemberWebhookDtoFromJSON, "MemberWebhookDtoFromJSON");
  function MemberWebhookDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "name": json["Name"],
      "guild": GuildDtoFromJSON(json["Guild"])
    };
  }
  __name(MemberWebhookDtoFromJSONTyped, "MemberWebhookDtoFromJSONTyped");
  function PostImageDtoToJSON(json) {
    return PostImageDtoToJSONTyped(json, false);
  }
  __name(PostImageDtoToJSON, "PostImageDtoToJSON");
  function PostImageDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "title": value["title"],
      "author": value["author"],
      "posterName": value["posterName"],
      "onlyImage": value["onlyImage"],
      "imageBase64": value["imageBase64"]
    };
  }
  __name(PostImageDtoToJSONTyped, "PostImageDtoToJSONTyped");
  function SceneThemeDtoFromJSON(json) {
    return SceneThemeDtoFromJSONTyped(json);
  }
  __name(SceneThemeDtoFromJSON, "SceneThemeDtoFromJSON");
  function SceneThemeDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "name": json["name"],
      "shift": json["shift"]
    };
  }
  __name(SceneThemeDtoFromJSONTyped, "SceneThemeDtoFromJSONTyped");
  function SceneDtoFromJSON(json) {
    return SceneDtoFromJSONTyped(json);
  }
  __name(SceneDtoFromJSON, "SceneDtoFromJSON");
  function SceneDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "name": json["name"],
      "id": json["id"],
      "url": json["url"],
      "exclusive": json["exclusive"],
      "event": json["event"] == null ? void 0 : EventDtoFromJSON(json["event"]),
      "primaryColor": json["primaryColor"] == null ? void 0 : json["primaryColor"],
      "guessedColor": json["guessedColor"] == null ? void 0 : json["guessedColor"],
      "artist": json["artist"] == null ? void 0 : json["artist"],
      "themes": json["themes"].map(SceneThemeDtoFromJSON)
    };
  }
  __name(SceneDtoFromJSONTyped, "SceneDtoFromJSONTyped");
  function SceneInventoryItemDtoFromJSON(json) {
    return SceneInventoryItemDtoFromJSONTyped(json);
  }
  __name(SceneInventoryItemDtoFromJSON, "SceneInventoryItemDtoFromJSON");
  function SceneInventoryItemDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "sceneId": json["sceneId"],
      "sceneShift": json["sceneShift"] == null ? void 0 : json["sceneShift"]
    };
  }
  __name(SceneInventoryItemDtoFromJSONTyped, "SceneInventoryItemDtoFromJSONTyped");
  function SceneInventoryItemDtoToJSON(json) {
    return SceneInventoryItemDtoToJSONTyped(json, false);
  }
  __name(SceneInventoryItemDtoToJSON, "SceneInventoryItemDtoToJSON");
  function SceneInventoryItemDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "sceneId": value["sceneId"],
      "sceneShift": value["sceneShift"]
    };
  }
  __name(SceneInventoryItemDtoToJSONTyped, "SceneInventoryItemDtoToJSONTyped");
  function SceneInventoryDtoFromJSON(json) {
    return SceneInventoryDtoFromJSONTyped(json);
  }
  __name(SceneInventoryDtoFromJSON, "SceneInventoryDtoFromJSON");
  function SceneInventoryDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "activeId": json["activeId"] == null ? void 0 : json["activeId"],
      "activeShift": json["activeShift"] == null ? void 0 : json["activeShift"],
      "scenes": json["scenes"].map(SceneInventoryItemDtoFromJSON)
    };
  }
  __name(SceneInventoryDtoFromJSONTyped, "SceneInventoryDtoFromJSONTyped");
  function SetActiveSceneDtoToJSON(json) {
    return SetActiveSceneDtoToJSONTyped(json, false);
  }
  __name(SetActiveSceneDtoToJSON, "SetActiveSceneDtoToJSON");
  function SetActiveSceneDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "scene": SceneInventoryItemDtoToJSON(value["scene"])
    };
  }
  __name(SetActiveSceneDtoToJSONTyped, "SetActiveSceneDtoToJSONTyped");
  function SpriteSlotDtoToJSON(json) {
    return SpriteSlotDtoToJSONTyped(json, false);
  }
  __name(SpriteSlotDtoToJSON, "SpriteSlotDtoToJSON");
  function SpriteSlotDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "slotId": value["slotId"],
      "spriteId": value["spriteId"]
    };
  }
  __name(SpriteSlotDtoToJSONTyped, "SpriteSlotDtoToJSONTyped");
  function SpriteComboDtoToJSON(json) {
    return SpriteComboDtoToJSONTyped(json, false);
  }
  __name(SpriteComboDtoToJSON, "SpriteComboDtoToJSON");
  function SpriteComboDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "slots": value["slots"].map(SpriteSlotDtoToJSON)
    };
  }
  __name(SpriteComboDtoToJSONTyped, "SpriteComboDtoToJSONTyped");
  function SpriteDtoFromJSON(json) {
    return SpriteDtoFromJSONTyped(json);
  }
  __name(SpriteDtoFromJSON, "SpriteDtoFromJSON");
  function SpriteDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "name": json["name"],
      "id": json["id"],
      "cost": json["cost"],
      "url": json["url"],
      "eventDrop": json["eventDrop"] == null ? void 0 : EventDropDtoFromJSON(json["eventDrop"]),
      "isRainbowAllowed": json["isRainbowAllowed"],
      "isSpecial": json["isSpecial"],
      "artist": json["artist"] == null ? void 0 : json["artist"],
      "requiredFlags": json["requiredFlags"]
    };
  }
  __name(SpriteDtoFromJSONTyped, "SpriteDtoFromJSONTyped");
  function SpriteInventoryDtoFromJSON(json) {
    return SpriteInventoryDtoFromJSONTyped(json);
  }
  __name(SpriteInventoryDtoFromJSON, "SpriteInventoryDtoFromJSON");
  function SpriteInventoryDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "slot": json["slot"] == null ? void 0 : json["slot"],
      "spriteId": json["spriteId"],
      "colorShift": json["colorShift"] == null ? void 0 : json["colorShift"]
    };
  }
  __name(SpriteInventoryDtoFromJSONTyped, "SpriteInventoryDtoFromJSONTyped");
  function SpriteSlotCountDtoFromJSON(json) {
    return SpriteSlotCountDtoFromJSONTyped(json);
  }
  __name(SpriteSlotCountDtoFromJSON, "SpriteSlotCountDtoFromJSON");
  function SpriteSlotCountDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "unlockedSlots": json["unlockedSlots"]
    };
  }
  __name(SpriteSlotCountDtoFromJSONTyped, "SpriteSlotCountDtoFromJSONTyped");
  function ThemeMetaDtoFromJSON(json) {
    return ThemeMetaDtoFromJSONTyped(json);
  }
  __name(ThemeMetaDtoFromJSON, "ThemeMetaDtoFromJSON");
  function ThemeMetaDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "author": json["author"],
      "created": json["created"],
      "type": json["type"],
      "id": json["id"],
      "name": json["name"]
    };
  }
  __name(ThemeMetaDtoFromJSONTyped, "ThemeMetaDtoFromJSONTyped");
  function ThemeMetaDtoToJSON(json) {
    return ThemeMetaDtoToJSONTyped(json, false);
  }
  __name(ThemeMetaDtoToJSON, "ThemeMetaDtoToJSON");
  function ThemeMetaDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "author": value["author"],
      "created": value["created"],
      "type": value["type"],
      "id": value["id"],
      "name": value["name"]
    };
  }
  __name(ThemeMetaDtoToJSONTyped, "ThemeMetaDtoToJSONTyped");
  function ThemeDtoFromJSON(json) {
    return ThemeDtoFromJSONTyped(json);
  }
  __name(ThemeDtoFromJSON, "ThemeDtoFromJSON");
  function ThemeDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "colors": json["colors"],
      "hooks": json["hooks"],
      "images": json["images"],
      "misc": json["misc"],
      "meta": ThemeMetaDtoFromJSON(json["meta"])
    };
  }
  __name(ThemeDtoFromJSONTyped, "ThemeDtoFromJSONTyped");
  function ThemeDtoToJSON(json) {
    return ThemeDtoToJSONTyped(json, false);
  }
  __name(ThemeDtoToJSON, "ThemeDtoToJSON");
  function ThemeDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "colors": value["colors"],
      "hooks": value["hooks"],
      "images": value["images"],
      "misc": value["misc"],
      "meta": ThemeMetaDtoToJSON(value["meta"])
    };
  }
  __name(ThemeDtoToJSONTyped, "ThemeDtoToJSONTyped");
  function ThemeListingDtoFromJSON(json) {
    return ThemeListingDtoFromJSONTyped(json);
  }
  __name(ThemeListingDtoFromJSON, "ThemeListingDtoFromJSON");
  function ThemeListingDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "id": json["id"],
      "downloads": json["downloads"],
      "version": json["version"],
      "name": json["name"],
      "author": json["author"]
    };
  }
  __name(ThemeListingDtoFromJSONTyped, "ThemeListingDtoFromJSONTyped");
  function ThemePublishRequestDtoToJSON(json) {
    return ThemePublishRequestDtoToJSONTyped(json, false);
  }
  __name(ThemePublishRequestDtoToJSON, "ThemePublishRequestDtoToJSON");
  function ThemePublishRequestDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "owner": value["owner"]
    };
  }
  __name(ThemePublishRequestDtoToJSONTyped, "ThemePublishRequestDtoToJSONTyped");
  function ThemeShareDtoFromJSON(json) {
    return ThemeShareDtoFromJSONTyped(json);
  }
  __name(ThemeShareDtoFromJSON, "ThemeShareDtoFromJSON");
  function ThemeShareDtoFromJSONTyped(json, ignoreDiscriminator) {
    if (json == null) {
      return json;
    }
    return {
      "id": json["id"]
    };
  }
  __name(ThemeShareDtoFromJSONTyped, "ThemeShareDtoFromJSONTyped");
  function ThemeUpdateRequestDtoToJSON(json) {
    return ThemeUpdateRequestDtoToJSONTyped(json, false);
  }
  __name(ThemeUpdateRequestDtoToJSON, "ThemeUpdateRequestDtoToJSON");
  function ThemeUpdateRequestDtoToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "newId": value["newId"]
    };
  }
  __name(ThemeUpdateRequestDtoToJSONTyped, "ThemeUpdateRequestDtoToJSONTyped");
  function UpdateDiscordIDToJSON(json) {
    return UpdateDiscordIDToJSONTyped(json, false);
  }
  __name(UpdateDiscordIDToJSON, "UpdateDiscordIDToJSON");
  function UpdateDiscordIDToJSONTyped(value, ignoreDiscriminator = false) {
    if (value == null) {
      return value;
    }
    return {
      "id": value["id"]
    };
  }
  __name(UpdateDiscordIDToJSONTyped, "UpdateDiscordIDToJSONTyped");
  const _AnnouncementsApi = class _AnnouncementsApi extends BaseAPI {
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all announcements
     */
    async getAnnouncementsRaw(initOverrides) {
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/announcements`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(AnnouncementDtoFromJSON));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all announcements
     */
    async getAnnouncements(initOverrides) {
      const response = await this.getAnnouncementsRaw(initOverrides);
      return await response.value();
    }
  };
  __name(_AnnouncementsApi, "AnnouncementsApi");
  let AnnouncementsApi = _AnnouncementsApi;
  const _AwardsApi = class _AwardsApi extends BaseAPI {
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all awards
     */
    async getAllAwardsRaw(initOverrides) {
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/awards`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(AwardDtoFromJSON));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all awards
     */
    async getAllAwards(initOverrides) {
      const response = await this.getAllAwardsRaw(initOverrides);
      return await response.value();
    }
  };
  __name(_AwardsApi, "AwardsApi");
  let AwardsApi = _AwardsApi;
  const _CloudApi = class _CloudApi extends BaseAPI {
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Delete multiple images from the user\'s cloud
     */
    async bulkDeleteFromUserCloudRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling bulkDeleteFromUserCloud().'
        );
      }
      if (requestParameters["cloudDeleteDto"] == null) {
        throw new RequiredError(
          "cloudDeleteDto",
          'Required parameter "cloudDeleteDto" was null or undefined when calling bulkDeleteFromUserCloud().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/cloud/{login}/delete`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CloudDeleteDtoToJSON(requestParameters["cloudDeleteDto"])
      }, initOverrides);
      return new VoidApiResponse(response);
    }
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Delete multiple images from the user\'s cloud
     */
    async bulkDeleteFromUserCloud(requestParameters, initOverrides) {
      await this.bulkDeleteFromUserCloudRaw(requestParameters, initOverrides);
    }
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Delete a image by id from the cloud
     */
    async deleteImageFromUserCloudRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling deleteImageFromUserCloud().'
        );
      }
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling deleteImageFromUserCloud().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/cloud/{login}/{id}`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    }
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Delete a image by id from the cloud
     */
    async deleteImageFromUserCloud(requestParameters, initOverrides) {
      await this.deleteImageFromUserCloudRaw(requestParameters, initOverrides);
    }
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Get a image by id from the cloud
     */
    async getImageFromUserCloudRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling getImageFromUserCloud().'
        );
      }
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling getImageFromUserCloud().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/cloud/{login}/{id}`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => CloudImageDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Get a image by id from the cloud
     */
    async getImageFromUserCloud(requestParameters, initOverrides) {
      const response = await this.getImageFromUserCloudRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Link an image of the user to an award in their received inventory, which has no linked image yet
     */
    async linkImageToAwardRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling linkImageToAward().'
        );
      }
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling linkImageToAward().'
        );
      }
      if (requestParameters["token"] == null) {
        throw new RequiredError(
          "token",
          'Required parameter "token" was null or undefined when calling linkImageToAward().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/cloud/{login}/{id}/award/{token}`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters["token"]))),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    }
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Link an image of the user to an award in their received inventory, which has no linked image yet
     */
    async linkImageToAward(requestParameters, initOverrides) {
      await this.linkImageToAwardRaw(requestParameters, initOverrides);
    }
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Search for cloud images
     */
    async searchUserCloudRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling searchUserCloud().'
        );
      }
      if (requestParameters["cloudSearchDto"] == null) {
        throw new RequiredError(
          "cloudSearchDto",
          'Required parameter "cloudSearchDto" was null or undefined when calling searchUserCloud().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/cloud/{login}/search`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CloudSearchDtoToJSON(requestParameters["cloudSearchDto"])
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(CloudImageDtoFromJSON));
    }
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Search for cloud images
     */
    async searchUserCloud(requestParameters, initOverrides) {
      const response = await this.searchUserCloudRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Upload a new image to the user\'s cloud
     */
    async uploadToUserCloudRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling uploadToUserCloud().'
        );
      }
      if (requestParameters["cloudUploadDto"] == null) {
        throw new RequiredError(
          "cloudUploadDto",
          'Required parameter "cloudUploadDto" was null or undefined when calling uploadToUserCloud().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/cloud/{login}`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CloudUploadDtoToJSON(requestParameters["cloudUploadDto"])
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => CloudUploadedDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Member - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Upload a new image to the user\'s cloud
     */
    async uploadToUserCloud(requestParameters, initOverrides) {
      const response = await this.uploadToUserCloudRaw(requestParameters, initOverrides);
      return await response.value();
    }
  };
  __name(_CloudApi, "CloudApi");
  let CloudApi = _CloudApi;
  const _EmojisApi = class _EmojisApi extends BaseAPI {
    /**
     *   Required Roles: Admin | EmojiManagement | ContentModerator  Rate limit default: 30 Requests / 60000 ms TTL
     * Add a new emoji
     */
    async addEmojiRaw(requestParameters, initOverrides) {
      if (requestParameters["emojiCandidateDto"] == null) {
        throw new RequiredError(
          "emojiCandidateDto",
          'Required parameter "emojiCandidateDto" was null or undefined when calling addEmoji().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/emojis`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EmojiCandidateDtoToJSON(requestParameters["emojiCandidateDto"])
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmojiDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Admin | EmojiManagement | ContentModerator  Rate limit default: 30 Requests / 60000 ms TTL
     * Add a new emoji
     */
    async addEmoji(requestParameters, initOverrides) {
      const response = await this.addEmojiRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Admin | ContentModerator | Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Delete a saved emoji  by name (id) and nameId
     */
    async deleteEmojiRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling deleteEmoji().'
        );
      }
      const queryParameters = {};
      if (requestParameters["nameId"] != null) {
        queryParameters["nameId"] = requestParameters["nameId"];
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/emojis/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    }
    /**
     *   Required Roles: Admin | ContentModerator | Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Delete a saved emoji  by name (id) and nameId
     */
    async deleteEmoji(requestParameters, initOverrides) {
      await this.deleteEmojiRaw(requestParameters, initOverrides);
    }
    /**
     *   Required Roles: None  Rate limit default: 30 Requests / 60000 ms TTL
     * Search all emojis
     */
    async getAllEmojisRaw(requestParameters, initOverrides) {
      if (requestParameters["limit"] == null) {
        throw new RequiredError(
          "limit",
          'Required parameter "limit" was null or undefined when calling getAllEmojis().'
        );
      }
      if (requestParameters["animated"] == null) {
        throw new RequiredError(
          "animated",
          'Required parameter "animated" was null or undefined when calling getAllEmojis().'
        );
      }
      if (requestParameters["statics"] == null) {
        throw new RequiredError(
          "statics",
          'Required parameter "statics" was null or undefined when calling getAllEmojis().'
        );
      }
      const queryParameters = {};
      if (requestParameters["query"] != null) {
        queryParameters["query"] = requestParameters["query"];
      }
      if (requestParameters["limit"] != null) {
        queryParameters["limit"] = requestParameters["limit"];
      }
      if (requestParameters["animated"] != null) {
        queryParameters["animated"] = requestParameters["animated"];
      }
      if (requestParameters["statics"] != null) {
        queryParameters["statics"] = requestParameters["statics"];
      }
      const headerParameters = {};
      const response = await this.request({
        path: `/emojis`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(EmojiDtoFromJSON));
    }
    /**
     *   Required Roles: None  Rate limit default: 30 Requests / 60000 ms TTL
     * Search all emojis
     */
    async getAllEmojis(requestParameters, initOverrides) {
      const response = await this.getAllEmojisRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: None  Rate limit default: 30 Requests / 60000 ms TTL
     * Search all emojis with cache enabled
     */
    async getAllEmojisCachedRaw(requestParameters, initOverrides) {
      if (requestParameters["limit"] == null) {
        throw new RequiredError(
          "limit",
          'Required parameter "limit" was null or undefined when calling getAllEmojisCached().'
        );
      }
      if (requestParameters["animated"] == null) {
        throw new RequiredError(
          "animated",
          'Required parameter "animated" was null or undefined when calling getAllEmojisCached().'
        );
      }
      if (requestParameters["statics"] == null) {
        throw new RequiredError(
          "statics",
          'Required parameter "statics" was null or undefined when calling getAllEmojisCached().'
        );
      }
      const queryParameters = {};
      if (requestParameters["query"] != null) {
        queryParameters["query"] = requestParameters["query"];
      }
      if (requestParameters["limit"] != null) {
        queryParameters["limit"] = requestParameters["limit"];
      }
      if (requestParameters["animated"] != null) {
        queryParameters["animated"] = requestParameters["animated"];
      }
      if (requestParameters["statics"] != null) {
        queryParameters["statics"] = requestParameters["statics"];
      }
      const headerParameters = {};
      const response = await this.request({
        path: `/emojis/cache`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(EmojiDtoFromJSON));
    }
    /**
     *   Required Roles: None  Rate limit default: 30 Requests / 60000 ms TTL
     * Search all emojis with cache enabled
     */
    async getAllEmojisCached(requestParameters, initOverrides) {
      const response = await this.getAllEmojisCachedRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a single saved emoji by name (id) and nameId
     */
    async getEmojiRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling getEmoji().'
        );
      }
      const queryParameters = {};
      if (requestParameters["nameId"] != null) {
        queryParameters["nameId"] = requestParameters["nameId"];
      }
      const headerParameters = {};
      const response = await this.request({
        path: `/emojis/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmojiDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a single saved emoji by name (id) and nameId
     */
    async getEmoji(requestParameters, initOverrides) {
      const response = await this.getEmojiRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Admin | EmojiManagement | ContentModerator  Rate limit default: 30 Requests / 60000 ms TTL
     * Search for new emojis that are not yet in the database
     */
    async getNewEmojisRaw(requestParameters, initOverrides) {
      if (requestParameters["limit"] == null) {
        throw new RequiredError(
          "limit",
          'Required parameter "limit" was null or undefined when calling getNewEmojis().'
        );
      }
      if (requestParameters["animated"] == null) {
        throw new RequiredError(
          "animated",
          'Required parameter "animated" was null or undefined when calling getNewEmojis().'
        );
      }
      if (requestParameters["statics"] == null) {
        throw new RequiredError(
          "statics",
          'Required parameter "statics" was null or undefined when calling getNewEmojis().'
        );
      }
      const queryParameters = {};
      if (requestParameters["query"] != null) {
        queryParameters["query"] = requestParameters["query"];
      }
      if (requestParameters["limit"] != null) {
        queryParameters["limit"] = requestParameters["limit"];
      }
      if (requestParameters["animated"] != null) {
        queryParameters["animated"] = requestParameters["animated"];
      }
      if (requestParameters["statics"] != null) {
        queryParameters["statics"] = requestParameters["statics"];
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/emojis/discover`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(EmojiDtoFromJSON));
    }
    /**
     *   Required Roles: Admin | EmojiManagement | ContentModerator  Rate limit default: 30 Requests / 60000 ms TTL
     * Search for new emojis that are not yet in the database
     */
    async getNewEmojis(requestParameters, initOverrides) {
      const response = await this.getNewEmojisRaw(requestParameters, initOverrides);
      return await response.value();
    }
  };
  __name(_EmojisApi, "EmojisApi");
  let EmojisApi = _EmojisApi;
  const _EventsApi = class _EventsApi extends BaseAPI {
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all event drops
     */
    async getAllEventDropsRaw(initOverrides) {
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/events/drops`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(EventDropDtoFromJSON));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all event drops
     */
    async getAllEventDrops(initOverrides) {
      const response = await this.getAllEventDropsRaw(initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all events
     */
    async getAllEventsRaw(initOverrides) {
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/events`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(EventDtoFromJSON));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all events
     */
    async getAllEvents(initOverrides) {
      const response = await this.getAllEventsRaw(initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get an event by ID
     */
    async getEventByIdRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling getEventById().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/events/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EventDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get an event by ID
     */
    async getEventById(requestParameters, initOverrides) {
      const response = await this.getEventByIdRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get an event drop by ID
     */
    async getEventDropRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling getEventDrop().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/events/drops/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EventDropDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get an event drop by ID
     */
    async getEventDrop(requestParameters, initOverrides) {
      const response = await this.getEventDropRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all event drops of an event
     */
    async getEventDropsOfEventRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling getEventDropsOfEvent().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/events/{id}/drops`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(EventDropDtoFromJSON));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all event drops of an event
     */
    async getEventDropsOfEvent(requestParameters, initOverrides) {
      const response = await this.getEventDropsOfEventRaw(requestParameters, initOverrides);
      return await response.value();
    }
  };
  __name(_EventsApi, "EventsApi");
  let EventsApi = _EventsApi;
  const _GuildsApi = class _GuildsApi extends BaseAPI {
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get invite information of a guild
     */
    async getGuildInviteRaw(requestParameters, initOverrides) {
      if (requestParameters["token"] == null) {
        throw new RequiredError(
          "token",
          'Required parameter "token" was null or undefined when calling getGuildInvite().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/guilds/{token}/invite`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters["token"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => GuildInviteDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get invite information of a guild
     */
    async getGuildInvite(requestParameters, initOverrides) {
      const response = await this.getGuildInviteRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Member  Rate limit default: 10 Requests / 600000 ms TTL
     * Post an image to a guild channel
     */
    async postImageToGuildRaw(requestParameters, initOverrides) {
      if (requestParameters["token"] == null) {
        throw new RequiredError(
          "token",
          'Required parameter "token" was null or undefined when calling postImageToGuild().'
        );
      }
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling postImageToGuild().'
        );
      }
      if (requestParameters["postImageDto"] == null) {
        throw new RequiredError(
          "postImageDto",
          'Required parameter "postImageDto" was null or undefined when calling postImageToGuild().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/guilds/{token}/imagepost/{id}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters["token"]))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PostImageDtoToJSON(requestParameters["postImageDto"])
      }, initOverrides);
      return new VoidApiResponse(response);
    }
    /**
     *   Required Roles: Member  Rate limit default: 10 Requests / 600000 ms TTL
     * Post an image to a guild channel
     */
    async postImageToGuild(requestParameters, initOverrides) {
      await this.postImageToGuildRaw(requestParameters, initOverrides);
    }
  };
  __name(_GuildsApi, "GuildsApi");
  let GuildsApi = _GuildsApi;
  const _InventoryApi = class _InventoryApi extends BaseAPI {
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Get all awards in the inventory of a member which are available to gift
     */
    async getMemberAvailableAwardInventoryRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling getMemberAvailableAwardInventory().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/member/{login}/inventory/awards/available`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(AwardInventoryDtoFromJSON));
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Get all awards in the inventory of a member which are available to gift
     */
    async getMemberAvailableAwardInventory(requestParameters, initOverrides) {
      const response = await this.getMemberAvailableAwardInventoryRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Get all scenes in the inventory of a member, and the currently activated scene
     */
    async getMemberSceneInventoryRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling getMemberSceneInventory().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/member/{login}/inventory/scenes`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SceneInventoryDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Get all scenes in the inventory of a member, and the currently activated scene
     */
    async getMemberSceneInventory(requestParameters, initOverrides) {
      const response = await this.getMemberSceneInventoryRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Get all sprites in the inventory of a member
     */
    async getMemberSpriteInventoryRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling getMemberSpriteInventory().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/member/{login}/inventory/sprites`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(SpriteInventoryDtoFromJSON));
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Get all sprites in the inventory of a member
     */
    async getMemberSpriteInventory(requestParameters, initOverrides) {
      const response = await this.getMemberSpriteInventoryRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Get the amount of unlocked sprite slots of a member
     */
    async getMemberSpriteSlotCountRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling getMemberSpriteSlotCount().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/member/{login}/inventory/sprites/slots`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SpriteSlotCountDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Get the amount of unlocked sprite slots of a member
     */
    async getMemberSpriteSlotCount(requestParameters, initOverrides) {
      const response = await this.getMemberSpriteSlotCountRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Set the activated scene for a member
     */
    async setMemberSceneRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling setMemberScene().'
        );
      }
      if (requestParameters["setActiveSceneDto"] == null) {
        throw new RequiredError(
          "setActiveSceneDto",
          'Required parameter "setActiveSceneDto" was null or undefined when calling setMemberScene().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/member/{login}/inventory/scenes`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: SetActiveSceneDtoToJSON(requestParameters["setActiveSceneDto"])
      }, initOverrides);
      return new VoidApiResponse(response);
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Set the activated scene for a member
     */
    async setMemberScene(requestParameters, initOverrides) {
      await this.setMemberSceneRaw(requestParameters, initOverrides);
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Set the sprite combo of a member
     */
    async setMemberSpriteComboRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling setMemberSpriteCombo().'
        );
      }
      if (requestParameters["spriteComboDto"] == null) {
        throw new RequiredError(
          "spriteComboDto",
          'Required parameter "spriteComboDto" was null or undefined when calling setMemberSpriteCombo().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/member/{login}/inventory/sprites/combo`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: SpriteComboDtoToJSON(requestParameters["spriteComboDto"])
      }, initOverrides);
      return new VoidApiResponse(response);
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Set the sprite combo of a member
     */
    async setMemberSpriteCombo(requestParameters, initOverrides) {
      await this.setMemberSpriteComboRaw(requestParameters, initOverrides);
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Set a sprite slot of a member
     */
    async setMemberSpriteSlotRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling setMemberSpriteSlot().'
        );
      }
      if (requestParameters["spriteSlotDto"] == null) {
        throw new RequiredError(
          "spriteSlotDto",
          'Required parameter "spriteSlotDto" was null or undefined when calling setMemberSpriteSlot().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/member/{login}/inventory/sprites/slot`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: SpriteSlotDtoToJSON(requestParameters["spriteSlotDto"])
      }, initOverrides);
      return new VoidApiResponse(response);
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 30 Requests / 60000 ms TTL
     * Set a sprite slot of a member
     */
    async setMemberSpriteSlot(requestParameters, initOverrides) {
      await this.setMemberSpriteSlotRaw(requestParameters, initOverrides);
    }
  };
  __name(_InventoryApi, "InventoryApi");
  let InventoryApi = _InventoryApi;
  const _MembersApi = class _MembersApi extends BaseAPI {
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Delete a dropboost of a member
     */
    async clearMemberDropboostRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling clearMemberDropboost().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/members/{login}/dropboost`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    }
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Delete a dropboost of a member
     */
    async clearMemberDropboost(requestParameters, initOverrides) {
      await this.clearMemberDropboostRaw(requestParameters, initOverrides);
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Connect a user to a guild with given server token
     */
    async connectMemberToGuildRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling connectMemberToGuild().'
        );
      }
      if (requestParameters["token"] == null) {
        throw new RequiredError(
          "token",
          'Required parameter "token" was null or undefined when calling connectMemberToGuild().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/members/{login}/guilds/{token}`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters["token"]))),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Connect a user to a guild with given server token
     */
    async connectMemberToGuild(requestParameters, initOverrides) {
      await this.connectMemberToGuildRaw(requestParameters, initOverrides);
    }
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Find members that contain a string
     */
    async findMembersWildcardSearchRaw(requestParameters, initOverrides) {
      if (requestParameters["content"] == null) {
        throw new RequiredError(
          "content",
          'Required parameter "content" was null or undefined when calling findMembersWildcardSearch().'
        );
      }
      const queryParameters = {};
      if (requestParameters["content"] != null) {
        queryParameters["content"] = requestParameters["content"];
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/members/search`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(MemberSearchDtoFromJSON));
    }
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Find members that contain a string
     */
    async findMembersWildcardSearch(requestParameters, initOverrides) {
      const response = await this.findMembersWildcardSearchRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Member  Rate limit default: 30 Requests / 60000 ms TTL
     * Get the currently authenticated member
     */
    async getAuthenticatedMemberRaw(initOverrides) {
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/members/me`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MemberDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Member  Rate limit default: 30 Requests / 60000 ms TTL
     * Get the currently authenticated member
     */
    async getAuthenticatedMember(initOverrides) {
      const response = await this.getAuthenticatedMemberRaw(initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Get an access token of a member
     */
    async getMemberAccessTokenRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling getMemberAccessToken().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/members/{login}/token`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => AccessTokenDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Get an access token of a member
     */
    async getMemberAccessToken(requestParameters, initOverrides) {
      const response = await this.getMemberAccessTokenRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a member by their discord id
     */
    async getMemberByDiscordIDRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling getMemberByDiscordID().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/members/discord/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MemberDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a member by their discord id
     */
    async getMemberByDiscordID(requestParameters, initOverrides) {
      const response = await this.getMemberByDiscordIDRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a member by their login
     */
    async getMemberByLoginRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling getMemberByLogin().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/members/{login}`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MemberDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a member by their login
     */
    async getMemberByLogin(requestParameters, initOverrides) {
      const response = await this.getMemberByLoginRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all webhooks of a member
     */
    async getMemberGuildWebhooksRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling getMemberGuildWebhooks().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/members/{login}/webhooks`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(MemberWebhookDtoFromJSON));
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all webhooks of a member
     */
    async getMemberGuildWebhooks(requestParameters, initOverrides) {
      const response = await this.getMemberGuildWebhooksRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Delete a server from a member\'s connected guilds
     */
    async removeConnectedGuildRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling removeConnectedGuild().'
        );
      }
      if (requestParameters["token"] == null) {
        throw new RequiredError(
          "token",
          'Required parameter "token" was null or undefined when calling removeConnectedGuild().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/members/{login}/guilds/{token}`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters["token"]))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    }
    /**
     *   Required Roles: Moderator - Role override if {login} matches the client login.  Rate limit default: 10 Requests / 60000 ms TTL
     * Delete a server from a member\'s connected guilds
     */
    async removeConnectedGuild(requestParameters, initOverrides) {
      await this.removeConnectedGuildRaw(requestParameters, initOverrides);
    }
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Update a member\'s discord ID and merge with other if present
     */
    async updateMemberDiscordIDRaw(requestParameters, initOverrides) {
      if (requestParameters["login"] == null) {
        throw new RequiredError(
          "login",
          'Required parameter "login" was null or undefined when calling updateMemberDiscordID().'
        );
      }
      if (requestParameters["updateDiscordID"] == null) {
        throw new RequiredError(
          "updateDiscordID",
          'Required parameter "updateDiscordID" was null or undefined when calling updateMemberDiscordID().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/members/{login}/discord`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters["login"]))),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: UpdateDiscordIDToJSON(requestParameters["updateDiscordID"])
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MemberDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Update a member\'s discord ID and merge with other if present
     */
    async updateMemberDiscordID(requestParameters, initOverrides) {
      const response = await this.updateMemberDiscordIDRaw(requestParameters, initOverrides);
      return await response.value();
    }
  };
  __name(_MembersApi, "MembersApi");
  let MembersApi = _MembersApi;
  const _ScenesApi = class _ScenesApi extends BaseAPI {
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all scenes
     */
    async getAllScenesRaw(initOverrides) {
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/scenes`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(SceneDtoFromJSON));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all scenes
     */
    async getAllScenes(initOverrides) {
      const response = await this.getAllScenesRaw(initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a scene by ID
     */
    async getSceneByIdRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling getSceneById().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/scenes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SceneDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a scene by ID
     */
    async getSceneById(requestParameters, initOverrides) {
      const response = await this.getSceneByIdRaw(requestParameters, initOverrides);
      return await response.value();
    }
  };
  __name(_ScenesApi, "ScenesApi");
  let ScenesApi = _ScenesApi;
  const _SpritesApi = class _SpritesApi extends BaseAPI {
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all sprites
     */
    async getAllSpritesRaw(initOverrides) {
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/sprites`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(SpriteDtoFromJSON));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all sprites
     */
    async getAllSprites(initOverrides) {
      const response = await this.getAllSpritesRaw(initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a sprite by ID
     */
    async getSpriteByIdRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling getSpriteById().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/sprites/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SpriteDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a sprite by ID
     */
    async getSpriteById(requestParameters, initOverrides) {
      const response = await this.getSpriteByIdRaw(requestParameters, initOverrides);
      return await response.value();
    }
  };
  __name(_SpritesApi, "SpritesApi");
  let SpritesApi = _SpritesApi;
  const _ThemesApi = class _ThemesApi extends BaseAPI {
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all published themes
     */
    async getAllThemesRaw(initOverrides) {
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/themes`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(ThemeListingDtoFromJSON));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get all published themes
     */
    async getAllThemes(initOverrides) {
      const response = await this.getAllThemesRaw(initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a theme by ID
     */
    async getThemeByIdRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling getThemeById().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ThemeDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Get a theme by ID
     */
    async getThemeById(requestParameters, initOverrides) {
      const response = await this.getThemeByIdRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Publish a theme to the public theme list
     */
    async publishThemeRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling publishTheme().'
        );
      }
      if (requestParameters["themePublishRequestDto"] == null) {
        throw new RequiredError(
          "themePublishRequestDto",
          'Required parameter "themePublishRequestDto" was null or undefined when calling publishTheme().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/themes/{id}/public`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ThemePublishRequestDtoToJSON(requestParameters["themePublishRequestDto"])
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ThemeShareDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Publish a theme to the public theme list
     */
    async publishTheme(requestParameters, initOverrides) {
      const response = await this.publishThemeRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Share a theme to be used by others
     */
    async shareThemeRaw(requestParameters, initOverrides) {
      if (requestParameters["themeDto"] == null) {
        throw new RequiredError(
          "themeDto",
          'Required parameter "themeDto" was null or undefined when calling shareTheme().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = await this.request({
        path: `/themes/share`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ThemeDtoToJSON(requestParameters["themeDto"])
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ThemeShareDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: None  Rate limit default: 10 Requests / 60000 ms TTL
     * Share a theme to be used by others
     */
    async shareTheme(requestParameters, initOverrides) {
      const response = await this.shareThemeRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Update the theme content from the provided new share and increment version
     */
    async updateThemeRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling updateTheme().'
        );
      }
      if (requestParameters["themeUpdateRequestDto"] == null) {
        throw new RequiredError(
          "themeUpdateRequestDto",
          'Required parameter "themeUpdateRequestDto" was null or undefined when calling updateTheme().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = await token("bearer", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = await this.request({
        path: `/themes/{id}/public`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: ThemeUpdateRequestDtoToJSON(requestParameters["themeUpdateRequestDto"])
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ThemeShareDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: Moderator  Rate limit default: 10 Requests / 60000 ms TTL
     * Update the theme content from the provided new share and increment version
     */
    async updateTheme(requestParameters, initOverrides) {
      const response = await this.updateThemeRaw(requestParameters, initOverrides);
      return await response.value();
    }
    /**
     *   Required Roles: None  Rate limit default: 100 Requests / 86400000 ms TTL
     * Get a theme by ID and increment use counter
     */
    async useThemeByIdRaw(requestParameters, initOverrides) {
      if (requestParameters["id"] == null) {
        throw new RequiredError(
          "id",
          'Required parameter "id" was null or undefined when calling useThemeById().'
        );
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = await this.request({
        path: `/themes/{id}/use`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ThemeDtoFromJSON(jsonValue));
    }
    /**
     *   Required Roles: None  Rate limit default: 100 Requests / 86400000 ms TTL
     * Get a theme by ID and increment use counter
     */
    async useThemeById(requestParameters, initOverrides) {
      const response = await this.useThemeByIdRaw(requestParameters, initOverrides);
      return await response.value();
    }
  };
  __name(_ThemesApi, "ThemesApi");
  let ThemesApi = _ThemesApi;
  var __defProp$1g = Object.defineProperty;
  var __getOwnPropDesc$l = Object.getOwnPropertyDescriptor;
  var __decorateClass$1g = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$l(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1g(target, key2, result);
    return result;
  }, "__decorateClass$1g");
  var __decorateParam$i = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$i");
  let TokenService = (_ha = class {
    constructor(loggerFactory2) {
      __publicField(this, "_logger");
      __publicField(this, "_token", new BehaviorSubject(void 0));
      this._logger = loggerFactory2(this);
      this.initToken();
    }
    async initToken() {
      let token = await typoRuntime.getToken();
      if (token === null) {
        const oidc = new OidcLogin();
        if (oidc.hasRedirectCallback()) {
          this._logger.error("Handling OIDC redirect callback");
          try {
            token = await oidc.exchangeAuthCode();
            await typoRuntime.setToken(token);
          } catch {
            oidc.clearUrlParams();
          }
        }
      }
      if (token && token.length === 64) {
        this._logger.info("Exchanging legacy token for OIDC token");
        try {
          const oidc = new OidcLogin();
          token = await oidc.exchangeLegacyToken(token);
          await typoRuntime.setToken(token);
        } catch {
          this._logger.warn("Failed to exchange legacy token, removing it");
        }
      }
      this._logger.info("Authenticated", token);
      this._token.next(token);
    }
    /**
     * Observable which emits the current token.
     */
    get token() {
      return this._token.asObservable();
    }
    async removeToken() {
      await typoRuntime.setToken(null);
      this._token.next(null);
    }
  }, __name(_ha, "TokenService"), _ha);
  TokenService = __decorateClass$1g([
    injectable(),
    __decorateParam$i(0, inject(loggerFactory))
  ], TokenService);
  var __defProp$1f = Object.defineProperty;
  var __getOwnPropDesc$k = Object.getOwnPropertyDescriptor;
  var __decorateClass$1f = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$k(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1f(target, key2, result);
    return result;
  }, "__decorateClass$1f");
  var __decorateParam$h = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$h");
  let ApiService = (_ia = class {
    constructor(loggerFactory2, tokenService) {
      __publicField(this, "_logger");
      __publicField(this, "_baseUrl", "https://api.typo.rip");
      __publicField(this, "_token", "");
      __publicField(this, "instances", /* @__PURE__ */ new Map());
      this._logger = loggerFactory2(this);
      tokenService.token.subscribe((token) => this._token = token ?? "");
    }
    /**
     * creates a new api config based on set options
     * @private
     */
    createApiConfig() {
      return new Configuration({
        basePath: this._baseUrl,
        accessToken: /* @__PURE__ */ __name(() => this._token, "accessToken")
      });
    }
    /**
     * create a new api client of given type
     * @param apiClass
     * @returns
     */
    getApi(apiClass) {
      let instance2 = this.instances.get(apiClass);
      if (instance2 === void 0) {
        instance2 = new apiClass(this.createApiConfig());
        this.instances.set(apiClass, instance2);
      }
      return instance2;
    }
    /**
     * Set the base url which will be used for api calls
     * @param url
     */
    set baseUrl(url) {
      this._baseUrl = url;
    }
  }, __name(_ia, "ApiService"), _ia);
  ApiService = __decorateClass$1f([
    injectable(),
    __decorateParam$h(0, inject(loggerFactory)),
    __decorateParam$h(1, inject(TokenService))
  ], ApiService);
  var __defProp$1e = Object.defineProperty;
  var __getOwnPropDesc$j = Object.getOwnPropertyDescriptor;
  var __decorateClass$1e = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$j(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1e(target, key2, result);
    return result;
  }, "__decorateClass$1e");
  var __decorateParam$g = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$g");
  let MemberService = (_ja = class {
    constructor(loggerFactory2, _apiService, _tokenService, _onboardingService) {
      __publicField(this, "_logger");
      __publicField(this, "_member$", new BehaviorSubject(void 0));
      __publicField(this, "_memberData$", new BehaviorSubject(void 0));
      this._apiService = _apiService;
      this._tokenService = _tokenService;
      this._onboardingService = _onboardingService;
      this._logger = loggerFactory2(this);
      this._tokenService.token.pipe(
        filter((token) => token !== void 0)
        // only when token is loaded
      ).subscribe((token) => this.loadMember(token === null));
      this._member$.pipe(
        switchMap((member) => {
          if (member === null || member === void 0) {
            return of(member);
          }
          return forkJoin({
            webhooks: fromPromise(_apiService.getApi(MembersApi).getMemberGuildWebhooks({ login: Number(member.userLogin) })),
            member: of(member),
            slots: fromPromise(_apiService.getApi(InventoryApi).getMemberSpriteSlotCount({ login: Number(member.userLogin) })),
            spriteInventory: fromPromise(_apiService.getApi(InventoryApi).getMemberSpriteInventory({ login: Number(member.userLogin) })),
            sceneInventory: fromPromise(_apiService.getApi(InventoryApi).getMemberSceneInventory({ login: Number(member.userLogin) }))
          });
        })
      ).subscribe((data) => {
        this._memberData$.next(data);
      });
      const task = _onboardingService.registerTask({
        key: "logged_in",
        name: "Log in with Discord",
        description: "Connect your discord account to typo to connect with friends and upgrade your avatar outfit.",
        start: /* @__PURE__ */ __name(() => this.login(), "start"),
        priority: 2
      });
      this._member$.subscribe((member) => {
        if (member === void 0) return;
        if (member !== null) task.complete();
        else task.clear();
      });
    }
    async loadMember(reset = false) {
      if (reset) {
        this._member$.next(null);
        return Promise.resolve(null);
      }
      const promise = this._apiService.getApi(MembersApi).getAuthenticatedMember();
      promise.then((member) => {
        this._member$.next(member);
      }).catch(() => {
        if (this._member$.value !== null) {
          this._member$.next(null);
        }
      });
      return promise;
    }
    /**
     * trigger a refresh that loads the member inventory and
     * results in a new emit of the memberdata observable
     */
    async refreshInventory() {
      await firstValueFrom(this.memberData$.pipe(
        take(1),
        switchMap(async (data) => {
          if (data !== null && data !== void 0) {
            const spriteInv = await this._apiService.getApi(InventoryApi).getMemberSpriteInventory({ login: Number(data.member.userLogin) });
            const sceneInv = await this._apiService.getApi(InventoryApi).getMemberSceneInventory({ login: Number(data.member.userLogin) });
            data.spriteInventory = spriteInv;
            data.sceneInventory = sceneInv;
            this._memberData$.next(data);
          }
        })
      ));
    }
    /**
     * Observable which emits the current member.
     */
    get member$() {
      return this._member$.asObservable();
    }
    /**
     * Observable which emits the current member and additional data.
     */
    get memberData$() {
      return this._memberData$.asObservable();
    }
    /**
     * Redirects the user to the login page.
     */
    login() {
      new OidcLogin().loginRedirect();
    }
    /**
     * Removes the token from the storage and the service.
     */
    async logout() {
      await this._tokenService.removeToken();
    }
    async refreshMember() {
      return this.loadMember();
    }
  }, __name(_ja, "MemberService"), _ja);
  MemberService = __decorateClass$1e([
    injectable(),
    __decorateParam$g(0, inject(loggerFactory)),
    __decorateParam$g(1, inject(ApiService)),
    __decorateParam$g(2, inject(TokenService)),
    __decorateParam$g(3, inject(OnboardingService))
  ], MemberService);
  const _SkribblOverlayPlayer = class _SkribblOverlayPlayer {
    constructor(_player, _lobbyKey, _overlayContainer) {
      __publicField(this, "_avatarContainer");
      __publicField(this, "_placeholderBackgroundContainer");
      __publicField(this, "iconsContainer", null);
      this._player = _player;
      this._lobbyKey = _lobbyKey;
      this._overlayContainer = _overlayContainer;
      this._avatarContainer = requireElement(".avatar", this._overlayContainer);
      this._placeholderBackgroundContainer = createElement('<div style="display: none;"></div>');
      this._overlayContainer.appendChild(this._placeholderBackgroundContainer);
    }
    destroy() {
      this._placeholderBackgroundContainer.remove();
    }
    get typoId() {
      return { lobbyKey: this._lobbyKey, lobbyPlayerId: this._player.id };
    }
    get avatarContainer() {
      return this._avatarContainer;
    }
    get backgroundContainer() {
      return this._placeholderBackgroundContainer;
    }
    get container() {
      return this._overlayContainer;
    }
    set useBackground(value) {
    }
    set useSafeColor(value) {
    }
    set adjustToContainSprites(value) {
    }
    set viewPlayerId(value) {
    }
    /**
     * remove the elements; as container is disposable and updates in the short timespan it is shown can be ignored
     * @param value
     */
    set hideAvatar(value) {
      if (value) {
        elements(":is(.eyes, .mouth, .color)", this._avatarContainer).forEach(
          (element2) => element2.remove()
        );
      }
    }
  };
  __name(_SkribblOverlayPlayer, "SkribblOverlayPlayer");
  let SkribblOverlayPlayer = _SkribblOverlayPlayer;
  const _SkribblPopupPlayer = class _SkribblPopupPlayer {
    constructor(_player, _playerPopup, _lobbyKey, _playerLogin) {
      __publicField(this, "_avatarContainer");
      __publicField(this, "_placeholderBackgroundContainer");
      __publicField(this, "iconsContainer", null);
      this._player = _player;
      this._playerPopup = _playerPopup;
      this._lobbyKey = _lobbyKey;
      this._playerLogin = _playerLogin;
      if (_lobbyKey === void 0 && _playerLogin === void 0)
        throw new Error("No identification provided");
      this._avatarContainer = requireElement(".avatar", this._playerPopup);
      this._placeholderBackgroundContainer = createElement('<div style="display: none;"></div>');
      this._playerPopup.appendChild(this._placeholderBackgroundContainer);
    }
    destroy() {
      this._placeholderBackgroundContainer.remove();
    }
    get typoId() {
      if (this._playerLogin !== void 0) return { login: this._playerLogin };
      if (this._lobbyKey !== void 0)
        return { lobbyKey: this._lobbyKey, lobbyPlayerId: this._player.id };
      throw new Error("No identification provided");
    }
    get avatarContainer() {
      return this._avatarContainer;
    }
    get backgroundContainer() {
      return this._placeholderBackgroundContainer;
    }
    get container() {
      return this._playerPopup;
    }
    set useBackground(value) {
    }
    set useSafeColor(value) {
    }
    set adjustToContainSprites(value) {
    }
    set viewPlayerId(value) {
    }
    /**
     * remove the elements; as container is disposable and updates in the short timespan it is shown can be ignored
     * @param value
     */
    set hideAvatar(value) {
      if (value) {
        elements(":is(.eyes, .mouth, .color)", this._avatarContainer).forEach(
          (element2) => element2.remove()
        );
      }
    }
  };
  __name(_SkribblPopupPlayer, "SkribblPopupPlayer");
  let SkribblPopupPlayer = _SkribblPopupPlayer;
  const _SkribblScoreboardPodiumPlayer = class _SkribblScoreboardPodiumPlayer {
    constructor(_player, _lobbyKey) {
      __publicField(this, "_playerContainer");
      __publicField(this, "_avatarContainer");
      __publicField(this, "_placeholderBackgroundContainer");
      __publicField(this, "iconsContainer", null);
      this._player = _player;
      this._lobbyKey = _lobbyKey;
      this._playerContainer = requireElement(
        `.overlay-content .result.show .podests > div:has(.avatar[playerid='${this._player.id}'])`
      );
      this._avatarContainer = requireElement(".avatar", this._playerContainer);
      this._placeholderBackgroundContainer = createElement('<div style="display: none;"></div>');
      this._playerContainer.appendChild(this._placeholderBackgroundContainer);
    }
    destroy() {
      this._placeholderBackgroundContainer.remove();
    }
    get typoId() {
      return { lobbyKey: this._lobbyKey, lobbyPlayerId: this._player.id };
    }
    get avatarContainer() {
      return this._avatarContainer;
    }
    get backgroundContainer() {
      return this._placeholderBackgroundContainer;
    }
    get container() {
      return this._playerContainer;
    }
    set useBackground(value) {
    }
    set useSafeColor(value) {
    }
    set adjustToContainSprites(value) {
    }
    set viewPlayerId(value) {
    }
    /**
     * remove the elements; as container is disposable and updates in the short timespan it is shown can be ignored
     * @param value
     */
    set hideAvatar(value) {
      if (value) {
        elements(":is(.eyes, .mouth, .color)", this._avatarContainer).forEach(
          (element2) => element2.remove()
        );
      }
    }
  };
  __name(_SkribblScoreboardPodiumPlayer, "SkribblScoreboardPodiumPlayer");
  let SkribblScoreboardPodiumPlayer = _SkribblScoreboardPodiumPlayer;
  const _SkribblScoreboardRegularPlayer = class _SkribblScoreboardRegularPlayer {
    constructor(_player, _lobbyKey) {
      __publicField(this, "_playerContainer");
      __publicField(this, "_avatarContainer");
      __publicField(this, "_placeholderBackgroundContainer");
      __publicField(this, "iconsContainer", null);
      this._player = _player;
      this._lobbyKey = _lobbyKey;
      this._playerContainer = requireElement(
        `.overlay-content .result.show .ranks .rank[playerid='${this._player.id}']`
      );
      this._avatarContainer = requireElement(".avatar", this._playerContainer);
      this._placeholderBackgroundContainer = createElement('<div style="display: none;"></div>');
      this._playerContainer.appendChild(this._placeholderBackgroundContainer);
    }
    destroy() {
      this._placeholderBackgroundContainer.remove();
    }
    get typoId() {
      return { lobbyKey: this._lobbyKey, lobbyPlayerId: this._player.id };
    }
    get avatarContainer() {
      return this._avatarContainer;
    }
    get backgroundContainer() {
      return this._placeholderBackgroundContainer;
    }
    get container() {
      return this._playerContainer;
    }
    set useBackground(value) {
    }
    set useSafeColor(value) {
    }
    set adjustToContainSprites(value) {
    }
    set viewPlayerId(value) {
    }
    /**
     * remove the elements; as container is disposable and updates in the short timespan it is shown can be ignored
     * @param value
     */
    set hideAvatar(value) {
      if (value) {
        elements(":is(.eyes, .mouth, .color)", this._avatarContainer).forEach(
          (element2) => element2.remove()
        );
      }
    }
  };
  __name(_SkribblScoreboardRegularPlayer, "SkribblScoreboardRegularPlayer");
  let SkribblScoreboardRegularPlayer = _SkribblScoreboardRegularPlayer;
  var __defProp$1d = Object.defineProperty;
  var __decorateClass$1d = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$1d(target, key2, result);
    return result;
  }, "__decorateClass$1d");
  const _LandingPlayerSetup = class _LandingPlayerSetup extends Setup {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_globalSettingsService");
      __publicField(this, "_memberService");
    }
    async runSetup() {
      const elements2 = await this._elementsSetup.complete();
      return this._memberService.member$.pipe(
        combineLatestWith(this._globalSettingsService.settings.showLandingOutfit.changes$),
        map(([member, enabled]) => {
          if (member === void 0 || member === null || elements2 === void 0 || !enabled) return void 0;
          return new SkribblLandingPlayer(Number(member.userLogin), elements2.landingCustomizeContainer, elements2.landingAvatar);
        })
      );
    }
  };
  __name(_LandingPlayerSetup, "LandingPlayerSetup");
  let LandingPlayerSetup = _LandingPlayerSetup;
  __decorateClass$1d([
    inject(ElementsSetup)
  ], LandingPlayerSetup.prototype, "_elementsSetup");
  __decorateClass$1d([
    inject(GlobalSettingsService)
  ], LandingPlayerSetup.prototype, "_globalSettingsService");
  __decorateClass$1d([
    inject(MemberService)
  ], LandingPlayerSetup.prototype, "_memberService");
  const calculateLobbyKey = /* @__PURE__ */ __name((key2) => {
    const sum = [...key2].reduce((sum2, char) => sum2 + char.charCodeAt(0), 0);
    const hashed = [...key2].map((char) => String.fromCharCode(char.charCodeAt(0) + sum));
    const newKey = hashed.join("");
    return newKey;
  }, "calculateLobbyKey");
  var __defProp$1c = Object.defineProperty;
  var __getOwnPropDesc$i = Object.getOwnPropertyDescriptor;
  var __decorateClass$1c = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$i(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1c(target, key2, result);
    return result;
  }, "__decorateClass$1c");
  var __decorateParam$f = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$f");
  let PlayersService = (_ka = class {
    constructor(loggerFactory2) {
      __publicField(this, "_elementsSetup");
      __publicField(this, "_lobbyJoinedEvent");
      __publicField(this, "_lobbyLeftEvent");
      __publicField(this, "_lobbyStateChangedEvent");
      __publicField(this, "_playerChangedEvent");
      __publicField(this, "_scoreboardVisibleEvent");
      __publicField(this, "_textOverlayVisibleEvent");
      __publicField(this, "_popupVisibleEvent");
      __publicField(this, "_memberService");
      __publicField(this, "_lobbyService");
      __publicField(this, "_landingPlayerSetup");
      __publicField(this, "_logger");
      __publicField(this, "_lobbyPlayers$", new BehaviorSubject([]));
      __publicField(this, "_landingPlayer$", new BehaviorSubject(void 0));
      __publicField(this, "_scoreboardPlayers$", new BehaviorSubject([]));
      __publicField(this, "_popupPlayer$", new BehaviorSubject(void 0));
      __publicField(this, "_overlayPlayer$", new BehaviorSubject(void 0));
      __publicField(this, "_chatPlayers$", new BehaviorSubject([]));
      __publicField(this, "_players$", new BehaviorSubject([]));
      this._logger = loggerFactory2(this);
    }
    postConstruct() {
      this.setupLandingPlayer();
      this.setupLobbyPlayers();
      this.setupScoreboardPlayers();
      this.setupPopupPlayer();
      this.setupOverlayPlayer();
      this.setupCombinedPlayers();
    }
    setupCombinedPlayers() {
      this._lobbyPlayers$.pipe(
        startWith([]),
        combineLatestWith(
          this.landingPlayer$,
          this.scoreboardPlayers$,
          this.popupPlayer$,
          this.overlayPlayer$,
          this._chatPlayers$
        ),
        map(([players, landing, scoreboard, popup, overlay, chat]) => [
          ...players,
          landing,
          ...scoreboard,
          popup,
          overlay,
          ...chat
        ].filter((player) => player !== void 0))
      ).subscribe(this._players$);
      this.players$.pipe(
        pairwise()
      ).subscribe(([oldPlayers, newPlayers]) => {
        oldPlayers.filter((player) => !newPlayers.includes(player)).forEach((player) => player.destroy());
      });
    }
    setupLandingPlayer() {
      of(void 0).pipe(
        mergeWith(from(this._landingPlayerSetup.complete()).pipe(
          switchMap((player) => player)
        ))
      ).subscribe((player) => this._landingPlayer$.next(player));
    }
    setupLobbyPlayers() {
      this._lobbyJoinedEvent.events$.pipe(
        combineLatestWith(this._memberService.member$)
      ).subscribe(([event, member]) => {
        const players = event.data.players.map((player) => {
          try {
            const key2 = event.data.id ? calculateLobbyKey(event.data.id) : void 0;
            return new SkribblLobbyPlayer(
              player,
              key2,
              key2 === void 0 && member ? Number(member.userLogin) : void 0
            );
          } catch (e) {
            this._logger.error("Failed to create player", player, e);
            return null;
          }
        }).filter((player) => player !== null);
        this._lobbyPlayers$.next(players);
        this._logger.info("Lobby joined", players);
      });
      this._playerChangedEvent.events$.pipe(
        withLatestFrom(this._lobbyJoinedEvent.events$.pipe(
          map((event) => event.data.id),
          mergeWith(this._lobbyLeftEvent.events$.pipe(map(() => void 0)))
        )),
        combineLatestWith(this._memberService.member$)
      ).subscribe(([[event, lobbyId], member]) => {
        if (lobbyId === void 0) {
          this._lobbyPlayers$.next([]);
          return;
        }
        if (lobbyId === null && member === null || member === void 0) {
          this._lobbyPlayers$.next([]);
          return;
        }
        if (event.data.joined) {
          const current = this._lobbyPlayers$.value;
          let newPlayer;
          try {
            const key2 = lobbyId ? calculateLobbyKey(lobbyId) : void 0;
            newPlayer = new SkribblLobbyPlayer(
              event.data.joined,
              key2,
              key2 === void 0 && member ? Number(member.userLogin) : void 0
            );
          } catch (e) {
            this._logger.error("Failed to create player", event.data.joined, e);
            return;
          }
          current.push(newPlayer);
          this._lobbyPlayers$.next(current);
          this._logger.info("Player joined", newPlayer);
        }
        if (event.data.left) {
          const id2 = event.data.left.id;
          const left = this._lobbyPlayers$.value.find((player) => player.lobbyPlayerId === id2);
          const current = this._lobbyPlayers$.value.filter((player) => player != left);
          this._lobbyPlayers$.next(current);
          this._logger.info("Player left", left);
        }
      });
      this._lobbyLeftEvent.events$.subscribe(() => {
        this._lobbyPlayers$.next([]);
        this._logger.info("Lobby left");
      });
    }
    setupScoreboardPlayers() {
      this._lobbyStateChangedEvent.events$.pipe(
        combineLatestWith(this._lobbyService.lobby$, this._scoreboardVisibleEvent.events$),
        filter((data) => data[2].data === true),
        /* wait until scoreboard visible */
        map((data) => data[1] === null || data[0].data.gameEnded === void 0 ? void 0 : data),
        distinctUntilChanged()
      ).subscribe((data) => {
        var _a2;
        const event = (_a2 = data == null ? void 0 : data[0].data) == null ? void 0 : _a2.gameEnded;
        const lobby = (data == null ? void 0 : data[1]) ?? void 0;
        const lobbyId = (lobby == null ? void 0 : lobby.id) ?? null;
        if (event === void 0 || lobby === void 0 || lobbyId === null) {
          this._logger.info("Lobby changed, no scoreboard data");
          this._scoreboardPlayers$.next([]);
          return;
        }
        const players = event.ranking.map((player) => ({ player: lobby.players.find((p) => p.id === player.playerId), rank: player.rank })).filter((player) => player.player !== void 0).map(
          (player) => player.rank < 3 ? new SkribblScoreboardPodiumPlayer(player.player, calculateLobbyKey(lobbyId)) : new SkribblScoreboardRegularPlayer(player.player, calculateLobbyKey(lobbyId))
        );
        this._logger.info("Scoreboard visible, scoreboard data", players);
        this._scoreboardPlayers$.next(players);
      });
    }
    setupPopupPlayer() {
      this._popupVisibleEvent.events$.pipe(
        withLatestFrom(this._memberService.member$, this._lobbyService.lobby$, this._elementsSetup.complete())
      ).subscribe(([visible, member, lobby, elements2]) => {
        var _a2;
        if (!visible || lobby === null) {
          this._logger.info("Popup player hidden");
          this._popupPlayer$.next(void 0);
          return;
        }
        const playerId = ((_a2 = element$1(".player", elements2.playerPopup)) == null ? void 0 : _a2.getAttribute("playerid")) ?? void 0;
        if (playerId === void 0) {
          this._logger.error("No player id in popup");
          this._popupPlayer$.next(void 0);
          return;
        }
        const player = lobby.players.find((p) => p.id === Number(playerId));
        if (player === void 0) {
          this._logger.error("Player not found in lobby", playerId);
          this._popupPlayer$.next(void 0);
          return;
        }
        const lobbyKey = lobby.id ? calculateLobbyKey(lobby.id) : void 0;
        const playerDisplay = new SkribblPopupPlayer(player, elements2.playerPopup, lobbyKey, lobbyKey === void 0 && member ? Number(member.userLogin) : void 0);
        this._popupPlayer$.next(playerDisplay);
        this._logger.info("Popup player visible", playerDisplay);
      });
    }
    setupOverlayPlayer() {
      this._textOverlayVisibleEvent.events$.pipe(
        withLatestFrom(this._lobbyService.lobby$, this._elementsSetup.complete())
      ).subscribe(([visible, lobby, elements2]) => {
        if (!visible || lobby === null || lobby.id === null) {
          this._logger.info("Overlay player hidden");
          this._overlayPlayer$.next(void 0);
          return;
        }
        const playerId = elements2.textOverlay.getAttribute("playerid") ?? void 0;
        if (element$1(".avatar", elements2.textOverlay) === void 0 || playerId === void 0) {
          this._logger.info("No player or playerid in overlay, probably not a choosing info");
          this._popupPlayer$.next(void 0);
          return;
        }
        const player = lobby.players.find((p) => p.id === Number(playerId));
        if (player === void 0) {
          this._logger.error("Player not found in lobby", playerId);
          this._popupPlayer$.next(void 0);
          return;
        }
        const lobbyKey = calculateLobbyKey(lobby.id);
        const playerDisplay = new SkribblOverlayPlayer(player, lobbyKey, elements2.textOverlay);
        this._popupPlayer$.next(playerDisplay);
        this._logger.info("Overlay player visible", playerDisplay);
      });
    }
    addChatPlayer(player) {
      const current = this._chatPlayers$.value;
      current.push(player);
      this._chatPlayers$.next(current);
    }
    removeChatPlayer(player) {
      const current = this._chatPlayers$.value.filter((p) => p !== player);
      this._chatPlayers$.next(current);
    }
    clearChatPlayers() {
      this._chatPlayers$.next([]);
    }
    get lobbyPlayers$() {
      return this._lobbyPlayers$.asObservable();
    }
    get landingPlayer$() {
      return this._landingPlayer$.asObservable();
    }
    get scoreboardPlayers$() {
      return this._scoreboardPlayers$.asObservable();
    }
    get popupPlayer$() {
      return this._popupPlayer$.asObservable();
    }
    get overlayPlayer$() {
      return this._overlayPlayer$.asObservable();
    }
    get players$() {
      return this._players$.asObservable();
    }
  }, __name(_ka, "PlayersService"), _ka);
  __decorateClass$1c([
    inject(ElementsSetup)
  ], PlayersService.prototype, "_elementsSetup", 2);
  __decorateClass$1c([
    inject(LobbyJoinedEventListener)
  ], PlayersService.prototype, "_lobbyJoinedEvent", 2);
  __decorateClass$1c([
    inject(LobbyLeftEventListener)
  ], PlayersService.prototype, "_lobbyLeftEvent", 2);
  __decorateClass$1c([
    inject(LobbyStateChangedEventListener)
  ], PlayersService.prototype, "_lobbyStateChangedEvent", 2);
  __decorateClass$1c([
    inject(LobbyPlayerChangedEventListener)
  ], PlayersService.prototype, "_playerChangedEvent", 2);
  __decorateClass$1c([
    inject(ScoreboardVisibilityChangedEventListener)
  ], PlayersService.prototype, "_scoreboardVisibleEvent", 2);
  __decorateClass$1c([
    inject(TextOverlayVisibilityChangedEventListener)
  ], PlayersService.prototype, "_textOverlayVisibleEvent", 2);
  __decorateClass$1c([
    inject(PlayerPopupVisibilityChangedEventListener)
  ], PlayersService.prototype, "_popupVisibleEvent", 2);
  __decorateClass$1c([
    inject(MemberService)
  ], PlayersService.prototype, "_memberService", 2);
  __decorateClass$1c([
    inject(LobbyService)
  ], PlayersService.prototype, "_lobbyService", 2);
  __decorateClass$1c([
    inject(LandingPlayerSetup)
  ], PlayersService.prototype, "_landingPlayerSetup", 2);
  __decorateClass$1c([
    postConstruct()
  ], PlayersService.prototype, "postConstruct", 1);
  PlayersService = __decorateClass$1c([
    injectable(),
    __decorateParam$f(0, inject(loggerFactory))
  ], PlayersService);
  function create_fragment$1t(ctx) {
    let p;
    let span1;
    let b;
    let t0;
    let b_class_value;
    let t1;
    let span0;
    let t2;
    return {
      c() {
        p = element("p");
        span1 = element("span");
        b = element("b");
        t0 = text(
          /*title*/
          ctx[1]
        );
        t1 = space();
        span0 = element("span");
        t2 = text(
          /*content*/
          ctx[0]
        );
        attr(b, "class", b_class_value = null_to_empty(
          /*style*/
          ctx[2]
        ) + " svelte-1q3466u");
        attr(span0, "class", "svelte-1q3466u");
        attr(span1, "class", "svelte-1q3466u");
        attr(p, "class", "typo-chat-message svelte-1q3466u");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        append(p, span1);
        append(span1, b);
        append(b, t0);
        ctx[8](b);
        append(span1, t1);
        append(span1, span0);
        append(span0, t2);
        ctx[9](span0);
        ctx[10](span1);
        ctx[11](p);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*title*/
        2) set_data(
          t0,
          /*title*/
          ctx2[1]
        );
        if (dirty & /*style*/
        4 && b_class_value !== (b_class_value = null_to_empty(
          /*style*/
          ctx2[2]
        ) + " svelte-1q3466u")) {
          attr(b, "class", b_class_value);
        }
        if (dirty & /*content*/
        1) set_data(
          t2,
          /*content*/
          ctx2[0]
        );
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(p);
        }
        ctx[8](null);
        ctx[9](null);
        ctx[10](null);
        ctx[11](null);
      }
    };
  }
  __name(create_fragment$1t, "create_fragment$1t");
  function instance$1k($$self, $$props, $$invalidate) {
    let { content: content2 = "" } = $$props;
    let { title = "" } = $$props;
    let { style: style2 = "normal" } = $$props;
    let resolve2;
    const message = new Promise((res) => resolve2 = res);
    let messageElement;
    let titleElement;
    let contentElement;
    let wrapperElement;
    onMount(() => {
      resolve2({
        element: messageElement,
        title,
        content: content2,
        contentElement,
        titleElement,
        wrapperElement
      });
    });
    function b_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        titleElement = $$value;
        $$invalidate(4, titleElement);
      });
    }
    __name(b_binding, "b_binding");
    function span0_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        contentElement = $$value;
        $$invalidate(5, contentElement);
      });
    }
    __name(span0_binding, "span0_binding");
    function span1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        messageElement = $$value;
        $$invalidate(3, messageElement);
      });
    }
    __name(span1_binding, "span1_binding");
    function p_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        wrapperElement = $$value;
        $$invalidate(6, wrapperElement);
      });
    }
    __name(p_binding, "p_binding");
    $$self.$$set = ($$props2) => {
      if ("content" in $$props2) $$invalidate(0, content2 = $$props2.content);
      if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
      if ("style" in $$props2) $$invalidate(2, style2 = $$props2.style);
    };
    return [
      content2,
      title,
      style2,
      messageElement,
      titleElement,
      contentElement,
      wrapperElement,
      message,
      b_binding,
      span0_binding,
      span1_binding,
      p_binding
    ];
  }
  __name(instance$1k, "instance$1k");
  const _Message = class _Message extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1k, create_fragment$1t, safe_not_equal, {
        content: 0,
        title: 1,
        style: 2,
        message: 7
      });
    }
    get message() {
      return this.$$.ctx[7];
    }
  };
  __name(_Message, "Message");
  let Message = _Message;
  var __defProp$1b = Object.defineProperty;
  var __getOwnPropDesc$h = Object.getOwnPropertyDescriptor;
  var __decorateClass$1b = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$h(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$1b(target, key2, result);
    return result;
  }, "__decorateClass$1b");
  var __decorateParam$e = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$e");
  let ChatService = (_la = class {
    constructor(loggerFactory2) {
      __publicField(this, "_elementsSetup");
      __publicField(this, "_lobbyPlayersService");
      __publicField(this, "_messageReceivedEventListener");
      __publicField(this, "_messageRelaySetup");
      __publicField(this, "_logger");
      __publicField(this, "_elementDiscovered$", new Subject$1());
      __publicField(this, "_messageDiscovered$", new Subject$1());
      __publicField(this, "_playerMessageReceived$", new Subject$1());
      this._logger = loggerFactory2(this);
    }
    postConstruct() {
      this._logger.debug("Initializing chat service");
      this.setupMessageObserver();
    }
    /**
     * Setup the message observer to link chat messages with lobby players
     * @private
     */
    async setupMessageObserver() {
      const elements2 = await this._elementsSetup.complete();
      const elementObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.addedNodes.length > 0) {
            const addedNode = mutation.addedNodes[0];
            if (addedNode.tagName !== "P" || addedNode.children.length != 2) return;
            const title = addedNode.children[0];
            const content2 = addedNode.children[1];
            if (title.tagName !== "B" || content2.tagName !== "SPAN") return;
            this._elementDiscovered$.next({
              title: title.textContent ?? "",
              content: content2.textContent ?? "",
              element: addedNode,
              titleElement: addedNode.children[0],
              contentElement: addedNode.children[1]
            });
          }
        });
      });
      elementObserver.observe(elements2.chatContent, { childList: true, subtree: false });
      this._messageReceivedEventListener.events$.pipe(
        withLatestFrom(this._lobbyPlayersService.lobbyPlayers$),
        map(([event, players]) => {
          const player = players.find((p) => p.lobbyPlayerId === event.data.senderId);
          if (!player) {
            this._logger.warn("Player not found for message", event.data);
            return;
          }
          return { player, content: event.data.message };
        }),
        filter((data) => data !== void 0)
      ).subscribe((data) => this._messageDiscovered$.next(data));
      const pendingMessages = [];
      const pendingElements = [];
      this._messageDiscovered$.pipe(
        map((data) => pendingMessages.push(data)),
        mergeWith(
          this._elementDiscovered$.pipe(
            filter((element2) => element2.content.length !== 0),
            map((data) => pendingElements.push(data))
          )
        )
      ).subscribe(() => {
        const matches = this.findMessageMatches(pendingMessages, pendingElements);
        for (const match of matches) {
          this._playerMessageReceived$.next(match);
          this._logger.debug("Message match found", match);
        }
      });
    }
    /**
     * Find matches between recorded messages and chat elements
     * @param messages
     * @param elements
     * @private
     */
    findMessageMatches(messages, elements2) {
      const matches = [];
      for (const message of messages) {
        for (const element2 of elements2) {
          if (`${message.player.name}: ` === element2.title && message.content === element2.content) {
            matches.push({ ...message, ...element2 });
            messages.splice(messages.indexOf(message), 1);
            elements2.splice(elements2.indexOf(element2), 1);
            break;
          }
        }
      }
      return matches;
    }
    get chatMessageAdded$() {
      return this._elementDiscovered$.asObservable();
    }
    get playerMessageReceived$() {
      return this._playerMessageReceived$.asObservable();
    }
    /**
     * Sends a chat message over socket.io as the player
     */
    async sendChatMessage(content2) {
      this._logger.debug("Sending chat message", content2);
      const relay = await this._messageRelaySetup.complete();
      relay.insertMessage({ id: 30, data: { msg: content2 } });
    }
    /**
     * Add a chat message to the local chat history
     * @param content
     * @param title
     * @param style
     */
    async addChatMessage(content2, title, style2 = "normal") {
      const elements2 = await this._elementsSetup.complete();
      const container = elements2.chatContent;
      const isScrolledDown = container.scrollHeight - container.scrollTop - container.clientHeight < 50;
      const message = new Message({
        target: container,
        props: { title: title ?? "", content: content2, style: style2 }
      });
      const chatMessage = await message.message;
      if (isScrolledDown) container.scrollTo({ top: container.scrollHeight, behavior: "instant" });
      this._elementDiscovered$.next(chatMessage);
      return message;
    }
  }, __name(_la, "ChatService"), _la);
  __decorateClass$1b([
    inject(ElementsSetup)
  ], ChatService.prototype, "_elementsSetup", 2);
  __decorateClass$1b([
    inject(PlayersService)
  ], ChatService.prototype, "_lobbyPlayersService", 2);
  __decorateClass$1b([
    inject(MessageReceivedEventListener)
  ], ChatService.prototype, "_messageReceivedEventListener", 2);
  __decorateClass$1b([
    inject(SkribblMessageRelaySetup)
  ], ChatService.prototype, "_messageRelaySetup", 2);
  __decorateClass$1b([
    postConstruct()
  ], ChatService.prototype, "postConstruct", 1);
  ChatService = __decorateClass$1b([
    injectable(),
    __decorateParam$e(0, inject(loggerFactory))
  ], ChatService);
  const _SkribblChatPlayer = class _SkribblChatPlayer {
    constructor(_player, _lobbyKey, _container) {
      __publicField(this, "_elementId");
      __publicField(this, "_placeholderBackgroundContainer");
      __publicField(this, "_playerStyle");
      __publicField(this, "_playerHideAvatarRuleIndex");
      __publicField(this, "iconsContainer", null);
      this._player = _player;
      this._lobbyKey = _lobbyKey;
      this._container = _container;
      this._placeholderBackgroundContainer = document.createElement("div");
      this._elementId = "typo-chat-player-" + _SkribblChatPlayer.idCounter++;
      this._playerStyle = document.createElement("style");
      this._container.appendChild(this._playerStyle);
      this.container.classList.add(this._elementId);
    }
    destroy() {
      this._container.classList.remove(this._elementId);
      this._playerStyle.remove();
    }
    get typoId() {
      return { lobbyKey: this._lobbyKey, lobbyPlayerId: this._player.id };
    }
    get player() {
      return this._player;
    }
    get lobbyPlayerId() {
      return this._player.id;
    }
    get name() {
      return this._player.name;
    }
    get container() {
      return this._container;
    }
    get avatarContainer() {
      return this._container;
    }
    get backgroundContainer() {
      return this._placeholderBackgroundContainer;
    }
    set useBackground(value) {
    }
    set useSafeColor(value) {
    }
    set adjustToContainSprites(value) {
    }
    set viewPlayerId(value) {
    }
    set hideAvatar(value) {
      this._playerHideAvatarRuleIndex = replaceOrAddCssRule(
        this._playerStyle,
        value ? `
      .${this._elementId} :is(.eyes, .mouth, .color) { 
        display: ${value ? "none" : "block"}
      }` : void 0,
        this._playerHideAvatarRuleIndex
      );
    }
  };
  __name(_SkribblChatPlayer, "SkribblChatPlayer");
  __publicField(_SkribblChatPlayer, "idCounter", 0);
  let SkribblChatPlayer = _SkribblChatPlayer;
  const AVATAR_ATLAS_SIZE = 480;
  const CONTAINER_ATLAS_SIZE = 800;
  const AVATAR_SIZE = 48;
  const CONTAINER_SIZE = 80;
  const AVATAR_COUNT = AVATAR_ATLAS_SIZE / AVATAR_SIZE;
  const CONTAINER_COUNT = CONTAINER_ATLAS_SIZE / CONTAINER_SIZE;
  const calculateAtlasOffsets = /* @__PURE__ */ __name((atlas, index) => {
    const size = atlas === "avatar" ? AVATAR_SIZE : CONTAINER_SIZE;
    const atlasSize = atlas === "avatar" ? AVATAR_ATLAS_SIZE : CONTAINER_ATLAS_SIZE;
    const columns = atlasSize / size;
    const row = Math.floor(index / columns);
    const column = index % columns;
    return {
      x: column * size,
      y: row * size
    };
  }, "calculateAtlasOffsets");
  const wrapOffsetAsStyle = /* @__PURE__ */ __name((atlas, offset, containerSize) => {
    const containerScale = (atlas === "avatar" ? AVATAR_SIZE : CONTAINER_SIZE) / AVATAR_SIZE;
    const atlasSize = atlas === "avatar" ? AVATAR_ATLAS_SIZE : CONTAINER_ATLAS_SIZE;
    const atlasCount = atlas === "avatar" ? AVATAR_COUNT : CONTAINER_COUNT;
    const backgroundSize = `${containerScale} * ${containerSize} * ${atlasCount}`;
    return `
    background-position: 
      calc(-${offset.x} / ${atlasSize} * ${backgroundSize}) 
      calc(-${offset.y} / ${atlasSize} * ${backgroundSize}); 
    background-size: calc(${backgroundSize});
  `;
  }, "wrapOffsetAsStyle");
  function create_if_block$D(ctx) {
    let div;
    let div_style_value;
    return {
      c() {
        div = element("div");
        attr(div, "class", "typo-avatar-layer special svelte-ma71bf");
        attr(div, "style", div_style_value = wrapOffsetAsStyle("container", calculateAtlasOffsets(
          "container",
          /*avatar*/
          ctx[0][3]
        ), "var(--typo-avatar-container-size)"));
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*avatar*/
        1 && div_style_value !== (div_style_value = wrapOffsetAsStyle("container", calculateAtlasOffsets(
          "container",
          /*avatar*/
          ctx2[0][3]
        ), "var(--typo-avatar-container-size)"))) {
          attr(div, "style", div_style_value);
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_if_block$D, "create_if_block$D");
  function create_fragment$1s(ctx) {
    let div3;
    let div0;
    let div0_style_value;
    let t0;
    let div1;
    let div1_style_value;
    let t1;
    let div2;
    let div2_style_value;
    let t2;
    let if_block = (
      /*avatar*/
      ctx[0][3] !== void 0 && /*avatar*/
      ctx[0][3] >= 0 && create_if_block$D(ctx)
    );
    return {
      c() {
        div3 = element("div");
        div0 = element("div");
        t0 = space();
        div1 = element("div");
        t1 = space();
        div2 = element("div");
        t2 = space();
        if (if_block) if_block.c();
        attr(div0, "class", "typo-avatar-layer color svelte-ma71bf");
        attr(div0, "style", div0_style_value = wrapOffsetAsStyle("avatar", calculateAtlasOffsets(
          "avatar",
          /*avatar*/
          ctx[0][0]
        ), "var(--typo-avatar-container-size)"));
        attr(div1, "class", "typo-avatar-layer mouth svelte-ma71bf");
        attr(div1, "style", div1_style_value = wrapOffsetAsStyle("avatar", calculateAtlasOffsets(
          "avatar",
          /*avatar*/
          ctx[0][2]
        ), "var(--typo-avatar-container-size)"));
        attr(div2, "class", "typo-avatar-layer eyes svelte-ma71bf");
        attr(div2, "style", div2_style_value = wrapOffsetAsStyle("avatar", calculateAtlasOffsets(
          "avatar",
          /*avatar*/
          ctx[0][1]
        ), "var(--typo-avatar-container-size)"));
        attr(div3, "class", "typo-avatar-container svelte-ma71bf");
        set_style(
          div3,
          "--typo-avatar-container-size",
          /*size*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, div3, anchor);
        append(div3, div0);
        append(div3, t0);
        append(div3, div1);
        append(div3, t1);
        append(div3, div2);
        append(div3, t2);
        if (if_block) if_block.m(div3, null);
        ctx[4](div3);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*avatar*/
        1 && div0_style_value !== (div0_style_value = wrapOffsetAsStyle("avatar", calculateAtlasOffsets(
          "avatar",
          /*avatar*/
          ctx2[0][0]
        ), "var(--typo-avatar-container-size)"))) {
          attr(div0, "style", div0_style_value);
        }
        if (dirty & /*avatar*/
        1 && div1_style_value !== (div1_style_value = wrapOffsetAsStyle("avatar", calculateAtlasOffsets(
          "avatar",
          /*avatar*/
          ctx2[0][2]
        ), "var(--typo-avatar-container-size)"))) {
          attr(div1, "style", div1_style_value);
        }
        if (dirty & /*avatar*/
        1 && div2_style_value !== (div2_style_value = wrapOffsetAsStyle("avatar", calculateAtlasOffsets(
          "avatar",
          /*avatar*/
          ctx2[0][1]
        ), "var(--typo-avatar-container-size)"))) {
          attr(div2, "style", div2_style_value);
        }
        if (
          /*avatar*/
          ctx2[0][3] !== void 0 && /*avatar*/
          ctx2[0][3] >= 0
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$D(ctx2);
            if_block.c();
            if_block.m(div3, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & /*size*/
        2) {
          set_style(
            div3,
            "--typo-avatar-container-size",
            /*size*/
            ctx2[1]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div3);
        }
        if (if_block) if_block.d();
        ctx[4](null);
      }
    };
  }
  __name(create_fragment$1s, "create_fragment$1s");
  function instance$1j($$self, $$props, $$invalidate) {
    let { avatar } = $$props;
    let { size = "80px" } = $$props;
    let resolve2;
    let container;
    const element2 = new Promise((res) => resolve2 = res);
    onMount(() => {
      resolve2(container);
    });
    function div3_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        container = $$value;
        $$invalidate(2, container);
      });
    }
    __name(div3_binding, "div3_binding");
    $$self.$$set = ($$props2) => {
      if ("avatar" in $$props2) $$invalidate(0, avatar = $$props2.avatar);
      if ("size" in $$props2) $$invalidate(1, size = $$props2.size);
    };
    return [avatar, size, container, element2, div3_binding];
  }
  __name(instance$1j, "instance$1j");
  const _Skribbl_avatar = class _Skribbl_avatar extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1j, create_fragment$1s, safe_not_equal, { avatar: 0, size: 1, element: 3 });
    }
    get element() {
      return this.$$.ctx[3];
    }
  };
  __name(_Skribbl_avatar, "Skribbl_avatar");
  let Skribbl_avatar = _Skribbl_avatar;
  var __defProp$1a = Object.defineProperty;
  var __decorateClass$1a = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$1a(target, key2, result);
    return result;
  }, "__decorateClass$1a");
  const _ChatAvatarsFeature = class _ChatAvatarsFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_chatService");
      __publicField(this, "_playersService");
      __publicField(this, "_lobbyService");
      __publicField(this, "_elementsSetup");
      __publicField(this, "name", "Chat Avatars");
      __publicField(this, "description", "Display the avatar of a player next to their chat messages.");
      __publicField(this, "tags", [FeatureTag.INTERFACE]);
      __publicField(this, "featureId", 50);
      __publicField(this, "_avatarContainers", /* @__PURE__ */ new Set());
      __publicField(this, "featureEnabledDefault", false);
      __publicField(this, "_chatSubscription");
      __publicField(this, "_chatMutationObserver");
    }
    async onActivate() {
      this._chatSubscription = this._chatService.playerMessageReceived$.pipe(
        withLatestFrom(
          this._lobbyService.lobby$.pipe(
            map((lobby) => (lobby == null ? void 0 : lobby.id) ? calculateLobbyKey(lobby.id) : null)
          )
        ),
        filter(([, key2]) => key2 !== null)
      ).subscribe(async ([message, key2]) => this.processNewMessage(message, key2));
      this.observeRemovedMessages();
    }
    async onDestroy() {
      var _a2, _b2;
      (_a2 = this._chatSubscription) == null ? void 0 : _a2.unsubscribe();
      this._chatSubscription = void 0;
      this._playersService.clearChatPlayers();
      for (const container of this._avatarContainers) {
        container.element.remove();
      }
      this._avatarContainers.clear();
      (_b2 = this._chatMutationObserver) == null ? void 0 : _b2.disconnect();
      this._chatMutationObserver = void 0;
    }
    async processNewMessage(message, key2) {
      this._logger.info("Processing new chat message", message);
      if (key2 === null) {
        this._logger.warn("No lobby key found for chat message", message);
        return;
      }
      const skribblPlayer = message.player.player;
      const container = createElement(`<div
        style="display: inline-flex; align-items: center; height: 0; vertical-align: middle; margin-right: .5rem"
      ></div>`);
      const avatar = new Skribbl_avatar({
        target: container,
        props: {
          avatar: skribblPlayer.avatar,
          size: "1rem"
        }
      });
      message.element.insertAdjacentElement("afterbegin", container);
      const avatarContainer = await avatar.element;
      const display = new SkribblChatPlayer(skribblPlayer, key2, avatarContainer);
      this._avatarContainers.add({ element: container, player: display });
      this._playersService.addChatPlayer(display);
    }
    async observeRemovedMessages() {
      const elements2 = await this._elementsSetup.complete();
      this._chatMutationObserver = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) {
            this._avatarContainers.forEach((container) => {
              if (!container.element.isConnected) {
                this._playersService.removeChatPlayer(container.player);
                this._avatarContainers.delete(container);
              }
            });
          }
        }
      });
      this._chatMutationObserver.observe(elements2.chatContent, {
        childList: true,
        subtree: true
      });
    }
  };
  __name(_ChatAvatarsFeature, "ChatAvatarsFeature");
  let ChatAvatarsFeature = _ChatAvatarsFeature;
  __decorateClass$1a([
    inject(ChatService)
  ], ChatAvatarsFeature.prototype, "_chatService");
  __decorateClass$1a([
    inject(PlayersService)
  ], ChatAvatarsFeature.prototype, "_playersService");
  __decorateClass$1a([
    inject(LobbyService)
  ], ChatAvatarsFeature.prototype, "_lobbyService");
  __decorateClass$1a([
    inject(ElementsSetup)
  ], ChatAvatarsFeature.prototype, "_elementsSetup");
  var __defProp$19 = Object.defineProperty;
  var __decorateClass$19 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$19(target, key2, result);
    return result;
  }, "__decorateClass$19");
  const _ChatClearFeature = class _ChatClearFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_lobbyJoinedEventListener");
      __publicField(this, "_chatService");
      __publicField(this, "name", "Chat Clear");
      __publicField(this, "description", "Clears old messages in the chat for better performance");
      __publicField(this, "tags", [
        FeatureTag.GAMEPLAY,
        FeatureTag.INTERFACE
      ]);
      __publicField(this, "featureId", 42);
      __publicField(this, "_chatSubscription");
      __publicField(this, "_chatCleared$", new Subject$1());
      __publicField(this, "_clearChatCommand", this.useCommand(
        new ExtensionCommand("clear", this, "Clear Chat", "Clears the chat messages")
      ).run(async (command) => {
        this._chatCleared$.next(void 0);
        return new InterpretableSuccess(command, "Chat cleared");
      }));
      __publicField(this, "_clearChatQuotaSetting", this.useSetting(
        new NumericExtensionSetting("clear_quota", 200, this).withName("Message Limit").withDescription(
          "When the chat contains more than this limit, old messages are deleted. Set to 0 to disable."
        )
      ));
    }
    async onActivate() {
      this._chatSubscription = this._lobbyJoinedEventListener.events$.pipe(
        switchMap(
          () => this._chatService.chatMessageAdded$.pipe(
            withLatestFrom(this._clearChatQuotaSetting.changes$),
            scan((acc, [message, limit]) => {
              if (limit <= 0 || acc.length < limit) {
                acc.push(message.element);
              } else {
                acc[0].remove();
                acc.splice(1);
                acc.push(message.element);
              }
              return acc;
            }, []),
            /* listen for clear and modify reduced array in-place */
            switchMap((elements2) => this._chatCleared$.pipe(
              tap(() => {
                elements2.forEach((element2) => element2.remove());
                elements2.splice(0, elements2.length);
              })
            ))
          )
        )
      ).subscribe();
    }
    async onDestroy() {
      var _a2;
      (_a2 = this._chatSubscription) == null ? void 0 : _a2.unsubscribe();
      this._chatSubscription = void 0;
    }
  };
  __name(_ChatClearFeature, "ChatClearFeature");
  let ChatClearFeature = _ChatClearFeature;
  __decorateClass$19([
    inject(LobbyJoinedEventListener)
  ], ChatClearFeature.prototype, "_lobbyJoinedEventListener");
  __decorateClass$19([
    inject(ChatService)
  ], ChatClearFeature.prototype, "_chatService");
  const _InterpretableEmptyRemainder = class _InterpretableEmptyRemainder extends InterpretableError {
  };
  __name(_InterpretableEmptyRemainder, "InterpretableEmptyRemainder");
  let InterpretableEmptyRemainder = _InterpretableEmptyRemainder;
  const _ExtensionCommandParameter = class _ExtensionCommandParameter {
    constructor(_name, _description) {
      __publicField(this, "_execute");
      this._name = _name;
      this._description = _description;
    }
    get name() {
      return this._name;
    }
    get description() {
      return this._description;
    }
    /**
     * Set the action to be executed after interpretation
     * @param action
     */
    withAction(action) {
      this._execute = action;
      return this;
    }
    interpret(args, source, context) {
      let skipMarkAsInterpreting = false;
      try {
        const { argument, remainder } = this.readArg(args, () => skipMarkAsInterpreting = true);
        if (!skipMarkAsInterpreting) context.currentInterpretedParameter = this;
        return Promise.resolve({
          result: { ...source, ...argument },
          context,
          remainder
        });
      } catch (e) {
        if (!(e instanceof InterpretableEmptyRemainder)) {
          context.currentInterpretedParameter = this;
        }
        throw e;
      }
    }
    execute(result, context) {
      var _a2;
      return ((_a2 = this._execute) == null ? void 0 : _a2.call(this, result, context)) ?? Promise.resolve({ result: new InterpretableSuccess(this) });
    }
  };
  __name(_ExtensionCommandParameter, "ExtensionCommandParameter");
  let ExtensionCommandParameter = _ExtensionCommandParameter;
  const _StringCommandParameter = class _StringCommandParameter extends ExtensionCommandParameter {
    constructor(name, description, _mapping) {
      super(name, description);
      __publicField(this, "typeName", "text");
      __publicField(this, "typeDescription", "a single word or text wrapped in quotes");
      this._mapping = _mapping;
    }
    readArg(args) {
      const regex = /^\s*(["'])(.*?)\1/;
      let arg = "";
      let remainder = "";
      const matchQuoted = args.trim().match(regex);
      if (matchQuoted !== null) {
        arg = matchQuoted[2];
        remainder = args.trim().slice(matchQuoted[0].length).trim();
      } else {
        const split = args.trim().split(" ");
        arg = split[0].trim();
        remainder = split.slice(1).join(" ");
      }
      if (arg.length < 1) {
        throw new InterpretableEmptyRemainder(this);
      }
      const argument = this._mapping(arg);
      return { remainder, argument };
    }
  };
  __name(_StringCommandParameter, "StringCommandParameter");
  let StringCommandParameter = _StringCommandParameter;
  const _InterpretableArgumentParsingError = class _InterpretableArgumentParsingError extends InterpretableError {
  };
  __name(_InterpretableArgumentParsingError, "InterpretableArgumentParsingError");
  let InterpretableArgumentParsingError = _InterpretableArgumentParsingError;
  const _InterpretableSilentSuccess = class _InterpretableSilentSuccess extends InterpretableResult {
    constructor(interpretable) {
      super(interpretable, void 0);
    }
  };
  __name(_InterpretableSilentSuccess, "InterpretableSilentSuccess");
  let InterpretableSilentSuccess = _InterpretableSilentSuccess;
  function create_if_block_1$j(ctx) {
    let h3;
    let t0;
    let span;
    let t1;
    let if_block = (
      /*iconName*/
      ctx[7] && create_if_block_2$f(ctx)
    );
    return {
      c() {
        h3 = element("h3");
        if (if_block) if_block.c();
        t0 = space();
        span = element("span");
        t1 = text(
          /*title*/
          ctx[6]
        );
        attr(h3, "class", "svelte-1lmlzvv");
      },
      m(target, anchor) {
        insert(target, h3, anchor);
        if (if_block) if_block.m(h3, null);
        append(h3, t0);
        append(h3, span);
        append(span, t1);
      },
      p(ctx2, dirty) {
        if (
          /*iconName*/
          ctx2[7]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block_2$f(ctx2);
            if_block.c();
            if_block.m(h3, t0);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & /*title*/
        64) set_data(
          t1,
          /*title*/
          ctx2[6]
        );
      },
      d(detaching) {
        if (detaching) {
          detach(h3);
        }
        if (if_block) if_block.d();
      }
    };
  }
  __name(create_if_block_1$j, "create_if_block_1$j");
  function create_if_block_2$f(ctx) {
    let img;
    let img_src_value;
    return {
      c() {
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        attr(img, "alt", "Icon");
        set_style(img, "content", "var(--" + /*iconName*/
        ctx[7] + ")");
        attr(img, "class", "svelte-1lmlzvv");
      },
      m(target, anchor) {
        insert(target, img, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*iconName*/
        128) {
          set_style(img, "content", "var(--" + /*iconName*/
          ctx2[7] + ")");
        }
      },
      d(detaching) {
        if (detaching) {
          detach(img);
        }
      }
    };
  }
  __name(create_if_block_2$f, "create_if_block_2$f");
  function create_if_block$C(ctx) {
    let span;
    let mounted;
    let dispose;
    return {
      c() {
        span = element("span");
        span.textContent = "×";
        attr(span, "class", "close-explicit svelte-1lmlzvv");
      },
      m(target, anchor) {
        insert(target, span, anchor);
        if (!mounted) {
          dispose = listen(
            span,
            "click",
            /*click_handler*/
            ctx[17]
          );
          mounted = true;
        }
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(span);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block$C, "create_if_block$C");
  function create_fragment$1r(ctx) {
    let div1;
    let t0;
    let div0;
    let switch_instance;
    let t1;
    let current;
    let if_block0 = (
      /*title*/
      ctx[6] && create_if_block_1$j(ctx)
    );
    const switch_instance_spread_levels = [
      /*componentData*/
      ctx[5].props
    ];
    var switch_value = (
      /*componentData*/
      ctx[5].componentType
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {};
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*componentData*/
      32) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*componentData*/
          ctx2[5].props
        )]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    let if_block1 = (
      /*closeStrategy*/
      ctx[0] === "explicit" && create_if_block$C(ctx)
    );
    return {
      c() {
        div1 = element("div");
        if (if_block0) if_block0.c();
        t0 = space();
        div0 = element("div");
        if (switch_instance) create_component(switch_instance.$$.fragment);
        t1 = space();
        if (if_block1) if_block1.c();
        attr(div0, "class", "content svelte-1lmlzvv");
        toggle_class(
          div0,
          "padding",
          /*contentPadding*/
          ctx[8] !== false
        );
        attr(div1, "class", "typo-area-flyout color-scrollbar svelte-1lmlzvv");
        set_style(
          div1,
          "max-height",
          /*getMaxHeightCss*/
          ctx[12]()
        );
        set_style(
          div1,
          "max-width",
          /*getMaxWidthCss*/
          ctx[13]()
        );
        set_style(
          div1,
          "grid-area",
          /*areaName*/
          ctx[4]
        );
        set_style(
          div1,
          "margin",
          /*marginY*/
          ctx[2] + " " + /*marginX*/
          ctx[3]
        );
        toggle_class(
          div1,
          "closing",
          /*closing*/
          ctx[11]
        );
        toggle_class(
          div1,
          "align-top",
          /*alignment*/
          ctx[1] === "top"
        );
        toggle_class(
          div1,
          "align-bottom",
          /*alignment*/
          ctx[1] === "bottom"
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        if (if_block0) if_block0.m(div1, null);
        append(div1, t0);
        append(div1, div0);
        if (switch_instance) mount_component(switch_instance, div0, null);
        append(div1, t1);
        if (if_block1) if_block1.m(div1, null);
        ctx[18](div1);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (
          /*title*/
          ctx2[6]
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_1$j(ctx2);
            if_block0.c();
            if_block0.m(div1, t0);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        if (dirty & /*componentData*/
        32 && switch_value !== (switch_value = /*componentData*/
        ctx2[5].componentType)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, div0, null);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*componentData*/
          32 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
            /*componentData*/
            ctx2[5].props
          )]) : {};
          switch_instance.$set(switch_instance_changes);
        }
        if (!current || dirty & /*contentPadding*/
        256) {
          toggle_class(
            div0,
            "padding",
            /*contentPadding*/
            ctx2[8] !== false
          );
        }
        if (
          /*closeStrategy*/
          ctx2[0] === "explicit"
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
          } else {
            if_block1 = create_if_block$C(ctx2);
            if_block1.c();
            if_block1.m(div1, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
        if (!current || dirty & /*areaName*/
        16) {
          set_style(
            div1,
            "grid-area",
            /*areaName*/
            ctx2[4]
          );
        }
        if (!current || dirty & /*marginY, marginX*/
        12) {
          set_style(
            div1,
            "margin",
            /*marginY*/
            ctx2[2] + " " + /*marginX*/
            ctx2[3]
          );
        }
        if (!current || dirty & /*closing*/
        2048) {
          toggle_class(
            div1,
            "closing",
            /*closing*/
            ctx2[11]
          );
        }
        if (!current || dirty & /*alignment*/
        2) {
          toggle_class(
            div1,
            "align-top",
            /*alignment*/
            ctx2[1] === "top"
          );
        }
        if (!current || dirty & /*alignment*/
        2) {
          toggle_class(
            div1,
            "align-bottom",
            /*alignment*/
            ctx2[1] === "bottom"
          );
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if (if_block0) if_block0.d();
        if (switch_instance) destroy_component(switch_instance);
        if (if_block1) if_block1.d();
        ctx[18](null);
      }
    };
  }
  __name(create_fragment$1r, "create_fragment$1r");
  function instance$1i($$self, $$props, $$invalidate) {
    let { closeStrategy = "implicit" } = $$props;
    let { alignment = "bottom" } = $$props;
    let { marginY = ".5em" } = $$props;
    let { marginX = "1em" } = $$props;
    let { areaName } = $$props;
    let { maxHeight = void 0 } = $$props;
    let { maxWidth = void 0 } = $$props;
    let { componentData } = $$props;
    let { title = void 0 } = $$props;
    let { iconName = void 0 } = $$props;
    let { contentPadding = void 0 } = $$props;
    const clickedOutside = new Subject$1();
    const closed$ = clickedOutside.asObservable();
    let self2;
    let closing = false;
    const clickListener = /* @__PURE__ */ __name((event) => {
      if (!self2 || closeStrategy !== "implicit") return;
      const target = event.target;
      if (!(self2 === target) && !self2.contains(target)) {
        close();
      }
    }, "clickListener");
    const close = /* @__PURE__ */ __name(() => {
      $$invalidate(11, closing = true);
      setTimeout(
        () => {
          clickedOutside.next();
        },
        80
      );
    }, "close");
    onDestroy(() => {
      document.removeEventListener("click", clickListener);
      clickedOutside.complete();
    });
    onMount(() => {
      setTimeout(() => document.addEventListener("click", clickListener), 1);
    });
    const getMaxHeightCss = /* @__PURE__ */ __name(() => {
      return maxHeight ? `calc(${maxHeight} - (2 * ${marginY}))` : "auto";
    }, "getMaxHeightCss");
    const getMaxWidthCss = /* @__PURE__ */ __name(() => {
      return maxWidth ? `calc(${maxWidth} - (2 * ${marginX}))` : "auto";
    }, "getMaxWidthCss");
    const click_handler2 = /* @__PURE__ */ __name(() => close(), "click_handler");
    function div1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        self2 = $$value;
        $$invalidate(10, self2);
      });
    }
    __name(div1_binding, "div1_binding");
    $$self.$$set = ($$props2) => {
      if ("closeStrategy" in $$props2) $$invalidate(0, closeStrategy = $$props2.closeStrategy);
      if ("alignment" in $$props2) $$invalidate(1, alignment = $$props2.alignment);
      if ("marginY" in $$props2) $$invalidate(2, marginY = $$props2.marginY);
      if ("marginX" in $$props2) $$invalidate(3, marginX = $$props2.marginX);
      if ("areaName" in $$props2) $$invalidate(4, areaName = $$props2.areaName);
      if ("maxHeight" in $$props2) $$invalidate(14, maxHeight = $$props2.maxHeight);
      if ("maxWidth" in $$props2) $$invalidate(15, maxWidth = $$props2.maxWidth);
      if ("componentData" in $$props2) $$invalidate(5, componentData = $$props2.componentData);
      if ("title" in $$props2) $$invalidate(6, title = $$props2.title);
      if ("iconName" in $$props2) $$invalidate(7, iconName = $$props2.iconName);
      if ("contentPadding" in $$props2) $$invalidate(8, contentPadding = $$props2.contentPadding);
    };
    return [
      closeStrategy,
      alignment,
      marginY,
      marginX,
      areaName,
      componentData,
      title,
      iconName,
      contentPadding,
      close,
      self2,
      closing,
      getMaxHeightCss,
      getMaxWidthCss,
      maxHeight,
      maxWidth,
      closed$,
      click_handler2,
      div1_binding
    ];
  }
  __name(instance$1i, "instance$1i");
  const _Area_flyout = class _Area_flyout extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1i, create_fragment$1r, safe_not_equal, {
        closeStrategy: 0,
        alignment: 1,
        marginY: 2,
        marginX: 3,
        areaName: 4,
        maxHeight: 14,
        maxWidth: 15,
        componentData: 5,
        title: 6,
        iconName: 7,
        contentPadding: 8,
        closed$: 16,
        close: 9
      });
    }
    get closed$() {
      return this.$$.ctx[16];
    }
    get close() {
      return this.$$.ctx[9];
    }
  };
  __name(_Area_flyout, "Area_flyout");
  let Area_flyout = _Area_flyout;
  function get_each_context$x(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[5] = list[i];
    return child_ctx;
  }
  __name(get_each_context$x, "get_each_context$x");
  function get_each_context_1$c(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[5] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1$c, "get_each_context_1$c");
  function get_each_context_2$5(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[11] = list[i];
    return child_ctx;
  }
  __name(get_each_context_2$5, "get_each_context_2$5");
  function create_if_block_1$i(ctx) {
    let div3;
    let div1;
    let div0;
    let t0;
    let promise;
    let t1;
    let t2;
    let div2;
    let show_if;
    let t3;
    let info = {
      ctx,
      current: null,
      token: null,
      hasCatch: false,
      pending: create_pending_block_1,
      then: create_then_block_1,
      catch: create_catch_block_1,
      value: 8
    };
    handle_promise(promise = firstValueFrom(
      /*result*/
      ctx[5].context.command.idSetting.changes$
    ), info);
    let each_value_2 = ensure_array_like(
      /*result*/
      ctx[5].context.parameters
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_2.length; i += 1) {
      each_blocks[i] = create_each_block_2$5(get_each_context_2$5(ctx, each_value_2, i));
    }
    function select_block_type(ctx2, dirty) {
      if (dirty & /*feature, $currentCommands*/
      3) show_if = null;
      if (
        /*result*/
        ctx2[5].context.currentInterpretedParameter === void 0
      ) return create_if_block_4$9;
      if (show_if == null) show_if = !!!/*feature*/
      ctx2[0].otherHasExecutionTarget(
        /*result*/
        ctx2[5],
        /*$currentCommands*/
        ctx2[1]
      );
      if (show_if) return create_if_block_5$5;
    }
    __name(select_block_type, "select_block_type");
    let current_block_type = select_block_type(ctx, -1);
    let if_block0 = current_block_type && current_block_type(ctx);
    let if_block1 = !/*result*/
    (ctx[5].result instanceof InterpretableCommandPartialMatch) && create_if_block_2$e(ctx);
    return {
      c() {
        div3 = element("div");
        div1 = element("div");
        div0 = element("div");
        t0 = text("/\n            ");
        info.block.c();
        t1 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t2 = space();
        div2 = element("div");
        if (if_block0) if_block0.c();
        t3 = space();
        if (if_block1) if_block1.c();
        attr(div0, "class", "typo-command-result-id svelte-19nsl5m");
        toggle_class(
          div0,
          "current",
          /*feature*/
          ctx[0].isActiveTypingId(
            /*result*/
            ctx[5]
          )
        );
        attr(div1, "class", "typo-command-result-synopsis svelte-19nsl5m");
        attr(div2, "class", "typo-command-result-description");
        attr(div3, "class", "typo-command-result svelte-19nsl5m");
      },
      m(target, anchor) {
        insert(target, div3, anchor);
        append(div3, div1);
        append(div1, div0);
        append(div0, t0);
        info.block.m(div0, info.anchor = null);
        info.mount = () => div0;
        info.anchor = null;
        append(div1, t1);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div1, null);
          }
        }
        append(div3, t2);
        append(div3, div2);
        if (if_block0) if_block0.m(div2, null);
        append(div3, t3);
        if (if_block1) if_block1.m(div3, null);
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        info.ctx = ctx;
        if (dirty & /*$currentCommands*/
        2 && promise !== (promise = firstValueFrom(
          /*result*/
          ctx[5].context.command.idSetting.changes$
        )) && handle_promise(promise, info)) ;
        else {
          update_await_block_branch(info, ctx, dirty);
        }
        if (dirty & /*feature, $currentCommands*/
        3) {
          toggle_class(
            div0,
            "current",
            /*feature*/
            ctx[0].isActiveTypingId(
              /*result*/
              ctx[5]
            )
          );
        }
        if (dirty & /*feature, $currentCommands*/
        3) {
          each_value_2 = ensure_array_like(
            /*result*/
            ctx[5].context.parameters
          );
          let i;
          for (i = 0; i < each_value_2.length; i += 1) {
            const child_ctx = get_each_context_2$5(ctx, each_value_2, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_2$5(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div1, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_2.length;
        }
        if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if (if_block0) if_block0.d(1);
          if_block0 = current_block_type && current_block_type(ctx);
          if (if_block0) {
            if_block0.c();
            if_block0.m(div2, null);
          }
        }
        if (!/*result*/
        (ctx[5].result instanceof InterpretableCommandPartialMatch)) {
          if (if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1 = create_if_block_2$e(ctx);
            if_block1.c();
            if_block1.m(div3, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div3);
        }
        info.block.d();
        info.token = null;
        info = null;
        destroy_each(each_blocks, detaching);
        if (if_block0) {
          if_block0.d();
        }
        if (if_block1) if_block1.d();
      }
    };
  }
  __name(create_if_block_1$i, "create_if_block_1$i");
  function create_catch_block_1(ctx) {
    return { c: noop, m: noop, p: noop, d: noop };
  }
  __name(create_catch_block_1, "create_catch_block_1");
  function create_then_block_1(ctx) {
    let t_value = (
      /*res*/
      ctx[8] + ""
    );
    let t;
    return {
      c() {
        t = text(t_value);
      },
      m(target, anchor) {
        insert(target, t, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*$currentCommands*/
        2 && t_value !== (t_value = /*res*/
        ctx2[8] + "")) set_data(t, t_value);
      },
      d(detaching) {
        if (detaching) {
          detach(t);
        }
      }
    };
  }
  __name(create_then_block_1, "create_then_block_1");
  function create_pending_block_1(ctx) {
    return { c: noop, m: noop, p: noop, d: noop };
  }
  __name(create_pending_block_1, "create_pending_block_1");
  function create_each_block_2$5(ctx) {
    let div;
    let t0_value = (
      /*param*/
      ctx[11].typeName + ""
    );
    let t0;
    let t1;
    return {
      c() {
        div = element("div");
        t0 = text(t0_value);
        t1 = space();
        attr(div, "class", "typo-command-result-arg svelte-19nsl5m");
        toggle_class(
          div,
          "current",
          /*feature*/
          ctx[0].isActiveTypingParam(
            /*result*/
            ctx[5],
            /*param*/
            ctx[11]
          )
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, t0);
        append(div, t1);
      },
      p(ctx2, dirty) {
        if (dirty & /*$currentCommands*/
        2 && t0_value !== (t0_value = /*param*/
        ctx2[11].typeName + "")) set_data(t0, t0_value);
        if (dirty & /*feature, $currentCommands*/
        3) {
          toggle_class(
            div,
            "current",
            /*feature*/
            ctx2[0].isActiveTypingParam(
              /*result*/
              ctx2[5],
              /*param*/
              ctx2[11]
            )
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_each_block_2$5, "create_each_block_2$5");
  function create_if_block_5$5(ctx) {
    let b0;
    let t0_value = (
      /*result*/
      ctx[5].context.currentInterpretedParameter.name + ""
    );
    let t0;
    let t1;
    let t2;
    let t3_value = (
      /*result*/
      ctx[5].context.currentInterpretedParameter.description + ""
    );
    let t3;
    let br;
    let t4;
    let span;
    let b1;
    let t6_value = (
      /*result*/
      ctx[5].context.currentInterpretedParameter.typeDescription + ""
    );
    let t6;
    return {
      c() {
        b0 = element("b");
        t0 = text(t0_value);
        t1 = text(":");
        t2 = space();
        t3 = text(t3_value);
        br = element("br");
        t4 = space();
        span = element("span");
        b1 = element("b");
        b1.textContent = "Content: ";
        t6 = text(t6_value);
        attr(span, "class", "typo-command-result-param-type svelte-19nsl5m");
      },
      m(target, anchor) {
        insert(target, b0, anchor);
        append(b0, t0);
        append(b0, t1);
        insert(target, t2, anchor);
        insert(target, t3, anchor);
        insert(target, br, anchor);
        insert(target, t4, anchor);
        insert(target, span, anchor);
        append(span, b1);
        append(span, t6);
      },
      p(ctx2, dirty) {
        if (dirty & /*$currentCommands*/
        2 && t0_value !== (t0_value = /*result*/
        ctx2[5].context.currentInterpretedParameter.name + "")) set_data(t0, t0_value);
        if (dirty & /*$currentCommands*/
        2 && t3_value !== (t3_value = /*result*/
        ctx2[5].context.currentInterpretedParameter.description + "")) set_data(t3, t3_value);
        if (dirty & /*$currentCommands*/
        2 && t6_value !== (t6_value = /*result*/
        ctx2[5].context.currentInterpretedParameter.typeDescription + "")) set_data(t6, t6_value);
      },
      d(detaching) {
        if (detaching) {
          detach(b0);
          detach(t2);
          detach(t3);
          detach(br);
          detach(t4);
          detach(span);
        }
      }
    };
  }
  __name(create_if_block_5$5, "create_if_block_5$5");
  function create_if_block_4$9(ctx) {
    let t_value = (
      /*result*/
      ctx[5].context.command.description + ""
    );
    let t;
    return {
      c() {
        t = text(t_value);
      },
      m(target, anchor) {
        insert(target, t, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*$currentCommands*/
        2 && t_value !== (t_value = /*result*/
        ctx2[5].context.command.description + "")) set_data(t, t_value);
      },
      d(detaching) {
        if (detaching) {
          detach(t);
        }
      }
    };
  }
  __name(create_if_block_4$9, "create_if_block_4$9");
  function create_if_block_2$e(ctx) {
    let div;
    let show_if;
    function select_block_type_1(ctx2, dirty) {
      if (dirty & /*feature, $currentCommands*/
      3) show_if = null;
      if (show_if == null) show_if = !!/*feature*/
      ctx2[0].otherHasExecutionTarget(
        /*result*/
        ctx2[5],
        /*$currentCommands*/
        ctx2[1]
      );
      if (show_if) return create_if_block_3$9;
      return create_else_block$k;
    }
    __name(select_block_type_1, "select_block_type_1");
    let current_block_type = select_block_type_1(ctx, -1);
    let if_block = current_block_type(ctx);
    return {
      c() {
        div = element("div");
        if_block.c();
        attr(div, "class", "typo-command-result-state svelte-19nsl5m");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_block.m(div, null);
      },
      p(ctx2, dirty) {
        if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(div, null);
          }
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if_block.d();
      }
    };
  }
  __name(create_if_block_2$e, "create_if_block_2$e");
  function create_else_block$k(ctx) {
    let img;
    let img_src_value;
    let t0;
    let span;
    let t1_value = (
      /*feature*/
      ctx[0].getResultStateMessage(
        /*result*/
        ctx[5],
        /*$combo*/
        ctx[2]
      ) + ""
    );
    let t1;
    return {
      c() {
        img = element("img");
        t0 = space();
        span = element("span");
        t1 = text(t1_value);
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        attr(img, "alt", "icon");
        set_style(img, "content", "var(--" + /*feature*/
        (ctx[0].isValidCommand(
          /*result*/
          ctx[5]
        ) ? "file-img-enabled-gif" : "file-img-disabled-gif") + ")");
        attr(img, "class", "svelte-19nsl5m");
      },
      m(target, anchor) {
        insert(target, img, anchor);
        insert(target, t0, anchor);
        insert(target, span, anchor);
        append(span, t1);
      },
      p(ctx2, dirty) {
        if (dirty & /*feature, $currentCommands*/
        3) {
          set_style(img, "content", "var(--" + /*feature*/
          (ctx2[0].isValidCommand(
            /*result*/
            ctx2[5]
          ) ? "file-img-enabled-gif" : "file-img-disabled-gif") + ")");
        }
        if (dirty & /*feature, $currentCommands, $combo*/
        7 && t1_value !== (t1_value = /*feature*/
        ctx2[0].getResultStateMessage(
          /*result*/
          ctx2[5],
          /*$combo*/
          ctx2[2]
        ) + "")) set_data(t1, t1_value);
      },
      d(detaching) {
        if (detaching) {
          detach(img);
          detach(t0);
          detach(span);
        }
      }
    };
  }
  __name(create_else_block$k, "create_else_block$k");
  function create_if_block_3$9(ctx) {
    let span;
    return {
      c() {
        span = element("span");
        span.textContent = "Another command is prioritized";
      },
      m(target, anchor) {
        insert(target, span, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  __name(create_if_block_3$9, "create_if_block_3$9");
  function create_each_block_1$c(ctx) {
    let if_block_anchor;
    let if_block = (
      /*result*/
      ctx[5].result !== null && create_if_block_1$i(ctx)
    );
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (
          /*result*/
          ctx2[5].result !== null
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block_1$i(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
      }
    };
  }
  __name(create_each_block_1$c, "create_each_block_1$c");
  function create_if_block$B(ctx) {
    let div;
    let t1;
    let each_1_anchor;
    let each_value = ensure_array_like(
      /*$currentCommands*/
      ctx[1]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$x(get_each_context$x(ctx, each_value, i));
    }
    return {
      c() {
        div = element("div");
        div.textContent = "Type a command id..";
        t1 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        insert(target, div, anchor);
        insert(target, t1, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*$currentCommands*/
        2) {
          each_value = ensure_array_like(
            /*$currentCommands*/
            ctx2[1]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$x(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$x(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
          detach(t1);
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_if_block$B, "create_if_block$B");
  function create_catch_block$5(ctx) {
    return { c: noop, m: noop, p: noop, d: noop };
  }
  __name(create_catch_block$5, "create_catch_block$5");
  function create_then_block$5(ctx) {
    let t_value = (
      /*res*/
      ctx[8] + ""
    );
    let t;
    return {
      c() {
        t = text(t_value);
      },
      m(target, anchor) {
        insert(target, t, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*$currentCommands*/
        2 && t_value !== (t_value = /*res*/
        ctx2[8] + "")) set_data(t, t_value);
      },
      d(detaching) {
        if (detaching) {
          detach(t);
        }
      }
    };
  }
  __name(create_then_block$5, "create_then_block$5");
  function create_pending_block$5(ctx) {
    return { c: noop, m: noop, p: noop, d: noop };
  }
  __name(create_pending_block$5, "create_pending_block$5");
  function create_each_block$x(ctx) {
    let b;
    let t0;
    let promise;
    let t1;
    let info = {
      ctx,
      current: null,
      token: null,
      hasCatch: false,
      pending: create_pending_block$5,
      then: create_then_block$5,
      catch: create_catch_block$5,
      value: 8
    };
    handle_promise(promise = firstValueFrom(
      /*result*/
      ctx[5].context.command.idSetting.changes$
    ), info);
    return {
      c() {
        b = element("b");
        t0 = text("/\n        ");
        info.block.c();
        t1 = space();
      },
      m(target, anchor) {
        insert(target, b, anchor);
        append(b, t0);
        info.block.m(b, info.anchor = null);
        info.mount = () => b;
        info.anchor = t1;
        append(b, t1);
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        info.ctx = ctx;
        if (dirty & /*$currentCommands*/
        2 && promise !== (promise = firstValueFrom(
          /*result*/
          ctx[5].context.command.idSetting.changes$
        )) && handle_promise(promise, info)) ;
        else {
          update_await_block_branch(info, ctx, dirty);
        }
      },
      d(detaching) {
        if (detaching) {
          detach(b);
        }
        info.block.d();
        info.token = null;
        info = null;
      }
    };
  }
  __name(create_each_block$x, "create_each_block$x");
  function create_fragment$1q(ctx) {
    let div;
    let t;
    let show_if = (
      /*$currentCommands*/
      ctx[1].every(func$4)
    );
    let each_value_1 = ensure_array_like(
      /*$currentCommands*/
      ctx[1]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1$c(get_each_context_1$c(ctx, each_value_1, i));
    }
    let if_block = show_if && create_if_block$B(ctx);
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t = space();
        if (if_block) if_block.c();
        attr(div, "class", "typo-command-preview svelte-19nsl5m");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
        append(div, t);
        if (if_block) if_block.m(div, null);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*feature, $currentCommands, $combo, undefined*/
        7) {
          each_value_1 = ensure_array_like(
            /*$currentCommands*/
            ctx2[1]
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$c(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_1$c(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div, t);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_1.length;
        }
        if (dirty & /*$currentCommands*/
        2) show_if = /*$currentCommands*/
        ctx2[1].every(func$4);
        if (show_if) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$B(ctx2);
            if_block.c();
            if_block.m(div, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_each(each_blocks, detaching);
        if (if_block) if_block.d();
      }
    };
  }
  __name(create_fragment$1q, "create_fragment$1q");
  const func$4 = /* @__PURE__ */ __name((result) => result.result === null, "func$4");
  function instance$1h($$self, $$props, $$invalidate) {
    let $currentCommands;
    let $combo;
    let { feature } = $$props;
    const currentCommands = feature.commandResultStore;
    component_subscribe($$self, currentCommands, (value) => $$invalidate(1, $currentCommands = value));
    const combo = feature.submitHotkeyStore;
    component_subscribe($$self, combo, (value) => $$invalidate(2, $combo = value));
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [feature, $currentCommands, $combo, currentCommands, combo];
  }
  __name(instance$1h, "instance$1h");
  const _Command_preview = class _Command_preview extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1h, create_fragment$1q, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Command_preview, "Command_preview");
  let Command_preview = _Command_preview;
  function create_fragment$1p(ctx) {
    let input;
    let mounted;
    let dispose;
    return {
      c() {
        input = element("input");
        attr(input, "id", "typo-command-input");
        input.autofocus = true;
        attr(input, "type", "text");
        input.value = "/";
        attr(input, "placeholder", "Type your command here..");
      },
      m(target, anchor) {
        insert(target, input, anchor);
        input.focus();
        if (!mounted) {
          dispose = [
            listen(
              input,
              "input",
              /*input_handler*/
              ctx[1]
            ),
            listen(input, "submit", submit_handler)
          ];
          mounted = true;
        }
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(input);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$1p, "create_fragment$1p");
  const submit_handler = /* @__PURE__ */ __name((e) => {
    e.preventDefault();
    e.stopImmediatePropagation();
  }, "submit_handler");
  function instance$1g($$self, $$props, $$invalidate) {
    let { onInput } = $$props;
    const input_handler = /* @__PURE__ */ __name((e) => {
      onInput(e.currentTarget.value);
    }, "input_handler");
    $$self.$$set = ($$props2) => {
      if ("onInput" in $$props2) $$invalidate(0, onInput = $$props2.onInput);
    };
    return [onInput, input_handler];
  }
  __name(instance$1g, "instance$1g");
  const _Command_input = class _Command_input extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1g, create_fragment$1p, safe_not_equal, { onInput: 0 });
    }
  };
  __name(_Command_input, "Command_input");
  let Command_input = _Command_input;
  var __defProp$18 = Object.defineProperty;
  var __decorateClass$18 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$18(target, key2, result);
    return result;
  }, "__decorateClass$18");
  const _ChatCommandsFeature = class _ChatCommandsFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elements");
      __publicField(this, "_toastService");
      __publicField(this, "name", "Chat Commands");
      __publicField(this, "description", "Execute actions of other features with chat commands");
      __publicField(this, "tags", [
        FeatureTag.GAMEPLAY
      ]);
      __publicField(this, "featureId", 38);
      __publicField(this, "_interpreterSubscription");
      __publicField(this, "_submitSubscription");
      __publicField(this, "_commandArgs$", new Subject$1());
      __publicField(this, "_hotkeySubmitted$", new Subject$1());
      __publicField(this, "_commandResults$", new Subject$1());
      __publicField(this, "_flyoutComponent");
      __publicField(this, "_flyoutSubscription");
      __publicField(this, "_commandInput");
      __publicField(this, "_inputChangeListener", this.handleInputEvent.bind(this));
      __publicField(this, "_submitCommandHotkey", this.useHotkey(
        new HotkeyAction(
          "submit_command",
          "Submit Command",
          "When pressed, the currently typed command will be submitted",
          this,
          async () => {
            if (!this._flyoutComponent) return;
            const elements2 = await this._elements.complete();
            elements2.chatInput.value = "";
            this._hotkeySubmitted$.next(void 0);
          },
          true,
          ["Enter"],
          void 0,
          false
        )
      ));
      __publicField(this, "_customPrefixSetting", this.useSetting(
        new TextExtensionSetting("custom_prefix", "", this).withName("Custom Command Prefix").withDescription("Set a custom prefix for chat commands that will trigger the command prompt, additionally to ' / '")
      ));
      __publicField(this, "_muteResultsSetting", this.useSetting(
        new BooleanExtensionSetting("mute_results", false, this).withName("Mute Command Results").withDescription("Don't show a toast message with the command result when a command has been executed")
      ));
      __publicField(this, "_echoCommand", this.useCommand(
        new ExtensionCommand("echo", this, "Echo", "Echo a text :)")
      ).withParameters(
        (params) => params.addParam(new StringCommandParameter("text", "The text to echo", (text2) => ({ text: text2 }))).run(async ({ text: text2 }, command) => {
          return new InterpretableSuccess(command, text2);
        })
      ));
    }
    async onActivate() {
      const elements2 = await this._elements.complete();
      elements2.chatInput.addEventListener("input", this._inputChangeListener);
      this._interpreterSubscription = this._commandArgs$.pipe(
        withLatestFrom(this._commandsService.commands$),
        switchMap(async ([args, commands]) => {
          var _a2;
          if (args.startsWith("/")) {
            args = args.substring(1);
            return Promise.all(
              commands.map(async (command) => this._commandsService.executeCommand(command, args))
            );
          } else {
            (_a2 = this._commandInput) == null ? void 0 : _a2.$destroy();
            this._commandInput = void 0;
            elements2.chatInput.focus();
            return [];
          }
        })
      ).subscribe((results) => {
        this._logger.debug("Command results changed", results);
        this.setFlyoutState(results.length > 0, elements2);
        const sorted = [...results].sort((a, b) => {
          const aIsSuccess = a.result instanceof InterpretableSuccess;
          const bIsSuccess = b.result instanceof InterpretableSuccess;
          if (aIsSuccess === bIsSuccess) return 0;
          return aIsSuccess ? -1 : 1;
        });
        this._commandResults$.next(sorted);
      });
      this._submitSubscription = this._hotkeySubmitted$.pipe(
        withLatestFrom(this._commandResults$, this._commandArgs$, this._muteResultsSetting.changes$),
        filter(([, , args]) => args.startsWith("/"))
      ).subscribe(async ([, results, , silent]) => this.commandSubmitted(results, silent));
    }
    async onDestroy() {
      var _a2, _b2, _c2;
      const elements2 = await this._elements.complete();
      elements2.chatInput.removeEventListener("input", this._inputChangeListener);
      (_a2 = this._interpreterSubscription) == null ? void 0 : _a2.unsubscribe();
      this._interpreterSubscription = void 0;
      (_b2 = this._submitSubscription) == null ? void 0 : _b2.unsubscribe();
      this._submitSubscription = void 0;
      (_c2 = this._commandInput) == null ? void 0 : _c2.$destroy();
      this._commandInput = void 0;
      this.setFlyoutState(false, elements2);
    }
    get commandResultStore() {
      return fromObservable(this._commandResults$, []);
    }
    get submitHotkeyStore() {
      return this._submitCommandHotkey.comboSetting.store;
    }
    /**
     * chat received input
     * check if starts with / and show command input instead
     */
    async handleInputEvent(event) {
      const target = event.currentTarget;
      const customPrefix = await this._customPrefixSetting.getValue();
      if (target !== null && (target.value === "/" || customPrefix !== "" && target.value === customPrefix)) {
        await this.switchToCommandMode();
      }
    }
    /**
     * Hide the original chat input and open the command input
     * @private
     */
    async switchToCommandMode() {
      const elements2 = await this._elements.complete();
      elements2.chatInput.value = "";
      elements2.chatInput.dispatchEvent(new Event("input"));
      if (!this._commandInput) {
        this._commandInput = new Command_input({
          target: elements2.chatForm,
          props: {
            onInput: /* @__PURE__ */ __name((args) => this._commandArgs$.next(args), "onInput")
          }
        });
        this._commandArgs$.next("/");
      }
    }
    /**
     * Callback when the command submit hotkey has been pressed
     * Check interpretation results and run valid command
     * @param interpretationResults
     */
    async commandSubmitted(interpretationResults, silent) {
      var _a2;
      this._logger.info("Commands submitted", interpretationResults);
      (_a2 = this._commandInput) == null ? void 0 : _a2.$destroy();
      this._commandArgs$.next("");
      const match = interpretationResults.find((result) => result.result instanceof InterpretableSuccess);
      if (match !== void 0 && match.result instanceof InterpretableSuccess) {
        if (match.result instanceof InterpretableDeferResult) {
          const toast = silent ? void 0 : await this._toastService.showLoadingToast(`Command: ${match.context.command.name}`);
          const result = await match.result.run();
          if (!(result instanceof InterpretableSilentSuccess)) toast == null ? void 0 : toast.resolve(result.message);
          else toast == null ? void 0 : toast.close();
        } else {
          if (match.result.message && !silent) await this._toastService.showToast(`${match.result.message}`);
          else if (!(match.result instanceof InterpretableSilentSuccess) && !silent) await this._toastService.showToast(`${match.context.command.name}`);
        }
      } else {
        await this._toastService.showToast("No valid command entered");
      }
    }
    /**
     * Create or destroy the command preview flyout
     * @param state
     * @param elements
     */
    setFlyoutState(state, elements2) {
      if (state && this._flyoutComponent === void 0) {
        const flyoutContent = {
          componentType: Command_preview,
          props: {
            feature: this
          }
        };
        this._flyoutComponent = new Area_flyout({
          target: elements2.gameWrapper,
          props: {
            componentData: flyoutContent,
            areaName: "chat",
            maxHeight: "600px",
            maxWidth: "300px",
            marginY: "2.5rem",
            title: "Command Preview",
            closeStrategy: "implicit"
          }
        });
        this._flyoutSubscription = this._flyoutComponent.closed$.subscribe(() => {
          var _a2, _b2;
          this._logger.info("Destroyed flyout");
          (_a2 = this._flyoutComponent) == null ? void 0 : _a2.$destroy();
          (_b2 = this._flyoutSubscription) == null ? void 0 : _b2.unsubscribe();
          this._flyoutComponent = void 0;
        });
      } else if (this._flyoutComponent !== void 0 && !state) {
        this._flyoutComponent.close();
      }
    }
    /**
     * Check if the parameter is currently interpreting the user input
     * @param result
     * @param param
     */
    isActiveTypingParam(result, param) {
      this._logger.debug("Checking if param is active", result, param);
      return result.context.currentInterpretedParameter === param;
    }
    /**
     * Check if the command (name) is currently interpreting the user input
     * @param result
     */
    isActiveTypingId(result) {
      return result.result === void 0;
    }
    /**
     * Check if the command is currently interpreting
     * @param result
     */
    isValidCommand(result) {
      return result.result instanceof InterpretableSuccess;
    }
    /**
     * Check if there are other commands that are the current execution target
     * @param result
     * @param commands
     */
    otherHasExecutionTarget(result, commands) {
      const successes = commands.filter((command) => command.result instanceof InterpretableSuccess);
      return successes.length == 0 || successes[0] !== result;
    }
    /**
     * Get a human readable status message of a command interpretation context
     * @param result
     * @param hotkeys
     */
    getResultStateMessage(result, hotkeys) {
      if (result.result instanceof InterpretableSuccess) {
        return `Press ${hotkeys.join(" + ")} to submit`;
      }
      if (result.result instanceof InterpretableArgumentParsingError) {
        return "The current argument is invalid";
      }
      if (result.result instanceof InterpretableCommandPartialMatch) {
        return "The command id is incomplete";
      }
      if (result.result instanceof InterpretableEmptyRemainder) {
        return "Some arguments are missing";
      }
      if (result.result instanceof InterpretableError) {
        return result.result.message;
      }
    }
  };
  __name(_ChatCommandsFeature, "ChatCommandsFeature");
  let ChatCommandsFeature = _ChatCommandsFeature;
  __decorateClass$18([
    inject(ElementsSetup)
  ], ChatCommandsFeature.prototype, "_elements");
  __decorateClass$18([
    inject(ToastService)
  ], ChatCommandsFeature.prototype, "_toastService");
  var __defProp$17 = Object.defineProperty;
  var __decorateClass$17 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$17(target, key2, result);
    return result;
  }, "__decorateClass$17");
  const _ChatCopyFormattedFeature = class _ChatCopyFormattedFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_toastService");
      __publicField(this, "_iconElement");
      __publicField(this, "name", "Copy Chat Formatted");
      __publicField(this, "description", "Enables to copy selected chat messages formatted for discord messages");
      __publicField(this, "tags", [
        FeatureTag.INTERFACE
      ]);
      __publicField(this, "featureId", 36);
      __publicField(this, "selectedText$", new BehaviorSubject(null));
      /* current chat message selection */
      __publicField(this, "_selectionChangeListener", this.onSelectionChange.bind(this));
      /* bind listener for context, needed to make unsubscription possible */
      __publicField(this, "_selectedTextSubscription");
      __publicField(this, "_iconClickSubscription");
    }
    async onActivate() {
      document.addEventListener("selectionchange", this._selectionChangeListener);
      this._selectedTextSubscription = this.selectedText$.pipe(
        distinctUntilChanged()
      ).subscribe((text2) => {
        this.processChangedChatSelection(text2);
      });
    }
    onDestroy() {
      var _a2, _b2, _c2;
      document.removeEventListener("selectionchange", this._selectionChangeListener);
      (_a2 = this._selectedTextSubscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._iconClickSubscription) == null ? void 0 : _b2.unsubscribe();
      this._iconClickSubscription = void 0;
      (_c2 = this._iconElement) == null ? void 0 : _c2.$destroy();
      this._iconElement = void 0;
    }
    /**
     * Callback for DOM selection change event
     * @private
     */
    async onSelectionChange() {
      this._logger.debug("Selection changed");
      const elements2 = await this._elementsSetup.complete();
      const selection = document.getSelection();
      if (!selection || selection.rangeCount === 0) {
        this.selectedText$.next(null);
        return;
      }
      const range = selection.getRangeAt(0);
      if (range.commonAncestorContainer instanceof HTMLElement && range.commonAncestorContainer === elements2.chatContent) {
        let start = range.startContainer.nodeName === "#text" ? range.startContainer.parentElement : range.startContainer;
        let end = range.endContainer.nodeName === "#text" ? range.endContainer.parentElement : range.endContainer;
        if (!(end instanceof HTMLElement && start instanceof HTMLElement)) {
          this._logger.warn("Could not find start or end element", start, end);
          this.selectedText$.next(null);
          return;
        }
        start = start.closest("p");
        end = end.closest("p");
        if (!(start instanceof HTMLElement && end instanceof HTMLElement)) {
          this._logger.warn("Could not find start or end paragraph", start, end);
          this.selectedText$.next(null);
          return;
        }
        const ps = [...document.querySelectorAll(".chat-content p")];
        const elems = ps.slice(ps.indexOf(start), ps.indexOf(end) + 1);
        console.log(elems.length);
        const text2 = elems.map((e) => e.textContent).join("\n");
        this.selectedText$.next(text2);
      } else this.selectedText$.next(null);
    }
    async processChangedChatSelection(text2) {
      var _a2, _b2;
      this._logger.info("Selected text changed", text2);
      const elements2 = await this._elementsSetup.complete();
      if (this._iconElement && text2 === null) {
        (_a2 = this._iconElement) == null ? void 0 : _a2.$destroy();
        this._iconElement = void 0;
        (_b2 = this._iconClickSubscription) == null ? void 0 : _b2.unsubscribe();
        this._iconClickSubscription = void 0;
      }
      if (text2 !== null && !this._iconElement) {
        this._iconElement = new Icon_button({
          target: elements2.chatControls,
          props: {
            icon: "file-img-discord-gif",
            name: "Copy Chat for Discord",
            order: 3,
            size: "2rem",
            hoverMove: false,
            greyscaleInactive: true,
            tooltipAction: this.createTooltip
          }
        });
        this._iconClickSubscription = this._iconElement.click$.subscribe(async () => {
          var _a3;
          const currentText = this.selectedText$.value;
          if (currentText === null) {
            this._logger.warn("No text selected, but copy button clicked - illegal state");
            return;
          }
          const formatted = this.formatChatForDiscord(currentText);
          this._logger.info("Copy button clicked for selection", formatted);
          await navigator.clipboard.writeText(formatted);
          await this._toastService.showToast("Chat copied to clipboard");
          (_a3 = document.getSelection()) == null ? void 0 : _a3.removeAllRanges();
        });
      }
    }
    /**
     * Create discord code block from text
     * @param text
     * @private
     */
    formatChatForDiscord(text2) {
      const chat = text2.replace(/(\n)(?=.*? guessed the word!)/g, "\n+ ").replace(/(\n)(?=.*? joined.)/g, "\n+ ").replace(/(\n)(?=The word was)/g, "\n+ ").replace(/(\n)(?=.*? is drawing now!)/g, "\n+ ").replace(/(\n)(?=.*? is now the room owner!)/g, "\n+ ").replace(/(\n)(?=.*? left.)/g, "\n- ").replace(/(\n)(?=.*? is voting to kick.)/g, "\n- ").replace(/(\n)(?=.*? was kicked.)/g, "\n- ").replace(/(\n)(?=Whoops.*? caught the drop before you.)/g, "\n--- ").replace(/(\n)(?=Yeee.*? and caught the drop!)/g, "\n--- ");
      return "```diff\n" + chat + "\n```";
    }
  };
  __name(_ChatCopyFormattedFeature, "ChatCopyFormattedFeature");
  let ChatCopyFormattedFeature = _ChatCopyFormattedFeature;
  __decorateClass$17([
    inject(ElementsSetup)
  ], ChatCopyFormattedFeature.prototype, "_elementsSetup");
  __decorateClass$17([
    inject(ToastService)
  ], ChatCopyFormattedFeature.prototype, "_toastService");
  function promiseAllObject(obj) {
    return Promise.all(
      Object.entries(obj).map(async ([k, v]) => [k, await v])
    ).then(Object.fromEntries);
  }
  __name(promiseAllObject, "promiseAllObject");
  var __defProp$16 = Object.defineProperty;
  var __decorateClass$16 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$16(target, key2, result);
    return result;
  }, "__decorateClass$16");
  function getData(spritesApi, scenesApi, eventsApi, emojisApi, announcementsApi, themesApi, awardsApi) {
    return {
      sprites: spritesApi.getAllSprites(),
      scenes: scenesApi.getAllScenes(),
      emojis: emojisApi.getAllEmojisCached({ limit: 1e5, animated: true, statics: true }),
      announcements: announcementsApi.getAnnouncements(),
      themes: themesApi.getAllThemes(),
      drops: eventsApi.getAllEventDrops(),
      awards: awardsApi.getAllAwards()
    };
  }
  __name(getData, "getData");
  const _ApiDataSetup = class _ApiDataSetup extends Setup {
    constructor() {
      super(...arguments);
      __publicField(this, "_apiService");
      __publicField(this, "_toastService");
      __publicField(this, "_loggerFactory");
    }
    async runSetup() {
      const logger = this._loggerFactory(this);
      const promise = promiseAllObject(getData(
        this._apiService.getApi(SpritesApi),
        this._apiService.getApi(ScenesApi),
        this._apiService.getApi(EventsApi),
        this._apiService.getApi(EmojisApi),
        this._apiService.getApi(AnnouncementsApi),
        this._apiService.getApi(ThemesApi),
        this._apiService.getApi(AwardsApi)
      ));
      promise.catch((e) => {
        this._toastService.showToast("Fatal error", "Failed to fetch data from the typo servers. \nPlease ask for support on the typo discord server.");
        logger.error("Failed to fetch data from the typo servers", e);
      });
      return promise;
    }
  };
  __name(_ApiDataSetup, "ApiDataSetup");
  let ApiDataSetup = _ApiDataSetup;
  __decorateClass$16([
    inject(ApiService)
  ], ApiDataSetup.prototype, "_apiService");
  __decorateClass$16([
    inject(ToastService)
  ], ApiDataSetup.prototype, "_toastService");
  __decorateClass$16([
    inject(loggerFactory)
  ], ApiDataSetup.prototype, "_loggerFactory");
  function create_fragment$1o(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        attr(div, "class", "typo-emojis-enabled");
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_fragment$1o, "create_fragment$1o");
  function instance$1f($$self) {
    return [];
  }
  __name(instance$1f, "instance$1f");
  const _Chat_emojis = class _Chat_emojis extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1f, create_fragment$1o, safe_not_equal, {});
    }
  };
  __name(_Chat_emojis, "Chat_emojis");
  let Chat_emojis = _Chat_emojis;
  function get_each_context$w(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[8] = list[i];
    return child_ctx;
  }
  __name(get_each_context$w, "get_each_context$w");
  function create_else_block$j(ctx) {
    let t;
    return {
      c() {
        t = text("Hover emojis & click to pick");
      },
      m(target, anchor) {
        insert(target, t, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(t);
        }
      }
    };
  }
  __name(create_else_block$j, "create_else_block$j");
  function create_if_block_1$h(ctx) {
    let t0;
    let t1_value = (
      /*hoverEmoji*/
      ctx[1].name + ""
    );
    let t1;
    let t2;
    return {
      c() {
        t0 = text(":");
        t1 = text(t1_value);
        t2 = text(":");
      },
      m(target, anchor) {
        insert(target, t0, anchor);
        insert(target, t1, anchor);
        insert(target, t2, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*hoverEmoji*/
        2 && t1_value !== (t1_value = /*hoverEmoji*/
        ctx2[1].name + "")) set_data(t1, t1_value);
      },
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(t1);
          detach(t2);
        }
      }
    };
  }
  __name(create_if_block_1$h, "create_if_block_1$h");
  function create_if_block$A(ctx) {
    let t0;
    let br;
    let t1;
    return {
      c() {
        t0 = text("No matching emojis.");
        br = element("br");
        t1 = text("Type something else to search again!");
      },
      m(target, anchor) {
        insert(target, t0, anchor);
        insert(target, br, anchor);
        insert(target, t1, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(br);
          detach(t1);
        }
      }
    };
  }
  __name(create_if_block$A, "create_if_block$A");
  function create_each_block$w(ctx) {
    let img;
    let img_src_value;
    let img_alt_value;
    let mounted;
    let dispose;
    function mouseenter_handler() {
      return (
        /*mouseenter_handler*/
        ctx[5](
          /*emoji*/
          ctx[8]
        )
      );
    }
    __name(mouseenter_handler, "mouseenter_handler");
    function click_handler2() {
      return (
        /*click_handler*/
        ctx[6](
          /*emoji*/
          ctx[8]
        )
      );
    }
    __name(click_handler2, "click_handler");
    return {
      c() {
        img = element("img");
        attr(img, "class", "emoji-picker-candidate svelte-198xt5o");
        if (!src_url_equal(img.src, img_src_value = /*emoji*/
        ctx[8].url)) attr(img, "src", img_src_value);
        attr(img, "alt", img_alt_value = /*emoji*/
        ctx[8].name);
      },
      m(target, anchor) {
        insert(target, img, anchor);
        if (!mounted) {
          dispose = [
            listen(img, "mouseenter", mouseenter_handler),
            listen(img, "click", click_handler2)
          ];
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*$emojiCandidates*/
        4 && !src_url_equal(img.src, img_src_value = /*emoji*/
        ctx[8].url)) {
          attr(img, "src", img_src_value);
        }
        if (dirty & /*$emojiCandidates*/
        4 && img_alt_value !== (img_alt_value = /*emoji*/
        ctx[8].name)) {
          attr(img, "alt", img_alt_value);
        }
      },
      d(detaching) {
        if (detaching) {
          detach(img);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_each_block$w, "create_each_block$w");
  function create_fragment$1n(ctx) {
    let div0;
    let t;
    let div1;
    let mounted;
    let dispose;
    function select_block_type(ctx2, dirty) {
      if (
        /*$emojiCandidates*/
        ctx2[2].length === 0
      ) return create_if_block$A;
      if (
        /*hoverEmoji*/
        ctx2[1] !== void 0
      ) return create_if_block_1$h;
      return create_else_block$j;
    }
    __name(select_block_type, "select_block_type");
    let current_block_type = select_block_type(ctx);
    let if_block = current_block_type(ctx);
    let each_value = ensure_array_like(
      /*$emojiCandidates*/
      ctx[2]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$w(get_each_context$w(ctx, each_value, i));
    }
    return {
      c() {
        div0 = element("div");
        if_block.c();
        t = space();
        div1 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div0, "class", "typo-emoji-picker-hint svelte-198xt5o");
        attr(div1, "class", "typo-command-preview svelte-198xt5o");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        if_block.m(div0, null);
        insert(target, t, anchor);
        insert(target, div1, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div1, null);
          }
        }
        if (!mounted) {
          dispose = listen(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[7]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(div0, null);
          }
        }
        if (dirty & /*$emojiCandidates, hoverEmoji, onSelected*/
        7) {
          each_value = ensure_array_like(
            /*$emojiCandidates*/
            ctx2[2]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$w(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$w(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div1, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t);
          detach(div1);
        }
        if_block.d();
        destroy_each(each_blocks, detaching);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$1n, "create_fragment$1n");
  function instance$1e($$self, $$props, $$invalidate) {
    let $emojiCandidates;
    let { feature } = $$props;
    let { onSelected = void 0 } = $$props;
    let hoverEmoji;
    const emojiCandidates = feature.emojiCandidatesStore;
    component_subscribe($$self, emojiCandidates, (value) => $$invalidate(2, $emojiCandidates = value));
    const mouseenter_handler = /* @__PURE__ */ __name((emoji) => $$invalidate(1, hoverEmoji = emoji), "mouseenter_handler");
    const click_handler2 = /* @__PURE__ */ __name((emoji) => onSelected == null ? void 0 : onSelected(emoji), "click_handler");
    const mouseleave_handler = /* @__PURE__ */ __name(() => $$invalidate(1, hoverEmoji = void 0), "mouseleave_handler");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(4, feature = $$props2.feature);
      if ("onSelected" in $$props2) $$invalidate(0, onSelected = $$props2.onSelected);
    };
    return [
      onSelected,
      hoverEmoji,
      $emojiCandidates,
      emojiCandidates,
      feature,
      mouseenter_handler,
      click_handler2,
      mouseleave_handler
    ];
  }
  __name(instance$1e, "instance$1e");
  const _Emoji_picker = class _Emoji_picker extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1e, create_fragment$1n, safe_not_equal, { feature: 4, onSelected: 0 });
    }
  };
  __name(_Emoji_picker, "Emoji_picker");
  let Emoji_picker = _Emoji_picker;
  var __defProp$15 = Object.defineProperty;
  var __decorateClass$15 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$15(target, key2, result);
    return result;
  }, "__decorateClass$15");
  const _ChatEmojisFeature = class _ChatEmojisFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elements");
      __publicField(this, "_apiDataSetup");
      __publicField(this, "_chatService");
      __publicField(this, "_lobbyService");
      __publicField(this, "name", "Chat Emojis");
      __publicField(this, "description", "Adds support for emojis using ':emoji-name:' format in the chat.");
      __publicField(this, "tags", [
        FeatureTag.SOCIAL
      ]);
      __publicField(this, "featureId", 22);
      __publicField(this, "decayRate", 0.99);
      __publicField(this, "boostAmount", 1);
      __publicField(this, "_inputListener", this.handleInputEvent.bind(this));
      __publicField(this, "_emojiScoresSetting", new ExtensionSetting("emojiScores", {}, this));
      __publicField(this, "_subscription");
      __publicField(this, "_component");
      __publicField(this, "_flyoutComponent");
      __publicField(this, "_flyoutSubscription");
      __publicField(this, "_emojiCandidates$", new BehaviorSubject([]));
      __publicField(this, "_emojiScores", {});
    }
    async onActivate() {
      const elements2 = await this._elements.complete();
      elements2.chatInput.addEventListener("keyup", this._inputListener);
      const emojis = (await this._apiDataSetup.complete()).emojis;
      this._subscription = this._chatService.playerMessageReceived$.pipe(
        withLatestFrom(this._lobbyService.lobby$)
      ).subscribe(([{ contentElement, player }, lobby]) => {
        const isMyMessage = player.lobbyPlayerId === (lobby == null ? void 0 : lobby.meId);
        this.processAddedMessage(contentElement, emojis, isMyMessage);
      });
      this._component = new Chat_emojis({ target: elements2.chatArea });
      this._emojiScores = await this._emojiScoresSetting.getValue();
    }
    async onDestroy() {
      var _a2, _b2, _c2, _d2;
      const elements2 = await this._elements.complete();
      elements2.chatInput.removeEventListener("keyup", this._inputListener);
      (_a2 = this._subscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._component) == null ? void 0 : _b2.$destroy();
      this._component = void 0;
      this._subscription = void 0;
      (_c2 = this._flyoutSubscription) == null ? void 0 : _c2.unsubscribe();
      (_d2 = this._flyoutComponent) == null ? void 0 : _d2.$destroy();
      this._flyoutComponent = void 0;
      this._flyoutSubscription = void 0;
    }
    updateScores(usedEmoji) {
      for (const key2 in this._emojiScores) {
        this._emojiScores[key2] *= this.decayRate;
        this._emojiScores[key2] = parseFloat(this._emojiScores[key2].toFixed(4));
      }
      if (!this._emojiScores[usedEmoji]) {
        this._emojiScores[usedEmoji] = 0;
      }
      this._emojiScores[usedEmoji] += this.boostAmount;
      this._emojiScoresSetting.setValue(this._emojiScores);
    }
    async handleInputEvent() {
      const emojis = (await this._apiDataSetup.complete()).emojis;
      const elements2 = await this._elements.complete();
      this._logger.debug("Finding emoji candidates for: ", elements2.chatInput.value);
      const emojiHead = this.parseUnfinishedEmoji(elements2.chatInput.value);
      const emojiCandidates = emojiHead !== void 0 ? emojis.filter((e) => e.name.toLowerCase().includes(emojiHead.toLowerCase())).sort((a, b) => {
        const scoreA = this._emojiScores[this.getEmojiId(a)] ?? 0;
        const scoreB = this._emojiScores[this.getEmojiId(b)] ?? 0;
        return scoreB - scoreA;
      }) : [];
      this._emojiCandidates$.next(emojiCandidates);
      if (emojiHead !== void 0 && this._flyoutComponent === void 0) {
        const flyoutContent = {
          componentType: Emoji_picker,
          props: {
            feature: this,
            onSelected: /* @__PURE__ */ __name((emoji) => {
              var _a2;
              const text2 = elements2.chatInput.value;
              elements2.chatInput.value = text2.slice(0, text2.lastIndexOf(":")) + `:${this.getEmojiId(emoji)}:`;
              (_a2 = this._flyoutComponent) == null ? void 0 : _a2.close();
              elements2.chatInput.focus();
            }, "onSelected")
          }
        };
        this._flyoutComponent = new Area_flyout({
          target: elements2.gameWrapper,
          props: {
            componentData: flyoutContent,
            areaName: "chat",
            maxHeight: "600px",
            maxWidth: "300px",
            marginY: "2.5rem",
            title: "Emoji Picker",
            closeStrategy: "explicit"
          }
        });
        this._flyoutSubscription = this._flyoutComponent.closed$.subscribe(() => {
          var _a2, _b2;
          this._logger.info("Destroyed flyout");
          (_a2 = this._flyoutComponent) == null ? void 0 : _a2.$destroy();
          (_b2 = this._flyoutSubscription) == null ? void 0 : _b2.unsubscribe();
          this._flyoutComponent = void 0;
        });
      } else if (this._flyoutComponent !== void 0 && emojiHead === void 0) {
        this._flyoutComponent.close();
      }
    }
    processAddedMessage(message, emojis, isMyMessage) {
      const textNodes = Array.from(message.childNodes).filter((node) => node.nodeType === Node.TEXT_NODE);
      textNodes.forEach((node) => {
        const parsedEmojis = this.parseTextWithEmojis(node.textContent ?? "");
        if (parsedEmojis.filter((e) => e.emoji !== void 0).length === 0) return;
        const newTextNode = document.createElement("span");
        newTextNode.classList.add("typo-emoji-container");
        parsedEmojis.forEach(({ emoji, plain }) => {
          if (plain) {
            newTextNode.appendChild(document.createTextNode(plain));
          }
          if (emoji) {
            const emojiDto = emojis.find((e) => `:${this.getEmojiId(e)}:` === emoji);
            if (emojiDto) {
              const emojiElement = document.createElement("span");
              emojiElement.textContent = emoji;
              emojiElement.style.setProperty("--typo-emoji-url", `url(${emojiDto.url})`);
              emojiElement.style.setProperty("--typo-emoji-name", emojiDto.name);
              emojiElement.classList.add("typo-emoji");
              newTextNode.appendChild(emojiElement);
              this.createTooltip(emojiElement, { title: emoji, lock: "Y" });
              if (isMyMessage) {
                this.updateScores(this.getEmojiId(emojiDto));
              }
            } else {
              newTextNode.appendChild(document.createTextNode(emoji));
            }
          }
        });
        node.replaceWith(newTextNode);
      });
    }
    parseTextWithEmojis(text2) {
      const emojiPattern = /:([a-zA-Z0-9_-]+):/g;
      const result = [];
      let lastIndex = 0;
      let match;
      while ((match = emojiPattern.exec(text2)) !== null) {
        if (match.index > lastIndex) {
          result.push({ plain: text2.slice(lastIndex, match.index) });
        }
        result.push({ emoji: match[0] });
        lastIndex = match.index + match[0].length;
      }
      if (lastIndex < text2.length) {
        result.push({ plain: text2.slice(lastIndex) });
      }
      return result;
    }
    parseUnfinishedEmoji(text2) {
      const parsedEmojiPattern = /:([a-zA-Z0-9_-]+):/g;
      text2 = text2.replace(parsedEmojiPattern, "");
      const emojiPattern = /:([a-zA-Z0-9_-]*)$/;
      const match = emojiPattern.exec(text2);
      return match == null ? void 0 : match[1];
    }
    getEmojiId(emoji) {
      return emoji.nameId > 0 ? `${emoji.name}-${emoji.nameId}` : emoji.name;
    }
    get emojiCandidatesStore() {
      return fromObservable(this._emojiCandidates$, this._emojiCandidates$.value);
    }
  };
  __name(_ChatEmojisFeature, "ChatEmojisFeature");
  let ChatEmojisFeature = _ChatEmojisFeature;
  __decorateClass$15([
    inject(ElementsSetup)
  ], ChatEmojisFeature.prototype, "_elements");
  __decorateClass$15([
    inject(ApiDataSetup)
  ], ChatEmojisFeature.prototype, "_apiDataSetup");
  __decorateClass$15([
    inject(ChatService)
  ], ChatEmojisFeature.prototype, "_chatService");
  __decorateClass$15([
    inject(LobbyService)
  ], ChatEmojisFeature.prototype, "_lobbyService");
  function create_fragment$1m(ctx) {
    let t0;
    let br0;
    let t1;
    let br1;
    return {
      c() {
        t0 = text("Add a hotkey to quickly focus the chat input, so you can start guessing right away. ");
        br0 = element("br");
        t1 = text("\nIf the auto-focus setting is enabled, the chat input will be focused automatically when someone else starts drawing. ");
        br1 = element("br");
      },
      m(target, anchor) {
        insert(target, t0, anchor);
        insert(target, br0, anchor);
        insert(target, t1, anchor);
        insert(target, br1, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(br0);
          detach(t1);
          detach(br1);
        }
      }
    };
  }
  __name(create_fragment$1m, "create_fragment$1m");
  const _Chat_focus_info = class _Chat_focus_info extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment$1m, safe_not_equal, {});
    }
  };
  __name(_Chat_focus_info, "Chat_focus_info");
  let Chat_focus_info = _Chat_focus_info;
  var __defProp$14 = Object.defineProperty;
  var __decorateClass$14 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$14(target, key2, result);
    return result;
  }, "__decorateClass$14");
  const _ChatFocusFeature = class _ChatFocusFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "elementsSetup");
      __publicField(this, "_lobbyStateChangedEventListener");
      __publicField(this, "name", "Chat Focus");
      __publicField(this, "description", "Quickly focus the chat input with a hotkey or when someone starts drawing");
      __publicField(this, "tags", [
        FeatureTag.GAMEPLAY
      ]);
      __publicField(this, "featureId", 28);
      __publicField(this, "_chatFocusHotkey", this.useHotkey(new HotkeyAction(
        "chat_focus",
        "Chat Focus",
        "Focus the chat input",
        this,
        async () => (await this.elementsSetup.complete()).chatInput.focus(),
        true,
        ["Tab"],
        void 0,
        false
      )));
      __publicField(this, "_autoFocusChatInputSetting", this.useSetting(
        new BooleanExtensionSetting("auto_focus_chat_input", true, this).withName("Auto Focus Chat Input").withDescription("Automatically focus the chat input when someone else starts drawing")
      ));
      __publicField(this, "_autoFocusSubscription");
    }
    get featureInfoComponent() {
      return { componentType: Chat_focus_info, props: {} };
    }
    async onActivate() {
      this._autoFocusSubscription = this._lobbyStateChangedEventListener.events$.pipe(
        filter((event) => event.data.drawingStarted !== void 0 && event.data.drawingStarted.word === void 0),
        withLatestFrom(this._autoFocusChatInputSetting.changes$, this.elementsSetup.complete()),
        filter(([, enabled]) => enabled)
      ).subscribe(([, , elements2]) => elements2.chatInput.focus());
    }
    async onDestroy() {
      var _a2;
      (_a2 = this._autoFocusSubscription) == null ? void 0 : _a2.unsubscribe();
      this._autoFocusSubscription = void 0;
    }
    get chatAutoFocusStore() {
      return this._autoFocusChatInputSetting.store;
    }
  };
  __name(_ChatFocusFeature, "ChatFocusFeature");
  let ChatFocusFeature = _ChatFocusFeature;
  __decorateClass$14([
    inject(ElementsSetup)
  ], ChatFocusFeature.prototype, "elementsSetup");
  __decorateClass$14([
    inject(LobbyStateChangedEventListener)
  ], ChatFocusFeature.prototype, "_lobbyStateChangedEventListener");
  const _Chat_message_splits = class _Chat_message_splits extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, null, safe_not_equal, {});
    }
  };
  __name(_Chat_message_splits, "Chat_message_splits");
  let Chat_message_splits = _Chat_message_splits;
  var __defProp$13 = Object.defineProperty;
  var __decorateClass$13 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$13(target, key2, result);
    return result;
  }, "__decorateClass$13");
  const _ChatMessageSplitsFeature = class _ChatMessageSplitsFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "name", "Longer Chat Messages");
      __publicField(this, "description", "Allows typing longer chat messages and splits them");
      __publicField(this, "tags", [
        FeatureTag.INTERFACE,
        FeatureTag.GAMEPLAY
      ]);
      __publicField(this, "featureId", 43);
      __publicField(this, "_component");
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._component = new Chat_message_splits({
        target: elements2.chatForm
      });
      elements2.chatForm.classList.add("typo-extended");
      elements2.chatInput.maxLength = 300;
    }
    async onDestroy() {
      var _a2;
      const elements2 = await this._elementsSetup.complete();
      elements2.chatForm.classList.remove("typo-extended");
      elements2.chatInput.maxLength = 100;
      (_a2 = this._component) == null ? void 0 : _a2.$destroy();
      this._component = void 0;
    }
  };
  __name(_ChatMessageSplitsFeature, "ChatMessageSplitsFeature");
  let ChatMessageSplitsFeature = _ChatMessageSplitsFeature;
  __decorateClass$13([
    inject(ElementsSetup)
  ], ChatMessageSplitsFeature.prototype, "_elementsSetup");
  function create_if_block$z(ctx) {
    let div;
    let t0;
    let t1;
    return {
      c() {
        div = element("div");
        t0 = text(
          /*$ping*/
          ctx[0]
        );
        t1 = text("ms");
        attr(div, "class", "typo-ping-info svelte-wetrhq");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, t0);
        append(div, t1);
      },
      p(ctx2, dirty) {
        if (dirty & /*$ping*/
        1) set_data(
          t0,
          /*$ping*/
          ctx2[0]
        );
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_if_block$z, "create_if_block$z");
  function create_fragment$1l(ctx) {
    let if_block_anchor;
    let if_block = (
      /*$ping*/
      ctx[0] !== void 0 && create_if_block$z(ctx)
    );
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (
          /*$ping*/
          ctx2[0] !== void 0
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$z(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
      }
    };
  }
  __name(create_fragment$1l, "create_fragment$1l");
  function instance$1d($$self, $$props, $$invalidate) {
    let $ping;
    let { feature } = $$props;
    const ping = feature.pingStore;
    component_subscribe($$self, ping, (value) => $$invalidate(0, $ping = value));
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(2, feature = $$props2.feature);
    };
    return [$ping, ping, feature];
  }
  __name(instance$1d, "instance$1d");
  const _Chat_ping = class _Chat_ping extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1d, create_fragment$1l, safe_not_equal, { feature: 2 });
    }
  };
  __name(_Chat_ping, "Chat_ping");
  let Chat_ping = _Chat_ping;
  var __defProp$12 = Object.defineProperty;
  var __decorateClass$12 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$12(target, key2, result);
    return result;
  }, "__decorateClass$12");
  const _ChatPingFeature = class _ChatPingFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elements");
      __publicField(this, "_lobbyService");
      __publicField(this, "name", "Ping Display");
      __publicField(this, "description", "Shows a small box with the current skribbl game ping above the chat input");
      __publicField(this, "tags", [FeatureTag.INFORMATION]);
      __publicField(this, "featureId", 52);
      __publicField(this, "featureEnabledDefault", false);
      __publicField(this, "_currentPing$", new Subject$1());
      __publicField(this, "_pingSubscription");
      __publicField(this, "_pingElement");
    }
    async onActivate() {
      const elements2 = await this._elements.complete();
      this._pingElement = new Chat_ping({
        target: elements2.chatForm,
        props: {
          feature: this
        }
      });
      this._pingSubscription = this._lobbyService.lobby$.pipe(
        map((lobby) => lobby != null),
        distinctUntilChanged(),
        switchMap(
          (inLobby) => inLobby ? (
            /* if in lobby, measure every 5s and accumulate to past 5 measurements */
            interval(5e3).pipe(
              exhaustMap(() => this.measurePing()),
              scan((acc, curr) => [curr, ...acc.slice(0, 5)], [])
            )
          ) : (
            /* if not, don't measure and reset */
            of([])
          )
        ),
        /* map to average time */
        map(
          (pings) => pings.length === 0 ? void 0 : Math.round(pings.reduce((a, b) => a + b, 0) / pings.length)
        )
      ).subscribe((ping) => this._currentPing$.next(ping));
    }
    async onDestroy() {
      var _a2, _b2;
      (_a2 = this._pingSubscription) == null ? void 0 : _a2.unsubscribe();
      this._pingSubscription = void 0;
      (_b2 = this._pingElement) == null ? void 0 : _b2.$destroy();
      this._pingElement = void 0;
    }
    get pingStore() {
      return fromObservable(
        this._currentPing$,
        0
      );
    }
    async measurePing() {
      this._logger.info("Measuring ping");
      const now = performance.now();
      await fetch("./credits?this_is_for_ping_measure&now=" + now, { cache: "no-store" });
      return performance.now() - now;
    }
  };
  __name(_ChatPingFeature, "ChatPingFeature");
  let ChatPingFeature = _ChatPingFeature;
  __decorateClass$12([
    inject(ElementsSetup)
  ], ChatPingFeature.prototype, "_elements");
  __decorateClass$12([
    inject(LobbyService)
  ], ChatPingFeature.prototype, "_lobbyService");
  const _Chat_profile_link = class _Chat_profile_link extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, null, safe_not_equal, {});
    }
  };
  __name(_Chat_profile_link, "Chat_profile_link");
  let Chat_profile_link = _Chat_profile_link;
  var __defProp$11 = Object.defineProperty;
  var __decorateClass$11 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$11(target, key2, result);
    return result;
  }, "__decorateClass$11");
  const _ChatProfileLinkFeature = class _ChatProfileLinkFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_chatService");
      __publicField(this, "_toastService");
      __publicField(this, "_elementsSetup");
      __publicField(this, "name", "Chat Profile Link");
      __publicField(this, "description", "Open player profiles by clicking their name in the chat.");
      __publicField(this, "tags", [
        FeatureTag.GAMEPLAY,
        FeatureTag.INTERFACE
      ]);
      __publicField(this, "featureId", 23);
      __publicField(this, "_subscription");
      __publicField(this, "_addedElements", []);
      __publicField(this, "_component");
      __publicField(this, "_clickHandler", this.chatClicked.bind(this));
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._component = new Chat_profile_link({ target: elements2.chatContent });
      this._subscription = this._chatService.playerMessageReceived$.subscribe(({ titleElement, player }) => {
        titleElement.classList.add("typo-chat-profile-link");
        this._addedElements.push({ titleElement, player });
      });
      elements2.chatContent.addEventListener("click", this._clickHandler);
    }
    async onDestroy() {
      var _a2, _b2;
      const elements2 = await this._elementsSetup.complete();
      elements2.chatContent.removeEventListener("click", this._clickHandler);
      (_a2 = this._subscription) == null ? void 0 : _a2.unsubscribe();
      this._addedElements.forEach(({ titleElement }) => titleElement.classList.remove("typo-chat-profile-link"));
      this._addedElements = [];
      (_b2 = this._component) == null ? void 0 : _b2.$destroy();
    }
    async chatClicked(event) {
      if (event.target instanceof HTMLElement && event.target.classList.contains("typo-chat-profile-link")) {
        const element2 = this._addedElements.find((e) => e.titleElement === event.target);
        if (element2) {
          element2.player.container.click();
        } else {
          await this._toastService.showToast("Player Profile not found");
        }
      }
    }
  };
  __name(_ChatProfileLinkFeature, "ChatProfileLinkFeature");
  let ChatProfileLinkFeature = _ChatProfileLinkFeature;
  __decorateClass$11([
    inject(ChatService)
  ], ChatProfileLinkFeature.prototype, "_chatService");
  __decorateClass$11([
    inject(ToastService)
  ], ChatProfileLinkFeature.prototype, "_toastService");
  __decorateClass$11([
    inject(ElementsSetup)
  ], ChatProfileLinkFeature.prototype, "_elementsSetup");
  const _NumericOptionalCommandParameter = class _NumericOptionalCommandParameter extends ExtensionCommandParameter {
    constructor(name, description, _mapping) {
      super(name, description);
      __publicField(this, "typeName", "number?");
      __publicField(this, "typeDescription", "empty or any number");
      this._mapping = _mapping;
    }
    readArg(args, dontMarkAsInterpreting) {
      const split = args.trim().split(" ");
      const arg = split[0].trim();
      if (arg.length < 1) {
        dontMarkAsInterpreting();
        return { remainder: "", argument: this._mapping(void 0) };
      }
      const number = Number(arg);
      if (isNaN(number)) {
        throw new InterpretableArgumentParsingError(this, "Failed to parse number from args: " + args);
      }
      const argument = this._mapping(number);
      const remainder = split.slice(1).join(" ");
      return { remainder, argument };
    }
  };
  __name(_NumericOptionalCommandParameter, "NumericOptionalCommandParameter");
  let NumericOptionalCommandParameter = _NumericOptionalCommandParameter;
  const _StringOptionalCommandParameter = class _StringOptionalCommandParameter extends ExtensionCommandParameter {
    constructor(name, description, _mapping) {
      super(name, description);
      __publicField(this, "typeName", "text?");
      __publicField(this, "typeDescription", "empty, a single word or text wrapped in quotes");
      this._mapping = _mapping;
    }
    readArg(args, dontMarkAsInterpreting) {
      const regex = /^\s*(["'])(.*?)\1/;
      let arg = "";
      let remainder = "";
      const matchQuoted = args.trim().match(regex);
      if (matchQuoted !== null) {
        arg = matchQuoted[2];
        remainder = args.trim().slice(matchQuoted[0].length).trim();
      } else {
        const split = args.trim().split(" ");
        arg = split[0].trim();
        remainder = split.slice(1).join(" ");
      }
      if (arg.length < 1) {
        dontMarkAsInterpreting();
        return { remainder: "", argument: this._mapping(void 0) };
      }
      const argument = this._mapping(arg);
      return { remainder, argument };
    }
  };
  __name(_StringOptionalCommandParameter, "StringOptionalCommandParameter");
  let StringOptionalCommandParameter = _StringOptionalCommandParameter;
  var __defProp$10 = Object.defineProperty;
  var __getOwnPropDesc$g = Object.getOwnPropertyDescriptor;
  var __decorateClass$10 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$g(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$10(target, key2, result);
    return result;
  }, "__decorateClass$10");
  var __decorateParam$d = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$d");
  let LobbyInteractionsService = (_ma = class {
    constructor(loggerFactory2) {
      __publicField(this, "_lobbyService");
      __publicField(this, "_lobbyInteractedEvent");
      __publicField(this, "_lobbyStateChangedEvent");
      __publicField(this, "_skribblMessageRelaySetup");
      __publicField(this, "_availableInteractions$", new BehaviorSubject(void 0));
      __publicField(this, "_logger");
      this._logger = loggerFactory2(this);
    }
    postConstruct() {
      this._logger.debug("Initializing lobby interactions service");
      this.setupAvailableInteractions();
    }
    setupAvailableInteractions() {
      this._lobbyService.lobby$.pipe(
        distinctUntilChanged(),
        pairwise(),
        map(([last2, current]) => {
          if (last2 === null && current === null || last2 !== null && current === null) return void 0;
          if (last2 === null && current !== null) return {
            rateAvailable: true,
            votekickAvailable: true,
            interactionTarget: current.players.find((p) => p.id === current.drawerId && p.id !== current.meId)
          };
          return null;
        })
      ).subscribe((update2) => {
        if (update2 !== null) {
          this._logger.info("Interactions reset on lobby join", update2);
          this._availableInteractions$.next(update2);
        }
      });
      this._lobbyStateChangedEvent.events$.pipe(
        map((evt) => evt.data.drawingStarted),
        filter((started) => started !== void 0),
        withLatestFrom(this._availableInteractions$, this._lobbyService.lobby$),
        filter(([, state, lobby]) => state !== void 0 && lobby !== null)
      ).subscribe(([drawer, state, lobby]) => {
        if (lobby === null || state === void 0) return;
        state.rateAvailable = true;
        state.votekickAvailable = true;
        state.interactionTarget = lobby.players.find((p) => p.id === drawer.drawerId && p.id !== lobby.meId);
        this._logger.info("Interactions update on lobby change", state);
        this._availableInteractions$.next(state);
      });
      this._lobbyInteractedEvent.events$.pipe(
        withLatestFrom(this._availableInteractions$, this._lobbyService.lobby$),
        filter(([, state, lobby]) => state !== void 0 && lobby !== null)
      ).subscribe(([event, state, lobby]) => {
        if (lobby === null || state === void 0) return;
        const { likeInteraction, dislikeInteraction, votekickInteraction } = event.data;
        if ((likeInteraction == null ? void 0 : likeInteraction.sourcePlayerId) === lobby.meId || lobby.drawerId === null) state.rateAvailable = false;
        if ((dislikeInteraction == null ? void 0 : dislikeInteraction.sourcePlayerId) === lobby.meId || lobby.drawerId === null) state.rateAvailable = false;
        if ((votekickInteraction == null ? void 0 : votekickInteraction.sourcePlayerId) === lobby.meId) state.votekickAvailable = false;
        this._logger.info("Interactions update on interaction", state);
        this._availableInteractions$.next(state);
      });
      this._availableInteractions$.subscribe((state) => this._logger.info("Available interactions", state));
    }
    get availableInteractions$() {
      return this._availableInteractions$.asObservable();
    }
    async likePlayer() {
      const relay = await this._skribblMessageRelaySetup.complete();
      relay.insertMessage({ data: 1, id: 8 });
    }
    async dislikePlayer() {
      const relay = await this._skribblMessageRelaySetup.complete();
      relay.insertMessage({ data: 0, id: 8 });
    }
    async votekickPlayer(id2) {
      const relay = await this._skribblMessageRelaySetup.complete();
      relay.insertMessage({ data: id2, id: 5 });
    }
  }, __name(_ma, "LobbyInteractionsService"), _ma);
  __decorateClass$10([
    inject(LobbyService)
  ], LobbyInteractionsService.prototype, "_lobbyService", 2);
  __decorateClass$10([
    inject(LobbyInteractedEventListener)
  ], LobbyInteractionsService.prototype, "_lobbyInteractedEvent", 2);
  __decorateClass$10([
    inject(LobbyStateChangedEventListener)
  ], LobbyInteractionsService.prototype, "_lobbyStateChangedEvent", 2);
  __decorateClass$10([
    inject(SkribblMessageRelaySetup)
  ], LobbyInteractionsService.prototype, "_skribblMessageRelaySetup", 2);
  __decorateClass$10([
    postConstruct()
  ], LobbyInteractionsService.prototype, "postConstruct", 1);
  LobbyInteractionsService = __decorateClass$10([
    injectable(),
    __decorateParam$d(0, inject(loggerFactory))
  ], LobbyInteractionsService);
  function create_fragment$1k(ctx) {
    let button;
    let span;
    let t;
    let button_class_value;
    let mounted;
    let dispose;
    return {
      c() {
        button = element("button");
        span = element("span");
        t = text(
          /*content*/
          ctx[0]
        );
        attr(span, "class", "svelte-1nuwppq");
        attr(button, "class", button_class_value = "typo-flat-button flatUI " + /*color*/
        ctx[1] + " svelte-1nuwppq");
        toggle_class(
          button,
          "disabled",
          /*disabled*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, button, anchor);
        append(button, span);
        append(span, t);
        if (!mounted) {
          dispose = [
            listen(
              button,
              "click",
              /*click_handler_1*/
              ctx[6]
            ),
            listen(
              button,
              "click",
              /*click_handler*/
              ctx[5]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*content*/
        1) set_data(
          t,
          /*content*/
          ctx2[0]
        );
        if (dirty & /*color*/
        2 && button_class_value !== (button_class_value = "typo-flat-button flatUI " + /*color*/
        ctx2[1] + " svelte-1nuwppq")) {
          attr(button, "class", button_class_value);
        }
        if (dirty & /*color, disabled*/
        6) {
          toggle_class(
            button,
            "disabled",
            /*disabled*/
            ctx2[2]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(button);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$1k, "create_fragment$1k");
  function instance$1c($$self, $$props, $$invalidate) {
    let { content: content2 } = $$props;
    let { color } = $$props;
    let { disabled = false } = $$props;
    const click = new Subject$1();
    const click$ = click.asObservable();
    function click_handler2(event) {
      bubble.call(this, $$self, event);
    }
    __name(click_handler2, "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => click.next(void 0), "click_handler_1");
    $$self.$$set = ($$props2) => {
      if ("content" in $$props2) $$invalidate(0, content2 = $$props2.content);
      if ("color" in $$props2) $$invalidate(1, color = $$props2.color);
      if ("disabled" in $$props2) $$invalidate(2, disabled = $$props2.disabled);
    };
    return [content2, color, disabled, click, click$, click_handler2, click_handler_1];
  }
  __name(instance$1c, "instance$1c");
  const _Flat_button = class _Flat_button extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1c, create_fragment$1k, safe_not_equal, {
        content: 0,
        color: 1,
        disabled: 2,
        click$: 4
      });
    }
    get click$() {
      return this.$$.ctx[4];
    }
  };
  __name(_Flat_button, "Flat_button");
  let Flat_button = _Flat_button;
  function create_else_block$i(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        div.innerHTML = `<b class="svelte-yvtrmi">No interactions available</b>`;
        attr(div, "class", "typo-quickreact-keys svelte-yvtrmi");
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_else_block$i, "create_else_block$i");
  function create_if_block$y(ctx) {
    let div;
    let b;
    let t0;
    let t1_value = (
      /*$availableInteractions*/
      ctx[2].interactionTarget.name + ""
    );
    let t1;
    let t2;
    let flatbutton0;
    let t3;
    let flatbutton1;
    let t4;
    let flatbutton2;
    let t5;
    let flatbutton3;
    let current;
    flatbutton0 = new Flat_button({
      props: {
        content: "⬅️ Kick",
        disabled: !/*$availableInteractions*/
        ctx[2].votekickAvailable,
        color: "blue"
      }
    });
    flatbutton0.$on(
      "click",
      /*click_handler*/
      ctx[5]
    );
    flatbutton1 = new Flat_button({
      props: { content: "➡️ Close", color: "blue" }
    });
    flatbutton2 = new Flat_button({
      props: {
        content: "⬆️ Like",
        disabled: !/*$availableInteractions*/
        ctx[2].rateAvailable,
        color: "blue"
      }
    });
    flatbutton2.$on(
      "click",
      /*click_handler_1*/
      ctx[6]
    );
    flatbutton3 = new Flat_button({
      props: {
        content: "⬇️ Dislike",
        disabled: !/*$availableInteractions*/
        ctx[2].rateAvailable,
        color: "blue"
      }
    });
    flatbutton3.$on(
      "click",
      /*click_handler_2*/
      ctx[7]
    );
    return {
      c() {
        div = element("div");
        b = element("b");
        t0 = text("Press an arrow key to react to ");
        t1 = text(t1_value);
        t2 = space();
        create_component(flatbutton0.$$.fragment);
        t3 = space();
        create_component(flatbutton1.$$.fragment);
        t4 = space();
        create_component(flatbutton2.$$.fragment);
        t5 = space();
        create_component(flatbutton3.$$.fragment);
        attr(b, "class", "svelte-yvtrmi");
        attr(div, "class", "typo-quickreact-keys svelte-yvtrmi");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, b);
        append(b, t0);
        append(b, t1);
        append(div, t2);
        mount_component(flatbutton0, div, null);
        append(div, t3);
        mount_component(flatbutton1, div, null);
        append(div, t4);
        mount_component(flatbutton2, div, null);
        append(div, t5);
        mount_component(flatbutton3, div, null);
        current = true;
      },
      p(ctx2, dirty) {
        if ((!current || dirty & /*$availableInteractions*/
        4) && t1_value !== (t1_value = /*$availableInteractions*/
        ctx2[2].interactionTarget.name + "")) set_data(t1, t1_value);
        const flatbutton0_changes = {};
        if (dirty & /*$availableInteractions*/
        4) flatbutton0_changes.disabled = !/*$availableInteractions*/
        ctx2[2].votekickAvailable;
        flatbutton0.$set(flatbutton0_changes);
        const flatbutton2_changes = {};
        if (dirty & /*$availableInteractions*/
        4) flatbutton2_changes.disabled = !/*$availableInteractions*/
        ctx2[2].rateAvailable;
        flatbutton2.$set(flatbutton2_changes);
        const flatbutton3_changes = {};
        if (dirty & /*$availableInteractions*/
        4) flatbutton3_changes.disabled = !/*$availableInteractions*/
        ctx2[2].rateAvailable;
        flatbutton3.$set(flatbutton3_changes);
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        transition_in(flatbutton2.$$.fragment, local);
        transition_in(flatbutton3.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        transition_out(flatbutton2.$$.fragment, local);
        transition_out(flatbutton3.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
        destroy_component(flatbutton2);
        destroy_component(flatbutton3);
      }
    };
  }
  __name(create_if_block$y, "create_if_block$y");
  function create_fragment$1j(ctx) {
    let div;
    let current_block_type_index;
    let if_block;
    let current;
    let mounted;
    let dispose;
    const if_block_creators = [create_if_block$y, create_else_block$i];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*$availableInteractions*/
        ctx2[2] !== void 0 && /*$availableInteractions*/
        ctx2[2].interactionTarget !== void 0
      ) return 0;
      return 1;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div = element("div");
        if_block.c();
        attr(div, "class", "typo-quickreact-focus svelte-yvtrmi");
        attr(div, "tabindex", "0");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_blocks[current_block_type_index].m(div, null);
        ctx[8](div);
        current = true;
        if (!mounted) {
          dispose = listen(
            div,
            "keydown",
            /*keydown_handler*/
            ctx[9]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if_blocks[current_block_type_index].d();
        ctx[8](null);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$1j, "create_fragment$1j");
  function instance$1b($$self, $$props, $$invalidate) {
    let $availableInteractions;
    let { feature } = $$props;
    let wrapper;
    const availableInteractions = feature.availableInteractionsStore;
    component_subscribe($$self, availableInteractions, (value) => $$invalidate(2, $availableInteractions = value));
    const onKeyPress = /* @__PURE__ */ __name((event) => {
      if ($availableInteractions !== void 0 && $availableInteractions.interactionTarget !== void 0) {
        switch (event.key) {
          case "ArrowLeft":
            feature.votekickPlayer($availableInteractions.interactionTarget);
            feature.toggleQuickReactMenu();
            break;
          case "ArrowRight":
            feature.toggleQuickReactMenu();
            break;
          case "ArrowUp":
            feature.likeCurrentPlayer();
            feature.toggleQuickReactMenu();
            break;
          case "ArrowDown":
            feature.dislikeCurrentPlayer();
            feature.toggleQuickReactMenu();
            break;
        }
      }
    }, "onKeyPress");
    onMount(() => {
      wrapper.focus();
    });
    const click_handler2 = /* @__PURE__ */ __name(() => feature.votekickPlayer($availableInteractions.interactionTarget), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => feature.likeCurrentPlayer(), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(() => feature.dislikeCurrentPlayer(), "click_handler_2");
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        wrapper = $$value;
        $$invalidate(1, wrapper);
      });
    }
    __name(div_binding, "div_binding");
    const keydown_handler2 = /* @__PURE__ */ __name((event) => onKeyPress(event), "keydown_handler");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      wrapper,
      $availableInteractions,
      availableInteractions,
      onKeyPress,
      click_handler2,
      click_handler_1,
      click_handler_2,
      div_binding,
      keydown_handler2
    ];
  }
  __name(instance$1b, "instance$1b");
  const _Quick_react = class _Quick_react extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1b, create_fragment$1j, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Quick_react, "Quick_react");
  let Quick_react = _Quick_react;
  var __defProp$$ = Object.defineProperty;
  var __decorateClass$$ = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$$(target, key2, result);
    return result;
  }, "__decorateClass$$");
  const _ChatQuickReactFeature = class _ChatQuickReactFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elements");
      __publicField(this, "_lobbyInteractionsService");
      __publicField(this, "_toastService");
      __publicField(this, "_lobbyService");
      __publicField(this, "name", "Quick React");
      __publicField(this, "description", "Adds accessibility to kick, like, and dislike via keyboard by pressing CTRL in the chat box.");
      __publicField(this, "tags", [
        FeatureTag.GAMEPLAY
      ]);
      __publicField(this, "featureId", 33);
      __publicField(this, "_likeCommand", this.useCommand(
        new ExtensionCommand("like", this, "Like", "Like the current drawing")
      ).run(async (command) => {
        await this.likeCurrentPlayer();
        return new InterpretableSilentSuccess(command);
      }));
      __publicField(this, "_dislikeCommand", this.useCommand(
        new ExtensionCommand("dislike", this, "Dislike", "Dislike the current drawing")
      ).run(async (command) => {
        await this.dislikeCurrentPlayer();
        return new InterpretableSilentSuccess(command);
      }));
      __publicField(this, "_kickCommand", this.useCommand(
        new ExtensionCommand("kick", this, "Votekick by ID", "Kick the current (default) or another player by ID")
      ).withParameters(
        (params) => params.addParam(new NumericOptionalCommandParameter("Player ID", "The ID of the player to votekick, leave empty for current drawer", (id2) => ({ id: id2 }))).run(async (args, command) => {
          const lobby = await firstValueFrom(this._lobbyService.lobby$);
          if (args.id === void 0) args.id = (lobby == null ? void 0 : lobby.drawerId) ?? void 0;
          if (args.id !== void 0 && args.id === (lobby == null ? void 0 : lobby.meId)) {
            return new InterpretableError(command, "You can't votekick yourself :(");
          }
          const target = lobby == null ? void 0 : lobby.players.find((player) => player.id === args.id);
          if (target === void 0 && args.id !== void 0) return new InterpretableError(command, "Selected player not found");
          else if (target === void 0) return new InterpretableError(command, "No default player to votekick");
          await this.votekickPlayer(target);
          return new InterpretableSilentSuccess(command);
        })
      ));
      __publicField(this, "_kickByNameCommand", this.useCommand(
        new ExtensionCommand("kick", this, "Votekick by name", "Kick the current (default) or another player by name")
      ).withParameters(
        (params) => params.addParam(new StringOptionalCommandParameter("Player Name", "The name of the player to votekick", (name) => ({ name }))).run(async (args, command) => {
          const lobby = await firstValueFrom(this._lobbyService.lobby$);
          const target = args.name === void 0 ? lobby == null ? void 0 : lobby.players.find((p) => p.id === (lobby == null ? void 0 : lobby.drawerId)) : lobby == null ? void 0 : lobby.players.find((player) => {
            var _a2;
            return player.name.toLowerCase() === ((_a2 = args.name) == null ? void 0 : _a2.toLowerCase());
          });
          if (target === void 0 && args.name !== void 0) return new InterpretableError(command, "Selected player not found");
          else if (target === void 0) return new InterpretableError(command, "No default player to votekick");
          if (target.id === (lobby == null ? void 0 : lobby.meId)) {
            return new InterpretableError(command, "You can't votekick yourself :(");
          }
          await this.votekickPlayer(target);
          return new InterpretableSilentSuccess(command);
        })
      ));
      __publicField(this, "_openQuickReactHotkey", this.useHotkey(
        new HotkeyAction(
          "open_quickreact",
          "Quick React",
          "Open the quick react menu",
          this,
          () => {
            return void 0;
          },
          true,
          ["ControlRight"],
          () => {
            this.toggleQuickReactMenu();
          },
          false
        )
      ));
      __publicField(this, "_instantLikeHotkey", this.useHotkey(
        new HotkeyAction(
          "instant_like",
          "Like Current Drawing",
          "Instantly likes the current drawing, without quick react menu access",
          this,
          () => this.likeCurrentPlayer(),
          false,
          ["ControlRight", "ArrowUp"]
        )
      ));
      __publicField(this, "_instantDislikeHotkey", this.useHotkey(
        new HotkeyAction(
          "instant_dislike",
          "Dislike Current Drawing",
          "Dislikes the current drawing, without quick react menu access",
          this,
          () => this.dislikeCurrentPlayer(),
          false,
          ["ControlRight", "ArrowDown"]
        )
      ));
      __publicField(this, "_instantVotekickHotkey", this.useHotkey(
        new HotkeyAction(
          "instant_votekick",
          "Votekick Current Drawer",
          "Votes to kick the current drawer, without quick react menu access",
          this,
          () => this.votekickPlayer(void 0),
          false,
          ["ControlRight", "ArrowLeft"]
        )
      ));
      __publicField(this, "_muteActionToastsSetting", this.useSetting(
        new BooleanExtensionSetting("mute_action_toasts", false, this).withName("Mute Info Toasts").withDescription("Mute the info toasts when liking/disliking/votekicking a player")
      ));
      __publicField(this, "_subscription");
      __publicField(this, "_flyoutComponent");
      __publicField(this, "_flyoutSubscription");
      __publicField(this, "_rateInteractionsStyle", createElement("<style>.typo-hide-rate-interactions { display: none !important }</style>"));
      __publicField(this, "_interactionUpdateSubscription");
    }
    async onActivate() {
      document.body.appendChild(this._rateInteractionsStyle);
      const elements2 = await this._elements.complete();
      this._interactionUpdateSubscription = this._lobbyInteractionsService.availableInteractions$.subscribe((interactions) => {
        elements2.gameRate.classList.toggle("typo-hide-rate-interactions", (interactions == null ? void 0 : interactions.rateAvailable) !== true);
      });
    }
    async onDestroy() {
      var _a2, _b2, _c2, _d2;
      (_a2 = this._subscription) == null ? void 0 : _a2.unsubscribe();
      this._subscription = void 0;
      (_b2 = this._flyoutSubscription) == null ? void 0 : _b2.unsubscribe();
      (_c2 = this._flyoutComponent) == null ? void 0 : _c2.$destroy();
      this._flyoutComponent = void 0;
      this._flyoutSubscription = void 0;
      (_d2 = this._interactionUpdateSubscription) == null ? void 0 : _d2.unsubscribe();
      this._interactionUpdateSubscription = void 0;
      this._rateInteractionsStyle.remove();
    }
    async hideGameRate() {
      const elements2 = await this._elements.complete();
      elements2.gameRate.style.display = "none";
    }
    async toggleQuickReactMenu() {
      if (this._flyoutComponent) {
        this._flyoutComponent.close();
      } else {
        const elements2 = await this._elements.complete();
        const flyoutContent = {
          componentType: Quick_react,
          props: {
            feature: this
          }
        };
        this._flyoutComponent = new Area_flyout({
          target: elements2.gameWrapper,
          props: {
            componentData: flyoutContent,
            areaName: "chat",
            maxHeight: "600px",
            maxWidth: "300px",
            marginY: "2.5rem",
            title: "Quick React",
            closeStrategy: "implicit"
          }
        });
        this._flyoutSubscription = this._flyoutComponent.closed$.subscribe(async () => {
          var _a2, _b2;
          this._logger.debug("Destroyed menu");
          (_a2 = this._flyoutComponent) == null ? void 0 : _a2.$destroy();
          this._flyoutComponent = void 0;
          (_b2 = this._flyoutSubscription) == null ? void 0 : _b2.unsubscribe();
          this._flyoutSubscription = void 0;
          elements2.chatInput.focus();
        });
      }
    }
    get availableInteractionsStore() {
      return fromObservable(this._lobbyInteractionsService.availableInteractions$, void 0);
    }
    async getCurrentInteractionPlayer(matchesAvailable) {
      return firstValueFrom(this._lobbyInteractionsService.availableInteractions$.pipe(map((interactions) => {
        if (interactions === void 0 || matchesAvailable && !matchesAvailable(interactions)) {
          throw new Error("Interaction is not available");
        }
        return interactions.interactionTarget;
      })));
    }
    async likeCurrentPlayer() {
      const muteToasts = await this._muteActionToastsSetting.getValue();
      const toast = muteToasts ? void 0 : await this._toastService.showLoadingToast("Liking current player");
      let player;
      try {
        const availablePlayer = await this.getCurrentInteractionPlayer((interactions) => interactions.rateAvailable);
        if (availablePlayer === void 0) throw new Error("No player available to rate");
        player = availablePlayer;
      } catch (e) {
        toast == null ? void 0 : toast.reject(e.message);
        return;
      }
      await this._lobbyInteractionsService.likePlayer();
      await this.hideGameRate();
      toast == null ? void 0 : toast.resolve(`Liked the drawing of ${player.name}`);
    }
    async dislikeCurrentPlayer() {
      const muteToasts = await this._muteActionToastsSetting.getValue();
      const toast = muteToasts ? void 0 : await this._toastService.showLoadingToast("Disliking current player");
      let player;
      try {
        const availablePlayer = await this.getCurrentInteractionPlayer((interactions) => interactions.rateAvailable);
        if (availablePlayer === void 0) throw new Error("No player available to rate");
        player = availablePlayer;
      } catch (e) {
        toast == null ? void 0 : toast.reject(e.message);
        return;
      }
      await this._lobbyInteractionsService.dislikePlayer();
      await this.hideGameRate();
      toast == null ? void 0 : toast.resolve(`Disliked the drawing of ${player.name}`);
    }
    async votekickPlayer(player) {
      const muteToasts = await this._muteActionToastsSetting.getValue();
      const toast = muteToasts ? void 0 : await this._toastService.showLoadingToast(`Voting to kick ${player === void 0 ? "current player" : player.name}`);
      try {
        const targetPlayer = await this.getCurrentInteractionPlayer((interactions) => interactions.votekickAvailable);
        if (player === void 0) {
          if (targetPlayer === void 0) throw new Error("No default player available to votekick");
          player = targetPlayer;
        }
      } catch (e) {
        toast == null ? void 0 : toast.reject(e.message);
        return;
      }
      await this._lobbyInteractionsService.votekickPlayer(player.id);
      toast == null ? void 0 : toast.resolve(`Voted to kick ${player.name}`);
    }
  };
  __name(_ChatQuickReactFeature, "ChatQuickReactFeature");
  let ChatQuickReactFeature = _ChatQuickReactFeature;
  __decorateClass$$([
    inject(ElementsSetup)
  ], ChatQuickReactFeature.prototype, "_elements");
  __decorateClass$$([
    inject(LobbyInteractionsService)
  ], ChatQuickReactFeature.prototype, "_lobbyInteractionsService");
  __decorateClass$$([
    inject(ToastService)
  ], ChatQuickReactFeature.prototype, "_toastService");
  __decorateClass$$([
    inject(LobbyService)
  ], ChatQuickReactFeature.prototype, "_lobbyService");
  var __defProp$_ = Object.defineProperty;
  var __decorateClass$_ = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$_(target, key2, result);
    return result;
  }, "__decorateClass$_");
  const _ChatRecallFeature = class _ChatRecallFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elements");
      __publicField(this, "_messageSent");
      __publicField(this, "name", "Chat Recall");
      __publicField(this, "description", "Remembers your last messages so you can quickly recall them with arrow up/down in the chat box");
      __publicField(this, "tags", [
        FeatureTag.GAMEPLAY
      ]);
      __publicField(this, "featureId", 15);
      __publicField(this, "_history", []);
      __publicField(this, "_historyIndex");
      __publicField(this, "listener", this.handleInputEvent.bind(this));
    }
    async handleInputEvent(event) {
      if (event.key === "ArrowUp" || event.key === "ArrowDown") {
        event.preventDefault();
        const element2 = event.target;
        if (this._historyIndex === void 0) {
          if (event.key === "ArrowUp") {
            this._historyIndex = this._history.length - 1;
            element2.value = this._history[this._historyIndex] ?? "";
          }
        } else if (event.key === "ArrowDown") {
          if (this._historyIndex < this._history.length - 1) {
            this._historyIndex++;
            element2.value = this._history[this._historyIndex];
          } else {
            this._historyIndex = void 0;
            element2.value = "";
          }
        } else if (event.key === "ArrowUp") {
          if (this._historyIndex > 0) {
            this._historyIndex--;
            element2.value = this._history[this._historyIndex];
          }
        }
      }
    }
    async onActivate() {
      const elements2 = await this._elements.complete();
      elements2.chatInput.addEventListener("keydown", this.listener);
      this._messageSent.events$.subscribe((event) => {
        this._history.push(event.data);
        this._historyIndex = void 0;
      });
    }
    async onDestroy() {
      const elements2 = await this._elements.complete();
      elements2.chatInput.removeEventListener("keydown", this.listener);
      this._history = [];
      this._historyIndex = 0;
    }
  };
  __name(_ChatRecallFeature, "ChatRecallFeature");
  let ChatRecallFeature = _ChatRecallFeature;
  __decorateClass$_([
    inject(ElementsSetup)
  ], ChatRecallFeature.prototype, "_elements");
  __decorateClass$_([
    inject(MessageSentEventListener)
  ], ChatRecallFeature.prototype, "_messageSent");
  function createCrossCustomEvent(type, detail) {
    if (typeof cloneInto !== "undefined" && cloneInto !== void 0 && document.defaultView !== null) {
      const safeDetail = cloneInto(detail, document.defaultView);
      return new document.defaultView.CustomEvent(type, safeDetail);
    }
    return new CustomEvent(type, detail);
  }
  __name(createCrossCustomEvent, "createCrossCustomEvent");
  async function crossImage(src) {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = src;
    await new Promise((resolve2) => img.onload = resolve2);
    return img;
  }
  __name(crossImage, "crossImage");
  const _ImageData = class _ImageData {
    constructor(_base64Full, _blob) {
      this._base64Full = _base64Full;
      this._blob = _blob;
    }
    static async fromImageUrl(url) {
      const blob = await (await fetch(url)).blob();
      return _ImageData.fromBlob(blob);
    }
    static async fromBlob(blob) {
      const reader = new FileReader();
      reader.readAsDataURL(blob);
      return new Promise((resolve2, reject) => {
        reader.onloadend = () => {
          const base64 = reader.result;
          resolve2(new _ImageData(base64, blob));
        };
        reader.onerror = () => reject();
      });
    }
    static async fromBase64(base64) {
      const blob = await (await fetch(base64)).blob();
      return new _ImageData(base64, blob);
    }
    get base64Full() {
      return this._base64Full;
    }
    get blob() {
      return this._blob;
    }
    get base64ApiTruncated() {
      return this._base64Full.split(",")[1].replace("==", "");
    }
    getBase64() {
      return this._base64Full;
    }
  };
  __name(_ImageData, "ImageData");
  let ImageData = _ImageData;
  var __defProp$Z = Object.defineProperty;
  var __getOwnPropDesc$f = Object.getOwnPropertyDescriptor;
  var __decorateClass$Z = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$f(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$Z(target, key2, result);
    return result;
  }, "__decorateClass$Z");
  var __decorateParam$c = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$c");
  let DrawingService = (_na = class {
    /* [commands, scheduled] -> scheduled false when cancel/schedule skipped */
    constructor(loggerFactory2, lobbyLeft, lobbyChanged, hintsAdded, draw, wordGuessed, imageReset, elementsSetup, skribblMessages) {
      __publicField(this, "_logger");
      __publicField(this, "_currentImageState$", new BehaviorSubject(null));
      __publicField(this, "_currentCommands$", new BehaviorSubject([]));
      __publicField(this, "_drawingState$", new BehaviorSubject("idle"));
      __publicField(this, "_pasteInProgress$", new BehaviorSubject(false));
      __publicField(this, "_abortCommands$", new BehaviorSubject(Number.MAX_VALUE));
      __publicField(this, "_incomingDrawCommands$", new Subject$1());
      this.lobbyLeft = lobbyLeft;
      this.lobbyChanged = lobbyChanged;
      this.hintsAdded = hintsAdded;
      this.draw = draw;
      this.wordGuessed = wordGuessed;
      this.imageReset = imageReset;
      this.elementsSetup = elementsSetup;
      this.skribblMessages = skribblMessages;
      this._logger = loggerFactory2(this);
      this.listenDrawCommands();
      this.listenCurrentImageState();
      this.imageState$.subscribe((data) => {
        this._logger.debug("Image state updated", data);
      });
      this.commands$.pipe(debounceTime(1e3)).subscribe((data) => {
        this._logger.debug("Commands updated", data);
      });
      lobbyLeft.events$.subscribe(() => this.cancelPendingDrawCommands());
      this._incomingDrawCommands$.pipe(
        /* not very satisfied with the access of the .value .. but it works */
        concatMap(([value, scheduled2]) => {
          if (!scheduled2) return of(value);
          const scheduledTime = Date.now();
          const abort = this._abortCommands$.value;
          if (scheduledTime < abort) return of(value).pipe(
            delay(2)
          );
          else return of(null);
        }),
        /* filter out cancelled commands */
        filter((value) => value !== null),
        /* perform commands */
        tap((command) => this.onDrawCommand(command)),
        /* count amount of pasted commands, reset when not drawing*/
        mergeWith(this._pasteInProgress$.pipe(
          distinctUntilChanged()
        )),
        scan((acc, pastingOrCommands) => pastingOrCommands === false ? 0 : pastingOrCommands === true ? acc : acc + 1, 0),
        /*filter(count => count > 0),*/
        /* inset when aborted to "finish" state even when no commands were pending */
        mergeWith(this._abortCommands$.pipe(
          distinctUntilChanged(),
          map(() => 0)
        )),
        /* after 50ms of no commands, treat as action */
        debounceTime(50)
      ).subscribe((count) => {
        this._logger.debug("finished pasting", count);
        if (count > 0) document.dispatchEvent(new CustomEvent("collapseUndoActions", { detail: count }));
        this._pasteInProgress$.next(false);
        this._abortCommands$.next(Number.MAX_VALUE);
      });
    }
    onDrawCommand(command) {
      this._logger.debug("Incoming draw command", command);
      document.dispatchEvent(createCrossCustomEvent("performDrawCommand", { detail: command }));
    }
    /**
     * create observable for all draw command updates
     * @private
     */
    listenDrawCommands() {
      merge$1(
        this.lobbyLeft.events$,
        this.lobbyChanged.events$,
        this.draw.events$,
        this.imageReset.events$
      ).pipe(
        withLatestFrom(this._currentCommands$),
        map((data) => ({ update: data[0], currentCommands: data[1] }))
      ).subscribe(({ update: update2, currentCommands }) => {
        currentCommands = structuredClone(currentCommands);
        if (update2 instanceof LobbyLeftEvent) {
          currentCommands = [];
        } else if (update2 instanceof LobbyStateChangedEvent) {
          if (update2.data.drawingStarted !== void 0) {
            currentCommands = [];
          }
        } else if (update2 instanceof LobbyLeftEvent) {
          currentCommands = [];
        } else if (update2 instanceof DrawEvent) {
          const commands = update2.data.map((command) => command.length > 7 ? arrayChunk(command, 7) : [command]).flat(1);
          currentCommands.push(...commands);
        } else if (update2 instanceof ImageResetEvent) {
          currentCommands = update2.data === 0 ? [] : currentCommands.slice(0, update2.data);
        }
        this._currentCommands$.next(currentCommands);
      });
    }
    /**
     * emit to observable for all drawing updates
     * @private
     */
    listenCurrentImageState() {
      merge$1(
        this.lobbyLeft.events$,
        this.lobbyChanged.events$,
        this.hintsAdded.events$,
        this.wordGuessed.events$
      ).pipe(
        withLatestFrom(this._currentImageState$),
        map((data) => ({ update: data[0], currentImageState: data[1] }))
      ).subscribe(({ update: update2, currentImageState }) => {
        currentImageState = currentImageState === null ? null : structuredClone(currentImageState);
        if (update2 instanceof LobbyLeftEvent) {
          currentImageState = null;
          this._drawingState$.next("idle");
        } else if (update2 instanceof LobbyStateChangedEvent) {
          currentImageState = currentImageState ?? {
            drawerId: void 0,
            word: {
              length: [0],
              hints: "",
              solution: void 0
            }
          };
          if (update2.data.drawingStarted !== void 0) {
            this._drawingState$.next("drawing");
            currentImageState.drawerId = update2.data.drawingStarted.drawerId;
            currentImageState.word.length = update2.data.drawingStarted.characters;
            currentImageState.word.solution = update2.data.drawingStarted.word;
            currentImageState.word.hints = update2.data.drawingStarted.word ?? update2.data.drawingStarted.characters.map((len) => "_".repeat(len)).join(" ");
          }
          if (update2.data.drawingRevealed !== void 0) {
            this._drawingState$.next("idle");
            currentImageState.word.solution = update2.data.drawingRevealed.word;
            currentImageState.word.hints = update2.data.drawingRevealed.word;
          }
        } else if (currentImageState !== null && update2 instanceof HintsAddedEvent) {
          const hints = [...currentImageState.word.hints];
          update2.data.forEach((hint) => {
            hints[hint[0]] = hint[1];
          });
          currentImageState.word.hints = hints.join("");
        } else if (currentImageState !== null && update2 instanceof WordGuessedEvent) {
          if (update2.data.word !== void 0) {
            currentImageState.word.solution = update2.data.word;
            currentImageState.word.hints = update2.data.word;
          }
        } else if (currentImageState !== null && update2 instanceof LobbyLeftEvent) {
          this._drawingState$.next("idle");
          currentImageState = null;
        }
        this._currentImageState$.next(currentImageState);
      });
    }
    /**
     * Observable which emits every change image state, including draw commands
     */
    get imageState$() {
      return this._currentImageState$.asObservable();
    }
    /**
     * Observable which emits every change to captured current draw commands
     */
    get commands$() {
      return this._currentCommands$.asObservable();
    }
    /**
     * Observable which emits when the drawer changes
     */
    get drawingState$() {
      return this._drawingState$.asObservable();
    }
    /**
     * Get the current canvas image as a base64 string
     */
    async getCurrentImageBase64() {
      return (await this.elementsSetup.complete()).canvas.toDataURL();
    }
    /**
     * Get the current canvas image as a blob
     */
    async getCurrentImageData() {
      const base64 = await this.getCurrentImageBase64();
      return await ImageData.fromBase64(base64);
    }
    /**
     * Paste draw commands on the canvas
     * @param commands
     * @param scheduled set to false to skip 2ms-delay-scheduling (scheduled react to cancel signal)
     */
    async pasteDrawCommands(commands, scheduled2 = true) {
      this._logger.debug("Pasting draw commands", commands);
      if (commands.length === 0) return;
      this._pasteInProgress$.next(true);
      commands.forEach((command) => this._incomingDrawCommands$.next([command, scheduled2]));
    }
    cancelPendingDrawCommands() {
      this._abortCommands$.next(Date.now());
    }
    get pasteInProgress$() {
      return this._pasteInProgress$.pipe(
        distinctUntilChanged()
      );
    }
    /**
     *
     * @param color the skribbl color code
     */
    setColor(color) {
      this._logger.debug("Setting color", color);
      document.dispatchEvent(new CustomEvent("setColor", { detail: { code: color } }));
    }
    /**
     * Disable or enable cursor updates
     * Prevents performance bottlenecks when mods change cursor properties frequently
     * When set to false, cursor will be updated once
     * @param state
     */
    disableCursorUpdates(state) {
      document.dispatchEvent(new CustomEvent("disableCursorUpdates", { detail: state }));
    }
    /**
     * Set the brush size, from 4 to 40
     * @param size
     */
    setSize(size) {
      this._logger.debug("Setting size", size);
      document.dispatchEvent(new CustomEvent("selectSkribblSize", { detail: size }));
    }
    clearImage() {
      this._logger.debug("Clearing image");
      document.dispatchEvent(new CustomEvent("clearDrawing"));
    }
    async drawImage(imageBase64, x, y, dx, dy) {
      this._logger.debug("Drawing image", imageBase64, x, y, dx, dy);
      const img = await crossImage(imageBase64);
      const canvas = (await this.elementsSetup.complete()).canvas;
      const ctx = canvas.getContext("2d");
      ctx == null ? void 0 : ctx.drawImage(img, x ?? 0, y ?? 0, dx ?? img.width, dy ?? img.height);
    }
    createLineCommand(coordinates, colorCode = void 0, size = void 0, clip = true) {
      var _a2;
      const clipped = clip ? (_a2 = this.clipLine([coordinates[0], coordinates[1]], [coordinates[2], coordinates[3]])) == null ? void 0 : _a2.flat() : [Math.floor(coordinates[0]), Math.floor(coordinates[1]), Math.floor(coordinates[2]), Math.floor(coordinates[3])];
      if (clipped === void 0) return;
      return [0, colorCode ?? 1, size ?? 4, ...clipped];
    }
    createFillCommand(coordinates, colorCode = void 0) {
      return [1, colorCode ?? 1, ...coordinates];
    }
    async drawLine(coordinates, colorCode = void 0, size = void 0) {
      var _a2;
      this._logger.debug("Drawing line", coordinates, colorCode, size);
      const clipped = (_a2 = this.clipLine([coordinates[0], coordinates[1]], [coordinates[2], coordinates[3]])) == null ? void 0 : _a2.flat();
      if (clipped === void 0) return;
      await this.pasteDrawCommands([[0, colorCode ?? 1, size ?? 4, ...clipped]]);
    }
    clipLine(origin, target) {
      const canvasWidth = 800;
      const canvasHeight = 600;
      if (origin[0] < 0 && target[0] < 0 || origin[0] >= canvasWidth && target[0] >= canvasWidth || origin[1] < 0 && target[1] < 0 || origin[1] >= canvasHeight && target[1] >= canvasHeight) {
        return void 0;
      }
      if (target[0] < 0 || target[0] >= canvasWidth) {
        const slope = (target[1] - origin[1]) / (target[0] - origin[0]);
        const y = slope * ((target[0] < 0 ? 0 : canvasWidth - 1) - origin[0]) + origin[1];
        target = [target[0] < 0 ? 0 : canvasWidth - 1, y];
      }
      if (target[1] < 0 || target[1] >= canvasHeight) {
        const slope = (target[0] - origin[0]) / (target[1] - origin[1]);
        const x = slope * ((target[1] < 0 ? 0 : canvasHeight - 1) - origin[1]) + origin[0];
        target = [x, target[1] < 0 ? 0 : canvasHeight - 1];
      }
      if (origin[1] < 0 || origin[1] >= canvasHeight) {
        const slope = (target[0] - origin[0]) / (target[1] - origin[1]);
        const x = slope * ((origin[1] < 0 ? 0 : canvasHeight - 1) - origin[1]) + origin[0];
        origin = [x, origin[1] < 0 ? 0 : canvasHeight - 1];
      }
      if (origin[0] < 0 || origin[0] >= canvasWidth) {
        const slope = (target[1] - origin[1]) / (target[0] - origin[0]);
        const y = slope * ((origin[0] < 0 ? 0 : canvasWidth - 1) - origin[0]) + origin[1];
        origin = [origin[0] < 0 ? 0 : canvasWidth - 1, y];
      }
      origin = [Math.floor(origin[0]), Math.floor(origin[1])];
      target = [Math.floor(target[0]), Math.floor(target[1])];
      return [origin, target];
    }
  }, __name(_na, "DrawingService"), _na);
  DrawingService = __decorateClass$Z([
    injectable(),
    __decorateParam$c(0, inject(loggerFactory)),
    __decorateParam$c(1, inject(LobbyLeftEventListener)),
    __decorateParam$c(2, inject(LobbyStateChangedEventListener)),
    __decorateParam$c(3, inject(HintsAddedEventListener)),
    __decorateParam$c(4, inject(DrawEventListener)),
    __decorateParam$c(5, inject(WordGuessedEventListener)),
    __decorateParam$c(6, inject(ImageResetEventListener)),
    __decorateParam$c(7, inject(ElementsSetup)),
    __decorateParam$c(8, inject(SkribblMessageRelaySetup))
  ], DrawingService);
  var __defProp$Y = Object.defineProperty;
  var __getOwnPropDesc$e = Object.getOwnPropertyDescriptor;
  var __decorateClass$Y = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$e(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$Y(target, key2, result);
    return result;
  }, "__decorateClass$Y");
  var __decorateParam$b = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$b");
  let ImageFinishedService = (_oa = class {
    constructor(loggerFactory2, _drawingService, _lobbyService) {
      __publicField(this, "_logger");
      __publicField(this, "_imageFinished$");
      this._drawingService = _drawingService;
      this._lobbyService = _lobbyService;
      this._logger = loggerFactory2(this);
      this._imageFinished$ = this.listenImageFinished();
    }
    listenImageFinished() {
      return this.mapToImageState(
        this._drawingService.drawingState$.pipe(
          delay(100),
          filter(
            (state) => state === "idle"
          )
        )
      ).pipe(
        filter((image) => image !== null),
        /* only if image mapping successfully */
        tap(() => this._logger.debug("Image finished"))
      );
    }
    /**
     * A new observable is returned, that whenever the input observable emits, gets the current image state
     * @param input
     * @private
     */
    mapToImageState(input) {
      if (input === void 0) input = of(1);
      return input.pipe(
        withLatestFrom(this._drawingService.imageState$, this._lobbyService.lobby$, this._drawingService.commands$),
        /* on every input, fetch latest lobby and drawing state */
        switchMap(
          (data) => fromPromise(this._drawingService.getCurrentImageData()).pipe(
            map((imageData) => ({ image: structuredClone(data[1]), lobby: structuredClone(data[2]), commands: structuredClone(data[3]), imageData }))
            /* fetch additionally current drawing blob and add to data */
          )
        ),
        map((state) => {
          var _a2, _b2;
          if (state.image === null || state.lobby === null) return null;
          const { lobby, image, imageData, commands } = state;
          return {
            name: image.word.solution ?? `${image.word.hints} (${image.word.length.join(", ")})`,
            image: imageData,
            commands,
            private: lobby.private,
            artist: ((_a2 = lobby.players.find((p) => p.id === image.drawerId)) == null ? void 0 : _a2.name) ?? "Unknown Artist",
            date: /* @__PURE__ */ new Date(),
            player: ((_b2 = lobby.players.find((p) => p.id === lobby.meId)) == null ? void 0 : _b2.name) ?? "Unknown Poster",
            isOwn: lobby.meId === image.drawerId,
            language: lobby.settings.language
          };
        })
      );
    }
    get imageFinished$() {
      return this._imageFinished$;
    }
    get imageHistory$() {
      return this._imageFinished$.pipe(
        scan((acc, image) => {
          if (image === null) return acc;
          else return [...acc, image];
        }, []),
        distinctUntilChanged(
          (a, b) => a.length === b.length
        )
        /* only emit when new image is added */
      );
    }
  }, __name(_oa, "ImageFinishedService"), _oa);
  ImageFinishedService = __decorateClass$Y([
    injectable(),
    __decorateParam$b(0, inject(loggerFactory)),
    __decorateParam$b(1, inject(DrawingService)),
    __decorateParam$b(2, inject(LobbyService))
  ], ImageFinishedService);
  var __defProp$X = Object.defineProperty;
  var __getOwnPropDesc$d = Object.getOwnPropertyDescriptor;
  var __decorateClass$X = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$d(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$X(target, key2, result);
    return result;
  }, "__decorateClass$X");
  var __decorateParam$a = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$a");
  let CloudService = (_pa = class {
    constructor(loggerFactory2) {
      __publicField(this, "_apiService");
      __publicField(this, "_logger");
      __publicField(this, "_pendingAwardInventoryIds", /* @__PURE__ */ new Set());
      this._logger = loggerFactory2(this);
    }
    async uploadToCloud(image, member, linkWithPendingAwards = false) {
      const api = this._apiService.getApi(CloudApi);
      const uploaded = await api.uploadToUserCloud({
        login: Number(member.userLogin),
        cloudUploadDto: {
          name: image.name,
          author: image.artist,
          inPrivate: image.private,
          isOwn: image.isOwn,
          language: image.language,
          commands: image.commands,
          imageBase64: image.image.base64ApiTruncated
        }
      });
      this._logger.debug("Image saved to cloud");
      if (linkWithPendingAwards && this._pendingAwardInventoryIds.size > 0) {
        const ids = Array.from(this._pendingAwardInventoryIds);
        this._pendingAwardInventoryIds.clear();
        const linked = await Promise.all(
          ids.map((id2) => api.linkImageToAward({ login: Number(member.userLogin), token: id2, id: uploaded.id }))
        );
        this._logger.info("Linked image to pending awards", linked.length);
      }
    }
    addPendingAwardInventoryId(inventoryId) {
      this._logger.debug("Adding pending award inventory id", inventoryId);
      this._pendingAwardInventoryIds.add(inventoryId);
    }
    clearPendingAwardInventoryIds() {
      this._logger.debug("Clearing pending award inventory ids");
      this._pendingAwardInventoryIds.clear();
    }
  }, __name(_pa, "CloudService"), _pa);
  __decorateClass$X([
    inject(ApiService)
  ], CloudService.prototype, "_apiService", 2);
  CloudService = __decorateClass$X([
    injectable(),
    __decorateParam$a(0, inject(loggerFactory))
  ], CloudService);
  const convertOldSkd = /* @__PURE__ */ __name((oldSkd) => {
    const commands = oldSkd.flat();
    commands.forEach((command) => {
      switch (command[0]) {
        case 2:
          command[0] = 1;
        case 0:
          if (command[1] > 11) command[1] += 2;
          if (command[1] > 21) command[1] += 2;
          break;
        case 1:
          command = [command[0], 0, command[1], command[2], command[3], command[4], command[5]];
          break;
      }
    });
    return commands;
  }, "convertOldSkd");
  var __defProp$W = Object.defineProperty;
  var __getOwnPropDesc$c = Object.getOwnPropertyDescriptor;
  var __decorateClass$W = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$c(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$W(target, key2, result);
    return result;
  }, "__decorateClass$W");
  var __decorateParam$9 = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$9");
  let ImagelabService = (_qa = class {
    constructor(loggerFactory2) {
      __publicField(this, "_logger");
      __publicField(this, "_savedDrawCommands$");
      this._logger = loggerFactory2(this);
    }
    async onFeatureDestroy() {
      this._savedDrawCommands$ = void 0;
    }
    async onFeatureActivate() {
      this._savedDrawCommands$ = new BehaviorSubject([]);
    }
    get savedDrawCommands$() {
      if (!this._savedDrawCommands$) {
        this._logger.error("Tried to access saved draw commands without initializing the service first. Imagelab feature enabled?");
        throw new Error("illegal state");
      }
      return this._savedDrawCommands$;
    }
    saveDrawCommands(name, commands) {
      if (!this._savedDrawCommands$) {
        this._logger.warn("Tried to save draw commands without initializing the service first. Imagelab feature enabled?");
        throw new Error("illegal state");
      }
      if (commands[0] && Array.isArray(commands[0]) && Array.isArray(commands[0][0])) {
        commands = convertOldSkd(commands);
      } else commands = commands;
      this._savedDrawCommands$.next([...this.savedDrawCommands$.value, { name, commands }]);
    }
    /**
     * Remove draw commands from saved commands
     * @param index
     */
    removeSavedDrawCommands(index) {
      if (!this._savedDrawCommands$) {
        this._logger.warn("Tried to save draw commands without initializing the service first. Imagelab feature enabled?");
        throw new Error("illegal state");
      }
      this._savedDrawCommands$.next(this._savedDrawCommands$.value.filter((item, i) => i !== index));
    }
  }, __name(_qa, "ImagelabService"), _qa);
  ImagelabService = __decorateClass$W([
    injectable(),
    __decorateParam$9(0, inject(loggerFactory))
  ], ImagelabService);
  var __defProp$V = Object.defineProperty;
  var __getOwnPropDesc$b = Object.getOwnPropertyDescriptor;
  var __decorateClass$V = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$b(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$V(target, key2, result);
    return result;
  }, "__decorateClass$V");
  var __decorateParam$8 = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$8");
  let ImagePostService = (_ra = class {
    constructor(loggerFactory2, _imageFinishedService) {
      __publicField(this, "_logger");
      __publicField(this, "_history$");
      __publicField(this, "_historySubscription");
      this._imageFinishedService = _imageFinishedService;
      this._logger = loggerFactory2(this);
    }
    /**
     *  listen for finished images and create history
     *
     */
    async onFeatureActivate() {
      this._history$ = new BehaviorSubject([]);
      this._historySubscription = this._imageFinishedService.imageHistory$.subscribe((data) => {
        var _a2;
        return (_a2 = this._history$) == null ? void 0 : _a2.next(data);
      });
    }
    /**
     * unsubscribe from history subscription
     * @private
     */
    async onFeatureDestroy() {
      var _a2;
      this._history$ = void 0;
      (_a2 = this._historySubscription) == null ? void 0 : _a2.unsubscribe();
    }
    get history$() {
      if (!this._history$) {
        this._logger.error("Tried to access history without initializing the service first. Imagelab feature enabled?");
        throw new Error("illegal state");
      }
      return this._history$.asObservable();
    }
    addToHistory(image) {
      if (!this._history$) {
        this._logger.error("Tried to access history without initializing the service first. Imagelab feature enabled?");
        throw new Error("illegal state");
      }
      this._history$.next([...this._history$.value, image]);
    }
  }, __name(_ra, "ImagePostService"), _ra);
  ImagePostService = __decorateClass$V([
    injectable(),
    __decorateParam$8(0, inject(loggerFactory)),
    __decorateParam$8(1, inject(ImageFinishedService))
  ], ImagePostService);
  function create_fragment$1i(ctx) {
    let div0;
    let t0;
    let div1;
    let t1;
    let div6;
    let div4;
    let div2;
    let t2;
    let h1;
    let t3;
    let t4;
    let div3;
    let t6;
    let div5;
    let switch_instance;
    let current;
    let mounted;
    let dispose;
    const switch_instance_spread_levels = [
      /*componentData*/
      ctx[0].props
    ];
    var switch_value = (
      /*componentData*/
      ctx[0].componentType
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {};
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*componentData*/
      1) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*componentData*/
          ctx2[0].props
        )]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        div0 = element("div");
        t0 = space();
        div1 = element("div");
        t1 = space();
        div6 = element("div");
        div4 = element("div");
        div2 = element("div");
        t2 = space();
        h1 = element("h1");
        t3 = text(
          /*title*/
          ctx[1]
        );
        t4 = space();
        div3 = element("div");
        div3.textContent = "×";
        t6 = space();
        div5 = element("div");
        if (switch_instance) create_component(switch_instance.$$.fragment);
        attr(div0, "class", "backdrop svelte-lwvpkp");
        attr(div0, "role", "presentation");
        toggle_class(
          div0,
          "closing",
          /*closing*/
          ctx[2]
        );
        attr(div1, "class", "content-top svelte-lwvpkp");
        attr(div1, "role", "presentation");
        toggle_class(
          div1,
          "closing",
          /*closing*/
          ctx[2]
        );
        attr(div2, "class", "svelte-lwvpkp");
        attr(div3, "role", "button");
        attr(div3, "tabindex", "0");
        attr(div3, "class", "svelte-lwvpkp");
        toggle_class(
          div3,
          "closing",
          /*closing*/
          ctx[2]
        );
        attr(div4, "class", "content-title svelte-lwvpkp");
        attr(div5, "class", "content-wrapper color-scrollbar svelte-lwvpkp");
        attr(div6, "class", "content typo-modal svelte-lwvpkp");
        toggle_class(
          div6,
          "closing",
          /*closing*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        insert(target, t0, anchor);
        insert(target, div1, anchor);
        insert(target, t1, anchor);
        insert(target, div6, anchor);
        append(div6, div4);
        append(div4, div2);
        append(div4, t2);
        append(div4, h1);
        append(h1, t3);
        append(div4, t4);
        append(div4, div3);
        append(div6, t6);
        append(div6, div5);
        if (switch_instance) mount_component(switch_instance, div5, null);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              div0,
              "click",
              /*click_handler*/
              ctx[5]
            ),
            listen(
              div1,
              "click",
              /*click_handler_1*/
              ctx[6]
            ),
            listen(
              div3,
              "keypress",
              /*keypress_handler*/
              ctx[7]
            ),
            listen(
              div3,
              "click",
              /*click_handler_2*/
              ctx[8]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (!current || dirty & /*closing*/
        4) {
          toggle_class(
            div0,
            "closing",
            /*closing*/
            ctx2[2]
          );
        }
        if (!current || dirty & /*closing*/
        4) {
          toggle_class(
            div1,
            "closing",
            /*closing*/
            ctx2[2]
          );
        }
        if (!current || dirty & /*title*/
        2) set_data(
          t3,
          /*title*/
          ctx2[1]
        );
        if (!current || dirty & /*closing*/
        4) {
          toggle_class(
            div3,
            "closing",
            /*closing*/
            ctx2[2]
          );
        }
        if (dirty & /*componentData*/
        1 && switch_value !== (switch_value = /*componentData*/
        ctx2[0].componentType)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, div5, null);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*componentData*/
          1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
            /*componentData*/
            ctx2[0].props
          )]) : {};
          switch_instance.$set(switch_instance_changes);
        }
        if (!current || dirty & /*closing*/
        4) {
          toggle_class(
            div6,
            "closing",
            /*closing*/
            ctx2[2]
          );
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t0);
          detach(div1);
          detach(t1);
          detach(div6);
        }
        if (switch_instance) destroy_component(switch_instance);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$1i, "create_fragment$1i");
  function instance$1a($$self, $$props, $$invalidate) {
    let { componentData } = $$props;
    let { closeHandler } = $$props;
    let { title } = $$props;
    let closing = false;
    const close = /* @__PURE__ */ __name(() => {
      $$invalidate(2, closing = true);
      setTimeout(() => closeHandler(), 150);
    }, "close");
    const click_handler2 = /* @__PURE__ */ __name(() => close(), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => close(), "click_handler_1");
    const keypress_handler = /* @__PURE__ */ __name((e) => e.key === "Alt" && close(), "keypress_handler");
    const click_handler_2 = /* @__PURE__ */ __name(() => close(), "click_handler_2");
    $$self.$$set = ($$props2) => {
      if ("componentData" in $$props2) $$invalidate(0, componentData = $$props2.componentData);
      if ("closeHandler" in $$props2) $$invalidate(4, closeHandler = $$props2.closeHandler);
      if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    };
    return [
      componentData,
      title,
      closing,
      close,
      closeHandler,
      click_handler2,
      click_handler_1,
      keypress_handler,
      click_handler_2
    ];
  }
  __name(instance$1a, "instance$1a");
  const _Modal_document = class _Modal_document extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1a, create_fragment$1i, safe_not_equal, {
        componentData: 0,
        closeHandler: 4,
        title: 1
      });
    }
  };
  __name(_Modal_document, "Modal_document");
  let Modal_document = _Modal_document;
  function create_fragment$1h(ctx) {
    let div5;
    let div4;
    let div2;
    let div0;
    let t0;
    let h1;
    let t1;
    let t2;
    let div1;
    let t4;
    let div3;
    let switch_instance;
    let current;
    let mounted;
    let dispose;
    const switch_instance_spread_levels = [
      /*componentData*/
      ctx[0].props
    ];
    var switch_value = (
      /*componentData*/
      ctx[0].componentType
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {};
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*componentData*/
      1) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*componentData*/
          ctx2[0].props
        )]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        div5 = element("div");
        div4 = element("div");
        div2 = element("div");
        div0 = element("div");
        t0 = space();
        h1 = element("h1");
        t1 = text(
          /*title*/
          ctx[1]
        );
        t2 = space();
        div1 = element("div");
        div1.textContent = "×";
        t4 = space();
        div3 = element("div");
        if (switch_instance) create_component(switch_instance.$$.fragment);
        attr(div0, "class", "svelte-1n76u56");
        attr(div1, "role", "button");
        attr(div1, "tabindex", "0");
        attr(div1, "class", "svelte-1n76u56");
        toggle_class(
          div1,
          "closing",
          /*closing*/
          ctx[2]
        );
        attr(div2, "class", "content-title svelte-1n76u56");
        attr(div3, "class", "content-wrapper color-scrollbar svelte-1n76u56");
        attr(div4, "class", "content typo-modal svelte-1n76u56");
        toggle_class(
          div4,
          "closing",
          /*closing*/
          ctx[2]
        );
        attr(div5, "class", "backdrop svelte-1n76u56");
        attr(div5, "role", "presentation");
        toggle_class(
          div5,
          "closing",
          /*closing*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, div5, anchor);
        append(div5, div4);
        append(div4, div2);
        append(div2, div0);
        append(div2, t0);
        append(div2, h1);
        append(h1, t1);
        append(div2, t2);
        append(div2, div1);
        append(div4, t4);
        append(div4, div3);
        if (switch_instance) mount_component(switch_instance, div3, null);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              div1,
              "keypress",
              /*keypress_handler*/
              ctx[5]
            ),
            listen(
              div1,
              "click",
              /*click_handler*/
              ctx[6]
            ),
            listen(
              div5,
              "click",
              /*click_handler_1*/
              ctx[7]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (!current || dirty & /*title*/
        2) set_data(
          t1,
          /*title*/
          ctx2[1]
        );
        if (!current || dirty & /*closing*/
        4) {
          toggle_class(
            div1,
            "closing",
            /*closing*/
            ctx2[2]
          );
        }
        if (dirty & /*componentData*/
        1 && switch_value !== (switch_value = /*componentData*/
        ctx2[0].componentType)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, div3, null);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*componentData*/
          1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
            /*componentData*/
            ctx2[0].props
          )]) : {};
          switch_instance.$set(switch_instance_changes);
        }
        if (!current || dirty & /*closing*/
        4) {
          toggle_class(
            div4,
            "closing",
            /*closing*/
            ctx2[2]
          );
        }
        if (!current || dirty & /*closing*/
        4) {
          toggle_class(
            div5,
            "closing",
            /*closing*/
            ctx2[2]
          );
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div5);
        }
        if (switch_instance) destroy_component(switch_instance);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$1h, "create_fragment$1h");
  function instance$19($$self, $$props, $$invalidate) {
    let { componentData } = $$props;
    let { closeHandler } = $$props;
    let { title } = $$props;
    let closing = false;
    const close = /* @__PURE__ */ __name(() => {
      $$invalidate(2, closing = true);
      setTimeout(() => closeHandler(), 150);
    }, "close");
    const keypress_handler = /* @__PURE__ */ __name((e) => e.key === "Alt" && close(), "keypress_handler");
    const click_handler2 = /* @__PURE__ */ __name(() => close(), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name((e) => {
      if (e.currentTarget === e.target) close();
    }, "click_handler_1");
    $$self.$$set = ($$props2) => {
      if ("componentData" in $$props2) $$invalidate(0, componentData = $$props2.componentData);
      if ("closeHandler" in $$props2) $$invalidate(4, closeHandler = $$props2.closeHandler);
      if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    };
    return [
      componentData,
      title,
      closing,
      close,
      closeHandler,
      keypress_handler,
      click_handler2,
      click_handler_1
    ];
  }
  __name(instance$19, "instance$19");
  const _Modal_card = class _Modal_card extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$19, create_fragment$1h, safe_not_equal, {
        componentData: 0,
        closeHandler: 4,
        title: 1
      });
    }
  };
  __name(_Modal_card, "Modal_card");
  let Modal_card = _Modal_card;
  var __defProp$U = Object.defineProperty;
  var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;
  var __decorateClass$U = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$U(target, key2, result);
    return result;
  }, "__decorateClass$U");
  var __decorateParam$7 = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$7");
  let ModalService = (_sa = class {
    constructor(loggerFactory2, _globalSettingsService) {
      __publicField(this, "_logger");
      __publicField(this, "_modalClosed$", new Subject$1());
      __publicField(this, "_closeHotkey", new HotkeyAction(
        "modal_close",
        "Close Modal",
        "Close open modals using a hotkey",
        void 0,
        () => {
          this._modalClosed$.next();
        },
        true,
        ["KeyA"]
      ));
      this._globalSettingsService = _globalSettingsService;
      this._logger = loggerFactory2(this);
    }
    showModal(componentType, args, title, style2 = "document") {
      const componentData = { componentType, props: args };
      const modal = style2 === "document" ? new Modal_document({
        target: document.body,
        props: {
          componentData,
          closeHandler: /* @__PURE__ */ __name(() => {
            modal.$destroy();
          }, "closeHandler"),
          title
        }
      }) : new Modal_card({
        target: document.body,
        props: {
          componentData,
          closeHandler: /* @__PURE__ */ __name(() => {
            modal.$destroy();
          }, "closeHandler"),
          title
        }
      });
      this._globalSettingsService.globalHotkeys.exitModal.once(() => {
        modal.$destroy();
      });
      return {
        close: /* @__PURE__ */ __name(() => {
          modal.$destroy();
        }, "close")
      };
    }
    async showPrompt(componentType, argsFactory, title, style2 = "card", validate) {
      const result$ = new Subject$1();
      const submit = /* @__PURE__ */ __name(async (result2) => {
        let validated = validate === void 0 ? true : validate(result2);
        if (validated instanceof Promise) validated = await validated;
        if (validated) result$.next(result2);
      }, "submit");
      const componentArgs = argsFactory(submit);
      const componentData = { componentType, props: componentArgs };
      const modal = style2 === "card" ? new Modal_card({
        target: document.body,
        props: {
          componentData,
          closeHandler: /* @__PURE__ */ __name(() => {
            modal.$destroy();
            result$.next(void 0);
          }, "closeHandler"),
          title
        }
      }) : new Modal_document({
        target: document.body,
        props: {
          componentData,
          closeHandler: /* @__PURE__ */ __name(() => {
            modal.$destroy();
            result$.next(void 0);
          }, "closeHandler"),
          title
        }
      });
      this._globalSettingsService.globalHotkeys.exitModal.once(() => {
        modal.$destroy();
        result$.next(void 0);
      });
      const result = await firstValueFrom(result$);
      modal.$destroy();
      return result;
    }
  }, __name(_sa, "ModalService"), _sa);
  ModalService = __decorateClass$U([
    injectable(),
    __decorateParam$7(0, inject(loggerFactory)),
    __decorateParam$7(1, inject(GlobalSettingsService))
  ], ModalService);
  const downloadBlob = /* @__PURE__ */ __name((blob, filename) => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.click();
  }, "downloadBlob");
  const downloadText = /* @__PURE__ */ __name((text2, filename) => {
    const blob = new Blob([text2], { type: "text/plain" });
    downloadBlob(blob, filename);
  }, "downloadText");
  const getCloudCommands = /* @__PURE__ */ __name(async (url) => {
    return await (await fetch(url)).json();
  }, "getCloudCommands");
  const getCloudMeta = /* @__PURE__ */ __name(async (url) => {
    return await (await fetch(url)).json();
  }, "getCloudMeta");
  const _TypedWorkerExecutor = class _TypedWorkerExecutor {
    constructor(workerUrl, _parent) {
      __publicField(this, "_worker");
      this._parent = _parent;
      this._worker = new Worker(workerUrl, { type: "module" });
      this._worker.addEventListener("message", (event) => {
        const { type, methodName, args } = event.data;
        if (type === "notification") {
          this._parent[methodName](...args);
        }
      });
    }
    async run(methodName, ...args) {
      return new Promise((resolve2) => {
        const messageId = Math.random().toString(36).slice(10);
        this._worker.addEventListener("message", (event) => {
          if (event.data.messageId === messageId && event.data.type === "result") {
            resolve2(event.data.result);
          }
        });
        this._worker.postMessage({ methodName, args, messageId });
      });
    }
  };
  __name(_TypedWorkerExecutor, "TypedWorkerExecutor");
  let TypedWorkerExecutor = _TypedWorkerExecutor;
  const gifRendererWorkerJs = '"use strict";(()=>{var hr=Object.create;var ir=Object.defineProperty;var dr=Object.getOwnPropertyDescriptor;var cr=Object.getOwnPropertyNames;var fr=Object.getPrototypeOf,gr=Object.prototype.hasOwnProperty;var vr=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports);var mr=(e,r,n,o)=>{if(r&&typeof r=="object"||typeof r=="function")for(let t of cr(r))!gr.call(e,t)&&t!==n&&ir(e,t,{get:()=>r[t],enumerable:!(o=dr(r,t))||o.enumerable});return e};var pr=(e,r,n)=>(n=e!=null?hr(fr(e)):{},mr(r||!e||!e.__esModule?ir(n,"default",{value:e,enumerable:!0}):n,e));var or=vr(nr=>{"use strict";function ur(e,r,n,i){var t=0,i=i===void 0?{}:i,l=i.loop===void 0?null:i.loop,s=i.palette===void 0?null:i.palette;if(r<=0||n<=0||r>65535||n>65535)throw new Error("Width/Height invalid.");function a(u){var v=u.length;if(v<2||v>256||v&v-1)throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");return v}e[t++]=71,e[t++]=73,e[t++]=70,e[t++]=56,e[t++]=57,e[t++]=97;var h=0,d=0;if(s!==null){for(var c=a(s);c>>=1;)++h;if(c=1<<h,--h,i.background!==void 0){if(d=i.background,d>=c)throw new Error("Background index out of range.");if(d===0)throw new Error("Background index explicitly passed as 0.")}}if(e[t++]=r&255,e[t++]=r>>8&255,e[t++]=n&255,e[t++]=n>>8&255,e[t++]=(s!==null?128:0)|h,e[t++]=d,e[t++]=0,s!==null)for(var f=0,g=s.length;f<g;++f){var m=s[f];e[t++]=m>>16&255,e[t++]=m>>8&255,e[t++]=m&255}if(l!==null){if(l<0||l>65535)throw new Error("Loop count invalid.");e[t++]=33,e[t++]=255,e[t++]=11,e[t++]=78,e[t++]=69,e[t++]=84,e[t++]=83,e[t++]=67,e[t++]=65,e[t++]=80,e[t++]=69,e[t++]=50,e[t++]=46,e[t++]=48,e[t++]=3,e[t++]=1,e[t++]=l&255,e[t++]=l>>8&255,e[t++]=0}var p=!1;this.addFrame=function(u,v,k,x,y,w){if(p===!0&&(--t,p=!1),w=w===void 0?{}:w,u<0||v<0||u>65535||v>65535)throw new Error("x/y invalid.");if(k<=0||x<=0||k>65535||x>65535)throw new Error("Width/Height invalid.");if(y.length<k*x)throw new Error("Not enough pixels for the frame size.");var I=!0,b=w.palette;if(b==null&&(I=!1,b=s),b==null)throw new Error("Must supply either a local or global palette.");for(var C=a(b),W=0;C>>=1;)++W;C=1<<W;var N=w.delay===void 0?0:w.delay,G=w.disposal===void 0?0:w.disposal;if(G<0||G>3)throw new Error("Disposal out of range.");var X=!1,D=0;if(w.transparent!==void 0&&w.transparent!==null&&(X=!0,D=w.transparent,D<0||D>=C))throw new Error("Transparent color index.");if((G!==0||X||N!==0)&&(e[t++]=33,e[t++]=249,e[t++]=4,e[t++]=G<<2|(X===!0?1:0),e[t++]=N&255,e[t++]=N>>8&255,e[t++]=D,e[t++]=0),e[t++]=44,e[t++]=u&255,e[t++]=u>>8&255,e[t++]=v&255,e[t++]=v>>8&255,e[t++]=k&255,e[t++]=k>>8&255,e[t++]=x&255,e[t++]=x>>8&255,e[t++]=I===!0?128|W-1:0,I===!0)for(var Y=0,Z=b.length;Y<Z;++Y){var S=b[Y];e[t++]=S>>16&255,e[t++]=S>>8&255,e[t++]=S&255}return t=xr(e,t,W<2?2:W,y),t},this.end=function(){return p===!1&&(e[t++]=59,p=!0),t},this.getOutputBuffer=function(){return e},this.setOutputBuffer=function(u){e=u},this.getOutputBufferPosition=function(){return t},this.setOutputBufferPosition=function(u){t=u}}function xr(e,r,n,o){e[r++]=n;var t=r++,i=1<<n,l=i-1,s=i+1,a=s+1,h=n+1,d=0,c=0;function f(w){for(;d>=w;)e[r++]=c&255,c>>=8,d-=8,r===t+256&&(e[t]=255,t=r++)}function g(w){c|=w<<d,d+=h,f(8)}var m=o[0]&l,p={};g(i);for(var u=1,v=o.length;u<v;++u){var k=o[u]&l,x=m<<8|k,y=p[x];if(y===void 0){for(c|=m<<d,d+=h;d>=8;)e[r++]=c&255,c>>=8,d-=8,r===t+256&&(e[t]=255,t=r++);a===4096?(g(i),a=s+1,h=n+1,p={}):(a>=1<<h&&++h,p[x]=a++),m=k}else m=y}return g(m),g(s),f(1),t+1===r?e[t]=0:(e[t]=r-t-1,e[r++]=0),r}function wr(e){var r=0;if(e[r++]!==71||e[r++]!==73||e[r++]!==70||e[r++]!==56||(e[r++]+1&253)!==56||e[r++]!==97)throw new Error("Invalid GIF 87a/89a header.");var n=e[r++]|e[r++]<<8,o=e[r++]|e[r++]<<8,t=e[r++],i=t>>7,l=t&7,s=1<<l+1,a=e[r++];e[r++];var h=null,d=null;i&&(h=r,d=s,r+=s*3);var c=!0,f=[],g=0,m=null,p=0,u=null;for(this.width=n,this.height=o;c&&r<e.length;)switch(e[r++]){case 33:switch(e[r++]){case 255:if(e[r]!==11||e[r+1]==78&&e[r+2]==69&&e[r+3]==84&&e[r+4]==83&&e[r+5]==67&&e[r+6]==65&&e[r+7]==80&&e[r+8]==69&&e[r+9]==50&&e[r+10]==46&&e[r+11]==48&&e[r+12]==3&&e[r+13]==1&&e[r+16]==0)r+=14,u=e[r++]|e[r++]<<8,r++;else for(r+=12;;){var v=e[r++];if(!(v>=0))throw Error("Invalid block size");if(v===0)break;r+=v}break;case 249:if(e[r++]!==4||e[r+4]!==0)throw new Error("Invalid graphics extension block.");var k=e[r++];g=e[r++]|e[r++]<<8,m=e[r++],(k&1)===0&&(m=null),p=k>>2&7,r++;break;case 254:for(;;){var v=e[r++];if(!(v>=0))throw Error("Invalid block size");if(v===0)break;r+=v}break;default:throw new Error("Unknown graphic control label: 0x"+e[r-1].toString(16))}break;case 44:var x=e[r++]|e[r++]<<8,y=e[r++]|e[r++]<<8,w=e[r++]|e[r++]<<8,I=e[r++]|e[r++]<<8,b=e[r++],C=b>>7,W=b>>6&1,N=b&7,G=1<<N+1,X=h,D=d,Y=!1;if(C){var Y=!0;X=r,D=G,r+=G*3}var Z=r;for(r++;;){var v=e[r++];if(!(v>=0))throw Error("Invalid block size");if(v===0)break;r+=v}f.push({x,y,width:w,height:I,has_local_palette:Y,palette_offset:X,palette_size:D,data_offset:Z,data_length:r-Z,transparent_index:m,interlaced:!!W,delay:g,disposal:p});break;case 59:c=!1;break;default:throw new Error("Unknown gif block: 0x"+e[r-1].toString(16))}this.numFrames=function(){return f.length},this.loopCount=function(){return u},this.frameInfo=function(S){if(S<0||S>=f.length)throw new Error("Frame index out of range.");return f[S]},this.decodeAndBlitFrameBGRA=function(S,T){var _=this.frameInfo(S),q=_.width*_.height,F=new Uint8Array(q);ar(e,_.data_offset,F,q);var A=_.palette_offset,B=_.transparent_index;B===null&&(B=256);var E=_.width,z=n-E,O=E,j=(_.y*n+_.x)*4,Q=((_.y+_.height)*n+_.x)*4,M=j,L=z*4;_.interlaced===!0&&(L+=n*4*7);for(var U=8,H=0,V=F.length;H<V;++H){var P=F[H];if(O===0&&(M+=L,O=E,M>=Q&&(L=z*4+n*4*(U-1),M=j+(E+z)*(U<<1),U>>=1)),P===B)M+=4;else{var rr=e[A+P*3],er=e[A+P*3+1],tr=e[A+P*3+2];T[M++]=tr,T[M++]=er,T[M++]=rr,T[M++]=255}--O}},this.decodeAndBlitFrameRGBA=function(S,T){var _=this.frameInfo(S),q=_.width*_.height,F=new Uint8Array(q);ar(e,_.data_offset,F,q);var A=_.palette_offset,B=_.transparent_index;B===null&&(B=256);var E=_.width,z=n-E,O=E,j=(_.y*n+_.x)*4,Q=((_.y+_.height)*n+_.x)*4,M=j,L=z*4;_.interlaced===!0&&(L+=n*4*7);for(var U=8,H=0,V=F.length;H<V;++H){var P=F[H];if(O===0&&(M+=L,O=E,M>=Q&&(L=z*4+n*4*(U-1),M=j+(E+z)*(U<<1),U>>=1)),P===B)M+=4;else{var rr=e[A+P*3],er=e[A+P*3+1],tr=e[A+P*3+2];T[M++]=rr,T[M++]=er,T[M++]=tr,T[M++]=255}--O}}}function ar(e,r,n,o){for(var t=e[r++],i=1<<t,l=i+1,s=l+1,a=t+1,h=(1<<a)-1,d=0,c=0,f=0,g=e[r++],m=new Int32Array(4096),p=null;;){for(;d<16&&g!==0;)c|=e[r++]<<d,d+=8,g===1?g=e[r++]:--g;if(d<a)break;var u=c&h;if(c>>=a,d-=a,u===i){s=l+1,a=t+1,h=(1<<a)-1,p=null;continue}else if(u===l)break;for(var v=u<s?u:p,k=0,x=v;x>i;)x=m[x]>>8,++k;var y=x,w=f+k+(v!==u?1:0);if(w>o){console.log("Warning, gif stream longer than expected.");return}n[f++]=y,f+=k;var I=f;for(v!==u&&(n[f++]=y),x=v;k--;)x=m[x],n[--I]=x&255,x>>=8;p!==null&&s<4096&&(m[s++]=p<<8|y,s>=h+1&&a<12&&(++a,h=h<<1|1)),p=u}return f!==o&&console.log("Warning, gif stream shorter than expected."),n}try{nr.GifWriter=ur,nr.GifReader=wr}catch{}});var R=class e{constructor(r,n,o,t){this._r=r;this._g=n;this._b=o;this._a=t}static skribblColors=[[255,255,255],[0,0,0],[193,193,193],[80,80,80],[239,19,11],[116,11,7],[255,113,0],[194,56,0],[255,228,0],[232,162,0],[0,204,0],[0,70,25],[0,255,145],[0,120,93],[0,178,255],[0,86,158],[35,31,211],[14,8,101],[163,0,186],[85,0,105],[223,105,167],[135,53,84],[255,172,142],[204,119,77],[160,82,45],[99,48,13]];get r(){return this._r}get g(){return this._g}get b(){return this._b}get rgbString(){return"rgb("+[this._r,this._g,this._b,this._a].filter(r=>r!==void 0).join(",")+")"}get rgbArray(){return this._a?[this._r,this._g,this._b,this._a]:[this._r,this._g,this._b]}get rgb(){return{r:this._r,g:this._g,b:this._b,a:this._a}}get hex(){return"#"+this._r.toString(16).padStart(2,"0")+this._g.toString(16).padStart(2,"0")+this._b.toString(16).padStart(2,"0")+(this._a?Math.floor(255*this._a).toString(16).padStart(2,"0"):"")}set hex(r){let n=e.fromHex(r);this._r=n._r,this._g=n._g,this._b=n._b,this._a=n._a}get skribblCode(){let r=e.skribblColors.findIndex(n=>n[0]===this._r&&n[1]===this._g&&n[2]===this._b);return r!==-1?r:this.typoCode}get typoCode(){let r=(this._r<<16|this._g<<8|this._b).toString(16).toUpperCase();return parseInt(r,16)+1e4}get hsl(){let r=this.r/255,n=this.g/255,o=this.b/255,t=Math.max(r,n,o),i=Math.min(r,n,o),l=0,s=0,a=(t+i)/2;if(t==i)l=s=0;else{let h=t-i;switch(s=a>.5?h/(2-t-i):h/(t+i),t){case r:l=(n-o)/h+(n<o?6:0);break;case n:l=(o-r)/h+2;break;case o:l=(r-n)/h+4;break}l/=6}return this._a!==void 0?[l*360,s*100,a*100,this._a]:[l*360,s*100,a*100]}get hsv(){let r=this.r/255,n=this.g/255,o=this.b/255,t=Math.max(r,n,o),i=Math.min(r,n,o),l=t-i,s=0,a=0,h=t;if(t!==0?a=l/t:(s=0,a=0),t!==i){switch(t){case r:s=(n-o)/l+(n<o?6:0);break;case n:s=(o-r)/l+2;break;case o:s=(r-n)/l+4;break}s/=6}return[s*360,a*100,h*100,this._a]}static fromRgb(r,n,o,t){return new e(Math.round(r),Math.round(n),Math.round(o),t?Math.round(t*100)/100:void 0)}static fromHex(r){r[0]=="#"&&(r=r.substring(1));let n=Math.round(parseInt("0x"+r.substring(0,2))),o=Math.round(parseInt("0x"+r.substring(2,4))),t=Math.round(parseInt("0x"+r.substring(4,6))),i=r.length>6?Math.round(parseInt("0x"+r.substring(6,8))):void 0;return new e(n,o,t,i)}static fromRgbString(r){let n=r.trim().replace(" ","").split(","),o=parseInt(n[0].replace(/[^\\d]/g,""),10),t=parseInt(n[1].replace(/[^\\d]/g,""),10),i=parseInt(n[2].replace(/[^\\d]/g,""),10),l=n.length>3?parseInt(n[4].replace(/[^\\d]/g,""),10):void 0;return new e(o,t,i,l)}static fromSkribblCode(r){if(r<1e4){let o=e.skribblColors[r];return e.fromRgb(o[0],o[1],o[2])}let n=(r-1e4).toString(16).padStart(6,"0");return e.fromHex(n)}static fromHsl(r,n,o,t){n/=100,o/=100;let i=c=>(c+r/30)%12,l=n*Math.min(o,1-o),s=c=>o-l*Math.max(-1,Math.min(i(c)-3,Math.min(9-i(c),1))),a=Math.round(s(0)*255),h=Math.round(s(8)*255),d=Math.round(s(4)*255);return new e(a,h,d,t)}static fromHsv(r,n,o,t){n/=100,o/=100;let i=o*n,l=i*(1-Math.abs(r/60%2-1)),s=o-i,a=0,h=0,d=0;return 0<=r&&r<60?(a=i,h=l,d=0):60<=r&&r<120?(a=l,h=i,d=0):120<=r&&r<180?(a=0,h=i,d=l):180<=r&&r<240?(a=0,h=l,d=i):240<=r&&r<300?(a=l,h=0,d=i):300<=r&&r<360&&(a=i,h=0,d=l),a=Math.round((a+s)*255),h=Math.round((h+s)*255),d=Math.round((d+s)*255),new e(a,h,d,t)}copy(){return new e(this._r,this._g,this._b,this._a)}withAlpha(r){return this._a=r,this}};var K=class{constructor(r){this._canvasContext=r;this._width=r.canvas.width,this._height=r.canvas.height,this._canvasContext.fillStyle="white",this._canvasContext.fillRect(0,0,this._width,this._height)}_width;_height;_thicknessMin=4;_thicknessMax=40;processDrawCommand(r){if(r.length<2)throw new Error("Invalid command length smaller than 2");switch(r[0]){case 0:if(r.length<7)throw new Error("Invalid brush command length smaller than 7");this.drawLine(r[3],r[4],r[5],r[6],r[1],r[2]);break;case 1:if(r.length<4)throw new Error("Invalid fill command length smaller than 4");this.floodFill(r[2],r[3],r[1]);break}}clear(){this._canvasContext.clearRect(0,0,this._width,this._height)}exportImage(){return this._canvasContext.getImageData(0,0,this._width,this._height).data}drawLine(r,n,o,t,i,l){l=l<this._thicknessMin?this._thicknessMin:l>this._thicknessMax?this._thicknessMax:Math.floor(l);let s=R.fromSkribblCode(i).rgb,a=Math.ceil(l/2),h=a*a,d=this.clamp(Math.floor(r),-a,this._width+a),c=this.clamp(Math.floor(n),-a,this._height+a),f=this.clamp(Math.floor(o),-a,this._width+a),g=this.clamp(Math.floor(t),-a,this._height+a),m=Math.min(d,f)-a,p=Math.min(c,g)-a,u=Math.max(d,f)+a,v=Math.max(c,g)+a;d-=m,c-=p,f-=m,g-=p;let k=this._canvasContext.getImageData(m,p,u-m,v-p),x=(y,w)=>{for(let I=-a;I<=a;I++)for(let b=-a;b<=a;b++)if(I*I+b*b<h){let C=4*((w+b)*k.width+y+I);this.setPixel(k,C,s.r,s.g,s.b)}};if(d===f&&c===g)x(d,c);else{x(d,c),x(f,g);let y=Math.abs(f-d),w=Math.abs(g-c),I=d<f?1:-1,b=c<g?1:-1,C=y-w;for(;d!==f||c!==g;){let W=C*2;W>-w&&(C-=w,d+=I),W<y&&(C+=y,c+=b),x(d,c)}}this._canvasContext.putImageData(k,m,p)}floodFill(r,n,o){let t=this._canvasContext.getImageData(0,0,this._width,this._height);r=this.clamp(Math.floor(r),0,this._width),n=this.clamp(Math.floor(n),0,this._height);let i=R.fromSkribblCode(o).rgb,l=[[r,n]],s=this.getPixel(t,r,n);if(i.r!==s[0]||i.g!==s[1]||i.b!==s[2]){let a=c=>{let f=t.data[c],g=t.data[c+1],m=t.data[c+2];return f===s[0]&&g===s[1]&&m===s[2]},h=t.width,d=t.height;for(;l.length>0;){let[c,f]=l.pop()??[-1,-1],g=4*(f*h+c);for(;f>=0&&a(g);)g-=4*h,f--;g+=4*h,f++;let m=!1,p=!1;for(;f<d&&a(g);)this.setPixel(t,g,i.r,i.g,i.b),c>0&&a(g-4)?m||(l.push([c-1,f]),m=!0):m&&(m=!1),c<h-1&&a(g+4)?p||(l.push([c+1,f]),p=!0):p&&(p=!1),g+=4*h,f++}this._canvasContext.putImageData(t,0,0)}}getPixel(r,n,o){let t=4*(o*r.width+n);return t<0||t>=r.data.length?[0,0,0]:[r.data[t],r.data[t+1],r.data[t+2]]}setPixel(r,n,o,t,i){n<0||n>=r.data.length||(r.data[n]=o,r.data[n+1]=t,r.data[n+2]=i,r.data[n+3]=255)}clamp(r,n,o){return Math.min(Math.max(r,n),o)}};var sr=pr(or(),1),$=class{width=800;height=600;buffer;gifWriter;frameCount=0;colors;constructor(r,n){this.buffer=new Uint8Array(this.width*this.height*5*n),this.gifWriter=new sr.GifWriter(this.buffer,this.width,this.height,{loop:1});let o=s=>s.rgbArray.slice(0,3).join(","),t=R.fromRgb(255,255,255);this.colors=new Map(r.values().map((s,a)=>[s.rgbArray.slice(0,3).toString(),{color:s,index:a}])),this.colors.has(o(t))||this.colors.set(o(t),{color:t,index:this.colors.size});let l=(s=>Math.pow(2,Math.ceil(Math.log2(s))))(this.colors.size);this.colors.size<l&&new Array(l-this.colors.size).fill(t).forEach((a,h)=>{this.colors.set(`fill-${h}`,{color:a,index:this.colors.size})})}get palette(){return[...this.colors.values()].map(r=>{let n=r.color.rgbArray;return n[2]|n[1]<<8|n[0]<<16})}mapToPaletteIndex(r){return this.colors.get(r.toString())?.index??0}addFrame(r,n){let o=this.palette,t=[];for(let i=0;i<r.length;i+=4){let l=[r[i],r[i+1],r[i+2]];t.push(this.mapToPaletteIndex(l))}this.gifWriter.addFrame(0,0,this.width,this.height,t,{delay:n/10,palette:o,disposal:2}),this.frameCount++}finalize(){if(this.frameCount===0)throw new Error("No frames added to the GIF.");let r=this.buffer.subarray(0,this.gifWriter.end());return new Blob([r],{type:"image/gif"})}};function lr(e,r,n,o,t,i){let l=new Set(r.map(h=>h[1]));if(l.size>256)throw new Error("Too many colors in the skribbl commands to render gif");let s=new Set(l.values().map(h=>R.fromSkribblCode(h))),a=new $(s,t);for(let h=0;h<r.length;h++)if(e.processDrawCommand(r[h]),h%n===0){let d=e.exportImage();a.addFrame(d,o),i?.(h,r.length)}return a.addFrame(e.exportImage(),2e3),a.finalize()}var J=class{constructor(r){this.worker=r;addEventListener("message",async n=>{let{methodName:o,args:t,messageId:i}=n.data,l=await this.worker[o](...t);postMessage({type:"result",messageId:i,result:l})})}send(r,...n){postMessage({type:"notification",methodName:r,args:n})}};var _r={renderGif(e,r){let o=new OffscreenCanvas(800,600).getContext("2d",{willReadFrequently:!0});if(!o)throw new Error("Failed to get 2d context");let t=new K(o),i=50,l=Math.ceil(r/i),s=Math.max(1,Math.floor(e.length/l));return lr(t,e,s,i,l,(h,d)=>kr.send("frameRendered",h,d))}},kr=new J(_r);})();\n';
  function get_each_context$v(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[33] = list[i];
    return child_ctx;
  }
  __name(get_each_context$v, "get_each_context$v");
  function create_if_block_2$d(ctx) {
    let flatbutton;
    let current;
    flatbutton = new Flat_button({
      props: { content: "Search Cloud", color: "green" }
    });
    flatbutton.$on(
      "click",
      /*click_handler_1*/
      ctx[20]
    );
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block_2$d, "create_if_block_2$d");
  function create_if_block_1$g(ctx) {
    let await_block_anchor;
    let promise;
    let current;
    let info = {
      ctx,
      current: null,
      token: null,
      hasCatch: false,
      pending: create_pending_block$4,
      then: create_then_block$4,
      catch: create_catch_block$4,
      value: 11,
      blocks: [, , ,]
    };
    handle_promise(promise = /*images*/
    ctx[11], info);
    return {
      c() {
        await_block_anchor = empty();
        info.block.c();
      },
      m(target, anchor) {
        insert(target, await_block_anchor, anchor);
        info.block.m(target, info.anchor = anchor);
        info.mount = () => await_block_anchor.parentNode;
        info.anchor = await_block_anchor;
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        info.ctx = ctx;
        if (dirty[0] & /*images*/
        2048 && promise !== (promise = /*images*/
        ctx[11]) && handle_promise(promise, info)) ;
        else {
          update_await_block_branch(info, ctx, dirty);
        }
      },
      i(local) {
        if (current) return;
        transition_in(info.block);
        current = true;
      },
      o(local) {
        for (let i = 0; i < 3; i += 1) {
          const block2 = info.blocks[i];
          transition_out(block2);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(await_block_anchor);
        }
        info.block.d(detaching);
        info.token = null;
        info = null;
      }
    };
  }
  __name(create_if_block_1$g, "create_if_block_1$g");
  function create_catch_block$4(ctx) {
    return {
      c: noop,
      m: noop,
      p: noop,
      i: noop,
      o: noop,
      d: noop
    };
  }
  __name(create_catch_block$4, "create_catch_block$4");
  function create_then_block$4(ctx) {
    let each_1_anchor;
    let each_value = ensure_array_like(
      /*images*/
      ctx[11]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$v(get_each_context$v(ctx, each_value, i));
    }
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (dirty[0] & /*images, hiddenImages, selectedImage*/
        3584) {
          each_value = ensure_array_like(
            /*images*/
            ctx2[11]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$v(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$v(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_then_block$4, "create_then_block$4");
  function create_each_block$v(ctx) {
    let img;
    let img_src_value;
    let img_alt_value;
    let mounted;
    let dispose;
    function click_handler_4() {
      return (
        /*click_handler_4*/
        ctx[23](
          /*image*/
          ctx[33]
        )
      );
    }
    __name(click_handler_4, "click_handler_4");
    return {
      c() {
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = /*image*/
        ctx[33].imageUrl)) attr(img, "src", img_src_value);
        attr(img, "alt", img_alt_value = /*image*/
        ctx[33].name);
        set_style(
          img,
          "display",
          /*hiddenImages*/
          ctx[9].includes(
            /*image*/
            ctx[33].id
          ) ? "none" : ""
        );
        attr(img, "class", "svelte-skb05m");
      },
      m(target, anchor) {
        insert(target, img, anchor);
        if (!mounted) {
          dispose = listen(img, "click", click_handler_4);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty[0] & /*images*/
        2048 && !src_url_equal(img.src, img_src_value = /*image*/
        ctx[33].imageUrl)) {
          attr(img, "src", img_src_value);
        }
        if (dirty[0] & /*images*/
        2048 && img_alt_value !== (img_alt_value = /*image*/
        ctx[33].name)) {
          attr(img, "alt", img_alt_value);
        }
        if (dirty[0] & /*hiddenImages, images*/
        2560) {
          set_style(
            img,
            "display",
            /*hiddenImages*/
            ctx[9].includes(
              /*image*/
              ctx[33].id
            ) ? "none" : ""
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(img);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block$v, "create_each_block$v");
  function create_pending_block$4(ctx) {
    let div;
    let bounceload;
    let current;
    bounceload = new Bounceload({ props: { content: "Loading Images..." } });
    return {
      c() {
        div = element("div");
        create_component(bounceload.$$.fragment);
        attr(div, "class", "loading svelte-skb05m");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(bounceload, div, null);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(bounceload);
      }
    };
  }
  __name(create_pending_block$4, "create_pending_block$4");
  function create_if_block$x(ctx) {
    let div0;
    let img;
    let img_src_value;
    let img_alt_value;
    let t0;
    let div2;
    let h3;
    let t1_value = (
      /*selectedImage*/
      ctx[10].name + ""
    );
    let t1;
    let t2;
    let span0;
    let t3;
    let t4_value = (
      /*selectedImage*/
      ctx[10].author + ""
    );
    let t4;
    let t5;
    let span1;
    let t6;
    let t7_value = new Date(Number(
      /*selectedImage*/
      ctx[10].createdAt
    )).toLocaleString() + "";
    let t7;
    let t8;
    let br0;
    let t9;
    let flatbutton0;
    let t10;
    let flatbutton1;
    let t11;
    let flatbutton2;
    let t12;
    let br1;
    let t13;
    let flatbutton3;
    let t14;
    let flatbutton4;
    let t15;
    let br2;
    let t16;
    let flatbutton5;
    let t17;
    let div1;
    let iconbutton;
    let t18;
    let current;
    let mounted;
    let dispose;
    flatbutton0 = new Flat_button({
      props: { content: "Download PNG", color: "green" }
    });
    flatbutton0.$on(
      "click",
      /*click_handler_7*/
      ctx[25]
    );
    flatbutton1 = new Flat_button({
      props: { content: "Download GIF", color: "green" }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_8*/
      ctx[26]
    );
    flatbutton2 = new Flat_button({
      props: { content: "Copy Link", color: "green" }
    });
    flatbutton2.$on(
      "click",
      /*click_handler_9*/
      ctx[27]
    );
    flatbutton3 = new Flat_button({
      props: {
        content: "Add to Image Post",
        color: "blue"
      }
    });
    flatbutton3.$on(
      "click",
      /*click_handler_10*/
      ctx[28]
    );
    flatbutton4 = new Flat_button({
      props: {
        content: "Add to Image Lab",
        color: "blue"
      }
    });
    flatbutton4.$on(
      "click",
      /*click_handler_11*/
      ctx[29]
    );
    flatbutton5 = new Flat_button({
      props: { content: "Delete Image", color: "orange" }
    });
    flatbutton5.$on(
      "click",
      /*click_handler_12*/
      ctx[30]
    );
    iconbutton = new Icon_button({
      props: {
        icon: "file-img-arrow-left-gif",
        hoverMove: false,
        name: "Exit"
      }
    });
    iconbutton.$on(
      "click",
      /*click_handler*/
      ctx[31]
    );
    return {
      c() {
        div0 = element("div");
        img = element("img");
        t0 = space();
        div2 = element("div");
        h3 = element("h3");
        t1 = text(t1_value);
        t2 = space();
        span0 = element("span");
        t3 = text("Drawn by ");
        t4 = text(t4_value);
        t5 = space();
        span1 = element("span");
        t6 = text("Created on ");
        t7 = text(t7_value);
        t8 = space();
        br0 = element("br");
        t9 = space();
        create_component(flatbutton0.$$.fragment);
        t10 = space();
        create_component(flatbutton1.$$.fragment);
        t11 = space();
        create_component(flatbutton2.$$.fragment);
        t12 = space();
        br1 = element("br");
        t13 = space();
        create_component(flatbutton3.$$.fragment);
        t14 = space();
        create_component(flatbutton4.$$.fragment);
        t15 = space();
        br2 = element("br");
        t16 = space();
        create_component(flatbutton5.$$.fragment);
        t17 = space();
        div1 = element("div");
        create_component(iconbutton.$$.fragment);
        t18 = text("\n        Back to Gallery");
        if (!src_url_equal(img.src, img_src_value = /*selectedImage*/
        ctx[10].imageUrl)) attr(img, "src", img_src_value);
        attr(img, "alt", img_alt_value = /*selectedImage*/
        ctx[10].name);
        attr(img, "class", "svelte-skb05m");
        attr(div0, "class", "present-image svelte-skb05m");
        attr(h3, "class", "svelte-skb05m");
        attr(span0, "class", "svelte-skb05m");
        attr(span1, "class", "svelte-skb05m");
        attr(div1, "class", "exit-present svelte-skb05m");
        attr(div2, "class", "present-sidebar svelte-skb05m");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        append(div0, img);
        insert(target, t0, anchor);
        insert(target, div2, anchor);
        append(div2, h3);
        append(h3, t1);
        append(div2, t2);
        append(div2, span0);
        append(span0, t3);
        append(span0, t4);
        append(div2, t5);
        append(div2, span1);
        append(span1, t6);
        append(span1, t7);
        append(div2, t8);
        append(div2, br0);
        append(div2, t9);
        mount_component(flatbutton0, div2, null);
        append(div2, t10);
        mount_component(flatbutton1, div2, null);
        append(div2, t11);
        mount_component(flatbutton2, div2, null);
        append(div2, t12);
        append(div2, br1);
        append(div2, t13);
        mount_component(flatbutton3, div2, null);
        append(div2, t14);
        mount_component(flatbutton4, div2, null);
        append(div2, t15);
        append(div2, br2);
        append(div2, t16);
        mount_component(flatbutton5, div2, null);
        append(div2, t17);
        append(div2, div1);
        mount_component(iconbutton, div1, null);
        append(div1, t18);
        current = true;
        if (!mounted) {
          dispose = [
            listen(img, "click", click_handler_5),
            listen(
              div0,
              "click",
              /*click_handler_6*/
              ctx[24]
            ),
            listen(
              div1,
              "click",
              /*click_handler_13*/
              ctx[32]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (!current || dirty[0] & /*selectedImage*/
        1024 && !src_url_equal(img.src, img_src_value = /*selectedImage*/
        ctx2[10].imageUrl)) {
          attr(img, "src", img_src_value);
        }
        if (!current || dirty[0] & /*selectedImage*/
        1024 && img_alt_value !== (img_alt_value = /*selectedImage*/
        ctx2[10].name)) {
          attr(img, "alt", img_alt_value);
        }
        if ((!current || dirty[0] & /*selectedImage*/
        1024) && t1_value !== (t1_value = /*selectedImage*/
        ctx2[10].name + "")) set_data(t1, t1_value);
        if ((!current || dirty[0] & /*selectedImage*/
        1024) && t4_value !== (t4_value = /*selectedImage*/
        ctx2[10].author + "")) set_data(t4, t4_value);
        if ((!current || dirty[0] & /*selectedImage*/
        1024) && t7_value !== (t7_value = new Date(Number(
          /*selectedImage*/
          ctx2[10].createdAt
        )).toLocaleString() + "")) set_data(t7, t7_value);
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        transition_in(flatbutton2.$$.fragment, local);
        transition_in(flatbutton3.$$.fragment, local);
        transition_in(flatbutton4.$$.fragment, local);
        transition_in(flatbutton5.$$.fragment, local);
        transition_in(iconbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        transition_out(flatbutton2.$$.fragment, local);
        transition_out(flatbutton3.$$.fragment, local);
        transition_out(flatbutton4.$$.fragment, local);
        transition_out(flatbutton5.$$.fragment, local);
        transition_out(iconbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t0);
          detach(div2);
        }
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
        destroy_component(flatbutton2);
        destroy_component(flatbutton3);
        destroy_component(flatbutton4);
        destroy_component(flatbutton5);
        destroy_component(iconbutton);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_if_block$x, "create_if_block$x");
  function create_fragment$1g(ctx) {
    let div3;
    let div1;
    let h3;
    let t1;
    let span0;
    let t3;
    let input0;
    let t4;
    let span1;
    let t6;
    let input1;
    let t7;
    let span2;
    let t9;
    let input2;
    let t10;
    let span3;
    let t12;
    let input3;
    let t13;
    let checkbox0;
    let updating_checked;
    let t14;
    let checkbox1;
    let updating_checked_1;
    let t15;
    let br;
    let t16;
    let t17;
    let div0;
    let iconbutton0;
    let t18;
    let span4;
    let t19;
    let t20_value = (
      /*page*/
      ctx[1] + 1 + ""
    );
    let t20;
    let t21;
    let iconbutton1;
    let t22;
    let div2;
    let t23;
    let current;
    let mounted;
    let dispose;
    function checkbox0_checked_binding(value) {
      ctx[18](value);
    }
    __name(checkbox0_checked_binding, "checkbox0_checked_binding");
    let checkbox0_props = { description: "Only private lobbies" };
    if (
      /*createdInPrivateLobbyQuery*/
      ctx[5] !== void 0
    ) {
      checkbox0_props.checked = /*createdInPrivateLobbyQuery*/
      ctx[5];
    }
    checkbox0 = new Checkbox({ props: checkbox0_props });
    binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding));
    function checkbox1_checked_binding(value) {
      ctx[19](value);
    }
    __name(checkbox1_checked_binding, "checkbox1_checked_binding");
    let checkbox1_props = { description: "Only own drawings" };
    if (
      /*isOwnQuery*/
      ctx[6] !== void 0
    ) {
      checkbox1_props.checked = /*isOwnQuery*/
      ctx[6];
    }
    checkbox1 = new Checkbox({ props: checkbox1_props });
    binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding));
    let if_block0 = (
      /*$member*/
      ctx[2] !== null && create_if_block_2$d(ctx)
    );
    iconbutton0 = new Icon_button({
      props: {
        icon: "file-img-arrow-left-gif",
        name: "Previous",
        size: "2rem",
        hoverMove: false,
        disabled: (
          /*page*/
          ctx[1] <= 0
        )
      }
    });
    iconbutton0.$on(
      "click",
      /*click_handler_2*/
      ctx[21]
    );
    iconbutton1 = new Icon_button({
      props: {
        icon: "file-img-arrow-right-gif",
        name: "Next",
        size: "2rem",
        hoverMove: false
      }
    });
    iconbutton1.$on(
      "click",
      /*click_handler_3*/
      ctx[22]
    );
    let if_block1 = (
      /*$member*/
      ctx[2] !== null && /*images*/
      ctx[11] !== null && create_if_block_1$g(ctx)
    );
    let if_block2 = (
      /*selectedImage*/
      ctx[10] !== null && create_if_block$x(ctx)
    );
    return {
      c() {
        div3 = element("div");
        div1 = element("div");
        h3 = element("h3");
        h3.textContent = "Filter Cloud";
        t1 = space();
        span0 = element("span");
        span0.textContent = "Artist Name";
        t3 = space();
        input0 = element("input");
        t4 = space();
        span1 = element("span");
        span1.textContent = "Image Name";
        t6 = space();
        input1 = element("input");
        t7 = space();
        span2 = element("span");
        span2.textContent = "Created Before";
        t9 = space();
        input2 = element("input");
        t10 = space();
        span3 = element("span");
        span3.textContent = "Created After";
        t12 = space();
        input3 = element("input");
        t13 = space();
        create_component(checkbox0.$$.fragment);
        t14 = space();
        create_component(checkbox1.$$.fragment);
        t15 = space();
        br = element("br");
        t16 = space();
        if (if_block0) if_block0.c();
        t17 = space();
        div0 = element("div");
        create_component(iconbutton0.$$.fragment);
        t18 = space();
        span4 = element("span");
        t19 = text("Page ");
        t20 = text(t20_value);
        t21 = space();
        create_component(iconbutton1.$$.fragment);
        t22 = space();
        div2 = element("div");
        if (if_block1) if_block1.c();
        t23 = space();
        if (if_block2) if_block2.c();
        attr(h3, "class", "svelte-skb05m");
        attr(span0, "class", "svelte-skb05m");
        attr(input0, "type", "text");
        attr(input0, "placeholder", "Filter exact artist name");
        attr(input0, "class", "svelte-skb05m");
        attr(span1, "class", "svelte-skb05m");
        attr(input1, "type", "text");
        attr(input1, "placeholder", "Filter exact image title");
        attr(input1, "class", "svelte-skb05m");
        attr(span2, "class", "svelte-skb05m");
        attr(input2, "type", "datetime-local");
        attr(input2, "class", "svelte-skb05m");
        attr(span3, "class", "svelte-skb05m");
        attr(input3, "type", "datetime-local");
        attr(input3, "class", "svelte-skb05m");
        attr(br, "class", "svelte-skb05m");
        attr(span4, "class", "svelte-skb05m");
        attr(div0, "class", "navigate-page svelte-skb05m");
        attr(div1, "class", "gallery-sidebar svelte-skb05m");
        toggle_class(
          div1,
          "present",
          /*selectedImage*/
          ctx[10] !== null
        );
        attr(div2, "class", "gallery-results svelte-skb05m");
        toggle_class(
          div2,
          "present",
          /*selectedImage*/
          ctx[10] !== null
        );
        attr(div3, "class", "typo-gallery-grid color-scrollbar svelte-skb05m");
      },
      m(target, anchor) {
        insert(target, div3, anchor);
        append(div3, div1);
        append(div1, h3);
        append(div1, t1);
        append(div1, span0);
        append(div1, t3);
        append(div1, input0);
        set_input_value(
          input0,
          /*authorQuery*/
          ctx[3]
        );
        append(div1, t4);
        append(div1, span1);
        append(div1, t6);
        append(div1, input1);
        set_input_value(
          input1,
          /*titleQuery*/
          ctx[4]
        );
        append(div1, t7);
        append(div1, span2);
        append(div1, t9);
        append(div1, input2);
        set_input_value(
          input2,
          /*createdBeforeQuery*/
          ctx[7]
        );
        append(div1, t10);
        append(div1, span3);
        append(div1, t12);
        append(div1, input3);
        set_input_value(
          input3,
          /*createdAfterQuery*/
          ctx[8]
        );
        append(div1, t13);
        mount_component(checkbox0, div1, null);
        append(div1, t14);
        mount_component(checkbox1, div1, null);
        append(div1, t15);
        append(div1, br);
        append(div1, t16);
        if (if_block0) if_block0.m(div1, null);
        append(div1, t17);
        append(div1, div0);
        mount_component(iconbutton0, div0, null);
        append(div0, t18);
        append(div0, span4);
        append(span4, t19);
        append(span4, t20);
        append(div0, t21);
        mount_component(iconbutton1, div0, null);
        append(div3, t22);
        append(div3, div2);
        if (if_block1) if_block1.m(div2, null);
        append(div3, t23);
        if (if_block2) if_block2.m(div3, null);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              input0,
              "input",
              /*input0_input_handler*/
              ctx[14]
            ),
            listen(
              input1,
              "input",
              /*input1_input_handler*/
              ctx[15]
            ),
            listen(
              input2,
              "input",
              /*input2_input_handler*/
              ctx[16]
            ),
            listen(
              input3,
              "input",
              /*input3_input_handler*/
              ctx[17]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty[0] & /*authorQuery*/
        8 && input0.value !== /*authorQuery*/
        ctx2[3]) {
          set_input_value(
            input0,
            /*authorQuery*/
            ctx2[3]
          );
        }
        if (dirty[0] & /*titleQuery*/
        16 && input1.value !== /*titleQuery*/
        ctx2[4]) {
          set_input_value(
            input1,
            /*titleQuery*/
            ctx2[4]
          );
        }
        if (dirty[0] & /*createdBeforeQuery*/
        128) {
          set_input_value(
            input2,
            /*createdBeforeQuery*/
            ctx2[7]
          );
        }
        if (dirty[0] & /*createdAfterQuery*/
        256) {
          set_input_value(
            input3,
            /*createdAfterQuery*/
            ctx2[8]
          );
        }
        const checkbox0_changes = {};
        if (!updating_checked && dirty[0] & /*createdInPrivateLobbyQuery*/
        32) {
          updating_checked = true;
          checkbox0_changes.checked = /*createdInPrivateLobbyQuery*/
          ctx2[5];
          add_flush_callback(() => updating_checked = false);
        }
        checkbox0.$set(checkbox0_changes);
        const checkbox1_changes = {};
        if (!updating_checked_1 && dirty[0] & /*isOwnQuery*/
        64) {
          updating_checked_1 = true;
          checkbox1_changes.checked = /*isOwnQuery*/
          ctx2[6];
          add_flush_callback(() => updating_checked_1 = false);
        }
        checkbox1.$set(checkbox1_changes);
        if (
          /*$member*/
          ctx2[2] !== null
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty[0] & /*$member*/
            4) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_2$d(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(div1, t17);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        const iconbutton0_changes = {};
        if (dirty[0] & /*page*/
        2) iconbutton0_changes.disabled = /*page*/
        ctx2[1] <= 0;
        iconbutton0.$set(iconbutton0_changes);
        if ((!current || dirty[0] & /*page*/
        2) && t20_value !== (t20_value = /*page*/
        ctx2[1] + 1 + "")) set_data(t20, t20_value);
        if (!current || dirty[0] & /*selectedImage*/
        1024) {
          toggle_class(
            div1,
            "present",
            /*selectedImage*/
            ctx2[10] !== null
          );
        }
        if (
          /*$member*/
          ctx2[2] !== null && /*images*/
          ctx2[11] !== null
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty[0] & /*$member, images*/
            2052) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_1$g(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(div2, null);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
        if (!current || dirty[0] & /*selectedImage*/
        1024) {
          toggle_class(
            div2,
            "present",
            /*selectedImage*/
            ctx2[10] !== null
          );
        }
        if (
          /*selectedImage*/
          ctx2[10] !== null
        ) {
          if (if_block2) {
            if_block2.p(ctx2, dirty);
            if (dirty[0] & /*selectedImage*/
            1024) {
              transition_in(if_block2, 1);
            }
          } else {
            if_block2 = create_if_block$x(ctx2);
            if_block2.c();
            transition_in(if_block2, 1);
            if_block2.m(div3, null);
          }
        } else if (if_block2) {
          group_outros();
          transition_out(if_block2, 1, 1, () => {
            if_block2 = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(checkbox0.$$.fragment, local);
        transition_in(checkbox1.$$.fragment, local);
        transition_in(if_block0);
        transition_in(iconbutton0.$$.fragment, local);
        transition_in(iconbutton1.$$.fragment, local);
        transition_in(if_block1);
        transition_in(if_block2);
        current = true;
      },
      o(local) {
        transition_out(checkbox0.$$.fragment, local);
        transition_out(checkbox1.$$.fragment, local);
        transition_out(if_block0);
        transition_out(iconbutton0.$$.fragment, local);
        transition_out(iconbutton1.$$.fragment, local);
        transition_out(if_block1);
        transition_out(if_block2);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div3);
        }
        destroy_component(checkbox0);
        destroy_component(checkbox1);
        if (if_block0) if_block0.d();
        destroy_component(iconbutton0);
        destroy_component(iconbutton1);
        if (if_block1) if_block1.d();
        if (if_block2) if_block2.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$1g, "create_fragment$1g");
  const pageSize = 200;
  const click_handler_5 = /* @__PURE__ */ __name((e) => e.stopImmediatePropagation(), "click_handler_5");
  function instance$18($$self, $$props, $$invalidate) {
    let $member;
    let { feature } = $$props;
    const member = feature.memberStore;
    component_subscribe($$self, member, (value) => $$invalidate(2, $member = value));
    let page = 0;
    let authorQuery = "";
    let titleQuery = "";
    let createdInPrivateLobbyQuery = false;
    let isOwnQuery = false;
    let createdBeforeQuery = /* @__PURE__ */ new Date();
    let createdAfterQuery = new Date((/* @__PURE__ */ new Date()).setFullYear(2020, 9, 1));
    let hiddenImages = [];
    const search = /* @__PURE__ */ __name((login, resetPage = false) => {
      if (resetPage) $$invalidate(1, page = 0);
      return feature.getImages(
        {
          page,
          pageSize,
          authorQuery,
          titleQuery,
          isOwnQuery,
          createdInPrivateLobbyQuery,
          createdAfterQuery: createdAfterQuery !== "" ? new Date(createdAfterQuery).getTime().toString() : void 0,
          createdBeforeQuery: createdBeforeQuery !== "" ? new Date(createdBeforeQuery).getTime().toString() : void 0
        },
        login
      );
    }, "search");
    let selectedImage = null;
    let images = $member ? search(Number($member.userLogin)) : null;
    function input0_input_handler() {
      authorQuery = this.value;
      $$invalidate(3, authorQuery);
    }
    __name(input0_input_handler, "input0_input_handler");
    function input1_input_handler() {
      titleQuery = this.value;
      $$invalidate(4, titleQuery);
    }
    __name(input1_input_handler, "input1_input_handler");
    function input2_input_handler() {
      createdBeforeQuery = this.value;
      $$invalidate(7, createdBeforeQuery);
    }
    __name(input2_input_handler, "input2_input_handler");
    function input3_input_handler() {
      createdAfterQuery = this.value;
      $$invalidate(8, createdAfterQuery);
    }
    __name(input3_input_handler, "input3_input_handler");
    function checkbox0_checked_binding(value) {
      createdInPrivateLobbyQuery = value;
      $$invalidate(5, createdInPrivateLobbyQuery);
    }
    __name(checkbox0_checked_binding, "checkbox0_checked_binding");
    function checkbox1_checked_binding(value) {
      isOwnQuery = value;
      $$invalidate(6, isOwnQuery);
    }
    __name(checkbox1_checked_binding, "checkbox1_checked_binding");
    const click_handler_1 = /* @__PURE__ */ __name(() => $$invalidate(11, images = search(Number($member == null ? void 0 : $member.userLogin), true)), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(() => $$invalidate(1, page--, page), "click_handler_2");
    const click_handler_3 = /* @__PURE__ */ __name(() => $$invalidate(1, page++, page), "click_handler_3");
    const click_handler_4 = /* @__PURE__ */ __name((image) => $$invalidate(10, selectedImage = image), "click_handler_4");
    const click_handler_6 = /* @__PURE__ */ __name(() => $$invalidate(10, selectedImage = null), "click_handler_6");
    const click_handler_7 = /* @__PURE__ */ __name(async () => {
      if ($member === null || $member === void 0 || selectedImage === null) throw new Error("illegal state");
      await feature.saveAsPng(selectedImage);
    }, "click_handler_7");
    const click_handler_8 = /* @__PURE__ */ __name(async () => {
      if ($member === null || $member === void 0 || selectedImage === null) throw new Error("illegal state");
      await feature.saveAsGif(selectedImage);
    }, "click_handler_8");
    const click_handler_9 = /* @__PURE__ */ __name(async () => {
      if ($member === null || $member === void 0 || selectedImage === null) throw new Error("illegal state");
      await feature.copyToClipboard(selectedImage);
    }, "click_handler_9");
    const click_handler_10 = /* @__PURE__ */ __name(async () => {
      if ($member === null || $member === void 0 || selectedImage === null) throw new Error("illegal state");
      await feature.addToImagePost(selectedImage, $member);
    }, "click_handler_10");
    const click_handler_11 = /* @__PURE__ */ __name(async () => {
      if ($member === null || $member === void 0 || selectedImage === null) throw new Error("illegal state");
      await feature.addToImageLab(selectedImage);
    }, "click_handler_11");
    const click_handler_12 = /* @__PURE__ */ __name(async () => {
      if ($member === null || $member === void 0 || selectedImage === null) throw new Error("illegal state");
      await feature.deleteImage(selectedImage.id, Number($member.userLogin));
      $$invalidate(9, hiddenImages = [...hiddenImages, selectedImage.id]);
      $$invalidate(10, selectedImage = null);
    }, "click_handler_12");
    function click_handler2(event) {
      bubble.call(this, $$self, event);
    }
    __name(click_handler2, "click_handler");
    const click_handler_13 = /* @__PURE__ */ __name(() => $$invalidate(10, selectedImage = null), "click_handler_13");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & /*page, $member*/
      6) {
        $$invalidate(11, images = $member ? search(Number($member.userLogin)) : null);
      }
    };
    return [
      feature,
      page,
      $member,
      authorQuery,
      titleQuery,
      createdInPrivateLobbyQuery,
      isOwnQuery,
      createdBeforeQuery,
      createdAfterQuery,
      hiddenImages,
      selectedImage,
      images,
      member,
      search,
      input0_input_handler,
      input1_input_handler,
      input2_input_handler,
      input3_input_handler,
      checkbox0_checked_binding,
      checkbox1_checked_binding,
      click_handler_1,
      click_handler_2,
      click_handler_3,
      click_handler_4,
      click_handler_6,
      click_handler_7,
      click_handler_8,
      click_handler_9,
      click_handler_10,
      click_handler_11,
      click_handler_12,
      click_handler2,
      click_handler_13
    ];
  }
  __name(instance$18, "instance$18");
  const _Controls_cloud = class _Controls_cloud extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$18, create_fragment$1g, safe_not_equal, { feature: 0 }, null, [-1, -1]);
    }
  };
  __name(_Controls_cloud, "Controls_cloud");
  let Controls_cloud = _Controls_cloud;
  var __defProp$T = Object.defineProperty;
  var __decorateClass$T = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$T(target, key2, result);
    return result;
  }, "__decorateClass$T");
  const _ControlsCloudFeature = class _ControlsCloudFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_modalService");
      __publicField(this, "_memberService");
      __publicField(this, "_cloudService");
      __publicField(this, "_imagePostService");
      __publicField(this, "_imageLabService");
      __publicField(this, "_toastService");
      __publicField(this, "_apiService");
      __publicField(this, "_imageFinishedService");
      __publicField(this, "name", "Typo Cloud");
      __publicField(this, "description", "Saves all images from your lobbies in a cloud and adds a gallery to browse them");
      __publicField(this, "tags", [
        FeatureTag.PALANTIR
      ]);
      __publicField(this, "featureId", 17);
      __publicField(this, "_iconComponent");
      __publicField(this, "_iconClickSubscription");
      __publicField(this, "_cloudSavedSubscription");
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._iconComponent = new Icon_button({
        target: elements2.controls,
        props: {
          hoverMove: false,
          size: "48px",
          icon: "file-img-cloud-gif",
          name: "Typo Cloud",
          order: 2,
          tooltipAction: this.createTooltip
        }
      });
      this._cloudSavedSubscription = this._imageFinishedService.imageFinished$.pipe(
        withLatestFrom(this._memberService.member$)
      ).subscribe(async ([image, member]) => {
        if (image === null || member === null || member === void 0) {
          this._logger.debug("Did not save image because either member or image not defined");
          return;
        }
        await this._cloudService.uploadToCloud(image, member, true);
      });
      this._iconClickSubscription = this._iconComponent.click$.subscribe(() => {
        const settingsComponent = {
          componentType: Controls_cloud,
          props: {
            feature: this
          }
        };
        this._modalService.showModal(settingsComponent.componentType, settingsComponent.props, "Typo Cloud");
      });
    }
    onDestroy() {
      var _a2, _b2, _c2;
      (_a2 = this._iconClickSubscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._iconComponent) == null ? void 0 : _b2.$destroy();
      (_c2 = this._cloudSavedSubscription) == null ? void 0 : _c2.unsubscribe();
    }
    get memberStore() {
      return fromObservable(this._memberService.member$, void 0);
    }
    async getImages(search, login) {
      if (search.authorQuery === "") search.authorQuery = void 0;
      if (search.titleQuery === "") search.titleQuery = void 0;
      if (search.createdInPrivateLobbyQuery === false) search.createdInPrivateLobbyQuery = void 0;
      if (search.isOwnQuery === false) search.isOwnQuery = void 0;
      return this._apiService.getApi(CloudApi).searchUserCloud({ login, cloudSearchDto: search });
    }
    async deleteImage(id2, login) {
      const toast = await this._toastService.showLoadingToast("Removing image from cloud");
      try {
        const image = await this._apiService.getApi(CloudApi).deleteImageFromUserCloud({ login, id: id2 });
        toast.resolve();
        return image;
      } catch {
        toast.reject();
      }
    }
    async addToImagePost(image, member) {
      const toast = await this._toastService.showLoadingToast("Adding image to history");
      try {
        const meta = await getCloudMeta(image.metaUrl);
        const commands = await getCloudCommands(image.commandsUrl);
        const imageData = await ImageData.fromImageUrl(image.imageUrl);
        const skribblImage = {
          name: image.name,
          artist: image.author,
          private: meta.private,
          isOwn: meta.own,
          language: meta.language,
          player: member.userName,
          date: new Date(meta.date),
          commands,
          image: imageData
        };
        this._imagePostService.addToHistory(skribblImage);
        toast.resolve();
      } catch {
        toast.reject();
      }
    }
    async saveAsPng(image) {
      const toast = await this._toastService.showLoadingToast("Downloading image");
      try {
        const imageData = await ImageData.fromImageUrl(image.imageUrl);
        downloadBlob(imageData.blob, `skribbl-${image.name}-by-${image.author}.png`);
        toast.resolve();
      } catch (e) {
        this._logger.error("Failed to download image", e);
        toast.reject();
        throw e;
      }
    }
    async saveAsGif(image) {
      const toast = await this._toastService.showStickyToast("Saving as GIF");
      const durationPrompt = await this._toastService.showPromptToast("Enter GIF duration", "Enter the preferred duration in seconds");
      const duration = await durationPrompt.result;
      const durationMs = parseFloat(duration ?? "") * 1e3;
      if (duration === null) {
        toast.close();
        return;
      }
      if (Number.isNaN(durationMs)) {
        toast.resolve("Invalid duration entered");
        return;
      }
      try {
        const commands = await getCloudCommands(image.commandsUrl);
        const progressBar = /* @__PURE__ */ __name((progress) => {
          const doneChar = "█";
          const leftChar = "░";
          const length = 10;
          const done = Math.floor(progress * length);
          const left = length - done;
          return `${doneChar.repeat(done)}${leftChar.repeat(left)}`;
        }, "progressBar");
        const workerBlob = new Blob([gifRendererWorkerJs], { type: "application/javascript" });
        const worker = new TypedWorkerExecutor(
          URL.createObjectURL(workerBlob),
          {
            frameRendered: /* @__PURE__ */ __name((index, total) => {
              toast.update(`Rendering GIF..   ${progressBar(index / total)} (${Math.floor(index * 100 / total).toString().padStart(2, " ")}%)`);
            }, "frameRendered")
          }
        );
        const name = `${image.name}-by-${image.author}`;
        const gif = await worker.run("renderGif", commands, durationMs);
        downloadBlob(gif, `${name}.gif`.replaceAll(" ", "_"));
        toast.resolve(`${name} saved as GIF`);
      } catch (e) {
        this._logger.error("Failed to download image", e);
        toast.resolve("An error occurred");
        throw e;
      }
    }
    async copyToClipboard(image) {
      const toast = await this._toastService.showLoadingToast("Copying image link");
      try {
        await navigator.clipboard.writeText(image.imageUrl);
        toast.resolve();
      } catch (e) {
        this._logger.error("Failed to copy image link to clipboard", e);
        toast.reject();
        throw e;
      }
    }
    async addToImageLab(image) {
      const toast = await this._toastService.showLoadingToast("Adding image to image lab");
      try {
        const commands = await getCloudCommands(image.commandsUrl);
        this._imageLabService.saveDrawCommands(`${image.name}-by-${image.author}`, commands);
        toast.resolve();
      } catch {
        toast.reject("Is the image lab feature enabled?");
      }
    }
  };
  __name(_ControlsCloudFeature, "ControlsCloudFeature");
  let ControlsCloudFeature = _ControlsCloudFeature;
  __decorateClass$T([
    inject(ElementsSetup)
  ], ControlsCloudFeature.prototype, "_elementsSetup");
  __decorateClass$T([
    inject(ModalService)
  ], ControlsCloudFeature.prototype, "_modalService");
  __decorateClass$T([
    inject(MemberService)
  ], ControlsCloudFeature.prototype, "_memberService");
  __decorateClass$T([
    inject(CloudService)
  ], ControlsCloudFeature.prototype, "_cloudService");
  __decorateClass$T([
    inject(ImagePostService)
  ], ControlsCloudFeature.prototype, "_imagePostService");
  __decorateClass$T([
    inject(ImagelabService)
  ], ControlsCloudFeature.prototype, "_imageLabService");
  __decorateClass$T([
    inject(ToastService)
  ], ControlsCloudFeature.prototype, "_toastService");
  __decorateClass$T([
    inject(ApiService)
  ], ControlsCloudFeature.prototype, "_apiService");
  __decorateClass$T([
    inject(ImageFinishedService)
  ], ControlsCloudFeature.prototype, "_imageFinishedService");
  var __defProp$S = Object.defineProperty;
  var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
  var __decorateClass$S = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$S(target, key2, result);
    return result;
  }, "__decorateClass$S");
  var __decorateParam$6 = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$6");
  let FeaturesService = (_ta = class {
    constructor(loggerFactory2) {
      __publicField(this, "_logger");
      __publicField(this, "_features", []);
      __publicField(this, "_featureStates", new Subject$1());
      this._logger = loggerFactory2(this);
    }
    async registerFeature(feature) {
      if (this.features.some((f) => f.featureId === feature.featureId)) {
        this._logger.error("Attempted to register a feature with a duplicate ID", feature.name);
        throw new Error("Duplicate feature ID");
      }
      this._features.push(feature);
      feature.activated$.subscribe((state) => this._featureStates.next({ feature, running: state }));
    }
    get features() {
      return [...this._features];
    }
    async activateFeature(featureType) {
      const feature = this._features.find((f) => f instanceof featureType);
      if (!feature) {
        this._logger.error("Attempted to activate a feature that is not registered", feature);
        throw new Error("Feature not registered");
      }
      return feature.activate();
    }
  }, __name(_ta, "FeaturesService"), _ta);
  FeaturesService = __decorateClass$S([
    injectable(),
    __decorateParam$6(0, inject(loggerFactory))
  ], FeaturesService);
  const themeColors = Object.freeze({
    "--COLOR_PANEL_BG": [226, 85, 32, 0.75],
    "--COLOR_PANEL_LO": [226, 90, 27, 0.75],
    "--COLOR_PANEL_BUTTON": [226, 67, 49],
    "--COLOR_PANEL_BUTTON_HOVER": [226, 73, 43],
    "--COLOR_PANEL_BUTTON_ACTIVE": [226, 72, 41],
    "--COLOR_PANEL_HI": [226, 80, 44],
    "--COLOR_PANEL_FOCUS": [32, 85, 56],
    "--COLOR_PANEL_BORDER": [232, 85, 11],
    "--COLOR_PANEL_BORDER_FOCUS": [207, 98, 66],
    "--COLOR_PANEL_TEXT": [0, 0, 94],
    "--COLOR_PANEL_TEXT_FOCUS": [0, 0, 100],
    "--COLOR_PANEL_TEXT_PLACEHOLDER": [0, 0, 61],
    "--COLOR_TOOL_BASE": [0, 0, 100],
    "--COLOR_TOOL_HOVER": [0, 0, 77],
    "--COLOR_TOOL_TEXT": [0, 0, 0],
    "--COLOR_TOOL_SIZE_BASE": [0, 0, 100],
    "--COLOR_TOOL_SIZE_HOVER": [0, 0, 77],
    "--COLOR_TOOL_ACTIVE": [271, 77, 66],
    "--COLOR_TOOL_SIZE_ACTIVE": [271, 77, 66],
    "--COLOR_INPUT_BG": [0, 0, 100],
    "--COLOR_INPUT_HOVER": [0, 0, 100],
    "--COLOR_INPUT_TEXT": [0, 0, 17],
    "--COLOR_INPUT_BORDER": [0, 0, 44],
    "--COLOR_INPUT_BORDER_FOCUS": [207, 98, 66],
    "--COLOR_PLAYER_TEXT_BASE": [0, 0, 0],
    "--COLOR_PLAYER_ME": [214, 100, 64],
    "--COLOR_PLAYER_ME_GUESSED": [216, 100, 35],
    "--COLOR_PLAYER_BG_BASE": [0, 0, 100],
    "--COLOR_PLAYER_BG_ALT": [0, 0, 93],
    "--COLOR_PLAYER_BG_GUESSED_BASE": [113, 68, 58],
    "--COLOR_PLAYER_BG_GUESSED_ALT": [113, 57, 50],
    "--COLOR_TOOL_TIP_BG": [226, 100, 64],
    "--COLOR_GAMEBAR_TEXT": [0, 0, 0],
    "--COLOR_GAMEBAR_ROUND_TEXT": [0, 0, 0],
    "--COLOR_GAMEBAR_WORD_DESCRIPTION": [0, 0, 21],
    "--COLOR_TEXT_CANVAS_TRANSPARENT": [0, 0, 25],
    "--COLOR_CHAT_TEXT_BASE": [0, 0, 0],
    "--COLOR_CHAT_TEXT_GUESSED": [103, 68, 48],
    "--COLOR_CHAT_TEXT_CLOSE": [54, 100, 44],
    "--COLOR_CHAT_TEXT_DRAWING": [216, 60, 52],
    "--COLOR_CHAT_TEXT_JOIN": [103, 68, 48],
    "--COLOR_CHAT_TEXT_LEAVE": [21, 91, 42],
    "--COLOR_CHAT_TEXT_OWNER": [32, 100, 63],
    "--COLOR_CHAT_TEXT_GUESSCHAT": [86, 47, 46],
    "--COLOR_CHAT_BG_BASE": [0, 0, 100],
    "--COLOR_CHAT_BG_ALT": [0, 0, 93],
    "--COLOR_CHAT_SCROLLBAR": [0, 0, 49],
    "--COLOR_CHAT_SCROLLBAR_THUMB": [0, 0, 78],
    "--COLOR_CHAT_BG_GUESSED_BASE": [105, 100, 94],
    "--COLOR_CHAT_BG_GUESSED_ALT": [104, 100, 87],
    "--COLOR_CHAT_INPUT_COUNT": [0, 0, 0],
    "--COLOR_BUTTON_DANGER_BG": [44, 81, 51],
    "--COLOR_BUTTON_SUBMIT_BG": [110, 75, 55],
    "--COLOR_BUTTON_NORMAL_BG": [208, 80, 54],
    "--COLOR_BUTTON_DANGER_TEXT": [0, 0, 100],
    "--COLOR_BUTTON_SUBMIT_TEXT": [0, 0, 100],
    "--COLOR_BUTTON_NORMAL_TEXT": [0, 0, 100]
  });
  const createEmptyTheme = /* @__PURE__ */ __name((author, name, id2) => {
    const date = /* @__PURE__ */ new Date();
    const theme = {
      meta: {
        author,
        created: date.getTime(),
        id: id2 === void 0 ? date.getTime() : id2,
        name: name ?? `Untitled Theme ${date.getTime()}`,
        type: "theme"
      },
      colors: structuredClone(themeColors),
      hooks: {},
      images: {},
      misc: {}
    };
    return theme;
  }, "createEmptyTheme");
  function convertOldTheme(options, theme) {
    theme.images.urlLogo = options.urlLogo;
    theme.images.urlBackground = options.urlBackground;
    theme.images.urlBackgroundGame = options.urlBackgroundGame;
    theme.misc.fontStyle = options.fontStyle;
    theme.misc.htmlText = options.injection;
    let css2 = "";
    if (options["containerBackgroundsCheck"] == true) {
      const val = options["containerBackgrounds"] ? options["containerBackgrounds"].trim() : "";
      css2 += ":root {--COLOR_PANEL_BUTTON: " + (val != "" ? val : "transparent") + " !important}";
      css2 += "#setting-bar .content, #emojiPrev, #imageAgent, #home .news ::-webkit-scrollbar, #home .news ::-webkit-scrollbar-thumb, .modalContainer, .toast, #modal .box, #home .panel, #home .bottom .footer {background-color: " + (val != "" ? val : "transparent") + " !important}";
      css2 += "#home .bottom svg {fill: " + (val != "" ? val : "transparent") + " !important}";
    }
    if (options["containerBackgroundsCheck"] == true && options["ingameContainerBackgroundsCheck"] !== false) {
      options["ingameContainerBackgrounds"] = options["containerBackgrounds"];
      options["ingameContainerBackgroundsCheck"] = true;
    }
    if (options["ingameContainerBackgroundsCheck"] == true) {
      const val = options["ingameContainerBackgrounds"] ? options["ingameContainerBackgrounds"].trim() : "";
      css2 += "#game-bar, .clickable,  #game-room .settings, #game-room .players,   .tooltip .tooltip-content, #imageAgent, #gamemodePopup, #optionsPopup, #downloadPopup, #sharePopup, #typoUserInfo, #imageOptions, div#game-toolbar.typomod div.tools-container div.tools div.tool, #game-toolbar divdiv.preview div.graphic-container, #game-room .container-settings, #game-chat .container, #game-players .players-list .player, #game-players .players-list .player.odd {background-color: " + (val != "" ? val : "transparent") + " !important}";
      css2 += "#game-players .players-list .player.odd{background-image: linear-gradient(0, " + (val != "" ? val : "transparent") + ", " + (val != "" ? val : "transparent") + ");}";
      css2 += "#game-chat .chat-content {background:none}";
      css2 += ":root{ --COLOR_TOOL_TIP_BG: " + val + " !important; --COLOR_CHAT_BG_BASE: " + val + " !important; } ";
      css2 += "#game-players div.list div.player div.bubble div.arrow{border-right-color:" + val + "} #game-players div.list div.player div.bubble div.content{background-color:" + val + "}";
      css2 += "#game-chat .chat-content p:nth-child(even), #game-chat .chat-content p.guessed:nth-child(even) {background-color: #ffffff20;} #game-chat .chat-content p.guessed:nth-child(odd){background-color:transparent}";
    }
    if (options["containerOutlinesCheck"] == true) {
      const val = options["containerOutlines"] ? options["containerOutlines"].trim() : "";
      css2 += "#game-bar,  #game-room .settings, #game-room .players,   #imageAgent, #modal .box, #home .panel, .modalContainer, #game-chat, #game-players .players-list .player, #imageOptions {border-radius: 4px; border: 2px solid " + (val != "" ? val : "transparent") + " !important}";
    }
    if (options["containerImages"] && options["containerImages"].trim() != "") {
      css2 += "#game-bar, #game-room .settings, #game-room .players,  #imageAgent, #gamemodePopup, #optionsPopup, #downloadPopup, #sharePopup, #typoUserInfo, #imageOptions, #game-room .container-settings, #game-chat, #game-players .players-list  {background-image: url(" + options["containerImages"].trim() + ") !important}";
      css2 += "#game-players .players-list {background:none !important}";
    }
    const color = options["fontColor"] ? options["fontColor"] : "";
    if (color && color != "") {
      css2 += "#home .bottom .footer .notice, *:not(.chat-content *), .characters {color:" + color.trim() + " !important}";
      css2 += "input[type=checkbox].flatUI, #game-chat form input, input[type=text].flatUI, #home .bottom .footer .section-container .section{color:unset}";
    }
    if (!options["ingameFontColor"] && options["fontColor"]) {
      options["ingameFontColor"] = options["fontColor"];
    }
    const ingamecolor = options["ingameFontColor"] ? options["ingameFontColor"] : "";
    if (ingamecolor && ingamecolor != "") {
      css2 += ":root{ --COLOR_CHAT_TEXT_BASE:" + ingamecolor.trim() + " !important}";
      css2 += "#game *:not(.chat-content *) {color:" + ingamecolor.trim() + "}";
      css2 += "div#game-toolbar.typomod div.tools-container div.tools div.tool div.key, #game-word .description, #game-round .round-max, #game-round span, #game-players .player-amount b:nth-child(4), #game-players .player-amount span {color:" + ingamecolor.trim() + "; filter: brightness(0.8);}";
    }
    const colorBtns = options["fontColorButtons"] ? options["fontColorButtons"] : "";
    if (colorBtns && colorBtns != "") css2 += "select, input, button, textarea {color:" + colorBtns.trim() + "}";
    if (ingamecolor || color || colorBtns) css2 += "#game-clock{color:black !important}";
    if (options["inputBackgroundsCheck"] == true) {
      const val = options["inputBackgrounds"] ? options["inputBackgrounds"].trim() : "";
      css2 += "input[type=checkbox], input[type=checkbox].flatUI,#modal .container .box .content .container-rooms .room, button.flatUI.green,button.flatUI.orange, button.flatUI.blue, button.flatUI, input[type=text].flatUI, .link .input-container .link-overlay, input, textarea, button, select, #quickreact > span {background: " + (val != "" ? val : "transparent") + " !important; box-shadow:none !important;} ";
      css2 += "button:is(.flatUI, .flatUI.green, .flatUI.orange, .flatUI.blue):is(:hover, :active, :focus), input:is(:hover, :active, :focus), textarea:is(:hover, :active, :focus), button:is(:hover, :active, :focus), select:is(:hover, :active, :focus) {background: " + (val != "" ? val : "transparent") + " !important; opacity: 0.75}";
      css2 += ":is(#game-room .container-settings .group.customwords .checkbox, .report-menu) input[type=checkbox]:checked:after { content: '🞬'; height:100%; width: 100%; display: grid; place-content: center;}";
    }
    if (options["inputOutlinesCheck"] == true) {
      const val = options["inputOutlines"] ? options["inputOutlines"].trim() : "";
      css2 += ".link .input-container .link-overlay {display:none !important} input[type=checkbox]{border:none !important;} input, textarea, button, select {border: 2px solid " + (val != "" ? val : "transparent") + " !important; }";
    }
    if (options["hideFooter"] == true) {
      css2 += ".tos, .notice {display:none}";
    }
    if (options["hideTypoInfo"] == true) {
      css2 += "#typoUserInfo {display:none !important}";
    }
    if (options["hideDiscord"] == true) {
      css2 += "#home .socials {opacity:0}";
    }
    if (options["hideInGameLogo"] == true) {
      css2 += "#game #game-logo{display:none} #game{margin-top:2em}";
    }
    if (options["hideAvatarLogo"] == true) {
      css2 += "#home .logo-big .avatar-container {display:none }";
    }
    if (options["hideTypoPanels"] == true) {
      css2 += "#panelgrid .panel:is(:first-child, :last-child) {display:none } #panelgrid{grid-template-columns: 100% !important}";
    }
    if (options["hideAvatarSprites"] == true) {
      css2 += ".avatar-customizer .spriteSlot{display:none }";
      css2 += ".avatar-customizer {background-image: unset !important }";
      css2 += ".avatar-customizer .color, .avatar-customizer .mouth, .avatar-customizer .eyes {opacity: 1 !important}";
    }
    theme.misc.cssText = css2;
  }
  __name(convertOldTheme, "convertOldTheme");
  var __defProp$R = Object.defineProperty;
  var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
  var __decorateClass$R = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$R(target, key2, result);
    return result;
  }, "__decorateClass$R");
  var __decorateParam$5 = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$5");
  let ThemesService = (_ua = class {
    constructor(loggerFactory2, _elementsSetup, _apiService) {
      __publicField(this, "_logger");
      __publicField(this, "_originalTheme", createEmptyTheme("Mel", "Original Skribbl", 0));
      __publicField(this, "_activeThemeSetting", new ExtensionSetting("active_theme_local_id", void 0));
      __publicField(this, "_savedThemesSetting", new ExtensionSetting("saved_themes", [{
        theme: this._originalTheme,
        savedAt: Date.now(),
        enableManage: false
      }]));
      __publicField(this, "_loadedEditorTheme$", new BehaviorSubject(void 0));
      this._elementsSetup = _elementsSetup;
      this._apiService = _apiService;
      this._logger = loggerFactory2(this);
    }
    get activeThemeSetting() {
      return this._activeThemeSetting.asFrozen;
    }
    get savedThemesSetting() {
      return this._savedThemesSetting.asFrozen;
    }
    get loadedEditorTheme$() {
      return this._loadedEditorTheme$.asObservable();
    }
    get loadedEditorThemeStore() {
      return fromObservable(this._loadedEditorTheme$, this._loadedEditorTheme$.value);
    }
    /**
     * Load a theme to the editor; might receive changes via updateLoadedEditorTheme without saving later
     * @param theme
     */
    async loadThemeToEditor(theme) {
      this._logger.info("Loading theme to editor", theme);
      const themes = await this._savedThemesSetting.getValue();
      const existingTheme = themes.find((t) => t.theme.meta.id === theme.theme.meta.id);
      if (existingTheme === void 0) {
        this._logger.error("Theme not found", theme);
        throw new Error("Theme not found");
      }
      this._loadedEditorTheme$.next(structuredClone(theme));
    }
    /**
     * Update the loaded theme in the editor
     * @param theme
     */
    updateLoadedEditorTheme(theme) {
      var _a2;
      this._logger.debug("Updating loaded theme", theme);
      if (((_a2 = this._loadedEditorTheme$.value) == null ? void 0 : _a2.theme.meta.id) !== theme.theme.meta.id) {
        this._logger.error("Theme not loaded or different theme loaded", theme);
        throw new Error("Theme not loaded or different theme loaded");
      }
      this._loadedEditorTheme$.next(structuredClone(theme));
    }
    /**
     * Unload a theme from the editor
     */
    async unloadThemeFromEditor() {
      this._logger.info("Unloading theme from editor");
      this._loadedEditorTheme$.next(void 0);
    }
    /**
     * Create an empty new local theme and sore it
     */
    async createLocalTheme() {
      this._logger.info("Creating new theme");
      const elements2 = await this._elementsSetup.complete();
      const username = elements2.inputName.value.length > 0 ? elements2.inputName.value : "User";
      const theme = createEmptyTheme(username, "Untitled Theme");
      const themes = await this._savedThemesSetting.getValue();
      const newTheme = {
        theme,
        savedAt: Date.now(),
        enableManage: true
      };
      await this._savedThemesSetting.setValue([newTheme, ...themes]);
      return newTheme;
    }
    /**
     * Save the state of the loaded theme in the editor to the original local theme and unload theme from editor
     */
    async saveLoadedEditorTheme() {
      this._logger.info("Updating local theme and unloading from editor");
      const editorTheme = this._loadedEditorTheme$.value;
      const themes = await this._savedThemesSetting.getValue();
      const savedTheme = themes.find((t) => t.theme.meta.id === (editorTheme == null ? void 0 : editorTheme.theme.meta.id));
      if (editorTheme === void 0 || savedTheme === void 0) {
        this._logger.error("Theme to update not found", editorTheme);
        throw new Error("Theme to update not found");
      }
      savedTheme.theme = editorTheme.theme;
      savedTheme.savedAt = Date.now();
      await this._savedThemesSetting.setValue([savedTheme, ...themes.filter((t) => t.theme.meta.id !== savedTheme.theme.meta.id)]);
      this._loadedEditorTheme$.next(void 0);
      await this._activeThemeSetting.setValue(savedTheme.theme.meta.id);
      return savedTheme;
    }
    async importOldTheme(options, name) {
      this._logger.info("Importing old theme", options);
      const theme = createEmptyTheme("Unknown", name);
      convertOldTheme(options, theme);
      const themes = await this._savedThemesSetting.getValue();
      const existingTheme = themes.find((t) => t.theme.meta.id === theme.meta.id);
      if (existingTheme !== void 0) {
        this._logger.warn("Theme already exists, assigning new ID", theme);
        theme.meta.id = Date.now();
      }
      const savedTheme = {
        theme,
        savedAt: Date.now(),
        publicTheme: void 0,
        enableManage: true
      };
      await this._savedThemesSetting.setValue([savedTheme, ...themes]);
      return savedTheme;
    }
    async importThemeFromString(themeString) {
      const theme = JSON.parse(themeString);
      if (typeof theme !== "object" || theme === null) {
        throw new Error("Invalid theme data");
      }
      const savedTheme = {
        theme,
        savedAt: Date.now(),
        publicTheme: void 0,
        enableManage: true
      };
      const themes = await this._savedThemesSetting.getValue();
      const existingTheme = themes.find((t) => t.theme.meta.id === theme.meta.id);
      if (existingTheme !== void 0) {
        this._logger.warn("Theme already exists, assigning new ID", theme);
        theme.meta.id = Date.now();
      }
      await this._savedThemesSetting.setValue([savedTheme, ...themes]);
      return savedTheme;
    }
    /**
     * Download a featured theme and save to local themes
     * @param theme
     */
    async savePublicTheme(theme) {
      this._logger.info("Saving public theme", theme);
      const themeData = await this._apiService.getApi(ThemesApi).useThemeById({ id: theme.id });
      const saveData = {
        theme: themeData,
        savedAt: Date.now(),
        publicTheme: {
          publicId: theme.id,
          localVersion: theme.version
        },
        enableManage: false
      };
      let currentThemes = await this._savedThemesSetting.getValue();
      const existingTheme = currentThemes.find((t) => t.theme.meta.id === themeData.meta.id);
      if (existingTheme !== void 0) {
        this._logger.warn("Theme already saved", theme);
        return existingTheme;
      }
      currentThemes = [saveData, ...currentThemes];
      await this._savedThemesSetting.setValue(currentThemes);
      return saveData;
    }
    /**
     * Activate a local theme
     */
    async activateLocalTheme(id2) {
      this._logger.info("Activating local theme", id2);
      const themes = await this._savedThemesSetting.getValue();
      const existingTheme = themes.find((t) => t.theme.meta.id === id2);
      if (existingTheme === void 0) {
        this._logger.warn("Local Theme not found", id2);
        throw new Error("Local Theme not found");
      }
      this._loadedEditorTheme$.next(void 0);
      await this._activeThemeSetting.setValue(existingTheme.theme.meta.id);
      return existingTheme;
    }
    /**
     * Activate a saved public theme
     */
    async activatePublicTheme(theme) {
      this._logger.debug("Getting saved theme of public listing", theme);
      const themes = await this._savedThemesSetting.getValue();
      const existingTheme = themes.find((t) => {
        var _a2;
        return ((_a2 = t.publicTheme) == null ? void 0 : _a2.publicId) === theme.id;
      });
      if (existingTheme === void 0) {
        this._logger.error("Theme not found", theme);
        throw new Error("Theme not found");
      }
      this._loadedEditorTheme$.next(void 0);
      await this._activeThemeSetting.setValue(existingTheme.theme.meta.id);
      return existingTheme;
    }
    /**
     * Removed a saved theme, no matter if local or public
     * @param localId
     */
    async removeSavedTheme(localId) {
      var _a2;
      this._logger.info("Removing saved theme", localId);
      const themes = await this._savedThemesSetting.getValue();
      const theme = themes.find((t) => t.theme.meta.id === localId);
      if (theme === void 0) {
        this._logger.error("Theme not found", localId);
        throw new Error("Theme not found");
      }
      const filtered = themes.filter((t) => t.theme.meta.id !== localId);
      await this._savedThemesSetting.setValue(filtered);
      if (((_a2 = this._loadedEditorTheme$.value) == null ? void 0 : _a2.theme.meta.id) === localId) {
        this._loadedEditorTheme$.next(void 0);
      }
      return theme;
    }
    /**
     * Share a theme by uploading it, creating a share id and copying it to clipboard
     * @param theme
     */
    async shareTheme(theme) {
      this._logger.debug("Sharing theme", theme);
      const response = await this._apiService.getApi(ThemesApi).shareTheme({ themeDto: theme });
      const shareId = response.id;
      this._logger.info("created theme share id:", response.id);
      return shareId;
    }
    /**
     * Import a theme by share id
     * @param shareId
     */
    async importTheme(shareId) {
      this._logger.debug("Importing theme", shareId);
      const theme = await this._apiService.getApi(ThemesApi).getThemeById({ id: shareId });
      this._logger.info("Loaded theme", theme);
      const themes = await this._savedThemesSetting.getValue();
      const existingTheme = themes.find((t) => t.theme.meta.id === theme.meta.id);
      if (existingTheme !== void 0) {
        this._logger.warn("Theme already exists, assigning new ID", theme);
        theme.meta.id = Date.now();
      }
      const savedTheme = {
        theme,
        savedAt: Date.now(),
        publicTheme: void 0,
        enableManage: true
      };
      await this._savedThemesSetting.setValue([savedTheme, ...themes]);
      return savedTheme;
    }
  }, __name(_ua, "ThemesService"), _ua);
  ThemesService = __decorateClass$R([
    injectable(),
    __decorateParam$5(0, inject(loggerFactory)),
    __decorateParam$5(1, inject(ElementsSetup)),
    __decorateParam$5(2, inject(ApiService))
  ], ThemesService);
  const getCssVariableSelectorHooks = /* @__PURE__ */ __name((cssText, colorVariables) => {
    var _a2;
    const parser = new DOMParser();
    const css2 = parser.parseFromString(`<style>${cssText}</style>`, "text/html").querySelector("style");
    const rules = (_a2 = css2 == null ? void 0 : css2.sheet) == null ? void 0 : _a2.cssRules;
    if (rules === null || rules === void 0) {
      throw new Error("Failed to parse css rules");
    }
    const variableSelectors = {};
    colorVariables.forEach((colorVariable) => {
      variableSelectors[colorVariable] = [];
    });
    for (const rule of rules) {
      if (rule instanceof CSSStyleRule) {
        for (const propertyName in rule.style) {
          const propertyValue = rule.style.getPropertyValue(propertyName);
          colorVariables.forEach((colorVariable) => {
            if (propertyValue.includes(`var(${colorVariable}`)) {
              variableSelectors[colorVariable].push(rule.selectorText);
            }
          });
        }
      }
    }
    return variableSelectors;
  }, "getCssVariableSelectorHooks");
  var __defProp$Q = Object.defineProperty;
  var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
  var __decorateClass$Q = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$Q(target, key2, result);
    return result;
  }, "__decorateClass$Q");
  let CssColorVarSelectorsSetup = (_va = class extends Setup {
    async runSetup() {
      const css2 = await (await fetch("/css/style.css")).text();
      return getCssVariableSelectorHooks(css2, Object.keys(themeColors));
    }
  }, __name(_va, "CssColorVarSelectorsSetup"), _va);
  CssColorVarSelectorsSetup = __decorateClass$Q([
    earlySetup()
  ], CssColorVarSelectorsSetup);
  const generateColorScheme = /* @__PURE__ */ __name((mainColor, textColor, useIngame, useInputs, invertInputText) => {
    const theme = structuredClone(themeColors);
    const mainHueBase = 226;
    const mainSatBase = 85;
    const mainLigBase = 32;
    const mainOpBase = 0.75;
    if (mainColor) {
      const mainHsl = mainColor.hsl;
      const mainHue = mainHsl[0];
      const mainSat = mainHsl[1];
      const mainLig = mainHsl[2];
      const mains = [
        "--COLOR_PANEL_BG",
        "--COLOR_PANEL_LO",
        "--COLOR_PANEL_BUTTON",
        "--COLOR_PANEL_BUTTON_HOVER",
        "--COLOR_PANEL_BUTTON_ACTIVE",
        "--COLOR_PANEL_HI",
        "--COLOR_PANEL_FOCUS",
        "--COLOR_PANEL_BORDER",
        "--COLOR_TOOL_TIP_BG"
      ];
      mains.forEach((k) => theme[k][0] = (theme[k][0] - mainHueBase + mainHue) % 360);
      mains.forEach((k) => theme[k][1] = theme[k][1] * (mainSat / 100));
      mains.forEach((k) => theme[k][2] = theme[k][2] * (mainLig / 100));
      theme["--COLOR_CHAT_SCROLLBAR"] = [...theme["--COLOR_PANEL_LO"]];
      theme["--COLOR_CHAT_SCROLLBAR_THUMB"] = [...theme["--COLOR_PANEL_HI"]];
      if (useIngame) {
        const themeSat = mainSatBase * (mainSat / 100);
        const themeLight = mainLigBase * (mainLig / 100);
        theme["--COLOR_CHAT_BG_BASE"] = [mainHue, themeSat, themeLight, mainOpBase];
        theme["--COLOR_CHAT_BG_ALT"] = [mainHue, themeSat, themeLight - 7, mainOpBase];
        theme["--COLOR_PLAYER_BG_BASE"] = [mainHue, themeSat, themeLight, mainOpBase];
        theme["--COLOR_PLAYER_BG_ALT"] = [mainHue, themeSat, themeLight - 7, mainOpBase];
      }
      if (useInputs) {
        theme["--COLOR_INPUT_BORDER"] = [mainHue, mainSatBase, 75 * (mainLigBase / 100), 0.4];
        theme["--COLOR_INPUT_BORDER_FOCUS"] = [mainHue, mainSatBase, 85 * (mainLigBase / 100), 0.4];
        theme["--COLOR_INPUT_BG"] = [mainHue, mainSatBase, 80 * (mainLigBase / 100), 0.3];
        theme["--COLOR_INPUT_HOVER"] = [mainHue, mainSatBase, 90 * (mainLigBase / 100), 0.3];
      }
    }
    if (textColor) {
      const textHsl = textColor.hsl;
      const texts = [
        /* if ingame generation enabled */
        ...useIngame ? [
          "--COLOR_GAMEBAR_TEXT",
          "--COLOR_GAMEBAR_ROUND_TEXT",
          "--COLOR_PLAYER_TEXT_BASE",
          "--COLOR_CHAT_TEXT_BASE"
        ] : [],
        /* if input generation enabled */
        ...useInputs ? [
          "--COLOR_INPUT_TEXT"
        ] : [],
        "--COLOR_PANEL_TEXT"
      ];
      texts.forEach((k) => theme[k] = [textHsl[0], textHsl[1], textHsl[2], ...textHsl[3] ? [textHsl[3]] : []]);
      if (useInputs) theme["--COLOR_PANEL_TEXT_PLACEHOLDER"] = [textHsl[0], textHsl[1], textHsl[2] - 50];
      if (useIngame) theme["--COLOR_GAMEBAR_WORD_DESCRIPTION"] = [textHsl[0], textHsl[1], textHsl[2], 0.7];
      if (invertInputText) theme["--COLOR_INPUT_TEXT"][2] = 100 - theme["--COLOR_INPUT_TEXT"][2];
    }
    return theme;
  }, "generateColorScheme");
  const generateThemeBackgroundElement = /* @__PURE__ */ __name((theme) => {
    return createElement(`<div id='typo-theme-background-${theme.meta.id}' class="typo-theme-background"></div>`);
  }, "generateThemeBackgroundElement");
  const stringHasContent = /* @__PURE__ */ __name((str) => {
    return str !== void 0 && str.trim().length > 0;
  }, "stringHasContent");
  const generateStyleElementForTheme = /* @__PURE__ */ __name((theme, selectorHooks) => {
    const colorsCss = Object.entries(theme.colors).map((entry) => {
      const value = entry[1];
      const colorString = value.length == 3 ? `hsl(${value[0]}, ${value[1]}%, ${value[2]}%)` : `hsla(${value[0]}, ${value[1]}%, ${value[2]}%, ${value[3]})`;
      return `${entry[0]}: ${colorString};`;
    }).join("\n");
    const style2 = document.createElement("STYLE");
    style2.id = `typo-theme-style-${theme.meta.id}`;
    style2.innerHTML = `
        :root {${colorsCss}}
        body {
            background: none;
        }
        .typo-theme-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: ${theme.images.backgroundTint ?? ""};
            z-index: -10;
            pointer-events: none;
            filter: brightness(${!stringHasContent(theme.images.urlBackground) && (theme.images.backgroundTint ?? "transparent") !== "transparent" ? 4 : 1});
        }
        .typo-theme-background::after {
            image-rendering: unset;
            content: "";
            position: absolute;
            inset: 0;
            background-position: center;
            background-image: url(${stringHasContent(theme.images.urlBackground) ? theme.images.urlBackground : "/img/background.png"});
            background-repeat: ${!stringHasContent(theme.images.urlBackground) || theme.images.backgroundRepeat ? "repeat" : "no-repeat"};
            background-size: ${!stringHasContent(theme.images.urlBackground) ? "350px" : theme.images.backgroundRepeat ? "auto" : "cover"};
            mix-blend-mode: ${theme.images.backgroundTint == "transparent" || !stringHasContent(theme.images.backgroundTint) ? "none" : "multiply"};
            filter: ${theme.images.backgroundTint == "transparent" || !stringHasContent(theme.images.backgroundTint) ? "none" : "saturate(0%)"};
        }
        body:has(#game[style*="display: flex"]) .typo-theme-background${stringHasContent(theme.images.urlBackgroundGame) ? "" : ".disabled"}::after {
            background-image: url(${theme.images.urlBackgroundGame});
        }

        ${theme.misc.hideFooter ? ".tos, .notice {display:none}" : ""}
        
        ${theme.misc.hideInGameLogo ? "#game #game-logo{display:none} #game{margin-top:2em}" : ""}

        ${theme.misc.hideAvatarLogo ? "#home .logo-big .avatar-container {display:none }" : ""}

        ${theme.misc.hideSkribblPanels ? ".bottom .footer .section-container { display: none !important }" : ""}

        ${stringHasContent(theme.images.containerImages) ? `
        #game-bar, #game-room .settings, #game-room .players,  #imageAgent, #gamemodePopup, #optionsPopup, #downloadPopup, 
        #sharePopup, #typoUserInfo, #imageOptions, #game-room .container-settings, #game-chat 
        .chat-content, #game-players .players-list  {background-image: url(${theme.images.containerImages}) !important}
        #game-players .players-list .player {background:none !important}
        ` : ""}

        .flatUi.orange, .button-orange {
            background-color: var(--COLOR_BUTTON_DANGER_BG) !important;
            color: var(--COLOR_BUTTON_DANGER_TEXT) !important;
        }
        .flatUI.green, .button-play, #start-game {
            color: var(--COLOR_BUTTON_SUBMIT_TEXT) !important;
            background-color: var(--COLOR_BUTTON_SUBMIT_BG) !important;
        }
        .flatUI.blue, .button-create, .button-blue, #copy-invite {
            background-color: var(--COLOR_BUTTON_NORMAL_BG) !important;
            color: var(--COLOR_BUTTON_NORMAL_TEXT) !important;
        }

        :is(.flatUi.orange, .button-orange):is(:hover, :active, :focus) {
            background-color: var(--COLOR_BUTTON_DANGER_BG) !important;
            color: var(--COLOR_BUTTON_DANGER_TEXT) !important;
            opacity: 0.8;
        }
        :is(.flatUI.green, .button-play, #start-game):is(:hover, :active, :focus) {
            color: var(--COLOR_BUTTON_SUBMIT_TEXT) !important;
            background-color: var(--COLOR_BUTTON_SUBMIT_BG) !important;
            opacity: 0.8;
        }
        :is(.flatUI.blue, .button-create, .button-blue, #copy-invite):is(:hover, :active, :focus) {
            background-color: var(--COLOR_BUTTON_NORMAL_BG) !important;
            color: var(--COLOR_BUTTON_NORMAL_TEXT) !important;
            opacity: 0.8;
        }

        ${stringHasContent(theme.misc.fontStyle) ? `*{font-family:'${theme.misc.fontStyle.trim().split(":")[0].replaceAll("+", " ")}', sans-serif !important}` : ""}

        ${stringHasContent(theme.images.urlLogo) ? `
          div.logo-big a {display: flex; justify-content: center }
          div.logo-big img, div#game-logo img {max-height:20vh; content: url(${theme.images.urlLogo}) }
        ` : ""}

        ${Object.entries(theme.hooks ? theme.hooks : {}).filter((entry) => entry[1] !== "").map((entry) => `${selectorHooks[entry[0]].join(",")}{${entry[1]}}`).join("\n")}

        ::-webkit-scrollbar {
            width: 14px;
            border-radius: 7px;
            background-color: var(--COLOR_PANEL_LO); 
        }
        
        ::-webkit-scrollbar-thumb {
            border-radius: 7px;
            background-color: var(--COLOR_PANEL_HI)
        }

        #game-chat ::-webkit-scrollbar {
            width: 14px;
            border-radius: 7px;
            background-color: var(--COLOR_CHAT_SCROLLBAR); 
        }
        
        #game-chat ::-webkit-scrollbar-thumb {
            border-radius: 7px;
            background-color: var(--COLOR_CHAT_SCROLLBAR_THUMB); 
        }

        ${theme.misc.cssText ?? ""}
    
        `;
    return style2;
  }, "generateStyleElementForTheme");
  const generateThemeExternalCssElement = /* @__PURE__ */ __name((theme) => {
    return theme.misc.themeCssUrl && theme.misc.themeCssUrl.length > 0 ? [
      createElement(`<link id='typo-theme-external-css-${theme.meta.id}' rel="stylesheet" href="${theme.misc.themeCssUrl}">`)
    ] : [];
  }, "generateThemeExternalCssElement");
  const generateThemeFontElements = /* @__PURE__ */ __name((theme) => {
    var _a2;
    return theme.misc.fontStyle && theme.misc.fontStyle.length > 0 ? [
      createElement(`<link id='typo-theme-font-preconnect-${theme.meta.id}' rel="preconnect" href="https://fonts.gstatic.com">`),
      createElement(`<link id='typo-theme-font-style-${theme.meta.id}' href="https://fonts.googleapis.com/css2?family=${(_a2 = theme.misc.fontStyle) == null ? void 0 : _a2.trim()}&display=swap" rel="stylesheet">`)
    ] : [];
  }, "generateThemeFontElements");
  const generateThemeCustomHtmlElement = /* @__PURE__ */ __name((theme) => {
    return theme.misc.htmlText && theme.misc.htmlText.length > 0 ? [
      createElement(`<div id='typo-theme-html-${theme.meta.id}'>${theme.misc.htmlText}</div>`)
    ] : [];
  }, "generateThemeCustomHtmlElement");
  function get_each_context$u(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[14] = list[i];
    return child_ctx;
  }
  __name(get_each_context$u, "get_each_context$u");
  function create_catch_block$3(ctx) {
    return {
      c: noop,
      m: noop,
      p: noop,
      i: noop,
      o: noop,
      d: noop
    };
  }
  __name(create_catch_block$3, "create_catch_block$3");
  function create_then_block$3(ctx) {
    let div;
    let current;
    let each_value = ensure_array_like(
      /*themes*/
      ctx[13]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$u(get_each_context$u(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div, "class", "typo-themes-browser-list svelte-17gbclg");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*feature, currentTheme, $savedThemes, $devmode*/
        15) {
          each_value = ensure_array_like(
            /*themes*/
            ctx2[13]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$u(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$u(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div, null);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_then_block$3, "create_then_block$3");
  function create_if_block_1$f(ctx) {
    let div0;
    let t0;
    let div1;
    let span0;
    let t1;
    let t2_value = (
      /*theme*/
      ctx[14].version + ""
    );
    let t2;
    let t3;
    let span1;
    let t4;
    let t5_value = (
      /*theme*/
      ctx[14].id + ""
    );
    let t5;
    return {
      c() {
        div0 = element("div");
        t0 = space();
        div1 = element("div");
        span0 = element("span");
        t1 = text("v");
        t2 = text(t2_value);
        t3 = space();
        span1 = element("span");
        t4 = text("#");
        t5 = text(t5_value);
        attr(div0, "class", "svelte-17gbclg");
        attr(span0, "class", "svelte-17gbclg");
        attr(span1, "class", "svelte-17gbclg");
        attr(div1, "class", "svelte-17gbclg");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        insert(target, t0, anchor);
        insert(target, div1, anchor);
        append(div1, span0);
        append(span0, t1);
        append(span0, t2);
        append(div1, t3);
        append(div1, span1);
        append(span1, t4);
        append(span1, t5);
      },
      p(ctx2, dirty) {
        if (dirty & /*feature*/
        1 && t2_value !== (t2_value = /*theme*/
        ctx2[14].version + "")) set_data(t2, t2_value);
        if (dirty & /*feature*/
        1 && t5_value !== (t5_value = /*theme*/
        ctx2[14].id + "")) set_data(t5, t5_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t0);
          detach(div1);
        }
      }
    };
  }
  __name(create_if_block_1$f, "create_if_block_1$f");
  function create_else_block$h(ctx) {
    let flatbutton;
    let current;
    function click_handler_1() {
      return (
        /*click_handler_1*/
        ctx[12](
          /*theme*/
          ctx[14]
        )
      );
    }
    __name(click_handler_1, "click_handler_1");
    flatbutton = new Flat_button({
      props: { content: "Download", color: "blue" }
    });
    flatbutton.$on("click", click_handler_1);
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_else_block$h, "create_else_block$h");
  function create_if_block$w(ctx) {
    var _a2, _b2, _c2, _d2;
    let flatbutton;
    let current;
    function click_handler2() {
      return (
        /*click_handler*/
        ctx[11](
          /*theme*/
          ctx[14]
        )
      );
    }
    __name(click_handler2, "click_handler");
    flatbutton = new Flat_button({
      props: {
        content: (
          /*currentTheme*/
          ((_b2 = (_a2 = ctx[2]) == null ? void 0 : _a2.publicTheme) == null ? void 0 : _b2.publicId) === /*theme*/
          ctx[14].id ? "Active" : "Activate"
        ),
        disabled: (
          /*currentTheme*/
          ((_d2 = (_c2 = ctx[2]) == null ? void 0 : _c2.publicTheme) == null ? void 0 : _d2.publicId) === /*theme*/
          ctx[14].id
        ),
        color: "green"
      }
    });
    flatbutton.$on("click", click_handler2);
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p(new_ctx, dirty) {
        var _a3, _b3, _c3, _d3;
        ctx = new_ctx;
        const flatbutton_changes = {};
        if (dirty & /*currentTheme, feature*/
        5) flatbutton_changes.content = /*currentTheme*/
        ((_b3 = (_a3 = ctx[2]) == null ? void 0 : _a3.publicTheme) == null ? void 0 : _b3.publicId) === /*theme*/
        ctx[14].id ? "Active" : "Activate";
        if (dirty & /*currentTheme, feature*/
        5) flatbutton_changes.disabled = /*currentTheme*/
        ((_d3 = (_c3 = ctx[2]) == null ? void 0 : _c3.publicTheme) == null ? void 0 : _d3.publicId) === /*theme*/
        ctx[14].id;
        flatbutton.$set(flatbutton_changes);
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block$w, "create_if_block$w");
  function create_each_block$u(ctx) {
    let div2;
    let b;
    let t0_value = (
      /*theme*/
      ctx[14].name + ""
    );
    let t0;
    let t1;
    let div0;
    let t2;
    let t3_value = (
      /*theme*/
      ctx[14].author + ""
    );
    let t3;
    let t4;
    let t5;
    let show_if;
    let current_block_type_index;
    let if_block1;
    let t6;
    let div1;
    let t7_value = (
      /*theme*/
      ctx[14].downloads + ""
    );
    let t7;
    let t8;
    let t9;
    let current;
    function func2(...args) {
      return (
        /*func*/
        ctx[10](
          /*theme*/
          ctx[14],
          ...args
        )
      );
    }
    __name(func2, "func");
    let if_block0 = (
      /*$devmode*/
      ctx[3] && create_if_block_1$f(ctx)
    );
    const if_block_creators = [create_if_block$w, create_else_block$h];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (dirty & /*$savedThemes, feature*/
      3) show_if = null;
      if (show_if == null) show_if = !!/*$savedThemes*/
      ctx2[1].some(func2);
      if (show_if) return 0;
      return 1;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx, -1);
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div2 = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = space();
        div0 = element("div");
        t2 = text("by ");
        t3 = text(t3_value);
        t4 = space();
        if (if_block0) if_block0.c();
        t5 = space();
        if_block1.c();
        t6 = space();
        div1 = element("div");
        t7 = text(t7_value);
        t8 = text(" downloads");
        t9 = space();
        attr(div0, "class", "svelte-17gbclg");
        attr(div1, "class", "svelte-17gbclg");
        attr(div2, "class", "typo-themes-browser-item svelte-17gbclg");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, b);
        append(b, t0);
        append(div2, t1);
        append(div2, div0);
        append(div0, t2);
        append(div0, t3);
        append(div2, t4);
        if (if_block0) if_block0.m(div2, null);
        append(div2, t5);
        if_blocks[current_block_type_index].m(div2, null);
        append(div2, t6);
        append(div2, div1);
        append(div1, t7);
        append(div1, t8);
        append(div2, t9);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if ((!current || dirty & /*feature*/
        1) && t0_value !== (t0_value = /*theme*/
        ctx[14].name + "")) set_data(t0, t0_value);
        if ((!current || dirty & /*feature*/
        1) && t3_value !== (t3_value = /*theme*/
        ctx[14].author + "")) set_data(t3, t3_value);
        if (
          /*$devmode*/
          ctx[3]
        ) {
          if (if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0 = create_if_block_1$f(ctx);
            if_block0.c();
            if_block0.m(div2, t5);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx, dirty);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block1.c();
          } else {
            if_block1.p(ctx, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div2, t6);
        }
        if ((!current || dirty & /*feature*/
        1) && t7_value !== (t7_value = /*theme*/
        ctx[14].downloads + "")) set_data(t7, t7_value);
      },
      i(local) {
        if (current) return;
        transition_in(if_block1);
        current = true;
      },
      o(local) {
        transition_out(if_block1);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        if (if_block0) if_block0.d();
        if_blocks[current_block_type_index].d();
      }
    };
  }
  __name(create_each_block$u, "create_each_block$u");
  function create_pending_block$3(ctx) {
    return {
      c: noop,
      m: noop,
      p: noop,
      i: noop,
      o: noop,
      d: noop
    };
  }
  __name(create_pending_block$3, "create_pending_block$3");
  function create_fragment$1f(ctx) {
    let div;
    let t2;
    let await_block_anchor;
    let promise;
    let current;
    let info = {
      ctx,
      current: null,
      token: null,
      hasCatch: false,
      pending: create_pending_block$3,
      then: create_then_block$3,
      catch: create_catch_block$3,
      value: 13,
      blocks: [, , ,]
    };
    handle_promise(promise = /*feature*/
    ctx[0].getOnlineThemes(), info);
    return {
      c() {
        div = element("div");
        div.innerHTML = `Here you can discover themes made by other typo users. When you download a theme, it will be activated and saved to your local themes.<br/>
  When a theme receives an update, it will be automatically downloaded.`;
        t2 = space();
        await_block_anchor = empty();
        info.block.c();
        attr(div, "class", "typo-themes-browser-header svelte-17gbclg");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        insert(target, t2, anchor);
        insert(target, await_block_anchor, anchor);
        info.block.m(target, info.anchor = anchor);
        info.mount = () => await_block_anchor.parentNode;
        info.anchor = await_block_anchor;
        current = true;
      },
      p(new_ctx, [dirty]) {
        ctx = new_ctx;
        info.ctx = ctx;
        if (dirty & /*feature*/
        1 && promise !== (promise = /*feature*/
        ctx[0].getOnlineThemes()) && handle_promise(promise, info)) ;
        else {
          update_await_block_branch(info, ctx, dirty);
        }
      },
      i(local) {
        if (current) return;
        transition_in(info.block);
        current = true;
      },
      o(local) {
        for (let i = 0; i < 3; i += 1) {
          const block2 = info.blocks[i];
          transition_out(block2);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
          detach(t2);
          detach(await_block_anchor);
        }
        info.block.d(detaching);
        info.token = null;
        info = null;
      }
    };
  }
  __name(create_fragment$1f, "create_fragment$1f");
  function instance$17($$self, $$props, $$invalidate) {
    let $currentThemeId;
    let $savedThemes;
    let $loadedEditorTheme;
    let $devmode;
    let { feature } = $$props;
    const devmode = feature.devmodeStore;
    component_subscribe($$self, devmode, (value) => $$invalidate(3, $devmode = value));
    const savedThemes = feature.savedThemesStore;
    component_subscribe($$self, savedThemes, (value) => $$invalidate(1, $savedThemes = value));
    const currentThemeId = feature.activeThemeStore;
    component_subscribe($$self, currentThemeId, (value) => $$invalidate(8, $currentThemeId = value));
    const loadedEditorTheme = feature.loadedEditorThemeStore;
    component_subscribe($$self, loadedEditorTheme, (value) => $$invalidate(9, $loadedEditorTheme = value));
    let currentTheme;
    const func2 = /* @__PURE__ */ __name((theme, t) => {
      var _a2;
      return ((_a2 = t.publicTheme) == null ? void 0 : _a2.publicId) === theme.id;
    }, "func");
    const click_handler2 = /* @__PURE__ */ __name((theme) => feature.activatePublicTheme(theme), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(async (theme) => {
      await feature.savePublicTheme(theme);
      await feature.activatePublicTheme(theme);
    }, "click_handler_1");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*$loadedEditorTheme, $savedThemes, $currentThemeId*/
      770) {
        {
          $$invalidate(2, currentTheme = $loadedEditorTheme === void 0 ? $savedThemes.find((t) => t.theme.meta.id === $currentThemeId) : void 0);
        }
      }
    };
    return [
      feature,
      $savedThemes,
      currentTheme,
      $devmode,
      devmode,
      savedThemes,
      currentThemeId,
      loadedEditorTheme,
      $currentThemeId,
      $loadedEditorTheme,
      func2,
      click_handler2,
      click_handler_1
    ];
  }
  __name(instance$17, "instance$17");
  const _Themes_browser = class _Themes_browser extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$17, create_fragment$1f, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Themes_browser, "Themes_browser");
  let Themes_browser = _Themes_browser;
  function get_each_context$t(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[61] = list[i];
    child_ctx[62] = list;
    child_ctx[63] = i;
    return child_ctx;
  }
  __name(get_each_context$t, "get_each_context$t");
  function get_each_context_1$b(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[61] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1$b, "get_each_context_1$b");
  function create_else_block$g(ctx) {
    let div0;
    let h3;
    let t0;
    let t1_value = (
      /*$loadedTheme*/
      ctx[2].theme.meta.name + ""
    );
    let t1;
    let t2;
    let br0;
    let t3;
    let flatbutton0;
    let t4;
    let flatbutton1;
    let t5;
    let flatbutton2;
    let t6;
    let div42;
    let div5;
    let div2;
    let div1;
    let t8;
    let input0;
    let t9;
    let div4;
    let div3;
    let t11;
    let input1;
    let t12;
    let details0;
    let summary0;
    let t14;
    let br1;
    let t15;
    let br2;
    let t16;
    let br3;
    let t17;
    let div10;
    let div7;
    let div6;
    let t19;
    let colorpickerbutton0;
    let updating_color;
    let t20;
    let div9;
    let div8;
    let t22;
    let colorpickerbutton1;
    let updating_color_1;
    let t23;
    let br4;
    let t24;
    let div11;
    let checkbox0;
    let updating_checked;
    let t25;
    let checkbox1;
    let updating_checked_1;
    let t26;
    let checkbox2;
    let updating_checked_2;
    let t27;
    let br5;
    let t28;
    let div12;
    let flatbutton3;
    let t29;
    let details1;
    let summary1;
    let t31;
    let div21;
    let div14;
    let div13;
    let t33;
    let input2;
    let t34;
    let div16;
    let div15;
    let t36;
    let input3;
    let t37;
    let div18;
    let div17;
    let t39;
    let input4;
    let t40;
    let div20;
    let div19;
    let t42;
    let input5;
    let t43;
    let br6;
    let t44;
    let div23;
    let div22;
    let checkbox3;
    let updating_checked_3;
    let t45;
    let colorpickerbutton2;
    let t46;
    let br7;
    let t47;
    let div24;
    let checkbox4;
    let updating_checked_4;
    let t48;
    let details2;
    let summary2;
    let t50;
    let p0;
    let t52;
    let p1;
    let t54;
    let p2;
    let t56;
    let br8;
    let t57;
    let div27;
    let div26;
    let div25;
    let t58;
    let details3;
    let summary3;
    let t60;
    let div32;
    let div29;
    let div28;
    let t62;
    let input6;
    let t63;
    let div31;
    let div30;
    let t65;
    let input7;
    let t66;
    let br9;
    let t67;
    let div37;
    let div34;
    let div33;
    let t69;
    let input8;
    let t70;
    let div36;
    let div35;
    let t72;
    let input9;
    let t73;
    let br10;
    let t74;
    let div38;
    let checkbox5;
    let updating_checked_5;
    let t75;
    let checkbox6;
    let updating_checked_6;
    let t76;
    let checkbox7;
    let updating_checked_7;
    let t77;
    let checkbox8;
    let updating_checked_8;
    let t78;
    let details4;
    let summary4;
    let t80;
    let p3;
    let t82;
    let p4;
    let t84;
    let p5;
    let t86;
    let br11;
    let t87;
    let div41;
    let div40;
    let div39;
    let current;
    let mounted;
    let dispose;
    flatbutton0 = new Flat_button({
      props: {
        content: "Discard & Delete",
        color: "orange"
      }
    });
    flatbutton0.$on(
      "click",
      /*click_handler_2*/
      ctx[18]
    );
    flatbutton1 = new Flat_button({
      props: {
        content: "Discard Changes",
        color: "blue"
      }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_3*/
      ctx[19]
    );
    flatbutton2 = new Flat_button({
      props: { content: "Save Theme", color: "green" }
    });
    flatbutton2.$on(
      "click",
      /*click_handler_4*/
      ctx[20]
    );
    function colorpickerbutton0_color_binding(value) {
      ctx[23](value);
    }
    __name(colorpickerbutton0_color_binding, "colorpickerbutton0_color_binding");
    let colorpickerbutton0_props = {};
    if (
      /*schemePrimaryColor*/
      ctx[3] !== void 0
    ) {
      colorpickerbutton0_props.color = /*schemePrimaryColor*/
      ctx[3];
    }
    colorpickerbutton0 = new Color_picker_button({ props: colorpickerbutton0_props });
    binding_callbacks.push(() => bind(colorpickerbutton0, "color", colorpickerbutton0_color_binding));
    function colorpickerbutton1_color_binding(value) {
      ctx[24](value);
    }
    __name(colorpickerbutton1_color_binding, "colorpickerbutton1_color_binding");
    let colorpickerbutton1_props = {};
    if (
      /*schemeTextColor*/
      ctx[4] !== void 0
    ) {
      colorpickerbutton1_props.color = /*schemeTextColor*/
      ctx[4];
    }
    colorpickerbutton1 = new Color_picker_button({ props: colorpickerbutton1_props });
    binding_callbacks.push(() => bind(colorpickerbutton1, "color", colorpickerbutton1_color_binding));
    function checkbox0_checked_binding(value) {
      ctx[25](value);
    }
    __name(checkbox0_checked_binding, "checkbox0_checked_binding");
    let checkbox0_props = {
      description: "Generate colors for input fields"
    };
    if (
      /*schemeOnInputs*/
      ctx[6] !== void 0
    ) {
      checkbox0_props.checked = /*schemeOnInputs*/
      ctx[6];
    }
    checkbox0 = new Checkbox({ props: checkbox0_props });
    binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding));
    function checkbox1_checked_binding(value) {
      ctx[26](value);
    }
    __name(checkbox1_checked_binding, "checkbox1_checked_binding");
    let checkbox1_props = {
      description: "Invert text brightness on input fields"
    };
    if (
      /*schemeInvertInputBrightness*/
      ctx[7] !== void 0
    ) {
      checkbox1_props.checked = /*schemeInvertInputBrightness*/
      ctx[7];
    }
    checkbox1 = new Checkbox({ props: checkbox1_props });
    binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding));
    function checkbox2_checked_binding(value) {
      ctx[27](value);
    }
    __name(checkbox2_checked_binding, "checkbox2_checked_binding");
    let checkbox2_props = { description: "Use theme colors in-game" };
    if (
      /*schemeIngame*/
      ctx[9] !== void 0
    ) {
      checkbox2_props.checked = /*schemeIngame*/
      ctx[9];
    }
    checkbox2 = new Checkbox({ props: checkbox2_props });
    binding_callbacks.push(() => bind(checkbox2, "checked", checkbox2_checked_binding));
    flatbutton3 = new Flat_button({
      props: {
        content: "Generate Color Scheme",
        color: "green"
      }
    });
    flatbutton3.$on(
      "click",
      /*click_handler_5*/
      ctx[28]
    );
    function checkbox3_checked_binding(value) {
      ctx[37](value);
    }
    __name(checkbox3_checked_binding, "checkbox3_checked_binding");
    let checkbox3_props = {
      description: "Tint the skribbl background with a color"
    };
    if (
      /*schemeEnableBackgroundTint*/
      ctx[8] !== void 0
    ) {
      checkbox3_props.checked = /*schemeEnableBackgroundTint*/
      ctx[8];
    }
    checkbox3 = new Checkbox({ props: checkbox3_props });
    binding_callbacks.push(() => bind(checkbox3, "checked", checkbox3_checked_binding));
    checkbox3.$on(
      "change",
      /*change_handler_4*/
      ctx[38]
    );
    colorpickerbutton2 = new Color_picker_button({
      props: {
        allowAlpha: true,
        colorChanged: (
          /*func*/
          ctx[39]
        )
      }
    });
    function checkbox4_checked_binding(value) {
      ctx[40](value);
    }
    __name(checkbox4_checked_binding, "checkbox4_checked_binding");
    let checkbox4_props = {
      description: "Repeat custom background image"
    };
    if (
      /*$loadedTheme*/
      ctx[2].theme.images.backgroundRepeat !== void 0
    ) {
      checkbox4_props.checked = /*$loadedTheme*/
      ctx[2].theme.images.backgroundRepeat;
    }
    checkbox4 = new Checkbox({ props: checkbox4_props });
    binding_callbacks.push(() => bind(checkbox4, "checked", checkbox4_checked_binding));
    checkbox4.$on(
      "change",
      /*change_handler_5*/
      ctx[41]
    );
    let each_value_1 = ensure_array_like(
      /*themeColors*/
      ctx[11]
    );
    let each_blocks_1 = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks_1[i] = create_each_block_1$b(get_each_context_1$b(ctx, each_value_1, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks_1[i], 1, 1, () => {
      each_blocks_1[i] = null;
    }), "out");
    function checkbox5_checked_binding(value) {
      ctx[51](value);
    }
    __name(checkbox5_checked_binding, "checkbox5_checked_binding");
    let checkbox5_props = { description: "Hide skribbl footer" };
    if (
      /*$loadedTheme*/
      ctx[2].theme.misc.hideFooter !== void 0
    ) {
      checkbox5_props.checked = /*$loadedTheme*/
      ctx[2].theme.misc.hideFooter;
    }
    checkbox5 = new Checkbox({ props: checkbox5_props });
    binding_callbacks.push(() => bind(checkbox5, "checked", checkbox5_checked_binding));
    checkbox5.$on(
      "change",
      /*change_handler_10*/
      ctx[52]
    );
    function checkbox6_checked_binding(value) {
      ctx[53](value);
    }
    __name(checkbox6_checked_binding, "checkbox6_checked_binding");
    let checkbox6_props = {
      description: "Hide About, News & How-To Panels"
    };
    if (
      /*$loadedTheme*/
      ctx[2].theme.misc.hideSkribblPanels !== void 0
    ) {
      checkbox6_props.checked = /*$loadedTheme*/
      ctx[2].theme.misc.hideSkribblPanels;
    }
    checkbox6 = new Checkbox({ props: checkbox6_props });
    binding_callbacks.push(() => bind(checkbox6, "checked", checkbox6_checked_binding));
    checkbox6.$on(
      "change",
      /*change_handler_11*/
      ctx[54]
    );
    function checkbox7_checked_binding(value) {
      ctx[55](value);
    }
    __name(checkbox7_checked_binding, "checkbox7_checked_binding");
    let checkbox7_props = {
      description: "Hide avatars below skribbl logo"
    };
    if (
      /*$loadedTheme*/
      ctx[2].theme.misc.hideAvatarLogo !== void 0
    ) {
      checkbox7_props.checked = /*$loadedTheme*/
      ctx[2].theme.misc.hideAvatarLogo;
    }
    checkbox7 = new Checkbox({ props: checkbox7_props });
    binding_callbacks.push(() => bind(checkbox7, "checked", checkbox7_checked_binding));
    checkbox7.$on(
      "change",
      /*change_handler_12*/
      ctx[56]
    );
    function checkbox8_checked_binding(value) {
      ctx[57](value);
    }
    __name(checkbox8_checked_binding, "checkbox8_checked_binding");
    let checkbox8_props = { description: "Hide in-game skribbl logo" };
    if (
      /*$loadedTheme*/
      ctx[2].theme.misc.hideInGameLogo !== void 0
    ) {
      checkbox8_props.checked = /*$loadedTheme*/
      ctx[2].theme.misc.hideInGameLogo;
    }
    checkbox8 = new Checkbox({ props: checkbox8_props });
    binding_callbacks.push(() => bind(checkbox8, "checked", checkbox8_checked_binding));
    checkbox8.$on(
      "change",
      /*change_handler_13*/
      ctx[58]
    );
    let each_value = ensure_array_like(Object.entries(
      /*variableHooks*/
      ctx[1]
    ));
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$t(get_each_context$t(ctx, each_value, i));
    }
    return {
      c() {
        div0 = element("div");
        h3 = element("h3");
        t0 = text("Editing Theme: ");
        t1 = text(t1_value);
        t2 = space();
        br0 = element("br");
        t3 = space();
        create_component(flatbutton0.$$.fragment);
        t4 = space();
        create_component(flatbutton1.$$.fragment);
        t5 = space();
        create_component(flatbutton2.$$.fragment);
        t6 = space();
        div42 = element("div");
        div5 = element("div");
        div2 = element("div");
        div1 = element("div");
        div1.textContent = "Theme Name:";
        t8 = space();
        input0 = element("input");
        t9 = space();
        div4 = element("div");
        div3 = element("div");
        div3.textContent = "Creator Name:";
        t11 = space();
        input1 = element("input");
        t12 = space();
        details0 = element("details");
        summary0 = element("summary");
        summary0.textContent = "Color Scheme";
        t14 = text("\n\n        Using the color scheme generator, you can easily create a unique color theme for skribbl.");
        br1 = element("br");
        t15 = text('\n        This overwrites all existing color customizations in "Advanced Color Settings".');
        br2 = element("br");
        t16 = space();
        br3 = element("br");
        t17 = space();
        div10 = element("div");
        div7 = element("div");
        div6 = element("div");
        div6.textContent = "Primary Color:";
        t19 = space();
        create_component(colorpickerbutton0.$$.fragment);
        t20 = space();
        div9 = element("div");
        div8 = element("div");
        div8.textContent = "Text Color:";
        t22 = space();
        create_component(colorpickerbutton1.$$.fragment);
        t23 = space();
        br4 = element("br");
        t24 = space();
        div11 = element("div");
        create_component(checkbox0.$$.fragment);
        t25 = space();
        create_component(checkbox1.$$.fragment);
        t26 = space();
        create_component(checkbox2.$$.fragment);
        t27 = space();
        br5 = element("br");
        t28 = space();
        div12 = element("div");
        create_component(flatbutton3.$$.fragment);
        t29 = space();
        details1 = element("details");
        summary1 = element("summary");
        summary1.textContent = "Image Settings";
        t31 = space();
        div21 = element("div");
        div14 = element("div");
        div13 = element("div");
        div13.textContent = "Replace Skribbl Logo:";
        t33 = space();
        input2 = element("input");
        t34 = space();
        div16 = element("div");
        div15 = element("div");
        div15.textContent = "Replace Background:";
        t36 = space();
        input3 = element("input");
        t37 = space();
        div18 = element("div");
        div17 = element("div");
        div17.textContent = "In-Game Background:";
        t39 = space();
        input4 = element("input");
        t40 = space();
        div20 = element("div");
        div19 = element("div");
        div19.textContent = "Container Background:";
        t42 = space();
        input5 = element("input");
        t43 = space();
        br6 = element("br");
        t44 = space();
        div23 = element("div");
        div22 = element("div");
        create_component(checkbox3.$$.fragment);
        t45 = space();
        create_component(colorpickerbutton2.$$.fragment);
        t46 = space();
        br7 = element("br");
        t47 = space();
        div24 = element("div");
        create_component(checkbox4.$$.fragment);
        t48 = space();
        details2 = element("details");
        summary2 = element("summary");
        summary2.textContent = "Advanced Color Settings";
        t50 = space();
        p0 = element("p");
        p0.textContent = "Advanced color settings allow you to customize the appearance of skribbl in more detail.";
        t52 = space();
        p1 = element("p");
        p1.textContent = "These settings are overwritten when the color scheme generator is used.";
        t54 = space();
        p2 = element("p");
        p2.textContent = "The color names are taken from the skribbl code.";
        t56 = space();
        br8 = element("br");
        t57 = space();
        div27 = element("div");
        div26 = element("div");
        div25 = element("div");
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].c();
        }
        t58 = space();
        details3 = element("details");
        summary3 = element("summary");
        summary3.textContent = "Miscellaneous";
        t60 = space();
        div32 = element("div");
        div29 = element("div");
        div28 = element("div");
        div28.textContent = "Use Google Font:";
        t62 = space();
        input6 = element("input");
        t63 = space();
        div31 = element("div");
        div30 = element("div");
        div30.textContent = "External CSS URL:";
        t65 = space();
        input7 = element("input");
        t66 = space();
        br9 = element("br");
        t67 = space();
        div37 = element("div");
        div34 = element("div");
        div33 = element("div");
        div33.textContent = "Custom CSS:";
        t69 = space();
        input8 = element("input");
        t70 = space();
        div36 = element("div");
        div35 = element("div");
        div35.textContent = "HTML Element Injection:";
        t72 = space();
        input9 = element("input");
        t73 = space();
        br10 = element("br");
        t74 = space();
        div38 = element("div");
        create_component(checkbox5.$$.fragment);
        t75 = space();
        create_component(checkbox6.$$.fragment);
        t76 = space();
        create_component(checkbox7.$$.fragment);
        t77 = space();
        create_component(checkbox8.$$.fragment);
        t78 = space();
        details4 = element("details");
        summary4 = element("summary");
        summary4.textContent = "Skribbl Style Hooks";
        t80 = space();
        p3 = element("p");
        p3.textContent = "Skribbl style hooks allow more advanced CSS styling without having to dig through the skribbl css classes.";
        t82 = space();
        p4 = element("p");
        p4.textContent = "The CSS you write will be applied wherever the skribbl color variable is used.";
        t84 = space();
        p5 = element("p");
        p5.textContent = "Hover over the ℹ️ icon to display the linked CSS classes.";
        t86 = space();
        br11 = element("br");
        t87 = space();
        div41 = element("div");
        div40 = element("div");
        div39 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        set_style(h3, "flex-grow", "1");
        attr(div0, "class", "typo-themes-editor-header svelte-1gh1qig");
        attr(input0, "type", "text");
        attr(input0, "class", "svelte-1gh1qig");
        attr(div2, "class", "group svelte-1gh1qig");
        attr(input1, "type", "text");
        attr(input1, "class", "svelte-1gh1qig");
        attr(div4, "class", "group svelte-1gh1qig");
        attr(div5, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        attr(summary0, "class", "svelte-1gh1qig");
        attr(div7, "class", "group svelte-1gh1qig");
        attr(div9, "class", "group svelte-1gh1qig");
        attr(div10, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        attr(div11, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        attr(div12, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        details0.open = true;
        attr(details0, "class", "svelte-1gh1qig");
        attr(summary1, "class", "svelte-1gh1qig");
        attr(input2, "type", "text");
        attr(input2, "placeholder", "https://link.here/image.gif");
        attr(input2, "class", "svelte-1gh1qig");
        attr(div14, "class", "group svelte-1gh1qig");
        attr(input3, "type", "text");
        attr(input3, "placeholder", "https://link.here/image.gif");
        attr(input3, "class", "svelte-1gh1qig");
        attr(div16, "class", "group svelte-1gh1qig");
        attr(input4, "type", "text");
        attr(input4, "placeholder", "https://link.here/image.gif");
        attr(input4, "class", "svelte-1gh1qig");
        attr(div18, "class", "group svelte-1gh1qig");
        attr(input5, "type", "text");
        attr(input5, "placeholder", "https://link.here/image.gif");
        attr(input5, "class", "svelte-1gh1qig");
        attr(div20, "class", "group svelte-1gh1qig");
        attr(div21, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        attr(div22, "class", "group svelte-1gh1qig");
        attr(div23, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        attr(div24, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        details1.open = true;
        attr(details1, "class", "svelte-1gh1qig");
        attr(summary2, "class", "svelte-1gh1qig");
        attr(div25, "class", "color-pickers svelte-1gh1qig");
        attr(div26, "class", "group svelte-1gh1qig");
        attr(div27, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        attr(details2, "class", "svelte-1gh1qig");
        attr(summary3, "class", "svelte-1gh1qig");
        attr(input6, "type", "text");
        attr(input6, "placeholder", "Google Fonts import URL");
        attr(input6, "class", "svelte-1gh1qig");
        attr(div29, "class", "group svelte-1gh1qig");
        attr(input7, "type", "text");
        attr(input7, "placeholder", "https://some.website/link-to-style.css");
        attr(input7, "class", "svelte-1gh1qig");
        attr(div31, "class", "group svelte-1gh1qig");
        attr(div32, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        attr(input8, "type", "text");
        attr(input8, "placeholder", ".logo-big { display: none !important; }");
        attr(input8, "class", "svelte-1gh1qig");
        attr(div34, "class", "group svelte-1gh1qig");
        attr(input9, "type", "text");
        attr(input9, "placeholder", "<div>hello there</div>");
        attr(input9, "class", "svelte-1gh1qig");
        attr(div36, "class", "group svelte-1gh1qig");
        attr(div37, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        attr(div38, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        attr(details3, "class", "svelte-1gh1qig");
        attr(summary4, "class", "svelte-1gh1qig");
        attr(div39, "class", "style-hooks svelte-1gh1qig");
        attr(div40, "class", "group svelte-1gh1qig");
        attr(div41, "class", "typo-themes-editor-content-section svelte-1gh1qig");
        attr(details4, "class", "svelte-1gh1qig");
        attr(div42, "class", "typo-themes-editor-content svelte-1gh1qig");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        append(div0, h3);
        append(h3, t0);
        append(h3, t1);
        append(div0, t2);
        append(div0, br0);
        append(div0, t3);
        mount_component(flatbutton0, div0, null);
        append(div0, t4);
        mount_component(flatbutton1, div0, null);
        append(div0, t5);
        mount_component(flatbutton2, div0, null);
        insert(target, t6, anchor);
        insert(target, div42, anchor);
        append(div42, div5);
        append(div5, div2);
        append(div2, div1);
        append(div2, t8);
        append(div2, input0);
        set_input_value(
          input0,
          /*$loadedTheme*/
          ctx[2].theme.meta.name
        );
        append(div5, t9);
        append(div5, div4);
        append(div4, div3);
        append(div4, t11);
        append(div4, input1);
        set_input_value(
          input1,
          /*$loadedTheme*/
          ctx[2].theme.meta.author
        );
        append(div42, t12);
        append(div42, details0);
        append(details0, summary0);
        append(details0, t14);
        append(details0, br1);
        append(details0, t15);
        append(details0, br2);
        append(details0, t16);
        append(details0, br3);
        append(details0, t17);
        append(details0, div10);
        append(div10, div7);
        append(div7, div6);
        append(div7, t19);
        mount_component(colorpickerbutton0, div7, null);
        append(div10, t20);
        append(div10, div9);
        append(div9, div8);
        append(div9, t22);
        mount_component(colorpickerbutton1, div9, null);
        append(details0, t23);
        append(details0, br4);
        append(details0, t24);
        append(details0, div11);
        mount_component(checkbox0, div11, null);
        append(div11, t25);
        mount_component(checkbox1, div11, null);
        append(div11, t26);
        mount_component(checkbox2, div11, null);
        append(details0, t27);
        append(details0, br5);
        append(details0, t28);
        append(details0, div12);
        mount_component(flatbutton3, div12, null);
        append(div42, t29);
        append(div42, details1);
        append(details1, summary1);
        append(details1, t31);
        append(details1, div21);
        append(div21, div14);
        append(div14, div13);
        append(div14, t33);
        append(div14, input2);
        set_input_value(
          input2,
          /*$loadedTheme*/
          ctx[2].theme.images.urlLogo
        );
        append(div21, t34);
        append(div21, div16);
        append(div16, div15);
        append(div16, t36);
        append(div16, input3);
        set_input_value(
          input3,
          /*$loadedTheme*/
          ctx[2].theme.images.urlBackground
        );
        append(div21, t37);
        append(div21, div18);
        append(div18, div17);
        append(div18, t39);
        append(div18, input4);
        set_input_value(
          input4,
          /*$loadedTheme*/
          ctx[2].theme.images.urlBackgroundGame
        );
        append(div21, t40);
        append(div21, div20);
        append(div20, div19);
        append(div20, t42);
        append(div20, input5);
        set_input_value(
          input5,
          /*$loadedTheme*/
          ctx[2].theme.images.containerImages
        );
        append(details1, t43);
        append(details1, br6);
        append(details1, t44);
        append(details1, div23);
        append(div23, div22);
        mount_component(checkbox3, div22, null);
        append(div22, t45);
        mount_component(colorpickerbutton2, div22, null);
        append(details1, t46);
        append(details1, br7);
        append(details1, t47);
        append(details1, div24);
        mount_component(checkbox4, div24, null);
        append(div42, t48);
        append(div42, details2);
        append(details2, summary2);
        append(details2, t50);
        append(details2, p0);
        append(details2, t52);
        append(details2, p1);
        append(details2, t54);
        append(details2, p2);
        append(details2, t56);
        append(details2, br8);
        append(details2, t57);
        append(details2, div27);
        append(div27, div26);
        append(div26, div25);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          if (each_blocks_1[i]) {
            each_blocks_1[i].m(div25, null);
          }
        }
        append(div42, t58);
        append(div42, details3);
        append(details3, summary3);
        append(details3, t60);
        append(details3, div32);
        append(div32, div29);
        append(div29, div28);
        append(div29, t62);
        append(div29, input6);
        set_input_value(
          input6,
          /*$loadedTheme*/
          ctx[2].theme.misc.fontStyle
        );
        append(div32, t63);
        append(div32, div31);
        append(div31, div30);
        append(div31, t65);
        append(div31, input7);
        set_input_value(
          input7,
          /*$loadedTheme*/
          ctx[2].theme.misc.themeCssUrl
        );
        append(details3, t66);
        append(details3, br9);
        append(details3, t67);
        append(details3, div37);
        append(div37, div34);
        append(div34, div33);
        append(div34, t69);
        append(div34, input8);
        set_input_value(
          input8,
          /*$loadedTheme*/
          ctx[2].theme.misc.cssText
        );
        append(div37, t70);
        append(div37, div36);
        append(div36, div35);
        append(div36, t72);
        append(div36, input9);
        set_input_value(
          input9,
          /*$loadedTheme*/
          ctx[2].theme.misc.htmlText
        );
        append(details3, t73);
        append(details3, br10);
        append(details3, t74);
        append(details3, div38);
        mount_component(checkbox5, div38, null);
        append(div38, t75);
        mount_component(checkbox6, div38, null);
        append(div38, t76);
        mount_component(checkbox7, div38, null);
        append(div38, t77);
        mount_component(checkbox8, div38, null);
        append(div42, t78);
        append(div42, details4);
        append(details4, summary4);
        append(details4, t80);
        append(details4, p3);
        append(details4, t82);
        append(details4, p4);
        append(details4, t84);
        append(details4, p5);
        append(details4, t86);
        append(details4, br11);
        append(details4, t87);
        append(details4, div41);
        append(div41, div40);
        append(div40, div39);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div39, null);
          }
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              input0,
              "input",
              /*input0_input_handler*/
              ctx[21]
            ),
            listen(
              input1,
              "input",
              /*input1_input_handler*/
              ctx[22]
            ),
            listen(
              input2,
              "input",
              /*input2_input_handler*/
              ctx[29]
            ),
            listen(
              input2,
              "change",
              /*change_handler*/
              ctx[30]
            ),
            listen(
              input3,
              "input",
              /*input3_input_handler*/
              ctx[31]
            ),
            listen(
              input3,
              "change",
              /*change_handler_1*/
              ctx[32]
            ),
            listen(
              input4,
              "input",
              /*input4_input_handler*/
              ctx[33]
            ),
            listen(
              input4,
              "change",
              /*change_handler_2*/
              ctx[34]
            ),
            listen(
              input5,
              "input",
              /*input5_input_handler*/
              ctx[35]
            ),
            listen(
              input5,
              "change",
              /*change_handler_3*/
              ctx[36]
            ),
            listen(
              input6,
              "input",
              /*input6_input_handler*/
              ctx[43]
            ),
            listen(
              input6,
              "change",
              /*change_handler_6*/
              ctx[44]
            ),
            listen(
              input7,
              "input",
              /*input7_input_handler*/
              ctx[45]
            ),
            listen(
              input7,
              "change",
              /*change_handler_7*/
              ctx[46]
            ),
            listen(
              input8,
              "input",
              /*input8_input_handler*/
              ctx[47]
            ),
            listen(
              input8,
              "change",
              /*change_handler_8*/
              ctx[48]
            ),
            listen(
              input9,
              "input",
              /*input9_input_handler*/
              ctx[49]
            ),
            listen(
              input9,
              "change",
              /*change_handler_9*/
              ctx[50]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if ((!current || dirty[0] & /*$loadedTheme*/
        4) && t1_value !== (t1_value = /*$loadedTheme*/
        ctx2[2].theme.meta.name + "")) set_data(t1, t1_value);
        if (dirty[0] & /*$loadedTheme*/
        4 && input0.value !== /*$loadedTheme*/
        ctx2[2].theme.meta.name) {
          set_input_value(
            input0,
            /*$loadedTheme*/
            ctx2[2].theme.meta.name
          );
        }
        if (dirty[0] & /*$loadedTheme*/
        4 && input1.value !== /*$loadedTheme*/
        ctx2[2].theme.meta.author) {
          set_input_value(
            input1,
            /*$loadedTheme*/
            ctx2[2].theme.meta.author
          );
        }
        const colorpickerbutton0_changes = {};
        if (!updating_color && dirty[0] & /*schemePrimaryColor*/
        8) {
          updating_color = true;
          colorpickerbutton0_changes.color = /*schemePrimaryColor*/
          ctx2[3];
          add_flush_callback(() => updating_color = false);
        }
        colorpickerbutton0.$set(colorpickerbutton0_changes);
        const colorpickerbutton1_changes = {};
        if (!updating_color_1 && dirty[0] & /*schemeTextColor*/
        16) {
          updating_color_1 = true;
          colorpickerbutton1_changes.color = /*schemeTextColor*/
          ctx2[4];
          add_flush_callback(() => updating_color_1 = false);
        }
        colorpickerbutton1.$set(colorpickerbutton1_changes);
        const checkbox0_changes = {};
        if (!updating_checked && dirty[0] & /*schemeOnInputs*/
        64) {
          updating_checked = true;
          checkbox0_changes.checked = /*schemeOnInputs*/
          ctx2[6];
          add_flush_callback(() => updating_checked = false);
        }
        checkbox0.$set(checkbox0_changes);
        const checkbox1_changes = {};
        if (!updating_checked_1 && dirty[0] & /*schemeInvertInputBrightness*/
        128) {
          updating_checked_1 = true;
          checkbox1_changes.checked = /*schemeInvertInputBrightness*/
          ctx2[7];
          add_flush_callback(() => updating_checked_1 = false);
        }
        checkbox1.$set(checkbox1_changes);
        const checkbox2_changes = {};
        if (!updating_checked_2 && dirty[0] & /*schemeIngame*/
        512) {
          updating_checked_2 = true;
          checkbox2_changes.checked = /*schemeIngame*/
          ctx2[9];
          add_flush_callback(() => updating_checked_2 = false);
        }
        checkbox2.$set(checkbox2_changes);
        if (dirty[0] & /*$loadedTheme*/
        4 && input2.value !== /*$loadedTheme*/
        ctx2[2].theme.images.urlLogo) {
          set_input_value(
            input2,
            /*$loadedTheme*/
            ctx2[2].theme.images.urlLogo
          );
        }
        if (dirty[0] & /*$loadedTheme*/
        4 && input3.value !== /*$loadedTheme*/
        ctx2[2].theme.images.urlBackground) {
          set_input_value(
            input3,
            /*$loadedTheme*/
            ctx2[2].theme.images.urlBackground
          );
        }
        if (dirty[0] & /*$loadedTheme*/
        4 && input4.value !== /*$loadedTheme*/
        ctx2[2].theme.images.urlBackgroundGame) {
          set_input_value(
            input4,
            /*$loadedTheme*/
            ctx2[2].theme.images.urlBackgroundGame
          );
        }
        if (dirty[0] & /*$loadedTheme*/
        4 && input5.value !== /*$loadedTheme*/
        ctx2[2].theme.images.containerImages) {
          set_input_value(
            input5,
            /*$loadedTheme*/
            ctx2[2].theme.images.containerImages
          );
        }
        const checkbox3_changes = {};
        if (!updating_checked_3 && dirty[0] & /*schemeEnableBackgroundTint*/
        256) {
          updating_checked_3 = true;
          checkbox3_changes.checked = /*schemeEnableBackgroundTint*/
          ctx2[8];
          add_flush_callback(() => updating_checked_3 = false);
        }
        checkbox3.$set(checkbox3_changes);
        const colorpickerbutton2_changes = {};
        if (dirty[0] & /*schemeBackgroundTint, schemeEnableBackgroundTint, $loadedTheme, feature*/
        293) colorpickerbutton2_changes.colorChanged = /*func*/
        ctx2[39];
        colorpickerbutton2.$set(colorpickerbutton2_changes);
        const checkbox4_changes = {};
        if (!updating_checked_4 && dirty[0] & /*$loadedTheme*/
        4) {
          updating_checked_4 = true;
          checkbox4_changes.checked = /*$loadedTheme*/
          ctx2[2].theme.images.backgroundRepeat;
          add_flush_callback(() => updating_checked_4 = false);
        }
        checkbox4.$set(checkbox4_changes);
        if (dirty[0] & /*themeColors, $loadedTheme, feature*/
        2053) {
          each_value_1 = ensure_array_like(
            /*themeColors*/
            ctx2[11]
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$b(ctx2, each_value_1, i);
            if (each_blocks_1[i]) {
              each_blocks_1[i].p(child_ctx, dirty);
              transition_in(each_blocks_1[i], 1);
            } else {
              each_blocks_1[i] = create_each_block_1$b(child_ctx);
              each_blocks_1[i].c();
              transition_in(each_blocks_1[i], 1);
              each_blocks_1[i].m(div25, null);
            }
          }
          group_outros();
          for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
            out(i);
          }
          check_outros();
        }
        if (dirty[0] & /*$loadedTheme*/
        4 && input6.value !== /*$loadedTheme*/
        ctx2[2].theme.misc.fontStyle) {
          set_input_value(
            input6,
            /*$loadedTheme*/
            ctx2[2].theme.misc.fontStyle
          );
        }
        if (dirty[0] & /*$loadedTheme*/
        4 && input7.value !== /*$loadedTheme*/
        ctx2[2].theme.misc.themeCssUrl) {
          set_input_value(
            input7,
            /*$loadedTheme*/
            ctx2[2].theme.misc.themeCssUrl
          );
        }
        if (dirty[0] & /*$loadedTheme*/
        4 && input8.value !== /*$loadedTheme*/
        ctx2[2].theme.misc.cssText) {
          set_input_value(
            input8,
            /*$loadedTheme*/
            ctx2[2].theme.misc.cssText
          );
        }
        if (dirty[0] & /*$loadedTheme*/
        4 && input9.value !== /*$loadedTheme*/
        ctx2[2].theme.misc.htmlText) {
          set_input_value(
            input9,
            /*$loadedTheme*/
            ctx2[2].theme.misc.htmlText
          );
        }
        const checkbox5_changes = {};
        if (!updating_checked_5 && dirty[0] & /*$loadedTheme*/
        4) {
          updating_checked_5 = true;
          checkbox5_changes.checked = /*$loadedTheme*/
          ctx2[2].theme.misc.hideFooter;
          add_flush_callback(() => updating_checked_5 = false);
        }
        checkbox5.$set(checkbox5_changes);
        const checkbox6_changes = {};
        if (!updating_checked_6 && dirty[0] & /*$loadedTheme*/
        4) {
          updating_checked_6 = true;
          checkbox6_changes.checked = /*$loadedTheme*/
          ctx2[2].theme.misc.hideSkribblPanels;
          add_flush_callback(() => updating_checked_6 = false);
        }
        checkbox6.$set(checkbox6_changes);
        const checkbox7_changes = {};
        if (!updating_checked_7 && dirty[0] & /*$loadedTheme*/
        4) {
          updating_checked_7 = true;
          checkbox7_changes.checked = /*$loadedTheme*/
          ctx2[2].theme.misc.hideAvatarLogo;
          add_flush_callback(() => updating_checked_7 = false);
        }
        checkbox7.$set(checkbox7_changes);
        const checkbox8_changes = {};
        if (!updating_checked_8 && dirty[0] & /*$loadedTheme*/
        4) {
          updating_checked_8 = true;
          checkbox8_changes.checked = /*$loadedTheme*/
          ctx2[2].theme.misc.hideInGameLogo;
          add_flush_callback(() => updating_checked_8 = false);
        }
        checkbox8.$set(checkbox8_changes);
        if (dirty[0] & /*$loadedTheme, variableHooks, feature*/
        7) {
          each_value = ensure_array_like(Object.entries(
            /*variableHooks*/
            ctx2[1]
          ));
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$t(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$t(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div39, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        transition_in(flatbutton2.$$.fragment, local);
        transition_in(colorpickerbutton0.$$.fragment, local);
        transition_in(colorpickerbutton1.$$.fragment, local);
        transition_in(checkbox0.$$.fragment, local);
        transition_in(checkbox1.$$.fragment, local);
        transition_in(checkbox2.$$.fragment, local);
        transition_in(flatbutton3.$$.fragment, local);
        transition_in(checkbox3.$$.fragment, local);
        transition_in(colorpickerbutton2.$$.fragment, local);
        transition_in(checkbox4.$$.fragment, local);
        for (let i = 0; i < each_value_1.length; i += 1) {
          transition_in(each_blocks_1[i]);
        }
        transition_in(checkbox5.$$.fragment, local);
        transition_in(checkbox6.$$.fragment, local);
        transition_in(checkbox7.$$.fragment, local);
        transition_in(checkbox8.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        transition_out(flatbutton2.$$.fragment, local);
        transition_out(colorpickerbutton0.$$.fragment, local);
        transition_out(colorpickerbutton1.$$.fragment, local);
        transition_out(checkbox0.$$.fragment, local);
        transition_out(checkbox1.$$.fragment, local);
        transition_out(checkbox2.$$.fragment, local);
        transition_out(flatbutton3.$$.fragment, local);
        transition_out(checkbox3.$$.fragment, local);
        transition_out(colorpickerbutton2.$$.fragment, local);
        transition_out(checkbox4.$$.fragment, local);
        each_blocks_1 = each_blocks_1.filter(Boolean);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          transition_out(each_blocks_1[i]);
        }
        transition_out(checkbox5.$$.fragment, local);
        transition_out(checkbox6.$$.fragment, local);
        transition_out(checkbox7.$$.fragment, local);
        transition_out(checkbox8.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t6);
          detach(div42);
        }
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
        destroy_component(flatbutton2);
        destroy_component(colorpickerbutton0);
        destroy_component(colorpickerbutton1);
        destroy_component(checkbox0);
        destroy_component(checkbox1);
        destroy_component(checkbox2);
        destroy_component(flatbutton3);
        destroy_component(checkbox3);
        destroy_component(colorpickerbutton2);
        destroy_component(checkbox4);
        destroy_each(each_blocks_1, detaching);
        destroy_component(checkbox5);
        destroy_component(checkbox6);
        destroy_component(checkbox7);
        destroy_component(checkbox8);
        destroy_each(each_blocks, detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_else_block$g, "create_else_block$g");
  function create_if_block$v(ctx) {
    let div0;
    let t0;
    let br0;
    let t1;
    let br1;
    let t2;
    let flatbutton0;
    let t3;
    let br2;
    let t4;
    let br3;
    let t5;
    let div2;
    let div1;
    let t7;
    let br4;
    let t8;
    let input;
    let t9;
    let flatbutton1;
    let current;
    let mounted;
    let dispose;
    flatbutton0 = new Flat_button({
      props: {
        content: "Create new Theme",
        color: "green"
      }
    });
    flatbutton0.$on(
      "click",
      /*click_handler*/
      ctx[15]
    );
    flatbutton1 = new Flat_button({
      props: { content: "Import Theme", color: "blue" }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_1*/
      ctx[17]
    );
    return {
      c() {
        div0 = element("div");
        t0 = text('No theme loaded for editing. Select one of your themes in the "Saved Themes" tab or create a new one!');
        br0 = element("br");
        t1 = space();
        br1 = element("br");
        t2 = space();
        create_component(flatbutton0.$$.fragment);
        t3 = space();
        br2 = element("br");
        t4 = space();
        br3 = element("br");
        t5 = space();
        div2 = element("div");
        div1 = element("div");
        div1.textContent = "If you have received a theme share ID, you can import it here:";
        t7 = space();
        br4 = element("br");
        t8 = space();
        input = element("input");
        t9 = space();
        create_component(flatbutton1.$$.fragment);
        attr(div0, "class", "typo-themes-editor-header svelte-1gh1qig");
        attr(input, "type", "text");
        set_style(input, "width", "auto");
        set_style(input, "margin-right", "1rem");
        attr(input, "placeholder", "Share ID");
        attr(div2, "class", "typo-themes-editor-header svelte-1gh1qig");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        append(div0, t0);
        append(div0, br0);
        append(div0, t1);
        append(div0, br1);
        append(div0, t2);
        mount_component(flatbutton0, div0, null);
        insert(target, t3, anchor);
        insert(target, br2, anchor);
        insert(target, t4, anchor);
        insert(target, br3, anchor);
        insert(target, t5, anchor);
        insert(target, div2, anchor);
        append(div2, div1);
        append(div2, t7);
        append(div2, br4);
        append(div2, t8);
        append(div2, input);
        set_input_value(
          input,
          /*shareId*/
          ctx[10]
        );
        append(div2, t9);
        mount_component(flatbutton1, div2, null);
        current = true;
        if (!mounted) {
          dispose = listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[16]
          );
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty[0] & /*shareId*/
        1024 && input.value !== /*shareId*/
        ctx2[10]) {
          set_input_value(
            input,
            /*shareId*/
            ctx2[10]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t3);
          detach(br2);
          detach(t4);
          detach(br3);
          detach(t5);
          detach(div2);
        }
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block$v, "create_if_block$v");
  function create_each_block_1$b(ctx) {
    let div;
    let t0_value = (
      /*color*/
      ctx[61][0].replace("--", "") + ""
    );
    let t0;
    let t1;
    let t2;
    let colorpickerbutton;
    let current;
    function func_12(...args) {
      return (
        /*func_1*/
        ctx[42](
          /*color*/
          ctx[61],
          ...args
        )
      );
    }
    __name(func_12, "func_1");
    colorpickerbutton = new Color_picker_button({
      props: {
        color: (
          /*color*/
          ctx[61][1]
        ),
        allowAlpha: true,
        colorChanged: func_12
      }
    });
    return {
      c() {
        div = element("div");
        t0 = text(t0_value);
        t1 = text(":");
        t2 = space();
        create_component(colorpickerbutton.$$.fragment);
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, t0);
        append(div, t1);
        insert(target, t2, anchor);
        mount_component(colorpickerbutton, target, anchor);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if ((!current || dirty[0] & /*themeColors*/
        2048) && t0_value !== (t0_value = /*color*/
        ctx[61][0].replace("--", "") + "")) set_data(t0, t0_value);
        const colorpickerbutton_changes = {};
        if (dirty[0] & /*themeColors*/
        2048) colorpickerbutton_changes.color = /*color*/
        ctx[61][1];
        if (dirty[0] & /*$loadedTheme, themeColors, feature*/
        2053) colorpickerbutton_changes.colorChanged = func_12;
        colorpickerbutton.$set(colorpickerbutton_changes);
      },
      i(local) {
        if (current) return;
        transition_in(colorpickerbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(colorpickerbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
          detach(t2);
        }
        destroy_component(colorpickerbutton, detaching);
      }
    };
  }
  __name(create_each_block_1$b, "create_each_block_1$b");
  function create_each_block$t(ctx) {
    let div;
    let abbr;
    let t0;
    let abbr_title_value;
    let t1;
    let t2_value = (
      /*color*/
      ctx[61][0].replace("--", "") + ""
    );
    let t2;
    let t3;
    let t4;
    let input;
    let mounted;
    let dispose;
    function input_input_handler_1() {
      ctx[59].call(
        input,
        /*color*/
        ctx[61]
      );
    }
    __name(input_input_handler_1, "input_input_handler_1");
    return {
      c() {
        div = element("div");
        abbr = element("abbr");
        t0 = text("ℹ️");
        t1 = space();
        t2 = text(t2_value);
        t3 = text(":");
        t4 = space();
        input = element("input");
        attr(abbr, "title", abbr_title_value = /*color*/
        ctx[61][1].join(", "));
        attr(input, "type", "text");
        attr(input, "placeholder", "color: red; border: 1px solid green;");
        attr(input, "class", "svelte-1gh1qig");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, abbr);
        append(abbr, t0);
        append(div, t1);
        append(div, t2);
        append(div, t3);
        insert(target, t4, anchor);
        insert(target, input, anchor);
        set_input_value(
          input,
          /*$loadedTheme*/
          ctx[2].theme.hooks[
            /*color*/
            ctx[61][0]
          ]
        );
        if (!mounted) {
          dispose = [
            listen(input, "input", input_input_handler_1),
            listen(
              input,
              "change",
              /*change_handler_14*/
              ctx[60]
            )
          ];
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty[0] & /*variableHooks*/
        2 && abbr_title_value !== (abbr_title_value = /*color*/
        ctx[61][1].join(", "))) {
          attr(abbr, "title", abbr_title_value);
        }
        if (dirty[0] & /*variableHooks*/
        2 && t2_value !== (t2_value = /*color*/
        ctx[61][0].replace("--", "") + "")) set_data(t2, t2_value);
        if (dirty[0] & /*$loadedTheme, variableHooks*/
        6 && input.value !== /*$loadedTheme*/
        ctx[2].theme.hooks[
          /*color*/
          ctx[61][0]
        ]) {
          set_input_value(
            input,
            /*$loadedTheme*/
            ctx[2].theme.hooks[
              /*color*/
              ctx[61][0]
            ]
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
          detach(t4);
          detach(input);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_each_block$t, "create_each_block$t");
  function create_fragment$1e(ctx) {
    let div;
    let current_block_type_index;
    let if_block;
    let current;
    const if_block_creators = [create_if_block$v, create_else_block$g];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*$loadedTheme*/
        ctx2[2] === void 0
      ) return 0;
      return 1;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div = element("div");
        if_block.c();
        attr(div, "class", "typo-themes-editor svelte-1gh1qig");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_blocks[current_block_type_index].m(div, null);
        current = true;
      },
      p(ctx2, dirty) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if_blocks[current_block_type_index].d();
      }
    };
  }
  __name(create_fragment$1e, "create_fragment$1e");
  function instance$16($$self, $$props, $$invalidate) {
    let $loadedTheme;
    let $activeThemeTab;
    let schemePrimaryColor = Color.fromHex("#4197c5");
    let schemeTextColor = Color.fromHex("#FFFFFF");
    let schemeBackgroundTint = Color.fromHex("#2f61eb");
    let schemeOnInputs = true;
    let schemeInvertInputBrightness = false;
    let schemeEnableBackgroundTint = true;
    let schemeIngame = false;
    let shareId = "";
    let { feature } = $$props;
    let { variableHooks } = $$props;
    const loadedTheme = feature.loadedEditorThemeStore;
    component_subscribe($$self, loadedTheme, (value) => $$invalidate(2, $loadedTheme = value));
    const activeThemeTab = feature.activeThemeTabStore;
    component_subscribe($$self, activeThemeTab, (value) => $$invalidate(12, $activeThemeTab = value));
    let themeColors2 = [];
    const click_handler2 = /* @__PURE__ */ __name(async () => {
      const theme = await feature.createLocalTheme();
      await feature.loadThemeToEditor(theme);
    }, "click_handler");
    function input_input_handler() {
      shareId = this.value;
      $$invalidate(10, shareId);
    }
    __name(input_input_handler, "input_input_handler");
    const click_handler_1 = /* @__PURE__ */ __name(async () => {
      const theme = await feature.importTheme(shareId);
      await feature.activateLocalTheme(theme.theme.meta.id);
      set_store_value(activeThemeTab, $activeThemeTab = "list", $activeThemeTab);
    }, "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(async () => {
      const id2 = $loadedTheme.theme.meta.id;
      await feature.discardLoadedEditorTheme(id2);
    }, "click_handler_2");
    const click_handler_3 = /* @__PURE__ */ __name(() => feature.discardLoadedEditorTheme(), "click_handler_3");
    const click_handler_4 = /* @__PURE__ */ __name(() => {
      feature.saveLoadedEditorTheme();
      feature.activeThemeTabStore.set("list");
    }, "click_handler_4");
    function input0_input_handler() {
      $loadedTheme.theme.meta.name = this.value;
      loadedTheme.set($loadedTheme);
    }
    __name(input0_input_handler, "input0_input_handler");
    function input1_input_handler() {
      $loadedTheme.theme.meta.author = this.value;
      loadedTheme.set($loadedTheme);
    }
    __name(input1_input_handler, "input1_input_handler");
    function colorpickerbutton0_color_binding(value) {
      schemePrimaryColor = value;
      $$invalidate(3, schemePrimaryColor);
    }
    __name(colorpickerbutton0_color_binding, "colorpickerbutton0_color_binding");
    function colorpickerbutton1_color_binding(value) {
      schemeTextColor = value;
      $$invalidate(4, schemeTextColor);
    }
    __name(colorpickerbutton1_color_binding, "colorpickerbutton1_color_binding");
    function checkbox0_checked_binding(value) {
      schemeOnInputs = value;
      $$invalidate(6, schemeOnInputs);
    }
    __name(checkbox0_checked_binding, "checkbox0_checked_binding");
    function checkbox1_checked_binding(value) {
      schemeInvertInputBrightness = value;
      $$invalidate(7, schemeInvertInputBrightness);
    }
    __name(checkbox1_checked_binding, "checkbox1_checked_binding");
    function checkbox2_checked_binding(value) {
      schemeIngame = value;
      $$invalidate(9, schemeIngame);
    }
    __name(checkbox2_checked_binding, "checkbox2_checked_binding");
    const click_handler_52 = /* @__PURE__ */ __name(async () => {
      await feature.setColorScheme($loadedTheme.theme, schemePrimaryColor, schemeTextColor, schemeOnInputs, schemeInvertInputBrightness, schemeIngame);
      feature.updateLoadedEditorTheme($loadedTheme);
    }, "click_handler_5");
    function input2_input_handler() {
      $loadedTheme.theme.images.urlLogo = this.value;
      loadedTheme.set($loadedTheme);
    }
    __name(input2_input_handler, "input2_input_handler");
    const change_handler = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler");
    function input3_input_handler() {
      $loadedTheme.theme.images.urlBackground = this.value;
      loadedTheme.set($loadedTheme);
    }
    __name(input3_input_handler, "input3_input_handler");
    const change_handler_1 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_1");
    function input4_input_handler() {
      $loadedTheme.theme.images.urlBackgroundGame = this.value;
      loadedTheme.set($loadedTheme);
    }
    __name(input4_input_handler, "input4_input_handler");
    const change_handler_2 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_2");
    function input5_input_handler() {
      $loadedTheme.theme.images.containerImages = this.value;
      loadedTheme.set($loadedTheme);
    }
    __name(input5_input_handler, "input5_input_handler");
    const change_handler_3 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_3");
    function checkbox3_checked_binding(value) {
      schemeEnableBackgroundTint = value;
      $$invalidate(8, schemeEnableBackgroundTint), $$invalidate(2, $loadedTheme);
    }
    __name(checkbox3_checked_binding, "checkbox3_checked_binding");
    const change_handler_4 = /* @__PURE__ */ __name(() => {
      if (schemeEnableBackgroundTint) {
        set_store_value(loadedTheme, $loadedTheme.theme.images.backgroundTint = schemeBackgroundTint.hex, $loadedTheme);
      } else {
        set_store_value(loadedTheme, $loadedTheme.theme.images.backgroundTint = void 0, $loadedTheme);
      }
      feature.updateLoadedEditorTheme($loadedTheme);
    }, "change_handler_4");
    const func2 = /* @__PURE__ */ __name((color) => {
      $$invalidate(5, schemeBackgroundTint = color);
      $$invalidate(8, schemeEnableBackgroundTint = true);
      set_store_value(loadedTheme, $loadedTheme.theme.images.backgroundTint = color.hex, $loadedTheme);
      feature.updateLoadedEditorTheme($loadedTheme);
    }, "func");
    function checkbox4_checked_binding(value) {
      if ($$self.$$.not_equal($loadedTheme.theme.images.backgroundRepeat, value)) {
        $loadedTheme.theme.images.backgroundRepeat = value;
        loadedTheme.set($loadedTheme);
      }
    }
    __name(checkbox4_checked_binding, "checkbox4_checked_binding");
    const change_handler_5 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_5");
    const func_12 = /* @__PURE__ */ __name((color, update2) => {
      set_store_value(loadedTheme, $loadedTheme.theme.colors[color[0]] = update2.hsl, $loadedTheme);
      feature.updateLoadedEditorTheme($loadedTheme);
    }, "func_1");
    function input6_input_handler() {
      $loadedTheme.theme.misc.fontStyle = this.value;
      loadedTheme.set($loadedTheme);
    }
    __name(input6_input_handler, "input6_input_handler");
    const change_handler_6 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_6");
    function input7_input_handler() {
      $loadedTheme.theme.misc.themeCssUrl = this.value;
      loadedTheme.set($loadedTheme);
    }
    __name(input7_input_handler, "input7_input_handler");
    const change_handler_7 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_7");
    function input8_input_handler() {
      $loadedTheme.theme.misc.cssText = this.value;
      loadedTheme.set($loadedTheme);
    }
    __name(input8_input_handler, "input8_input_handler");
    const change_handler_8 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_8");
    function input9_input_handler() {
      $loadedTheme.theme.misc.htmlText = this.value;
      loadedTheme.set($loadedTheme);
    }
    __name(input9_input_handler, "input9_input_handler");
    const change_handler_9 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_9");
    function checkbox5_checked_binding(value) {
      if ($$self.$$.not_equal($loadedTheme.theme.misc.hideFooter, value)) {
        $loadedTheme.theme.misc.hideFooter = value;
        loadedTheme.set($loadedTheme);
      }
    }
    __name(checkbox5_checked_binding, "checkbox5_checked_binding");
    const change_handler_10 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_10");
    function checkbox6_checked_binding(value) {
      if ($$self.$$.not_equal($loadedTheme.theme.misc.hideSkribblPanels, value)) {
        $loadedTheme.theme.misc.hideSkribblPanels = value;
        loadedTheme.set($loadedTheme);
      }
    }
    __name(checkbox6_checked_binding, "checkbox6_checked_binding");
    const change_handler_11 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_11");
    function checkbox7_checked_binding(value) {
      if ($$self.$$.not_equal($loadedTheme.theme.misc.hideAvatarLogo, value)) {
        $loadedTheme.theme.misc.hideAvatarLogo = value;
        loadedTheme.set($loadedTheme);
      }
    }
    __name(checkbox7_checked_binding, "checkbox7_checked_binding");
    const change_handler_12 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_12");
    function checkbox8_checked_binding(value) {
      if ($$self.$$.not_equal($loadedTheme.theme.misc.hideInGameLogo, value)) {
        $loadedTheme.theme.misc.hideInGameLogo = value;
        loadedTheme.set($loadedTheme);
      }
    }
    __name(checkbox8_checked_binding, "checkbox8_checked_binding");
    const change_handler_13 = /* @__PURE__ */ __name(() => feature.updateLoadedEditorTheme($loadedTheme), "change_handler_13");
    function input_input_handler_1(color) {
      $loadedTheme.theme.hooks[color[0]] = this.value;
      loadedTheme.set($loadedTheme);
    }
    __name(input_input_handler_1, "input_input_handler_1");
    const change_handler_14 = /* @__PURE__ */ __name(() => {
      feature.updateLoadedEditorTheme($loadedTheme);
    }, "change_handler_14");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
      if ("variableHooks" in $$props2) $$invalidate(1, variableHooks = $$props2.variableHooks);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & /*$loadedTheme*/
      4) {
        {
          $$invalidate(11, themeColors2 = $loadedTheme ? Object.entries($loadedTheme.theme.colors).map((entry) => {
            const color = Color.fromHsl(entry[1][0], entry[1][1], entry[1][2], entry[1][3]);
            return [entry[0], color];
          }) : []);
          if (($loadedTheme == null ? void 0 : $loadedTheme.theme.images.backgroundTint) && ($loadedTheme == null ? void 0 : $loadedTheme.theme.images.backgroundTint) !== "transparent") {
            $$invalidate(5, schemeBackgroundTint = Color.fromHex($loadedTheme.theme.images.backgroundTint));
            $$invalidate(8, schemeEnableBackgroundTint = true);
          } else {
            $$invalidate(8, schemeEnableBackgroundTint = false);
          }
        }
      }
    };
    return [
      feature,
      variableHooks,
      $loadedTheme,
      schemePrimaryColor,
      schemeTextColor,
      schemeBackgroundTint,
      schemeOnInputs,
      schemeInvertInputBrightness,
      schemeEnableBackgroundTint,
      schemeIngame,
      shareId,
      themeColors2,
      $activeThemeTab,
      loadedTheme,
      activeThemeTab,
      click_handler2,
      input_input_handler,
      click_handler_1,
      click_handler_2,
      click_handler_3,
      click_handler_4,
      input0_input_handler,
      input1_input_handler,
      colorpickerbutton0_color_binding,
      colorpickerbutton1_color_binding,
      checkbox0_checked_binding,
      checkbox1_checked_binding,
      checkbox2_checked_binding,
      click_handler_52,
      input2_input_handler,
      change_handler,
      input3_input_handler,
      change_handler_1,
      input4_input_handler,
      change_handler_2,
      input5_input_handler,
      change_handler_3,
      checkbox3_checked_binding,
      change_handler_4,
      func2,
      checkbox4_checked_binding,
      change_handler_5,
      func_12,
      input6_input_handler,
      change_handler_6,
      input7_input_handler,
      change_handler_7,
      input8_input_handler,
      change_handler_8,
      input9_input_handler,
      change_handler_9,
      checkbox5_checked_binding,
      change_handler_10,
      checkbox6_checked_binding,
      change_handler_11,
      checkbox7_checked_binding,
      change_handler_12,
      checkbox8_checked_binding,
      change_handler_13,
      input_input_handler_1,
      change_handler_14
    ];
  }
  __name(instance$16, "instance$16");
  const _Themes_editor = class _Themes_editor extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$16, create_fragment$1e, safe_not_equal, { feature: 0, variableHooks: 1 }, null, [-1, -1, -1]);
    }
  };
  __name(_Themes_editor, "Themes_editor");
  let Themes_editor = _Themes_editor;
  function get_each_context$s(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[15] = list[i];
    return child_ctx;
  }
  __name(get_each_context$s, "get_each_context$s");
  function create_else_block$f(ctx) {
    let div1;
    return {
      c() {
        div1 = element("div");
        div1.innerHTML = `<img src="" alt="disabled" style="content: var(--file-img-disabled-gif)" class="svelte-wdh6rb"/> <div>Inactive</div>`;
        attr(div1, "class", "active-marker svelte-wdh6rb");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
      }
    };
  }
  __name(create_else_block$f, "create_else_block$f");
  function create_if_block_5$4(ctx) {
    let div1;
    return {
      c() {
        div1 = element("div");
        div1.innerHTML = `<img src="" alt="enabled" style="content: var(--file-img-enabled-gif)" class="svelte-wdh6rb"/> <div>Editing</div>`;
        attr(div1, "class", "active-marker svelte-wdh6rb");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
      }
    };
  }
  __name(create_if_block_5$4, "create_if_block_5$4");
  function create_if_block_4$8(ctx) {
    let div1;
    return {
      c() {
        div1 = element("div");
        div1.innerHTML = `<img src="" alt="enabled" style="content: var(--file-img-enabled-gif)" class="svelte-wdh6rb"/> <div>Selected</div>`;
        attr(div1, "class", "active-marker svelte-wdh6rb");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
      }
    };
  }
  __name(create_if_block_4$8, "create_if_block_4$8");
  function create_if_block_3$8(ctx) {
    let span0;
    let t0;
    let t1_value = (
      /*theme*/
      ctx[15].publicTheme.localVersion + ""
    );
    let t1;
    let t2;
    let span1;
    let t3;
    let t4_value = (
      /*theme*/
      ctx[15].publicTheme.publicId + ""
    );
    let t4;
    return {
      c() {
        span0 = element("span");
        t0 = text("v");
        t1 = text(t1_value);
        t2 = space();
        span1 = element("span");
        t3 = text("#");
        t4 = text(t4_value);
        attr(span0, "class", "svelte-wdh6rb");
        attr(span1, "class", "svelte-wdh6rb");
      },
      m(target, anchor) {
        insert(target, span0, anchor);
        append(span0, t0);
        append(span0, t1);
        insert(target, t2, anchor);
        insert(target, span1, anchor);
        append(span1, t3);
        append(span1, t4);
      },
      p(ctx2, dirty) {
        if (dirty & /*$savedThemes*/
        2 && t1_value !== (t1_value = /*theme*/
        ctx2[15].publicTheme.localVersion + "")) set_data(t1, t1_value);
        if (dirty & /*$savedThemes*/
        2 && t4_value !== (t4_value = /*theme*/
        ctx2[15].publicTheme.publicId + "")) set_data(t4, t4_value);
      },
      d(detaching) {
        if (detaching) {
          detach(span0);
          detach(t2);
          detach(span1);
        }
      }
    };
  }
  __name(create_if_block_3$8, "create_if_block_3$8");
  function create_if_block_2$c(ctx) {
    let flatbutton;
    let current;
    function click_handler_1() {
      return (
        /*click_handler_1*/
        ctx[12](
          /*theme*/
          ctx[15]
        )
      );
    }
    __name(click_handler_1, "click_handler_1");
    flatbutton = new Flat_button({
      props: { content: "Remove", color: "orange" }
    });
    flatbutton.$on("click", click_handler_1);
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block_2$c, "create_if_block_2$c");
  function create_if_block_1$e(ctx) {
    var _a2, _b2;
    let flatbutton;
    let current;
    function click_handler_2() {
      return (
        /*click_handler_2*/
        ctx[13](
          /*theme*/
          ctx[15]
        )
      );
    }
    __name(click_handler_2, "click_handler_2");
    flatbutton = new Flat_button({
      props: {
        content: (
          /*$loadedEditorTheme*/
          ((_a2 = ctx[3]) == null ? void 0 : _a2.theme.meta.id) === /*theme*/
          ctx[15].theme.meta.id ? "Editing" : "Edit"
        ),
        color: "blue",
        disabled: (
          /*$loadedEditorTheme*/
          ((_b2 = ctx[3]) == null ? void 0 : _b2.theme.meta.id) === /*theme*/
          ctx[15].theme.meta.id
        )
      }
    });
    flatbutton.$on("click", click_handler_2);
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p(new_ctx, dirty) {
        var _a3, _b3;
        ctx = new_ctx;
        const flatbutton_changes = {};
        if (dirty & /*$loadedEditorTheme, $savedThemes*/
        10) flatbutton_changes.content = /*$loadedEditorTheme*/
        ((_a3 = ctx[3]) == null ? void 0 : _a3.theme.meta.id) === /*theme*/
        ctx[15].theme.meta.id ? "Editing" : "Edit";
        if (dirty & /*$loadedEditorTheme, $savedThemes*/
        10) flatbutton_changes.disabled = /*$loadedEditorTheme*/
        ((_b3 = ctx[3]) == null ? void 0 : _b3.theme.meta.id) === /*theme*/
        ctx[15].theme.meta.id;
        flatbutton.$set(flatbutton_changes);
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block_1$e, "create_if_block_1$e");
  function create_if_block$u(ctx) {
    var _a2;
    let flatbutton;
    let current;
    function click_handler_3() {
      return (
        /*click_handler_3*/
        ctx[14](
          /*theme*/
          ctx[15]
        )
      );
    }
    __name(click_handler_3, "click_handler_3");
    flatbutton = new Flat_button({
      props: {
        content: "Share",
        color: "blue",
        disabled: (
          /*$loadedEditorTheme*/
          ((_a2 = ctx[3]) == null ? void 0 : _a2.theme.meta.id) === /*theme*/
          ctx[15].theme.meta.id
        )
      }
    });
    flatbutton.$on("click", click_handler_3);
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p(new_ctx, dirty) {
        var _a3;
        ctx = new_ctx;
        const flatbutton_changes = {};
        if (dirty & /*$loadedEditorTheme, $savedThemes*/
        10) flatbutton_changes.disabled = /*$loadedEditorTheme*/
        ((_a3 = ctx[3]) == null ? void 0 : _a3.theme.meta.id) === /*theme*/
        ctx[15].theme.meta.id;
        flatbutton.$set(flatbutton_changes);
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block$u, "create_if_block$u");
  function create_each_block$s(ctx) {
    let div5;
    let div0;
    let b;
    let t0_value = (
      /*theme*/
      ctx[15].theme.meta.name + ""
    );
    let t0;
    let t1;
    let span;
    let t2_value = (
      /*theme*/
      ctx[15].publicTheme ? "Featured Theme" : "Local Theme"
    );
    let t2;
    let t3;
    let div2;
    let t4;
    let div1;
    let t5;
    let t6_value = (
      /*theme*/
      ctx[15].theme.meta.author + ""
    );
    let t6;
    let t7;
    let t8;
    let div3;
    let flatbutton;
    let t9;
    let t10;
    let div4;
    let t11;
    let t12;
    let current;
    function select_block_type(ctx2, dirty) {
      var _a2;
      if (
        /*$currentThemeId*/
        ctx2[2] === /*theme*/
        ctx2[15].theme.meta.id && /*$loadedEditorTheme*/
        ctx2[3] === void 0
      ) return create_if_block_4$8;
      if (
        /*$loadedEditorTheme*/
        ((_a2 = ctx2[3]) == null ? void 0 : _a2.theme.meta.id) === /*theme*/
        ctx2[15].theme.meta.id
      ) return create_if_block_5$4;
      return create_else_block$f;
    }
    __name(select_block_type, "select_block_type");
    let current_block_type = select_block_type(ctx);
    let if_block0 = current_block_type(ctx);
    let if_block1 = (
      /*$devmode*/
      ctx[4] && /*theme*/
      ctx[15].publicTheme && create_if_block_3$8(ctx)
    );
    function click_handler2() {
      return (
        /*click_handler*/
        ctx[11](
          /*theme*/
          ctx[15]
        )
      );
    }
    __name(click_handler2, "click_handler");
    flatbutton = new Flat_button({
      props: {
        content: (
          /*$currentThemeId*/
          ctx[2] === /*theme*/
          ctx[15].theme.meta.id && /*$loadedEditorTheme*/
          ctx[3] === void 0 ? "Active" : "Activate"
        ),
        disabled: (
          /*$currentThemeId*/
          ctx[2] === /*theme*/
          ctx[15].theme.meta.id && /*$loadedEditorTheme*/
          ctx[3] === void 0
        ),
        color: "green"
      }
    });
    flatbutton.$on("click", click_handler2);
    let if_block2 = (
      /*theme*/
      (ctx[15].publicTheme || /*theme*/
      ctx[15].enableManage === true) && create_if_block_2$c(ctx)
    );
    let if_block3 = (
      /*theme*/
      ctx[15].enableManage === true && create_if_block_1$e(ctx)
    );
    let if_block4 = (
      /*theme*/
      ctx[15].enableManage === true && create_if_block$u(ctx)
    );
    return {
      c() {
        div5 = element("div");
        div0 = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = space();
        span = element("span");
        t2 = text(t2_value);
        t3 = space();
        div2 = element("div");
        if_block0.c();
        t4 = space();
        div1 = element("div");
        t5 = text("by ");
        t6 = text(t6_value);
        t7 = space();
        if (if_block1) if_block1.c();
        t8 = space();
        div3 = element("div");
        create_component(flatbutton.$$.fragment);
        t9 = space();
        if (if_block2) if_block2.c();
        t10 = space();
        div4 = element("div");
        if (if_block3) if_block3.c();
        t11 = space();
        if (if_block4) if_block4.c();
        t12 = space();
        attr(b, "class", "svelte-wdh6rb");
        attr(span, "class", "svelte-wdh6rb");
        attr(div0, "class", "svelte-wdh6rb");
        attr(div1, "class", "svelte-wdh6rb");
        attr(div2, "class", "svelte-wdh6rb");
        attr(div3, "class", "svelte-wdh6rb");
        attr(div4, "class", "svelte-wdh6rb");
        attr(div5, "class", "typo-themes-list-item svelte-wdh6rb");
      },
      m(target, anchor) {
        insert(target, div5, anchor);
        append(div5, div0);
        append(div0, b);
        append(b, t0);
        append(div0, t1);
        append(div0, span);
        append(span, t2);
        append(div5, t3);
        append(div5, div2);
        if_block0.m(div2, null);
        append(div2, t4);
        append(div2, div1);
        append(div1, t5);
        append(div1, t6);
        append(div2, t7);
        if (if_block1) if_block1.m(div2, null);
        append(div5, t8);
        append(div5, div3);
        mount_component(flatbutton, div3, null);
        append(div3, t9);
        if (if_block2) if_block2.m(div3, null);
        append(div5, t10);
        append(div5, div4);
        if (if_block3) if_block3.m(div4, null);
        append(div4, t11);
        if (if_block4) if_block4.m(div4, null);
        append(div5, t12);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if ((!current || dirty & /*$savedThemes*/
        2) && t0_value !== (t0_value = /*theme*/
        ctx[15].theme.meta.name + "")) set_data(t0, t0_value);
        if ((!current || dirty & /*$savedThemes*/
        2) && t2_value !== (t2_value = /*theme*/
        ctx[15].publicTheme ? "Featured Theme" : "Local Theme")) set_data(t2, t2_value);
        if (current_block_type !== (current_block_type = select_block_type(ctx))) {
          if_block0.d(1);
          if_block0 = current_block_type(ctx);
          if (if_block0) {
            if_block0.c();
            if_block0.m(div2, t4);
          }
        }
        if ((!current || dirty & /*$savedThemes*/
        2) && t6_value !== (t6_value = /*theme*/
        ctx[15].theme.meta.author + "")) set_data(t6, t6_value);
        if (
          /*$devmode*/
          ctx[4] && /*theme*/
          ctx[15].publicTheme
        ) {
          if (if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1 = create_if_block_3$8(ctx);
            if_block1.c();
            if_block1.m(div2, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
        const flatbutton_changes = {};
        if (dirty & /*$currentThemeId, $savedThemes, $loadedEditorTheme*/
        14) flatbutton_changes.content = /*$currentThemeId*/
        ctx[2] === /*theme*/
        ctx[15].theme.meta.id && /*$loadedEditorTheme*/
        ctx[3] === void 0 ? "Active" : "Activate";
        if (dirty & /*$currentThemeId, $savedThemes, $loadedEditorTheme*/
        14) flatbutton_changes.disabled = /*$currentThemeId*/
        ctx[2] === /*theme*/
        ctx[15].theme.meta.id && /*$loadedEditorTheme*/
        ctx[3] === void 0;
        flatbutton.$set(flatbutton_changes);
        if (
          /*theme*/
          ctx[15].publicTheme || /*theme*/
          ctx[15].enableManage === true
        ) {
          if (if_block2) {
            if_block2.p(ctx, dirty);
            if (dirty & /*$savedThemes*/
            2) {
              transition_in(if_block2, 1);
            }
          } else {
            if_block2 = create_if_block_2$c(ctx);
            if_block2.c();
            transition_in(if_block2, 1);
            if_block2.m(div3, null);
          }
        } else if (if_block2) {
          group_outros();
          transition_out(if_block2, 1, 1, () => {
            if_block2 = null;
          });
          check_outros();
        }
        if (
          /*theme*/
          ctx[15].enableManage === true
        ) {
          if (if_block3) {
            if_block3.p(ctx, dirty);
            if (dirty & /*$savedThemes*/
            2) {
              transition_in(if_block3, 1);
            }
          } else {
            if_block3 = create_if_block_1$e(ctx);
            if_block3.c();
            transition_in(if_block3, 1);
            if_block3.m(div4, t11);
          }
        } else if (if_block3) {
          group_outros();
          transition_out(if_block3, 1, 1, () => {
            if_block3 = null;
          });
          check_outros();
        }
        if (
          /*theme*/
          ctx[15].enableManage === true
        ) {
          if (if_block4) {
            if_block4.p(ctx, dirty);
            if (dirty & /*$savedThemes*/
            2) {
              transition_in(if_block4, 1);
            }
          } else {
            if_block4 = create_if_block$u(ctx);
            if_block4.c();
            transition_in(if_block4, 1);
            if_block4.m(div4, null);
          }
        } else if (if_block4) {
          group_outros();
          transition_out(if_block4, 1, 1, () => {
            if_block4 = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        transition_in(if_block2);
        transition_in(if_block3);
        transition_in(if_block4);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        transition_out(if_block2);
        transition_out(if_block3);
        transition_out(if_block4);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div5);
        }
        if_block0.d();
        if (if_block1) if_block1.d();
        destroy_component(flatbutton);
        if (if_block2) if_block2.d();
        if (if_block3) if_block3.d();
        if (if_block4) if_block4.d();
      }
    };
  }
  __name(create_each_block$s, "create_each_block$s");
  function create_fragment$1d(ctx) {
    let div0;
    let t1;
    let div1;
    let current;
    let each_value = ensure_array_like(
      /*$savedThemes*/
      ctx[1]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$s(get_each_context$s(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        div0 = element("div");
        div0.textContent = "Downloaded and created themes will appear here. Select a theme to change the appearance of skribbl!";
        t1 = space();
        div1 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div0, "class", "typo-themes-list-header svelte-wdh6rb");
        attr(div1, "class", "typo-themes-list-list svelte-wdh6rb");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        insert(target, t1, anchor);
        insert(target, div1, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div1, null);
          }
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (dirty & /*$loadedEditorTheme, $savedThemes, feature, $selectedTab, $currentThemeId, undefined, $devmode*/
        63) {
          each_value = ensure_array_like(
            /*$savedThemes*/
            ctx2[1]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$s(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$s(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div1, null);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t1);
          detach(div1);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_fragment$1d, "create_fragment$1d");
  function instance$15($$self, $$props, $$invalidate) {
    let $savedThemes;
    let $currentThemeId;
    let $loadedEditorTheme;
    let $devmode;
    let $selectedTab;
    let { feature } = $$props;
    const devmode = feature.devmodeStore;
    component_subscribe($$self, devmode, (value) => $$invalidate(4, $devmode = value));
    const savedThemes = feature.savedThemesStore;
    component_subscribe($$self, savedThemes, (value) => $$invalidate(1, $savedThemes = value));
    const currentThemeId = feature.activeThemeStore;
    component_subscribe($$self, currentThemeId, (value) => $$invalidate(2, $currentThemeId = value));
    const loadedEditorTheme = feature.loadedEditorThemeStore;
    component_subscribe($$self, loadedEditorTheme, (value) => $$invalidate(3, $loadedEditorTheme = value));
    const selectedTab = feature.activeThemeTabStore;
    component_subscribe($$self, selectedTab, (value) => $$invalidate(5, $selectedTab = value));
    const click_handler2 = /* @__PURE__ */ __name((theme) => feature.activateLocalTheme(theme.theme.meta.id), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name((theme) => feature.removeSavedTheme(theme.theme.meta.id), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name((theme) => {
      feature.loadThemeToEditor(theme);
      set_store_value(selectedTab, $selectedTab = "editor", $selectedTab);
    }, "click_handler_2");
    const click_handler_3 = /* @__PURE__ */ __name((theme) => {
      feature.shareTheme(theme.theme);
    }, "click_handler_3");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      $savedThemes,
      $currentThemeId,
      $loadedEditorTheme,
      $devmode,
      $selectedTab,
      devmode,
      savedThemes,
      currentThemeId,
      loadedEditorTheme,
      selectedTab,
      click_handler2,
      click_handler_1,
      click_handler_2,
      click_handler_3
    ];
  }
  __name(instance$15, "instance$15");
  const _Themes_list = class _Themes_list extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$15, create_fragment$1d, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Themes_list, "Themes_list");
  let Themes_list = _Themes_list;
  function create_if_block_2$b(ctx) {
    let themesbrowser;
    let current;
    themesbrowser = new Themes_browser({ props: { feature: (
      /*feature*/
      ctx[0]
    ) } });
    return {
      c() {
        create_component(themesbrowser.$$.fragment);
      },
      m(target, anchor) {
        mount_component(themesbrowser, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const themesbrowser_changes = {};
        if (dirty & /*feature*/
        1) themesbrowser_changes.feature = /*feature*/
        ctx2[0];
        themesbrowser.$set(themesbrowser_changes);
      },
      i(local) {
        if (current) return;
        transition_in(themesbrowser.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(themesbrowser.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(themesbrowser, detaching);
      }
    };
  }
  __name(create_if_block_2$b, "create_if_block_2$b");
  function create_if_block_1$d(ctx) {
    let themeseditor;
    let current;
    themeseditor = new Themes_editor({
      props: {
        feature: (
          /*feature*/
          ctx[0]
        ),
        variableHooks: (
          /*variableHooks*/
          ctx[1]
        )
      }
    });
    return {
      c() {
        create_component(themeseditor.$$.fragment);
      },
      m(target, anchor) {
        mount_component(themeseditor, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const themeseditor_changes = {};
        if (dirty & /*feature*/
        1) themeseditor_changes.feature = /*feature*/
        ctx2[0];
        if (dirty & /*variableHooks*/
        2) themeseditor_changes.variableHooks = /*variableHooks*/
        ctx2[1];
        themeseditor.$set(themeseditor_changes);
      },
      i(local) {
        if (current) return;
        transition_in(themeseditor.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(themeseditor.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(themeseditor, detaching);
      }
    };
  }
  __name(create_if_block_1$d, "create_if_block_1$d");
  function create_if_block$t(ctx) {
    let themeslist;
    let current;
    themeslist = new Themes_list({ props: { feature: (
      /*feature*/
      ctx[0]
    ) } });
    return {
      c() {
        create_component(themeslist.$$.fragment);
      },
      m(target, anchor) {
        mount_component(themeslist, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const themeslist_changes = {};
        if (dirty & /*feature*/
        1) themeslist_changes.feature = /*feature*/
        ctx2[0];
        themeslist.$set(themeslist_changes);
      },
      i(local) {
        if (current) return;
        transition_in(themeslist.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(themeslist.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(themeslist, detaching);
      }
    };
  }
  __name(create_if_block$t, "create_if_block$t");
  function create_fragment$1c(ctx) {
    let div2;
    let div0;
    let h30;
    let t1;
    let h31;
    let t3;
    let h32;
    let t5;
    let div1;
    let current_block_type_index;
    let if_block;
    let current;
    let mounted;
    let dispose;
    const if_block_creators = [create_if_block$t, create_if_block_1$d, create_if_block_2$b];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*$selectedTab*/
        ctx2[2] === "list"
      ) return 0;
      if (
        /*$selectedTab*/
        ctx2[2] === "editor"
      ) return 1;
      if (
        /*$selectedTab*/
        ctx2[2] === "browser"
      ) return 2;
      return -1;
    }
    __name(select_block_type, "select_block_type");
    if (~(current_block_type_index = select_block_type(ctx))) {
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    }
    return {
      c() {
        div2 = element("div");
        div0 = element("div");
        h30 = element("h3");
        h30.textContent = "Saved Themes";
        t1 = space();
        h31 = element("h3");
        h31.textContent = "Theme Editor";
        t3 = space();
        h32 = element("h3");
        h32.textContent = "Discover Themes";
        t5 = space();
        div1 = element("div");
        if (if_block) if_block.c();
        attr(h30, "class", "svelte-1ikbg14");
        toggle_class(
          h30,
          "selected",
          /*$selectedTab*/
          ctx[2] === "list"
        );
        attr(h31, "class", "svelte-1ikbg14");
        toggle_class(
          h31,
          "selected",
          /*$selectedTab*/
          ctx[2] === "editor"
        );
        attr(h32, "class", "svelte-1ikbg14");
        toggle_class(
          h32,
          "selected",
          /*$selectedTab*/
          ctx[2] === "browser"
        );
        attr(div0, "class", "typo-themes-navigation svelte-1ikbg14");
        attr(div1, "class", "typo-themes-tab color-scrollbar svelte-1ikbg14");
        attr(div2, "class", "typo-themes-content svelte-1ikbg14");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, div0);
        append(div0, h30);
        append(div0, t1);
        append(div0, h31);
        append(div0, t3);
        append(div0, h32);
        append(div2, t5);
        append(div2, div1);
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].m(div1, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              h30,
              "click",
              /*click_handler*/
              ctx[4]
            ),
            listen(
              h31,
              "click",
              /*click_handler_1*/
              ctx[5]
            ),
            listen(
              h32,
              "click",
              /*click_handler_2*/
              ctx[6]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (!current || dirty & /*$selectedTab*/
        4) {
          toggle_class(
            h30,
            "selected",
            /*$selectedTab*/
            ctx2[2] === "list"
          );
        }
        if (!current || dirty & /*$selectedTab*/
        4) {
          toggle_class(
            h31,
            "selected",
            /*$selectedTab*/
            ctx2[2] === "editor"
          );
        }
        if (!current || dirty & /*$selectedTab*/
        4) {
          toggle_class(
            h32,
            "selected",
            /*$selectedTab*/
            ctx2[2] === "browser"
          );
        }
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if (~current_block_type_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          }
        } else {
          if (if_block) {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
          }
          if (~current_block_type_index) {
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(div1, null);
          } else {
            if_block = null;
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].d();
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$1c, "create_fragment$1c");
  function instance$14($$self, $$props, $$invalidate) {
    let $selectedTab;
    let { feature } = $$props;
    let { variableHooks } = $$props;
    const selectedTab = feature.activeThemeTabStore;
    component_subscribe($$self, selectedTab, (value) => $$invalidate(2, $selectedTab = value));
    const click_handler2 = /* @__PURE__ */ __name(() => set_store_value(selectedTab, $selectedTab = "list", $selectedTab), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => set_store_value(selectedTab, $selectedTab = "editor", $selectedTab), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(() => set_store_value(selectedTab, $selectedTab = "browser", $selectedTab), "click_handler_2");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
      if ("variableHooks" in $$props2) $$invalidate(1, variableHooks = $$props2.variableHooks);
    };
    return [
      feature,
      variableHooks,
      $selectedTab,
      selectedTab,
      click_handler2,
      click_handler_1,
      click_handler_2
    ];
  }
  __name(instance$14, "instance$14");
  const _Controls_themes = class _Controls_themes extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$14, create_fragment$1c, safe_not_equal, { feature: 0, variableHooks: 1 });
    }
  };
  __name(_Controls_themes, "Controls_themes");
  let Controls_themes = _Controls_themes;
  var __defProp$P = Object.defineProperty;
  var __decorateClass$P = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$P(target, key2, result);
    return result;
  }, "__decorateClass$P");
  const _ControlsThemesFeature = class _ControlsThemesFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_cssColorVarSelectorsSetup");
      __publicField(this, "_apiDataSetup");
      __publicField(this, "_modalService");
      __publicField(this, "_toastService");
      __publicField(this, "_themesService");
      __publicField(this, "_globalSettingsService");
      __publicField(this, "name", "Themes");
      __publicField(this, "description", "Customize the skribbl.io appearance with pre-made themes or your own style");
      __publicField(this, "tags", [
        FeatureTag.INTERFACE
      ]);
      __publicField(this, "featureId", 34);
      __publicField(this, "_onboardingTask", this.useOnboardingTask({
        key: "theme_activated",
        name: "Activate a theme",
        description: "Select a theme to customize the style of skribbl.",
        start: /* @__PURE__ */ __name(() => this.openThemesPopup(), "start")
      }));
      __publicField(this, "_iconComponent");
      __publicField(this, "_iconClickSubscription");
      __publicField(this, "_themeResetSubscription");
      __publicField(this, "_currentThemeSubscription");
      __publicField(this, "_activeThemeTab$", new BehaviorSubject("list"));
      __publicField(this, "_themeElements", []);
      __publicField(this, "_variableHooks");
      __publicField(this, "_importedOldThemes", new ExtensionSetting("imported_old_themes", false, this));
      __publicField(this, "_importedOldThemes2", new ExtensionSetting("imported_old_themes2", false, this));
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._variableHooks = await this._cssColorVarSelectorsSetup.complete();
      this._iconComponent = new Icon_button({
        target: elements2.controls,
        props: {
          hoverMove: false,
          size: "48px",
          icon: "file-img-themes-gif",
          name: "Themes",
          order: 3,
          tooltipAction: this.createTooltip
        }
      });
      this._iconClickSubscription = this._iconComponent.click$.subscribe(() => {
        this.openThemesPopup();
      });
      this._themeResetSubscription = this._themesService.savedThemesSetting.changes$.pipe(
        combineLatestWith(this._themesService.activeThemeSetting.changes$)
      ).subscribe(([themes, activeId]) => {
        if (!themes.some((t) => t.theme.meta.id === activeId)) this._themesService.activeThemeSetting.setValue(0);
      });
      this._currentThemeSubscription = this._themesService.activeThemeSetting.changes$.pipe(
        withLatestFrom(this._themesService.savedThemesSetting.changes$),
        map(([activeId, themes]) => {
          var _a2;
          return activeId === 0 ? void 0 : (_a2 = themes.find((t) => t.theme.meta.id === activeId)) == null ? void 0 : _a2.theme;
        }),
        combineLatestWith(this._themesService.loadedEditorTheme$),
        map(([activeTheme, loadedTheme]) => (loadedTheme == null ? void 0 : loadedTheme.theme) ?? activeTheme)
      ).subscribe((theme) => {
        this._logger.debug("Active theme changed", theme);
        this.setThemeElements(theme);
      });
      await this.importOldTypoThemes();
    }
    async onDestroy() {
      var _a2, _b2, _c2, _d2;
      (_a2 = this._iconComponent) == null ? void 0 : _a2.$destroy();
      (_b2 = this._iconClickSubscription) == null ? void 0 : _b2.unsubscribe();
      this._iconClickSubscription = void 0;
      (_c2 = this._themeResetSubscription) == null ? void 0 : _c2.unsubscribe();
      this._themeResetSubscription = void 0;
      (_d2 = this._currentThemeSubscription) == null ? void 0 : _d2.unsubscribe();
      this._currentThemeSubscription = void 0;
      await this.setThemeElements(void 0);
      this._variableHooks = void 0;
    }
    openThemesPopup() {
      if (!this._variableHooks) throw new Error("Themes feature not activated?");
      const themesComponent = {
        componentType: Controls_themes,
        props: {
          feature: this,
          variableHooks: this._variableHooks
        }
      };
      this._modalService.showModal(themesComponent.componentType, themesComponent.props, "Typo Themes");
    }
    get savedThemesStore() {
      return this._themesService.savedThemesSetting.store;
    }
    get activeThemeStore() {
      return this._themesService.activeThemeSetting.store;
    }
    get loadedEditorThemeStore() {
      return this._themesService.loadedEditorThemeStore;
    }
    get activeThemeTabStore() {
      return fromObservable(this._activeThemeTab$, this._activeThemeTab$.value, (value) => this._activeThemeTab$.next(value));
    }
    get devmodeStore() {
      return this._globalSettingsService.settings.devMode.store;
    }
    async getOnlineThemes() {
      return (await this._apiDataSetup.complete()).themes;
    }
    async loadThemeToEditor(theme) {
      const toast = await this._toastService.showLoadingToast("Loading theme to editor");
      try {
        await this._themesService.loadThemeToEditor(theme);
        toast.resolve(`Theme ${theme.theme.meta.name} loaded`);
      } catch {
        toast.reject("Failed to load theme");
      }
    }
    updateLoadedEditorTheme(theme) {
      this._themesService.updateLoadedEditorTheme(theme);
    }
    async discardLoadedEditorTheme(removeThemeId) {
      if (removeThemeId !== void 0) {
        if (!await (await this._toastService.showConfirmToast("Do you want to discard & remove the theme?", void 0, 1e4, { confirm: "Remove theme", cancel: "Keep editing" })).result) {
          this._logger.info("User canceled theme removal");
          return;
        }
      } else {
        if (!await (await this._toastService.showConfirmToast("Do you want to discard the changes?", void 0, 1e4, { confirm: "Discard changes", cancel: "Keep editing" })).result) {
          this._logger.info("User canceled theme discarding");
          return;
        }
      }
      await this._themesService.unloadThemeFromEditor();
      if (removeThemeId !== void 0) {
        const toast = await this._toastService.showLoadingToast("Removing theme");
        try {
          const theme = await this._themesService.removeSavedTheme(removeThemeId);
          toast.resolve(`Theme ${theme.theme.meta.name} removed`);
        } catch {
          toast.reject("Failed to remove theme");
        }
      } else {
        await this._toastService.showToast("Theme unloaded from editor");
      }
    }
    async createLocalTheme() {
      const toast = await this._toastService.showLoadingToast("Creating new theme");
      try {
        const theme = await this._themesService.createLocalTheme();
        toast.resolve("New theme created");
        return theme;
      } catch (e) {
        toast.reject("Failed to create theme");
        throw e;
      }
    }
    async importOldTypoThemes() {
      try {
        const oldThemes = localStorage.getItem("themes");
        if (!await this._importedOldThemes.getValue() && oldThemes !== null) {
          const oldThemesObject = JSON.parse(oldThemes);
          if (!Array.isArray(oldThemesObject)) throw new Error("invalid themes data");
          for (const theme of oldThemesObject) {
            try {
              await this.importOldTheme(theme);
            } catch (e) {
              this._logger.error("Failed to import old typo theme", e);
            }
          }
          await this._importedOldThemes.setValue(true);
        }
        const oldThemes2 = localStorage.getItem("themesv2");
        if (!await this._importedOldThemes2.getValue() && oldThemes2 !== null) {
          const oldThemes2Object = JSON.parse(oldThemes2);
          if (!Array.isArray(oldThemes2Object)) throw new Error("invalid themes data");
          for (const theme of oldThemes2Object) {
            try {
              await this._themesService.importThemeFromString(JSON.stringify(theme));
            } catch (e) {
              this._logger.error("Failed to import old typo theme", e);
            }
          }
          await this._importedOldThemes2.setValue(true);
        }
      } catch (e) {
        this._logger.error("Failed to import old typo themes", e);
        throw e;
      }
    }
    async importOldTheme(oldTheme) {
      try {
        if (typeof oldTheme !== "object") throw new Error("Invalid theme data");
        const oldThemeKeys = new Map(Object.entries(oldTheme));
        const options = oldThemeKeys.get("options");
        const name = oldThemeKeys.get("name");
        if (typeof options !== "object") throw new Error("Invalid theme options");
        if (typeof name !== "string") throw new Error("Invalid theme name");
        if (name === "Original") {
          this._logger.info("Skipping original theme");
          return;
        }
        await this._themesService.importOldTheme(options, name);
      } catch (e) {
        throw e;
      }
    }
    async saveLoadedEditorTheme() {
      const toast = await this._toastService.showLoadingToast("Saving theme changes");
      try {
        const theme = await this._themesService.saveLoadedEditorTheme();
        toast.resolve(`Theme ${theme.theme.meta.name} updated`);
        return theme;
      } catch (e) {
        toast.reject("Failed to create theme");
        throw e;
      }
    }
    async savePublicTheme(theme) {
      const toast = await this._toastService.showLoadingToast("Saving theme");
      try {
        const localTheme = await this._themesService.savePublicTheme(theme);
        toast.resolve(`Theme ${localTheme.theme.meta.name} saved`);
      } catch {
        toast.reject("Failed to save theme");
      }
    }
    async activateLocalTheme(id2) {
      const toast = await this._toastService.showLoadingToast("Activating theme");
      try {
        const theme = await this._themesService.activateLocalTheme(id2);
        (await this._onboardingTask).complete();
        toast.resolve(`Theme ${theme.theme.meta.name} activated`);
      } catch {
        toast.reject("Failed to activate theme");
      }
    }
    async activatePublicTheme(theme) {
      const toast = await this._toastService.showLoadingToast("Activating theme");
      try {
        const localTheme = await this._themesService.activatePublicTheme(theme);
        (await this._onboardingTask).complete();
        toast.resolve(`Theme ${localTheme.theme.meta.name} activated`);
      } catch {
        toast.reject("Failed to activate theme");
      }
    }
    async removeSavedTheme(localId) {
      if (!await (await this._toastService.showConfirmToast("Do you want to delete the theme?", void 0, 1e4, { confirm: "Delete theme", cancel: "Cancel deletion" })).result) {
        this._logger.info("User canceled theme removal");
        return;
      }
      const toast = await this._toastService.showLoadingToast("Removing theme");
      try {
        const theme = await this._themesService.removeSavedTheme(localId);
        toast.resolve(`Theme ${theme.theme.meta.name} removed`);
      } catch {
        toast.reject("Failed to remove theme");
      }
    }
    async shareTheme(theme) {
      const toast = await this._toastService.showLoadingToast("Sharing theme");
      try {
        const id2 = await this._themesService.shareTheme(theme);
        await navigator.clipboard.writeText(id2);
        toast.resolve(`Share id (${id2}) for theme ${theme.meta.name} copied`);
      } catch {
        toast.reject("Failed to share theme");
      }
    }
    async importTheme(shareId) {
      const toast = await this._toastService.showLoadingToast("Importing theme");
      try {
        const theme = await this._themesService.importTheme(shareId);
        toast.resolve(`Theme ${theme.theme.meta.name} imported`);
        return theme;
      } catch (e) {
        toast.reject("Failed to import theme");
        throw e;
      }
    }
    /**
     * Update the html elements that represent the selelcted theme
     * @param theme
     * @private
     */
    async setThemeElements(theme) {
      this._logger.info("Setting theme elements", theme);
      this._themeElements.forEach((e) => e.remove());
      this._themeElements = theme ? await this.createThemeElements(theme) : [];
      this._themeElements.forEach((e) => document.body.appendChild(e));
    }
    /**
     * Create html elements to display a theme
     * @param theme
     * @private
     */
    async createThemeElements(theme) {
      const selectorHooks = await this._cssColorVarSelectorsSetup.complete();
      const themeStyle = generateStyleElementForTheme(theme, selectorHooks);
      const themeFont = generateThemeFontElements(theme);
      const themeHtml = generateThemeCustomHtmlElement(theme);
      const themeExternalCss = generateThemeExternalCssElement(theme);
      const themeBackground = generateThemeBackgroundElement(theme);
      return [themeStyle, ...themeFont, ...themeHtml, ...themeExternalCss, themeBackground];
    }
    /**
     * Generate a color scheme based on parameters and fill the color variables accordingly
     * @param theme
     * @param primary
     * @param text
     * @param useOnInputs
     * @param invertInputText
     * @param useIngame
     */
    async setColorScheme(theme, primary, text2, useOnInputs, invertInputText, useIngame) {
      this._logger.debug("Setting color scheme", theme, primary, text2, useOnInputs, invertInputText, useIngame);
      const colors = generateColorScheme(primary, text2, useIngame, useOnInputs, invertInputText);
      theme.colors = colors;
      await this._toastService.showToast("Color scheme updated");
    }
  };
  __name(_ControlsThemesFeature, "ControlsThemesFeature");
  let ControlsThemesFeature = _ControlsThemesFeature;
  __decorateClass$P([
    inject(ElementsSetup)
  ], ControlsThemesFeature.prototype, "_elementsSetup");
  __decorateClass$P([
    inject(CssColorVarSelectorsSetup)
  ], ControlsThemesFeature.prototype, "_cssColorVarSelectorsSetup");
  __decorateClass$P([
    inject(ApiDataSetup)
  ], ControlsThemesFeature.prototype, "_apiDataSetup");
  __decorateClass$P([
    inject(ModalService)
  ], ControlsThemesFeature.prototype, "_modalService");
  __decorateClass$P([
    inject(ToastService)
  ], ControlsThemesFeature.prototype, "_toastService");
  __decorateClass$P([
    inject(ThemesService)
  ], ControlsThemesFeature.prototype, "_themesService");
  __decorateClass$P([
    inject(GlobalSettingsService)
  ], ControlsThemesFeature.prototype, "_globalSettingsService");
  var __defProp$O = Object.defineProperty;
  var __decorateClass$O = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$O(target, key2, result);
    return result;
  }, "__decorateClass$O");
  const _CustomizerOutfitToggleFeature = class _CustomizerOutfitToggleFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_globalSettingsService");
      __publicField(this, "_memberService");
      __publicField(this, "name", "Outfit Toggle");
      __publicField(this, "description", "Add a toggle to the customizer to show or hide your typo outfit");
      __publicField(this, "tags", [
        FeatureTag.SOCIAL,
        FeatureTag.PALANTIR
      ]);
      __publicField(this, "featureId", 45);
      __publicField(this, "_iconComponent");
      __publicField(this, "_iconClickSubscription");
      __publicField(this, "_memberSubscription");
    }
    async onActivate() {
      this._memberSubscription = this._memberService.member$.subscribe(async (member) => {
        await this.setIconEnabled(member !== void 0 && member !== null);
      });
    }
    async onDestroy() {
      var _a2;
      await this.setIconEnabled(false);
      (_a2 = this._memberSubscription) == null ? void 0 : _a2.unsubscribe();
      this._memberSubscription = void 0;
    }
    async setIconEnabled(enabled) {
      var _a2, _b2;
      (_a2 = this._iconClickSubscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._iconComponent) == null ? void 0 : _b2.$destroy();
      this._iconComponent = void 0;
      this._iconClickSubscription = void 0;
      if (enabled) {
        const elements2 = await this._elementsSetup.complete();
        this._iconComponent = new Icon_button({
          target: elements2.customizerActions,
          props: {
            hoverMove: false,
            greyscaleInactive: true,
            size: "30px",
            icon: "file-img-mask-gif",
            name: "Toggle Outfit View",
            order: 2,
            tooltipAction: this.createTooltip,
            lockTooltip: "Y"
          }
        });
        this._iconClickSubscription = this._iconComponent.click$.subscribe(async () => {
          const outfitEnabled = await this._globalSettingsService.settings.showLandingOutfit.getValue();
          await this._globalSettingsService.settings.showLandingOutfit.setValue(!outfitEnabled);
        });
      }
    }
  };
  __name(_CustomizerOutfitToggleFeature, "CustomizerOutfitToggleFeature");
  let CustomizerOutfitToggleFeature = _CustomizerOutfitToggleFeature;
  __decorateClass$O([
    inject(ElementsSetup)
  ], CustomizerOutfitToggleFeature.prototype, "_elementsSetup");
  __decorateClass$O([
    inject(GlobalSettingsService)
  ], CustomizerOutfitToggleFeature.prototype, "_globalSettingsService");
  __decorateClass$O([
    inject(MemberService)
  ], CustomizerOutfitToggleFeature.prototype, "_memberService");
  var __defProp$N = Object.defineProperty;
  var __decorateClass$N = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$N(target, key2, result);
    return result;
  }, "__decorateClass$N");
  const _CustomizerPracticeJoinFeature = class _CustomizerPracticeJoinFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "name", "Practice Lobby");
      __publicField(this, "description", "Add an option to draw on your own without time limit");
      __publicField(this, "tags", [
        FeatureTag.DRAWING
      ]);
      __publicField(this, "featureId", 44);
      __publicField(this, "_iconComponent");
      __publicField(this, "_iconClickSubscription");
      __publicField(this, "_onboardingTask", this.useOnboardingTask({
        key: "practice_joined",
        name: "Enter the practice mode",
        description: "Click the palette icon next to the avatar customizer to join a free draw practice mode.",
        start: /* @__PURE__ */ __name(() => void 0, "start")
      }));
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._iconComponent = new Icon_button({
        target: elements2.customizerActions,
        props: {
          hoverMove: false,
          greyscaleInactive: true,
          size: "30px",
          icon: "file-img-palette-gif",
          name: "Enter\nPractice Lobby",
          order: 1,
          tooltipAction: this.createTooltip,
          lockTooltip: "Y"
        }
      });
      this._iconClickSubscription = this._iconComponent.click$.subscribe(async () => {
        document.dispatchEvent(new CustomEvent("joinPractice"));
        (await this._onboardingTask).complete();
      });
    }
    async onDestroy() {
      var _a2, _b2;
      (_a2 = this._iconClickSubscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._iconComponent) == null ? void 0 : _b2.$destroy();
      this._iconComponent = void 0;
      this._iconClickSubscription = void 0;
    }
  };
  __name(_CustomizerPracticeJoinFeature, "CustomizerPracticeJoinFeature");
  let CustomizerPracticeJoinFeature = _CustomizerPracticeJoinFeature;
  __decorateClass$N([
    inject(ElementsSetup)
  ], CustomizerPracticeJoinFeature.prototype, "_elementsSetup");
  const defaultPalettes = {
    skribblPalette: {
      name: "Skribbl.io Original",
      columns: 13,
      colorHexCodes: [
        "#ffffff",
        "#c1c1c1",
        "#ef130b",
        "#ff7100",
        "#ffe400",
        "#00cc00",
        "#00ff91",
        "#00b2ff",
        "#231fd3",
        "#a300ba",
        "#df69a7",
        "#ffac8e",
        "#a0522d",
        "#000000",
        "#505050",
        "#740b07",
        "#c23800",
        "#e8a200",
        "#004619",
        "#00785d",
        "#00569e",
        "#0e0865",
        "#550069",
        "#873554",
        "#cc774d",
        "#63300d"
      ]
    },
    largerSkribbl: {
      name: "Skribbl XL",
      columns: 13,
      colorHexCodes: [
        "#ffffff",
        "#e3e3e3",
        "#ff4942",
        "#fea941",
        "#fefe43",
        "#43fe43",
        "#70ffc1",
        "#39e6fd",
        "#423ffe",
        "#ca00e2",
        "#ff83cf",
        "#ffc6ae",
        "#bc5b2d",
        "#c6c6c6",
        "#aaaaaa",
        "#ef130b",
        "#ff7100",
        "#ffe400",
        "#00cc00",
        "#00ff91",
        "#00b2ff",
        "#231fd3",
        "#a300ba",
        "#df69a7",
        "#ffac8e",
        "#a0522d",
        "#8e8e8e",
        "#717171",
        "#b20f09",
        "#e15500",
        "#f4c300",
        "#00890d",
        "#00bc77",
        "#0084cf",
        "#19149c",
        "#7c0092",
        "#b34f7e",
        "#e6926e",
        "#82411d",
        "#555555",
        "#393939",
        "#740b07",
        "#c23800",
        "#e8a200",
        "#004619",
        "#00785d",
        "#00569e",
        "#0e0865",
        "#550069",
        "#873554",
        "#cc774d",
        "#63300d",
        "#1c1c1c",
        "#000000",
        "#370705",
        "#7e2200",
        "#cb7701",
        "#00240e",
        "#004f3e",
        "#00286e",
        "#060043",
        "#2e0041",
        "#702135",
        "#b35d2d",
        "#451f00"
      ]
    },
    sketchful: {
      name: "Sketchful",
      columns: 13,
      colorHexCodes: [
        "#ffffff",
        "#d3d1d2",
        "#f70f0f",
        "#ff7200",
        "#fce700",
        "#02cb00",
        "#01fe94",
        "#05b0ff",
        "#221ecd",
        "#a300bd",
        "#cc7fad",
        "#fdad88",
        "#9e5425",
        "#514f54",
        "#a9a7a8",
        "#ae0b00",
        "#c84706",
        "#ec9e06",
        "#007612",
        "#049d6f",
        "#00579d",
        "#0f0b96",
        "#6e0083",
        "#a65673",
        "#e38a5e",
        "#5e320d",
        "#000000",
        "#827c80",
        "#57060c",
        "#8b2500",
        "#9e6600",
        "#003f00",
        "#00766a",
        "#003b75",
        "#0e0151",
        "#3c0350",
        "#73314d",
        "#d1754e",
        "#421e06"
      ]
    }
  };
  var __defProp$M = Object.defineProperty;
  var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
  var __decorateClass$M = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$M(target, key2, result);
    return result;
  }, "__decorateClass$M");
  var __decorateParam$4 = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$4");
  let ColorsService = (_wa = class {
    constructor(loggerFactory2) {
      __publicField(this, "_toastService");
      __publicField(this, "_featuresService");
      __publicField(this, "_logger");
      __publicField(this, "_savedPalettesSetting", new ExtensionSetting("colors_saved_palettes", []));
      __publicField(this, "_activePaletteSetting", new ExtensionSetting("colors_active_palette", void 0));
      __publicField(this, "_selectedPalette$", new BehaviorSubject(void 0));
      __publicField(this, "_pickerColors$", new BehaviorSubject(void 0));
      __publicField(this, "_colorSelector$", new BehaviorSubject(void 0));
      __publicField(this, "featureActive", false);
      this._logger = loggerFactory2(this);
      this._activePaletteSetting.changes$.pipe(
        combineLatestWith(this._savedPalettesSetting.changes$),
        /* if changed and active does not exist, update current to undefined */
        tap(([activePalette, savedPalettes]) => {
          if (activePalette !== void 0 && ![...savedPalettes, ...Object.values(defaultPalettes)].some((p) => p.name === activePalette)) {
            this._activePaletteSetting.setValue(void 0);
          }
        }),
        map(
          ([activePalette, savedPalettes]) => activePalette !== void 0 ? [...savedPalettes, ...Object.values(defaultPalettes)].find((p) => p.name === activePalette) : void 0
        ),
        distinctUntilChanged()
      ).subscribe((palette) => this._selectedPalette$.next(palette));
      this._selectedPalette$.pipe(
        combineLatestWith(this._colorSelector$),
        map(([palette, selector]) => selector ? selector(palette) : palette)
      ).subscribe((colors) => this._pickerColors$.next(colors));
    }
    /**
     * Selected palette or undefined if default skribbl palette
     */
    get selectedPalette$() {
      return this._selectedPalette$.asObservable();
    }
    /**
     * Colors to show in the picker or undefined to show default skribbl colors
     */
    get pickerColors$() {
      return this._pickerColors$.asObservable();
    }
    get activePaletteSetting() {
      return this._activePaletteSetting.asFrozen;
    }
    get savedPalettesSetting() {
      return this._savedPalettesSetting.asFrozen;
    }
    async removePalette(name) {
      this._logger.debug(`Removing palette ${name}`);
      const palettes = await this._savedPalettesSetting.getValue();
      const index = palettes.findIndex((p) => p.name === name);
      if (index === -1) {
        this._logger.error(`Palette with name ${name} does not exist`);
        throw new Error(`Palette with name ${name} does not exist`);
      }
      palettes.splice(index, 1);
      await this._savedPalettesSetting.setValue(palettes);
    }
    async savePalette(palette, overwrite = void 0) {
      this._logger.debug(`Saving palette ${palette.name}`, palette);
      let palettes = await this._savedPalettesSetting.getValue();
      if (palettes.some((p) => p.name === palette.name && p.name !== overwrite)) {
        this._logger.error(`Palette with name ${palette.name} already exists`);
        throw new Error(`Palette with name ${palette.name} already exists`);
      }
      palettes = palettes.filter((p) => p.name !== overwrite);
      palettes.push(palette);
      await this._savedPalettesSetting.setValue(palettes);
    }
    async setColorSelector(selector) {
      if (!this.featureActive) {
        this._logger.error("Attempted to save palette while feature is not active");
        const handle = await this._toastService.showConfirmToast("Attempted to modify color palette, feature disabled.", "Do you want to enable the palettes feature?", 5e3, { confirm: "Enable", cancel: "Cancel" });
        const result = await handle.result;
        if (result) await this._featuresService.activateFeature(DrawingColorPalettesFeature);
      }
      this._colorSelector$.next(selector);
    }
    resetColorSelector() {
      this._colorSelector$.next(void 0);
    }
    get colorSelectorActive() {
      return this._colorSelector$.value === void 0;
    }
    async onFeatureActivate() {
      this.featureActive = true;
    }
    async onFeatureDestroy() {
      this.featureActive = false;
    }
  }, __name(_wa, "ColorsService"), _wa);
  __decorateClass$M([
    inject(ToastService)
  ], ColorsService.prototype, "_toastService", 2);
  __decorateClass$M([
    inject(FeaturesService)
  ], ColorsService.prototype, "_featuresService", 2);
  ColorsService = __decorateClass$M([
    injectable(),
    __decorateParam$4(0, inject(loggerFactory))
  ], ColorsService);
  function create_fragment$1b(ctx) {
    let t0;
    let br0;
    let t1;
    let br1;
    let t2;
    let h3;
    let t4;
    let b;
    let t6;
    let br2;
    let t7;
    return {
      c() {
        t0 = text("Using custom palettes, you can customize the colors available in the typo toolbar.");
        br0 = element("br");
        t1 = space();
        br1 = element("br");
        t2 = space();
        h3 = element("h3");
        h3.textContent = "⚠️ Warning:";
        t4 = text("\nOnly ");
        b = element("b");
        b.textContent = "typo users can see custom colors";
        t6 = text(", other players will not see anything until the next time you clear the canvas.");
        br2 = element("br");
        t7 = text("\nUse custom colors and custom palettes only when you're in free draw mode, or when everyone in the lobby has typo installed.");
      },
      m(target, anchor) {
        insert(target, t0, anchor);
        insert(target, br0, anchor);
        insert(target, t1, anchor);
        insert(target, br1, anchor);
        insert(target, t2, anchor);
        insert(target, h3, anchor);
        insert(target, t4, anchor);
        insert(target, b, anchor);
        insert(target, t6, anchor);
        insert(target, br2, anchor);
        insert(target, t7, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(br0);
          detach(t1);
          detach(br1);
          detach(t2);
          detach(h3);
          detach(t4);
          detach(b);
          detach(t6);
          detach(br2);
          detach(t7);
        }
      }
    };
  }
  __name(create_fragment$1b, "create_fragment$1b");
  const _Drawing_color_palettes_info = class _Drawing_color_palettes_info extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment$1b, safe_not_equal, {});
    }
  };
  __name(_Drawing_color_palettes_info, "Drawing_color_palettes_info");
  let Drawing_color_palettes_info = _Drawing_color_palettes_info;
  function get_each_context$r(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[16] = list[i];
    child_ctx[17] = list;
    child_ctx[18] = i;
    return child_ctx;
  }
  __name(get_each_context$r, "get_each_context$r");
  function create_each_block$r(ctx) {
    let div;
    let colorpickerbutton;
    let updating_color;
    let t;
    let current;
    function colorpickerbutton_color_binding(value) {
      ctx[9](
        value,
        /*color*/
        ctx[16],
        /*each_value*/
        ctx[17],
        /*i*/
        ctx[18]
      );
    }
    __name(colorpickerbutton_color_binding, "colorpickerbutton_color_binding");
    let colorpickerbutton_props = { height: "auto" };
    if (
      /*color*/
      ctx[16] !== void 0
    ) {
      colorpickerbutton_props.color = /*color*/
      ctx[16];
    }
    colorpickerbutton = new Color_picker_button({ props: colorpickerbutton_props });
    binding_callbacks.push(() => bind(colorpickerbutton, "color", colorpickerbutton_color_binding));
    return {
      c() {
        div = element("div");
        create_component(colorpickerbutton.$$.fragment);
        t = space();
        attr(div, "class", "typo-palette-builder-color");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(colorpickerbutton, div, null);
        append(div, t);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        const colorpickerbutton_changes = {};
        if (!updating_color && dirty & /*colors*/
        16) {
          updating_color = true;
          colorpickerbutton_changes.color = /*color*/
          ctx[16];
          add_flush_callback(() => updating_color = false);
        }
        colorpickerbutton.$set(colorpickerbutton_changes);
      },
      i(local) {
        if (current) return;
        transition_in(colorpickerbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(colorpickerbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(colorpickerbutton);
      }
    };
  }
  __name(create_each_block$r, "create_each_block$r");
  function create_if_block_4$7(ctx) {
    let flatbutton;
    let current;
    flatbutton = new Flat_button({
      props: { color: "green", content: "Save Palette" }
    });
    flatbutton.$on(
      "click",
      /*click_handler*/
      ctx[10]
    );
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block_4$7, "create_if_block_4$7");
  function create_if_block_3$7(ctx) {
    let flatbutton;
    let current;
    flatbutton = new Flat_button({
      props: {
        color: "orange",
        content: "Delete Palette"
      }
    });
    flatbutton.$on(
      "click",
      /*click_handler_1*/
      ctx[11]
    );
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block_3$7, "create_if_block_3$7");
  function create_if_block_2$a(ctx) {
    let flatbutton;
    let current;
    flatbutton = new Flat_button({
      props: {
        color: "blue",
        content: "Export to clipboard"
      }
    });
    flatbutton.$on(
      "click",
      /*click_handler_2*/
      ctx[12]
    );
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block_2$a, "create_if_block_2$a");
  function create_if_block_1$c(ctx) {
    let flatbutton;
    let current;
    flatbutton = new Flat_button({
      props: { content: "Add Color", color: "green" }
    });
    flatbutton.$on(
      "click",
      /*click_handler_3*/
      ctx[13]
    );
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block_1$c, "create_if_block_1$c");
  function create_if_block$s(ctx) {
    let flatbutton;
    let current;
    flatbutton = new Flat_button({
      props: { content: "Remove Color", color: "orange" }
    });
    flatbutton.$on(
      "click",
      /*click_handler_4*/
      ctx[14]
    );
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block$s, "create_if_block$s");
  function create_fragment$1a(ctx) {
    let div3;
    let div1;
    let b0;
    let t1;
    let input0;
    let input0_disabled_value;
    let t2;
    let b1;
    let t4;
    let input1;
    let input1_disabled_value;
    let t5;
    let b2;
    let t7;
    let div0;
    let t8;
    let div2;
    let t9;
    let t10;
    let t11;
    let br;
    let t12;
    let t13;
    let current;
    let mounted;
    let dispose;
    let each_value = ensure_array_like(
      /*colors*/
      ctx[4]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$r(get_each_context$r(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    let if_block0 = (
      /*onPaletteSave*/
      ctx[0] && create_if_block_4$7(ctx)
    );
    let if_block1 = (
      /*onPaletteDelete*/
      ctx[2] && create_if_block_3$7(ctx)
    );
    let if_block2 = (
      /*onPaletteExport*/
      ctx[1] && create_if_block_2$a(ctx)
    );
    let if_block3 = (
      /*onPaletteSave*/
      ctx[0] && create_if_block_1$c(ctx)
    );
    let if_block4 = (
      /*onPaletteSave*/
      ctx[0] && create_if_block$s(ctx)
    );
    return {
      c() {
        div3 = element("div");
        div1 = element("div");
        b0 = element("b");
        b0.textContent = "Palette Name";
        t1 = space();
        input0 = element("input");
        t2 = space();
        b1 = element("b");
        b1.textContent = "Columns per row";
        t4 = space();
        input1 = element("input");
        t5 = space();
        b2 = element("b");
        b2.textContent = "Palette colors";
        t7 = space();
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t8 = space();
        div2 = element("div");
        if (if_block0) if_block0.c();
        t9 = space();
        if (if_block1) if_block1.c();
        t10 = space();
        if (if_block2) if_block2.c();
        t11 = space();
        br = element("br");
        t12 = space();
        if (if_block3) if_block3.c();
        t13 = space();
        if (if_block4) if_block4.c();
        attr(b0, "class", "svelte-nspiqx");
        attr(input0, "type", "text");
        input0.disabled = input0_disabled_value = /*onPaletteSave*/
        ctx[0] === void 0;
        attr(b1, "class", "svelte-nspiqx");
        attr(input1, "type", "number");
        attr(input1, "min", "0");
        input1.disabled = input1_disabled_value = /*onPaletteSave*/
        ctx[0] === void 0;
        attr(b2, "class", "svelte-nspiqx");
        attr(div0, "class", "typo-palette-builder-colors svelte-nspiqx");
        set_style(
          div0,
          "pointer-events",
          /*onPaletteSave*/
          ctx[0] === void 0 ? "none" : "all"
        );
        set_style(div0, "grid-template-columns", "repeat(" + /*columns*/
        ctx[5] + ", 2rem)");
        set_style(div0, "width", "calc(" + /*columns*/
        ctx[5] + " * 2rem + " + /*columns*/
        (ctx[5] - 1) + " * .2rem)");
        attr(div1, "class", "typo-palette-builder-inputs svelte-nspiqx");
        attr(div2, "class", "typo-palette-builder-actions svelte-nspiqx");
        attr(div3, "class", "typo-palette-builder-container svelte-nspiqx");
      },
      m(target, anchor) {
        insert(target, div3, anchor);
        append(div3, div1);
        append(div1, b0);
        append(div1, t1);
        append(div1, input0);
        set_input_value(
          input0,
          /*name*/
          ctx[3]
        );
        append(div1, t2);
        append(div1, b1);
        append(div1, t4);
        append(div1, input1);
        set_input_value(
          input1,
          /*columns*/
          ctx[5]
        );
        append(div1, t5);
        append(div1, b2);
        append(div1, t7);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
        append(div3, t8);
        append(div3, div2);
        if (if_block0) if_block0.m(div2, null);
        append(div2, t9);
        if (if_block1) if_block1.m(div2, null);
        append(div2, t10);
        if (if_block2) if_block2.m(div2, null);
        append(div2, t11);
        append(div2, br);
        append(div2, t12);
        if (if_block3) if_block3.m(div2, null);
        append(div2, t13);
        if (if_block4) if_block4.m(div2, null);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              input0,
              "input",
              /*input0_input_handler*/
              ctx[7]
            ),
            listen(
              input1,
              "input",
              /*input1_input_handler*/
              ctx[8]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (!current || dirty & /*onPaletteSave*/
        1 && input0_disabled_value !== (input0_disabled_value = /*onPaletteSave*/
        ctx2[0] === void 0)) {
          input0.disabled = input0_disabled_value;
        }
        if (dirty & /*name*/
        8 && input0.value !== /*name*/
        ctx2[3]) {
          set_input_value(
            input0,
            /*name*/
            ctx2[3]
          );
        }
        if (!current || dirty & /*onPaletteSave*/
        1 && input1_disabled_value !== (input1_disabled_value = /*onPaletteSave*/
        ctx2[0] === void 0)) {
          input1.disabled = input1_disabled_value;
        }
        if (dirty & /*columns*/
        32 && to_number(input1.value) !== /*columns*/
        ctx2[5]) {
          set_input_value(
            input1,
            /*columns*/
            ctx2[5]
          );
        }
        if (dirty & /*colors*/
        16) {
          each_value = ensure_array_like(
            /*colors*/
            ctx2[4]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$r(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$r(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div0, null);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
        if (!current || dirty & /*onPaletteSave*/
        1) {
          set_style(
            div0,
            "pointer-events",
            /*onPaletteSave*/
            ctx2[0] === void 0 ? "none" : "all"
          );
        }
        if (!current || dirty & /*columns*/
        32) {
          set_style(div0, "grid-template-columns", "repeat(" + /*columns*/
          ctx2[5] + ", 2rem)");
        }
        if (!current || dirty & /*columns*/
        32) {
          set_style(div0, "width", "calc(" + /*columns*/
          ctx2[5] + " * 2rem + " + /*columns*/
          (ctx2[5] - 1) + " * .2rem)");
        }
        if (
          /*onPaletteSave*/
          ctx2[0]
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty & /*onPaletteSave*/
            1) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_4$7(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(div2, t9);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        if (
          /*onPaletteDelete*/
          ctx2[2]
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty & /*onPaletteDelete*/
            4) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_3$7(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(div2, t10);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
        if (
          /*onPaletteExport*/
          ctx2[1]
        ) {
          if (if_block2) {
            if_block2.p(ctx2, dirty);
            if (dirty & /*onPaletteExport*/
            2) {
              transition_in(if_block2, 1);
            }
          } else {
            if_block2 = create_if_block_2$a(ctx2);
            if_block2.c();
            transition_in(if_block2, 1);
            if_block2.m(div2, t11);
          }
        } else if (if_block2) {
          group_outros();
          transition_out(if_block2, 1, 1, () => {
            if_block2 = null;
          });
          check_outros();
        }
        if (
          /*onPaletteSave*/
          ctx2[0]
        ) {
          if (if_block3) {
            if_block3.p(ctx2, dirty);
            if (dirty & /*onPaletteSave*/
            1) {
              transition_in(if_block3, 1);
            }
          } else {
            if_block3 = create_if_block_1$c(ctx2);
            if_block3.c();
            transition_in(if_block3, 1);
            if_block3.m(div2, t13);
          }
        } else if (if_block3) {
          group_outros();
          transition_out(if_block3, 1, 1, () => {
            if_block3 = null;
          });
          check_outros();
        }
        if (
          /*onPaletteSave*/
          ctx2[0]
        ) {
          if (if_block4) {
            if_block4.p(ctx2, dirty);
            if (dirty & /*onPaletteSave*/
            1) {
              transition_in(if_block4, 1);
            }
          } else {
            if_block4 = create_if_block$s(ctx2);
            if_block4.c();
            transition_in(if_block4, 1);
            if_block4.m(div2, null);
          }
        } else if (if_block4) {
          group_outros();
          transition_out(if_block4, 1, 1, () => {
            if_block4 = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        transition_in(if_block0);
        transition_in(if_block1);
        transition_in(if_block2);
        transition_in(if_block3);
        transition_in(if_block4);
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        transition_out(if_block0);
        transition_out(if_block1);
        transition_out(if_block2);
        transition_out(if_block3);
        transition_out(if_block4);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div3);
        }
        destroy_each(each_blocks, detaching);
        if (if_block0) if_block0.d();
        if (if_block1) if_block1.d();
        if (if_block2) if_block2.d();
        if (if_block3) if_block3.d();
        if (if_block4) if_block4.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$1a, "create_fragment$1a");
  function instance$13($$self, $$props, $$invalidate) {
    let name = "new-palette";
    let colors = [];
    let columns = 10;
    const loadPalette = /* @__PURE__ */ __name((palette) => {
      $$invalidate(3, name = palette.name);
      $$invalidate(4, colors = palette.colorHexCodes.map((code) => Color.fromHex(code)));
      $$invalidate(5, columns = palette.columns);
    }, "loadPalette");
    let { onPaletteSave = void 0 } = $$props;
    let { onPaletteExport = void 0 } = $$props;
    let { onPaletteDelete = void 0 } = $$props;
    let { initialPalette = void 0 } = $$props;
    onMount(() => {
      if (initialPalette) {
        loadPalette(initialPalette);
      }
    });
    function input0_input_handler() {
      name = this.value;
      $$invalidate(3, name);
    }
    __name(input0_input_handler, "input0_input_handler");
    function input1_input_handler() {
      columns = to_number(this.value);
      $$invalidate(5, columns);
    }
    __name(input1_input_handler, "input1_input_handler");
    function colorpickerbutton_color_binding(value, color, each_value, i) {
      each_value[i] = value;
      $$invalidate(4, colors);
    }
    __name(colorpickerbutton_color_binding, "colorpickerbutton_color_binding");
    const click_handler2 = /* @__PURE__ */ __name(() => onPaletteSave({
      name,
      columns,
      colorHexCodes: colors.map((c) => c.hex)
    }), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => onPaletteDelete(), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(() => onPaletteExport({
      name,
      columns,
      colorHexCodes: colors.map((c) => c.hex)
    }), "click_handler_2");
    const click_handler_3 = /* @__PURE__ */ __name(() => $$invalidate(4, colors = [...colors, Color.fromHex("#77c5fa")]), "click_handler_3");
    const click_handler_4 = /* @__PURE__ */ __name(() => $$invalidate(4, colors = [...colors.slice(0, colors.length - 1)]), "click_handler_4");
    $$self.$$set = ($$props2) => {
      if ("onPaletteSave" in $$props2) $$invalidate(0, onPaletteSave = $$props2.onPaletteSave);
      if ("onPaletteExport" in $$props2) $$invalidate(1, onPaletteExport = $$props2.onPaletteExport);
      if ("onPaletteDelete" in $$props2) $$invalidate(2, onPaletteDelete = $$props2.onPaletteDelete);
      if ("initialPalette" in $$props2) $$invalidate(6, initialPalette = $$props2.initialPalette);
    };
    return [
      onPaletteSave,
      onPaletteExport,
      onPaletteDelete,
      name,
      colors,
      columns,
      initialPalette,
      input0_input_handler,
      input1_input_handler,
      colorpickerbutton_color_binding,
      click_handler2,
      click_handler_1,
      click_handler_2,
      click_handler_3,
      click_handler_4
    ];
  }
  __name(instance$13, "instance$13");
  const _Color_palette_builder = class _Color_palette_builder extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$13, create_fragment$1a, safe_not_equal, {
        onPaletteSave: 0,
        onPaletteExport: 1,
        onPaletteDelete: 2,
        initialPalette: 6
      });
    }
  };
  __name(_Color_palette_builder, "Color_palette_builder");
  let Color_palette_builder = _Color_palette_builder;
  function get_each_context$q(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[15] = list[i];
    return child_ctx;
  }
  __name(get_each_context$q, "get_each_context$q");
  function get_each_context_1$a(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[15] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1$a, "get_each_context_1$a");
  function get_each_context_2$4(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[15] = list[i];
    return child_ctx;
  }
  __name(get_each_context_2$4, "get_each_context_2$4");
  function get_each_context_3$2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[15] = list[i];
    return child_ctx;
  }
  __name(get_each_context_3$2, "get_each_context_3$2");
  function create_each_block_3$2(ctx) {
    let option;
    let t_value = (
      /*palette*/
      ctx[15].name + ""
    );
    let t;
    let option_selected_value;
    return {
      c() {
        option = element("option");
        t = text(t_value);
        option.__value = /*palette*/
        ctx[15] === /*defaultPalettes*/
        ctx[5].skribblPalette ? void 0 : (
          /*palette*/
          ctx[15].name
        );
        set_input_value(option, option.__value);
        option.selected = option_selected_value = /*palette*/
        ctx[15] === /*defaultPalettes*/
        ctx[5].skribblPalette && /*$activePalette*/
        ctx[2] === void 0 || /*$activePalette*/
        ctx[2] === /*palette*/
        ctx[15].name;
      },
      m(target, anchor) {
        insert(target, option, anchor);
        append(option, t);
      },
      p(ctx2, dirty) {
        if (dirty & /*$activePalette, $palettes, Object, defaultPalettes, undefined*/
        44 && option_selected_value !== (option_selected_value = /*palette*/
        ctx2[15] === /*defaultPalettes*/
        ctx2[5].skribblPalette && /*$activePalette*/
        ctx2[2] === void 0 || /*$activePalette*/
        ctx2[2] === /*palette*/
        ctx2[15].name)) {
          option.selected = option_selected_value;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(option);
        }
      }
    };
  }
  __name(create_each_block_3$2, "create_each_block_3$2");
  function create_each_block_2$4(ctx) {
    let option;
    let t_value = (
      /*palette*/
      ctx[15].name + ""
    );
    let t;
    let option_value_value;
    let option_selected_value;
    return {
      c() {
        option = element("option");
        t = text(t_value);
        option.__value = option_value_value = /*palette*/
        ctx[15].name;
        set_input_value(option, option.__value);
        option.selected = option_selected_value = /*$activePalette*/
        ctx[2] === /*palette*/
        ctx[15].name;
      },
      m(target, anchor) {
        insert(target, option, anchor);
        append(option, t);
      },
      p(ctx2, dirty) {
        if (dirty & /*$palettes*/
        8 && t_value !== (t_value = /*palette*/
        ctx2[15].name + "")) set_data(t, t_value);
        if (dirty & /*$palettes*/
        8 && option_value_value !== (option_value_value = /*palette*/
        ctx2[15].name)) {
          option.__value = option_value_value;
          set_input_value(option, option.__value);
        }
        if (dirty & /*$activePalette, $palettes, Object, defaultPalettes, undefined*/
        44 && option_selected_value !== (option_selected_value = /*$activePalette*/
        ctx2[2] === /*palette*/
        ctx2[15].name)) {
          option.selected = option_selected_value;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(option);
        }
      }
    };
  }
  __name(create_each_block_2$4, "create_each_block_2$4");
  function create_key_block$1(ctx) {
    let colorpalettebuilder;
    let current;
    function func2(...args) {
      return (
        /*func*/
        ctx[9](
          /*palette*/
          ctx[15],
          ...args
        )
      );
    }
    __name(func2, "func");
    function func_22() {
      return (
        /*func_2*/
        ctx[11](
          /*palette*/
          ctx[15]
        )
      );
    }
    __name(func_22, "func_2");
    colorpalettebuilder = new Color_palette_builder({
      props: {
        initialPalette: (
          /*palette*/
          ctx[15]
        ),
        onPaletteSave: func2,
        onPaletteExport: (
          /*func_1*/
          ctx[10]
        ),
        onPaletteDelete: func_22
      }
    });
    return {
      c() {
        create_component(colorpalettebuilder.$$.fragment);
      },
      m(target, anchor) {
        mount_component(colorpalettebuilder, target, anchor);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        const colorpalettebuilder_changes = {};
        if (dirty & /*$palettes*/
        8) colorpalettebuilder_changes.initialPalette = /*palette*/
        ctx[15];
        if (dirty & /*feature, $palettes*/
        9) colorpalettebuilder_changes.onPaletteSave = func2;
        if (dirty & /*feature*/
        1) colorpalettebuilder_changes.onPaletteExport = /*func_1*/
        ctx[10];
        if (dirty & /*feature, $palettes*/
        9) colorpalettebuilder_changes.onPaletteDelete = func_22;
        colorpalettebuilder.$set(colorpalettebuilder_changes);
      },
      i(local) {
        if (current) return;
        transition_in(colorpalettebuilder.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(colorpalettebuilder.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(colorpalettebuilder, detaching);
      }
    };
  }
  __name(create_key_block$1, "create_key_block$1");
  function create_each_block_1$a(ctx) {
    let previous_key = (
      /*palette*/
      ctx[15]
    );
    let key_block_anchor;
    let current;
    let key_block = create_key_block$1(ctx);
    return {
      c() {
        key_block.c();
        key_block_anchor = empty();
      },
      m(target, anchor) {
        key_block.m(target, anchor);
        insert(target, key_block_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*$palettes*/
        8 && safe_not_equal(previous_key, previous_key = /*palette*/
        ctx2[15])) {
          group_outros();
          transition_out(key_block, 1, 1, noop);
          check_outros();
          key_block = create_key_block$1(ctx2);
          key_block.c();
          transition_in(key_block, 1);
          key_block.m(key_block_anchor.parentNode, key_block_anchor);
        } else {
          key_block.p(ctx2, dirty);
        }
      },
      i(local) {
        if (current) return;
        transition_in(key_block);
        current = true;
      },
      o(local) {
        transition_out(key_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(key_block_anchor);
        }
        key_block.d(detaching);
      }
    };
  }
  __name(create_each_block_1$a, "create_each_block_1$a");
  function create_each_block$q(ctx) {
    let colorpalettebuilder;
    let current;
    function func_3() {
      return (
        /*func_3*/
        ctx[12](
          /*palette*/
          ctx[15]
        )
      );
    }
    __name(func_3, "func_3");
    colorpalettebuilder = new Color_palette_builder({
      props: {
        initialPalette: (
          /*palette*/
          ctx[15]
        ),
        onPaletteExport: func_3
      }
    });
    return {
      c() {
        create_component(colorpalettebuilder.$$.fragment);
      },
      m(target, anchor) {
        mount_component(colorpalettebuilder, target, anchor);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        const colorpalettebuilder_changes = {};
        if (dirty & /*feature*/
        1) colorpalettebuilder_changes.onPaletteExport = func_3;
        colorpalettebuilder.$set(colorpalettebuilder_changes);
      },
      i(local) {
        if (current) return;
        transition_in(colorpalettebuilder.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(colorpalettebuilder.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(colorpalettebuilder, detaching);
      }
    };
  }
  __name(create_each_block$q, "create_each_block$q");
  function create_fragment$19(ctx) {
    let h30;
    let t1;
    let br0;
    let t2;
    let select;
    let each0_anchor;
    let br1;
    let t3;
    let br2;
    let t4;
    let h31;
    let t6;
    let br3;
    let t7;
    let br4;
    let t8;
    let br5;
    let t9;
    let br6;
    let t10;
    let br7;
    let t11;
    let flatbutton0;
    let br8;
    let t12;
    let br9;
    let t13;
    let h32;
    let t15;
    let br10;
    let t16;
    let div;
    let t17;
    let t18;
    let br11;
    let t19;
    let h33;
    let t21;
    let br12;
    let t22;
    let br13;
    let t23;
    let br14;
    let t24;
    let i;
    let br15;
    let t26;
    let br16;
    let t27;
    let input;
    let br17;
    let t28;
    let br18;
    let t29;
    let flatbutton1;
    let br19;
    let t30;
    let br20;
    let current;
    let mounted;
    let dispose;
    let each_value_3 = ensure_array_like(Object.values(
      /*defaultPalettes*/
      ctx[5]
    ));
    let each_blocks_3 = [];
    for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
      each_blocks_3[i2] = create_each_block_3$2(get_each_context_3$2(ctx, each_value_3, i2));
    }
    let each_value_2 = ensure_array_like(
      /*$palettes*/
      ctx[3]
    );
    let each_blocks_2 = [];
    for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
      each_blocks_2[i2] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i2));
    }
    flatbutton0 = new Flat_button({
      props: {
        color: "green",
        content: "Add new palette"
      }
    });
    flatbutton0.$on(
      "click",
      /*click_handler*/
      ctx[8]
    );
    let each_value_1 = ensure_array_like(
      /*$palettes*/
      ctx[3]
    );
    let each_blocks_1 = [];
    for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
      each_blocks_1[i2] = create_each_block_1$a(get_each_context_1$a(ctx, each_value_1, i2));
    }
    const out = /* @__PURE__ */ __name((i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
      each_blocks_1[i2] = null;
    }), "out");
    let each_value = ensure_array_like(Object.values(
      /*defaultPalettes*/
      ctx[5]
    ));
    let each_blocks = [];
    for (let i2 = 0; i2 < each_value.length; i2 += 1) {
      each_blocks[i2] = create_each_block$q(get_each_context$q(ctx, each_value, i2));
    }
    const out_1 = /* @__PURE__ */ __name((i2) => transition_out(each_blocks[i2], 1, 1, () => {
      each_blocks[i2] = null;
    }), "out_1");
    flatbutton1 = new Flat_button({
      props: {
        color: "green",
        content: "Import palette"
      }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_1*/
      ctx[14]
    );
    return {
      c() {
        h30 = element("h3");
        h30.textContent = "Active palette";
        t1 = text("\nSelect one of the saved palettes to customize the colors available in the skribbl toolbar.");
        br0 = element("br");
        t2 = space();
        select = element("select");
        for (let i2 = 0; i2 < each_blocks_3.length; i2 += 1) {
          each_blocks_3[i2].c();
        }
        each0_anchor = empty();
        for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
          each_blocks_2[i2].c();
        }
        br1 = element("br");
        t3 = space();
        br2 = element("br");
        t4 = space();
        h31 = element("h3");
        h31.textContent = "Create a new empty palette";
        t6 = text("\nCreate a new palette to customize the colors available in the skribbl toolbar.");
        br3 = element("br");
        t7 = text("\nYou can enter a name to identify the palette, choose a number of columns for the palette layout and add as many colors as you like.");
        br4 = element("br");
        t8 = text('\nClick a color box to change it, remove the last color with "Remove Color" or add a new color with "Add Color".');
        br5 = element("br");
        t9 = text('\nWhen you are done, click "Save Palette" to save the changes.');
        br6 = element("br");
        t10 = space();
        br7 = element("br");
        t11 = space();
        create_component(flatbutton0.$$.fragment);
        br8 = element("br");
        t12 = space();
        br9 = element("br");
        t13 = space();
        h32 = element("h3");
        h32.textContent = "Saved palettes";
        t15 = space();
        br10 = element("br");
        t16 = space();
        div = element("div");
        for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
          each_blocks_1[i2].c();
        }
        t17 = space();
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].c();
        }
        t18 = space();
        br11 = element("br");
        t19 = space();
        h33 = element("h3");
        h33.textContent = "Import a palette";
        t21 = text("\nYou can import existing palettes by pasting their data here.");
        br12 = element("br");
        t22 = text('\nExisting palettes can be exported by clicking the "Export to clipboard" button on the palette.');
        br13 = element("br");
        t23 = text("\nThe data is a JSON string that represents the palette; you can also create a new palette without the typo palette builder.");
        br14 = element("br");
        t24 = text("\nThe palette has to satisfy following interface: ");
        i = element("i");
        i.textContent = "{ name: string; columns: number; colorHexCodes: string[] }";
        br15 = element("br");
        t26 = space();
        br16 = element("br");
        t27 = space();
        input = element("input");
        br17 = element("br");
        t28 = space();
        br18 = element("br");
        t29 = space();
        create_component(flatbutton1.$$.fragment);
        br19 = element("br");
        t30 = space();
        br20 = element("br");
        set_style(select, "width", "auto");
        if (
          /*$activePalette*/
          ctx[2] === void 0
        ) add_render_callback(() => (
          /*select_change_handler*/
          ctx[7].call(select)
        ));
        attr(div, "class", "typo-color-palette-manage-list svelte-vvz4gm");
        attr(input, "type", "text");
        attr(input, "placeholder", "Paste palette data");
        set_style(input, "width", "auto");
      },
      m(target, anchor) {
        insert(target, h30, anchor);
        insert(target, t1, anchor);
        insert(target, br0, anchor);
        insert(target, t2, anchor);
        insert(target, select, anchor);
        for (let i2 = 0; i2 < each_blocks_3.length; i2 += 1) {
          if (each_blocks_3[i2]) {
            each_blocks_3[i2].m(select, null);
          }
        }
        append(select, each0_anchor);
        for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
          if (each_blocks_2[i2]) {
            each_blocks_2[i2].m(select, null);
          }
        }
        select_option(
          select,
          /*$activePalette*/
          ctx[2],
          true
        );
        insert(target, br1, anchor);
        insert(target, t3, anchor);
        insert(target, br2, anchor);
        insert(target, t4, anchor);
        insert(target, h31, anchor);
        insert(target, t6, anchor);
        insert(target, br3, anchor);
        insert(target, t7, anchor);
        insert(target, br4, anchor);
        insert(target, t8, anchor);
        insert(target, br5, anchor);
        insert(target, t9, anchor);
        insert(target, br6, anchor);
        insert(target, t10, anchor);
        insert(target, br7, anchor);
        insert(target, t11, anchor);
        mount_component(flatbutton0, target, anchor);
        insert(target, br8, anchor);
        insert(target, t12, anchor);
        insert(target, br9, anchor);
        insert(target, t13, anchor);
        insert(target, h32, anchor);
        insert(target, t15, anchor);
        insert(target, br10, anchor);
        insert(target, t16, anchor);
        insert(target, div, anchor);
        for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].m(div, null);
          }
        }
        append(div, t17);
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
          if (each_blocks[i2]) {
            each_blocks[i2].m(div, null);
          }
        }
        insert(target, t18, anchor);
        insert(target, br11, anchor);
        insert(target, t19, anchor);
        insert(target, h33, anchor);
        insert(target, t21, anchor);
        insert(target, br12, anchor);
        insert(target, t22, anchor);
        insert(target, br13, anchor);
        insert(target, t23, anchor);
        insert(target, br14, anchor);
        insert(target, t24, anchor);
        insert(target, i, anchor);
        insert(target, br15, anchor);
        insert(target, t26, anchor);
        insert(target, br16, anchor);
        insert(target, t27, anchor);
        insert(target, input, anchor);
        set_input_value(
          input,
          /*paletteImport*/
          ctx[1]
        );
        insert(target, br17, anchor);
        insert(target, t28, anchor);
        insert(target, br18, anchor);
        insert(target, t29, anchor);
        mount_component(flatbutton1, target, anchor);
        insert(target, br19, anchor);
        insert(target, t30, anchor);
        insert(target, br20, anchor);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              select,
              "change",
              /*select_change_handler*/
              ctx[7]
            ),
            listen(
              input,
              "input",
              /*input_input_handler*/
              ctx[13]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*Object, defaultPalettes, undefined, $activePalette*/
        36) {
          each_value_3 = ensure_array_like(Object.values(
            /*defaultPalettes*/
            ctx2[5]
          ));
          let i2;
          for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
            const child_ctx = get_each_context_3$2(ctx2, each_value_3, i2);
            if (each_blocks_3[i2]) {
              each_blocks_3[i2].p(child_ctx, dirty);
            } else {
              each_blocks_3[i2] = create_each_block_3$2(child_ctx);
              each_blocks_3[i2].c();
              each_blocks_3[i2].m(select, each0_anchor);
            }
          }
          for (; i2 < each_blocks_3.length; i2 += 1) {
            each_blocks_3[i2].d(1);
          }
          each_blocks_3.length = each_value_3.length;
        }
        if (dirty & /*$palettes, $activePalette*/
        12) {
          each_value_2 = ensure_array_like(
            /*$palettes*/
            ctx2[3]
          );
          let i2;
          for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
            const child_ctx = get_each_context_2$4(ctx2, each_value_2, i2);
            if (each_blocks_2[i2]) {
              each_blocks_2[i2].p(child_ctx, dirty);
            } else {
              each_blocks_2[i2] = create_each_block_2$4(child_ctx);
              each_blocks_2[i2].c();
              each_blocks_2[i2].m(select, null);
            }
          }
          for (; i2 < each_blocks_2.length; i2 += 1) {
            each_blocks_2[i2].d(1);
          }
          each_blocks_2.length = each_value_2.length;
        }
        if (dirty & /*$activePalette, $palettes, Object, defaultPalettes, undefined*/
        44) {
          select_option(
            select,
            /*$activePalette*/
            ctx2[2]
          );
        }
        if (dirty & /*$palettes, feature*/
        9) {
          each_value_1 = ensure_array_like(
            /*$palettes*/
            ctx2[3]
          );
          let i2;
          for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
            const child_ctx = get_each_context_1$a(ctx2, each_value_1, i2);
            if (each_blocks_1[i2]) {
              each_blocks_1[i2].p(child_ctx, dirty);
              transition_in(each_blocks_1[i2], 1);
            } else {
              each_blocks_1[i2] = create_each_block_1$a(child_ctx);
              each_blocks_1[i2].c();
              transition_in(each_blocks_1[i2], 1);
              each_blocks_1[i2].m(div, t17);
            }
          }
          group_outros();
          for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
            out(i2);
          }
          check_outros();
        }
        if (dirty & /*Object, defaultPalettes, feature*/
        33) {
          each_value = ensure_array_like(Object.values(
            /*defaultPalettes*/
            ctx2[5]
          ));
          let i2;
          for (i2 = 0; i2 < each_value.length; i2 += 1) {
            const child_ctx = get_each_context$q(ctx2, each_value, i2);
            if (each_blocks[i2]) {
              each_blocks[i2].p(child_ctx, dirty);
              transition_in(each_blocks[i2], 1);
            } else {
              each_blocks[i2] = create_each_block$q(child_ctx);
              each_blocks[i2].c();
              transition_in(each_blocks[i2], 1);
              each_blocks[i2].m(div, null);
            }
          }
          group_outros();
          for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
            out_1(i2);
          }
          check_outros();
        }
        if (dirty & /*paletteImport*/
        2 && input.value !== /*paletteImport*/
        ctx2[1]) {
          set_input_value(
            input,
            /*paletteImport*/
            ctx2[1]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
          transition_in(each_blocks_1[i2]);
        }
        for (let i2 = 0; i2 < each_value.length; i2 += 1) {
          transition_in(each_blocks[i2]);
        }
        transition_in(flatbutton1.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        each_blocks_1 = each_blocks_1.filter(Boolean);
        for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
          transition_out(each_blocks_1[i2]);
        }
        each_blocks = each_blocks.filter(Boolean);
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
          transition_out(each_blocks[i2]);
        }
        transition_out(flatbutton1.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(h30);
          detach(t1);
          detach(br0);
          detach(t2);
          detach(select);
          detach(br1);
          detach(t3);
          detach(br2);
          detach(t4);
          detach(h31);
          detach(t6);
          detach(br3);
          detach(t7);
          detach(br4);
          detach(t8);
          detach(br5);
          detach(t9);
          detach(br6);
          detach(t10);
          detach(br7);
          detach(t11);
          detach(br8);
          detach(t12);
          detach(br9);
          detach(t13);
          detach(h32);
          detach(t15);
          detach(br10);
          detach(t16);
          detach(div);
          detach(t18);
          detach(br11);
          detach(t19);
          detach(h33);
          detach(t21);
          detach(br12);
          detach(t22);
          detach(br13);
          detach(t23);
          detach(br14);
          detach(t24);
          detach(i);
          detach(br15);
          detach(t26);
          detach(br16);
          detach(t27);
          detach(input);
          detach(br17);
          detach(t28);
          detach(br18);
          detach(t29);
          detach(br19);
          detach(t30);
          detach(br20);
        }
        destroy_each(each_blocks_3, detaching);
        destroy_each(each_blocks_2, detaching);
        destroy_component(flatbutton0, detaching);
        destroy_each(each_blocks_1, detaching);
        destroy_each(each_blocks, detaching);
        destroy_component(flatbutton1, detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$19, "create_fragment$19");
  function instance$12($$self, $$props, $$invalidate) {
    let $activePalette;
    let $palettes;
    let { feature } = $$props;
    let paletteImport = "";
    const palettes = feature.savedPalettesStore;
    component_subscribe($$self, palettes, (value) => $$invalidate(3, $palettes = value));
    const defaultPalettes2 = feature.defaultPalettes;
    const activePalette = feature.activePaletteStore;
    component_subscribe($$self, activePalette, (value) => $$invalidate(2, $activePalette = value));
    function select_change_handler() {
      $activePalette = select_value(this);
      activePalette.set($activePalette);
      $$invalidate(5, defaultPalettes2);
    }
    __name(select_change_handler, "select_change_handler");
    const click_handler2 = /* @__PURE__ */ __name(() => feature.savePalette({
      name: "palette-" + Date.now(),
      columns: 10,
      colorHexCodes: ["#77c5fa"]
    }), "click_handler");
    const func2 = /* @__PURE__ */ __name((palette, newPalette) => feature.savePalette(newPalette, palette.name), "func");
    const func_12 = /* @__PURE__ */ __name((newPalette) => feature.exportPalette(newPalette), "func_1");
    const func_22 = /* @__PURE__ */ __name((palette) => feature.removePalette(palette.name), "func_2");
    const func_3 = /* @__PURE__ */ __name((palette) => feature.exportPalette(palette), "func_3");
    function input_input_handler() {
      paletteImport = this.value;
      $$invalidate(1, paletteImport);
    }
    __name(input_input_handler, "input_input_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => feature.savePalette(feature.parsePalette(paletteImport)), "click_handler_1");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      paletteImport,
      $activePalette,
      $palettes,
      palettes,
      defaultPalettes2,
      activePalette,
      select_change_handler,
      click_handler2,
      func2,
      func_12,
      func_22,
      func_3,
      input_input_handler,
      click_handler_1
    ];
  }
  __name(instance$12, "instance$12");
  const _Drawing_color_palettes_manage = class _Drawing_color_palettes_manage extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$12, create_fragment$19, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Drawing_color_palettes_manage, "Drawing_color_palettes_manage");
  let Drawing_color_palettes_manage = _Drawing_color_palettes_manage;
  function get_each_context$p(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[3] = list[i];
    return child_ctx;
  }
  __name(get_each_context$p, "get_each_context$p");
  function create_each_block$p(ctx) {
    let div;
    let mounted;
    let dispose;
    function pointerdown_handler() {
      return (
        /*pointerdown_handler*/
        ctx[2](
          /*color*/
          ctx[3]
        )
      );
    }
    __name(pointerdown_handler, "pointerdown_handler");
    return {
      c() {
        div = element("div");
        attr(div, "class", "typo-palette-picker-item svelte-1mmx4c4");
        set_style(
          div,
          "background-color",
          /*color*/
          ctx[3]
        );
        set_style(
          div,
          "width",
          /*colors*/
          ctx[0].preferredColumnWidth ? `calc(var(--UNIT) / 2 * ${/*colors*/
        ctx[0].preferredColumnWidth}` : ""
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if (!mounted) {
          dispose = listen(div, "pointerdown", pointerdown_handler);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*colors*/
        1) {
          set_style(
            div,
            "background-color",
            /*color*/
            ctx[3]
          );
        }
        if (dirty & /*colors*/
        1) {
          set_style(
            div,
            "width",
            /*colors*/
            ctx[0].preferredColumnWidth ? `calc(var(--UNIT) / 2 * ${/*colors*/
          ctx[0].preferredColumnWidth}` : ""
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block$p, "create_each_block$p");
  function create_fragment$18(ctx) {
    let div1;
    let div0;
    let mounted;
    let dispose;
    let each_value = ensure_array_like(
      /*colors*/
      ctx[0].colorHexCodes
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$p(get_each_context$p(ctx, each_value, i));
    }
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div0, "class", "typo-palette-picker color-scrollbar svelte-1mmx4c4");
        set_style(div0, "grid-template-columns", "repeat(" + /*colors*/
        ctx[0].columns + ", auto)");
        attr(div1, "class", "colors typo-palette svelte-1mmx4c4");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
        if (!mounted) {
          dispose = action_destroyer(
            /*feature*/
            ctx[1].createTooltip(div0, {
              title: "Choose a color!\nOnly typo users see custom colors.",
              lock: "Y"
            })
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*colors, feature*/
        3) {
          each_value = ensure_array_like(
            /*colors*/
            ctx2[0].colorHexCodes
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$p(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$p(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div0, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
        if (dirty & /*colors*/
        1) {
          set_style(div0, "grid-template-columns", "repeat(" + /*colors*/
          ctx2[0].columns + ", auto)");
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_each(each_blocks, detaching);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$18, "create_fragment$18");
  function instance$11($$self, $$props, $$invalidate) {
    let { colors } = $$props;
    let { feature } = $$props;
    const pointerdown_handler = /* @__PURE__ */ __name((color) => feature.setColor(color), "pointerdown_handler");
    $$self.$$set = ($$props2) => {
      if ("colors" in $$props2) $$invalidate(0, colors = $$props2.colors);
      if ("feature" in $$props2) $$invalidate(1, feature = $$props2.feature);
    };
    return [colors, feature, pointerdown_handler];
  }
  __name(instance$11, "instance$11");
  const _Color_palette_picker = class _Color_palette_picker extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$11, create_fragment$18, safe_not_equal, { colors: 0, feature: 1 });
    }
  };
  __name(_Color_palette_picker, "Color_palette_picker");
  let Color_palette_picker = _Color_palette_picker;
  var __defProp$L = Object.defineProperty;
  var __decorateClass$L = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$L(target, key2, result);
    return result;
  }, "__decorateClass$L");
  const _DrawingColorPalettesFeature = class _DrawingColorPalettesFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_toastService");
      __publicField(this, "_drawingService");
      __publicField(this, "_colorsService");
      __publicField(this, "name", "Color Palettes");
      __publicField(this, "description", "Use custom color palettes instead of the default skribbl colors");
      __publicField(this, "tags", [FeatureTag.DRAWING]);
      __publicField(this, "featureId", 32);
      __publicField(this, "_hideOriginalPaletteStyle", createElement(`<style>
    #game #game-toolbar .colors:has(.top) {
      display: none;
    }
  </style>`));
      __publicField(this, "_importedPalettes", new ExtensionSetting(
        "imported_palettes",
        false,
        this
      ));
      __publicField(this, "_activePaletteSubscription");
      __publicField(this, "_colorPalettePicker");
    }
    get boundServices() {
      return [this._colorsService];
    }
    get featureInfoComponent() {
      return { componentType: Drawing_color_palettes_info, props: {} };
    }
    get featureManagementComponent() {
      return { componentType: Drawing_color_palettes_manage, props: { feature: this } };
    }
    async onActivate() {
      this._activePaletteSubscription = this._colorsService.pickerColors$.subscribe(
        (palette) => this.updatePaletteStyle(palette)
      );
      if (!await this._importedPalettes.getValue()) {
        try {
          const savedPalettes = this.parseSavedOldTypoPalettes().filter(
            (p) => p.name !== "sketchfulPalette"
          );
          for (const palette of savedPalettes) {
            await this._colorsService.savePalette(palette);
          }
          this._logger.info("Imported old typo palettes", savedPalettes);
          await this._importedPalettes.setValue(true);
        } catch {
        }
      }
    }
    async onDestroy() {
      var _a2, _b2;
      this._hideOriginalPaletteStyle.remove();
      (_a2 = this._activePaletteSubscription) == null ? void 0 : _a2.unsubscribe();
      this._activePaletteSubscription = void 0;
      (_b2 = this._colorPalettePicker) == null ? void 0 : _b2.$destroy();
    }
    /**
     * Change the visibility of the default palette or custom palette
     * @param palette
     * @private
     */
    async updatePaletteStyle(colors) {
      var _a2;
      this._logger.info("Updating palette style", colors);
      (_a2 = this._colorPalettePicker) == null ? void 0 : _a2.$destroy();
      if (colors === void 0) {
        this._hideOriginalPaletteStyle.remove();
        return;
      }
      const elements2 = await this._elementsSetup.complete();
      if (this._hideOriginalPaletteStyle.parentElement === null)
        document.body.appendChild(this._hideOriginalPaletteStyle);
      this._colorPalettePicker = new Color_palette_picker({
        target: elements2.skribblToolbar,
        anchor: elements2.colorContainer,
        props: {
          feature: this,
          colors
        }
      });
    }
    /**
     * Remove a palette from the settings
     * @param name
     */
    async removePalette(name) {
      this._logger.info(`Removing palette ${name}`);
      if (!await (await this._toastService.showConfirmToast(
        `Do you want to remove the palette ${name}?`,
        void 0,
        1e4,
        { confirm: "Delete palette", cancel: "Cancel deletion" }
      )).result) {
        this._logger.info(`User canceled removal of palette ${name}`);
        return;
      }
      const toast = await this._toastService.showLoadingToast(`Removing palette ${name}`);
      try {
        await this._colorsService.removePalette(name);
      } catch (e) {
        this._logger.error(`Failed to remove palette ${name}`, e);
        toast.reject(`Failed to remove palette ${name}`);
        return;
      }
      toast.resolve();
    }
    /**
     * Parse a palette from a json string
     * @param json
     */
    parsePalette(json) {
      this._logger.info("Parsing palette from json", json);
      try {
        const palette = JSON.parse(json);
        if (typeof palette.name !== "string" || typeof palette.columns !== "number" || !Array.isArray(palette.colorHexCodes) || !palette.colorHexCodes.every((c) => typeof c === "string")) {
          this._logger.error("Invalid palette format", palette);
          throw new Error("Invalid palette format");
        }
        return palette;
      } catch (e) {
        this._logger.error("Failed to parse palette from json", e);
        this._toastService.showToast(
          "Failed to read palette",
          "Invalid palette format. Check the JSON data!"
        );
        throw e;
      }
    }
    parseSavedOldTypoPalettes() {
      this._logger.info("Parsing saved old typo palette");
      try {
        const data = localStorage.getItem("customPalettes");
        if (data === null) return [];
        const palettes = JSON.parse(data);
        if (!Array.isArray(palettes)) throw new Error("Palette data is not an array");
        const parsed = [];
        palettes.forEach((p) => {
          if (typeof p !== "object" || p === null) throw new Error("Palette is not an object");
          const map2 = new Map(Object.entries(p));
          const name = map2.get("name");
          const colors = map2.get("colors");
          const rowCount = map2.get("rowCount");
          if (typeof name !== "string" || !Array.isArray(colors) || typeof rowCount !== "number")
            throw new Error("Palette is missing properties");
          const mappedColors = [];
          for (const color of colors) {
            if (typeof color !== "object") throw new Error("Color data is not a object");
            const map22 = new Map(Object.entries(color));
            const rgb = map22.get("color");
            if (typeof rgb !== "string") throw new Error("Color is not a string");
            mappedColors.push(Color.fromRgbString(rgb));
          }
          parsed.push({
            name,
            columns: rowCount,
            colorHexCodes: mappedColors.map((c) => c.hex)
          });
        });
        return parsed;
      } catch (e) {
        this._logger.error("Failed to parse saved old typo palette", e);
        return [];
      }
    }
    /**
     * Save a palette to the settings, or overwrite with given name
     * @param palette
     * @param overwrite
     */
    async savePalette(palette, overwrite = void 0) {
      this._logger.info(`Saving palette ${palette.name}`, palette);
      const toast = await this._toastService.showLoadingToast(`Saving palette ${palette.name}`);
      if (palette.colorHexCodes.length === 0) {
        this._logger.error(`Palette ${palette.name} has no colors`);
        toast.reject(`Palette ${palette.name} has no colors`);
        return;
      }
      if (palette.name.trim() === "") {
        this._logger.error("Palette has no name set");
        toast.reject("Palette has no name set");
        return;
      }
      if (palette.columns < 1) {
        this._logger.error(`Palette ${palette.name} has less than 1 column`);
        toast.reject(`Palette ${palette.name} cannot have less than 1 column`);
        return;
      }
      try {
        await this._colorsService.savePalette(palette, overwrite);
      } catch (e) {
        this._logger.error(`Failed to save palette ${palette.name}`, e);
        toast.reject(`Failed to save palette ${palette.name}`);
        return;
      }
      toast.resolve();
    }
    /**
     * Copy the json of a palette to the clipboard
     * @param palette
     */
    async exportPalette(palette) {
      this._logger.info(`Exporting palette ${palette.name} to clipboard`, palette);
      const toast = await this._toastService.showLoadingToast(
        `Exporting palette ${palette.name} to clipboard`
      );
      try {
        const json = JSON.stringify(palette);
        await navigator.clipboard.writeText(json);
      } catch (e) {
        this._logger.error(`Failed to export palette ${palette.name} to clipboard`, e);
        toast.reject(`Failed to export palette ${palette.name} to clipboard`);
        return;
      }
      toast.resolve();
    }
    /**
     * Set the color of the skribbl tool
     * @param colorHex
     */
    setColor(colorHex) {
      this._logger.info(`Setting color to ${colorHex}`);
      const color = Color.fromHex(colorHex);
      this._drawingService.setColor(color.skribblCode);
    }
    get savedPalettesStore() {
      return this._colorsService.savedPalettesSetting.store;
    }
    get activePaletteStore() {
      return this._colorsService.activePaletteSetting.store;
    }
    get defaultPalettes() {
      return defaultPalettes;
    }
  };
  __name(_DrawingColorPalettesFeature, "DrawingColorPalettesFeature");
  let DrawingColorPalettesFeature = _DrawingColorPalettesFeature;
  __decorateClass$L([
    inject(ElementsSetup)
  ], DrawingColorPalettesFeature.prototype, "_elementsSetup");
  __decorateClass$L([
    inject(ToastService)
  ], DrawingColorPalettesFeature.prototype, "_toastService");
  __decorateClass$L([
    inject(DrawingService)
  ], DrawingColorPalettesFeature.prototype, "_drawingService");
  __decorateClass$L([
    inject(ColorsService)
  ], DrawingColorPalettesFeature.prototype, "_colorsService");
  var __defProp$K = Object.defineProperty;
  var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
  var __decorateClass$K = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$K(target, key2, result);
    return result;
  }, "__decorateClass$K");
  let TypoDrawMod = (_xa = class {
    constructor() {
      /**
       * Indicator if this mod requires the skribbl sampling throttle to be disabled
       * Needs to be set true if the mod produces many draw commands in a short time
       * TODO remove? seems unused
       */
      __publicField(this, "disableSkribblSamplingRate", false);
    }
    noLineEffect(line, pressure, brushStyle) {
      return { lines: [line], style: brushStyle };
    }
  }, __name(_xa, "TypoDrawMod"), _xa);
  TypoDrawMod = __decorateClass$K([
    injectable()
  ], TypoDrawMod);
  const _ConstantDrawMod = class _ConstantDrawMod extends TypoDrawMod {
    /**
     * @param line
     * @param pressure
     * @param brushStyle
     * @param eventId
     * @param strokeId
     * @param strokeCause
     */
    async applyEffect(line, pressure, brushStyle, eventId, strokeId, strokeCause) {
      const effect = this.applyConstantEffect(line, pressure, brushStyle, eventId, strokeId, strokeCause);
      const awaited = effect instanceof Promise ? await effect : effect;
      return {
        lines: [awaited.line],
        style: awaited.style
      };
    }
    noConstantEffect(line, pressure, brushStyle) {
      return { line, style: brushStyle };
    }
  };
  __name(_ConstantDrawMod, "ConstantDrawMod");
  let ConstantDrawMod = _ConstantDrawMod;
  const _TypoDrawTool = class _TypoDrawTool extends ConstantDrawMod {
    constructor() {
      super(...arguments);
      __publicField(this, "cursorCanvas", document.createElement("canvas"));
    }
    noCommands() {
      return [];
    }
    /**
     * Create a cursor based on the current brush style that looks like the skribbl cursor
     * @param brushStyle
     * @protected
     */
    createSkribblLikeCursor(brushStyle) {
      const color = Color.fromSkribblCode(brushStyle.color).rgbArray;
      color[3] = 0.8;
      const canvasSize = brushStyle.size + 2;
      const cursorSize = brushStyle.size;
      const canvas = this.cursorCanvas;
      canvas.width = canvasSize;
      canvas.height = canvasSize;
      const context = canvas.getContext("2d");
      if (!context) throw new Error("Could not get 2d context");
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`;
      context.beginPath();
      context.arc(canvasSize / 2, canvasSize / 2, cursorSize / 2 - 1, 0, 2 * Math.PI);
      context.fill();
      context.strokeStyle = "#FFF";
      context.beginPath();
      context.arc(canvasSize / 2, canvasSize / 2, cursorSize / 2 - 1, 0, 2 * Math.PI);
      context.stroke();
      context.strokeStyle = "#000";
      context.beginPath();
      context.arc(canvasSize / 2, canvasSize / 2, cursorSize / 2, 0, 2 * Math.PI);
      context.stroke();
      const cursorCenter = canvasSize / 2;
      return {
        source: `url(${canvas.toDataURL()})`,
        x: cursorCenter,
        y: cursorCenter
      };
    }
  };
  __name(_TypoDrawTool, "TypoDrawTool");
  let TypoDrawTool = _TypoDrawTool;
  var __defProp$J = Object.defineProperty;
  var __decorateClass$J = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$J(target, key2, result);
    return result;
  }, "__decorateClass$J");
  const _PipetteTool = class _PipetteTool extends TypoDrawTool {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "createCommands", this.noCommands);
    }
    createCursor() {
      return { source: "var(--file-img-pipette_cur-png)", x: 7, y: 37 };
    }
    /**
     * Get the pixel color of the canvas at a certain position
     * @param line
     * @param pressure
     * @param style
     */
    async applyConstantEffect(line, pressure, style2) {
      const elements2 = await this._elementsSetup.complete();
      const canvas = elements2.canvas;
      const ctx = canvas.getContext("2d");
      if (ctx !== null) {
        const imageData = ctx.getImageData(line.to[0], line.to[1], 1, 1);
        const rgb = imageData.data.slice(0, 3);
        style2.color = Color.fromRgb(rgb[0], rgb[1], rgb[2]).skribblCode;
      }
      return this.noConstantEffect(line, pressure, style2);
    }
  };
  __name(_PipetteTool, "PipetteTool");
  let PipetteTool = _PipetteTool;
  __decorateClass$J([
    inject(ElementsSetup)
  ], PipetteTool.prototype, "_elementsSetup");
  const _ExtensionContainer = class _ExtensionContainer {
    constructor(_interceptor) {
      /**
       * Root dependency injection container.
       * @private
       */
      __publicField(this, "_diContainer", new Container());
      __publicField(this, "_logging");
      __publicField(this, "_logger");
      __publicField(this, "_events");
      __publicField(this, "_features");
      this._interceptor = _interceptor;
      this.bindCoreServices();
      this._logging = this._diContainer.get(LoggingService);
      this._logger = this._diContainer.get(loggerFactory)(this);
      this._events = this._diContainer.get(EventsService);
      this._features = this._diContainer.get(FeaturesService);
      this._logger.debug("Extension container initialized");
    }
    /**
     * Binds core services to the dependency injection container.
     * @private
     */
    bindCoreServices() {
      this._diContainer.bind(Interceptor).toConstantValue(this._interceptor);
      this._diContainer.bind(_ExtensionContainer).toConstantValue(this);
      this._diContainer.bind(LoggingService).toSelf().inSingletonScope();
      const logging = this._diContainer.get(LoggingService);
      this._diContainer.bind(LoggerService).toSelf();
      this._diContainer.bind(loggerFactory).toFactory((context) => {
        return (loggerContext) => {
          const logger = context.container.get(LoggerService).bindTo(loggerContext);
          logging.trackLoggerInstance(logger);
          return logger;
        };
      });
      this._diContainer.bind(CommandsService).toSelf().inSingletonScope();
      this._diContainer.bind(HotkeysService).toSelf().inSingletonScope();
      this._diContainer.bind(TooltipsService).toSelf().inSingletonScope();
      this._diContainer.bind(EventsService).toSelf().inSingletonScope();
      this._diContainer.bind(TokenService).toSelf().inSingletonScope();
      this._diContainer.bind(FeaturesService).toSelf().inSingletonScope();
    }
    registerEventProcessors(...events) {
      events.forEach((event) => {
        this._diContainer.bind(event.processorType).toSelf().inSingletonScope();
        this._diContainer.bind(event.listenerType).toSelf().inRequestScope();
      });
      return this;
    }
    registerFeatures(...features) {
      features.forEach((feature) => {
        this._diContainer.bind(feature).toSelf().inSingletonScope();
        const featureInstance = this._diContainer.get(feature);
        this._features.registerFeature(featureInstance);
      });
      return this;
    }
    registerSetups(...setups) {
      setups.forEach((setup) => {
        this._diContainer.bind(setup).toSelf().inSingletonScope();
        if (isEarlySetup(setup)) {
          this._diContainer.get(setup).complete();
        }
      });
      return this;
    }
    registerServices(...services) {
      services.forEach((service) => {
        if (service.scope === "singleton") {
          this._diContainer.bind(service.type).toSelf().inSingletonScope();
        } else {
          this._diContainer.bind(service.type).toSelf();
        }
      });
      return this;
    }
    /**
     * Resolve a service that has not been registered with the container.
     * @param service
     */
    resolveService(service) {
      return this._diContainer.resolve(service);
    }
  };
  __name(_ExtensionContainer, "ExtensionContainer");
  let ExtensionContainer = _ExtensionContainer;
  const _CoordinateListener = class _CoordinateListener {
    constructor(_canvas) {
      __publicField(this, "_enabled", false);
      __publicField(this, "_sampleRate", 1e3 / 60);
      __publicField(this, "_currentStroke");
      __publicField(this, "_strokes$", new Subject$1());
      __publicField(this, "_pointerDown$", new Subject$1());
      __publicField(this, "_pointerUp$", new Subject$1());
      this._canvas = _canvas;
    }
    set enabled(enabled) {
      this._enabled = enabled;
    }
    set fps(fps) {
      this._sampleRate = 1e3 / fps;
    }
    get strokes$() {
      return this._strokes$.asObservable();
    }
    get pointerDown$() {
      return this._pointerDown$.asObservable();
    }
    get pointerUp$() {
      return this._pointerUp$.asObservable();
    }
    onCanvasPointerDown(event) {
      if (!this._enabled) return;
      event.stopImmediatePropagation();
      this._canvas.setPointerCapture(event.pointerId);
      const rect = this._canvas.getBoundingClientRect();
      const coords = this.mapPointerEventToDrawCoordinate(
        event,
        this._canvas,
        rect
      );
      this._currentStroke = {
        canvasRect: rect,
        lastSampleDate: Date.now(),
        pointerDownId: performance.now(),
        lastCoordinates: coords
      };
      this._strokes$.next({ from: coords, to: coords, cause: "down", stroke: this._currentStroke.pointerDownId });
      this._pointerDown$.next(event);
    }
    onCanvasPointerMove(event) {
      const now = Date.now();
      if (this._currentStroke === void 0 || now - this._currentStroke.lastSampleDate < this._sampleRate) {
        return;
      }
      event.stopImmediatePropagation();
      this._currentStroke.lastSampleDate = now;
      const coords = this.mapPointerEventToDrawCoordinate(
        event,
        this._canvas,
        this._currentStroke.canvasRect
      );
      this._strokes$.next({ from: this._currentStroke.lastCoordinates, to: coords, cause: "move", stroke: this._currentStroke.pointerDownId });
      this._currentStroke.lastCoordinates = coords;
    }
    onDocumentPointerUp(event) {
      if (this._currentStroke === void 0) return;
      const coords = this.mapPointerEventToDrawCoordinate(
        event,
        this._canvas,
        this._currentStroke.canvasRect
      );
      this._strokes$.next({ from: this._currentStroke.lastCoordinates, to: coords, cause: "up", stroke: this._currentStroke.pointerDownId });
      this._pointerUp$.next(event);
      this._currentStroke = void 0;
    }
    mapPointerEventToDrawCoordinate(event, canvas, canvasRect) {
      const canvasX = event.offsetX * canvas.width / canvasRect.width;
      const canvasY = event.offsetY * canvas.height / canvasRect.height;
      return [canvasX, canvasY, event.pointerType === "pen" ? event.pressure : void 0];
    }
  };
  __name(_CoordinateListener, "CoordinateListener");
  let CoordinateListener = _CoordinateListener;
  var __defProp$I = Object.defineProperty;
  var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
  var __decorateClass$I = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$I(target, key2, result);
    return result;
  }, "__decorateClass$I");
  var __decorateParam$3 = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$3");
  let ToolsService = (_ya = class {
    constructor(loggerFactory2) {
      __publicField(this, "_prioritizedCanvasEventsSetup");
      __publicField(this, "_drawingService");
      __publicField(this, "_toolChangedListener");
      __publicField(this, "_extensionContainer");
      __publicField(this, "_lobbyService");
      __publicField(this, "_sizeChangedListener");
      __publicField(this, "_colorChangedListener");
      __publicField(this, "_elementsSetup");
      __publicField(this, "_logger");
      __publicField(this, "_activeTool$", new BehaviorSubject(skribblTool.brush));
      __publicField(this, "_activeMods$", new BehaviorSubject([]));
      __publicField(this, "_activeBrushStyle$", new BehaviorSubject({ color: Color.fromHex("#000000").skribblCode, size: 1 }));
      __publicField(this, "_lastPointerDownPosition$", new BehaviorSubject(null));
      __publicField(this, "_canvasCursorStyle", document.createElement("style"));
      __publicField(this, "_insertedStrokes$", new Subject$1());
      this._logger = loggerFactory2(this);
    }
    postConstruct() {
      this._logger.debug("Post construct");
      this.initListeners();
    }
    async initListeners() {
      const elements2 = await this._elementsSetup.complete();
      const listeners = await this._prioritizedCanvasEventsSetup.complete();
      this._toolChangedListener.events$.subscribe((event) => {
        if (event.data !== skribblTool.deselected && event.data !== this._activeTool$.value) {
          this._logger.debug("Tool changed event", event.data);
          this._activeTool$.next(event.data);
        }
      });
      this._activeTool$.pipe(
        combineLatestWith(this._activeBrushStyle$)
      ).subscribe(async ([tool, style2]) => {
        if (tool instanceof TypoDrawTool) {
          if (!this._canvasCursorStyle.parentNode) document.body.appendChild(this._canvasCursorStyle);
          const cursor = tool.createCursor(style2);
          this._canvasCursorStyle.innerText = `#game-canvas canvas { cursor: ${cursor.source} ${cursor.x} ${cursor.y}, auto !important; }`;
        } else {
          this._canvasCursorStyle.remove();
        }
      });
      this._sizeChangedListener.events$.pipe(
        combineLatestWith(this._colorChangedListener.events$),
        map(([size, color]) => ({ size: size.data, color: color.data.skribblCode }))
      ).subscribe((style2) => this._activeBrushStyle$.next(style2));
      const coordinateListener = new CoordinateListener(elements2.canvas);
      listeners.add("draw")("pointerdown", coordinateListener.onCanvasPointerDown.bind(coordinateListener));
      listeners.add("draw")("pointermove", coordinateListener.onCanvasPointerMove.bind(coordinateListener));
      document.addEventListener("pointerup", coordinateListener.onDocumentPointerUp.bind(coordinateListener));
      const drawingMeta$ = this._activeTool$.pipe(
        combineLatestWith(this._activeMods$, this._activeBrushStyle$),
        map(([tool, mods, style2]) => {
          const typoMods = tool instanceof TypoDrawTool ? [tool, ...mods] : mods;
          return [style2, tool, typoMods];
        })
      );
      this._activeMods$.pipe(
        combineLatestWith(this._activeTool$),
        filter(([mods, tool]) => tool instanceof TypoDrawTool || mods.length > 0),
        switchMap(() => coordinateListener.pointerDown$.pipe(
          map(() => true),
          mergeWith(coordinateListener.pointerUp$.pipe(map(() => false)))
        ))
      ).subscribe((isDrawing) => {
        this._drawingService.disableCursorUpdates(isDrawing);
      });
      coordinateListener.strokes$.pipe(
        mergeWith(this._insertedStrokes$),
        withLatestFrom(drawingMeta$)
      ).subscribe(([stroke, [style2, tool, mods]]) => {
        this.processDrawCoordinates(stroke.from, stroke.to, stroke.cause, tool, mods, style2, stroke.stroke);
      });
      coordinateListener.pointerDown$.subscribe((position) => this._lastPointerDownPosition$.next(position));
      this._lobbyService.lobby$.pipe(
        map((lobby) => (lobby == null ? void 0 : lobby.meId) === (lobby == null ? void 0 : lobby.drawerId)),
        combineLatestWith(this._activeTool$, this._activeMods$),
        map(([isDrawer, tool, mods]) => isDrawer && (tool instanceof TypoDrawTool || (tool === skribblTool.brush || tool == skribblTool.fill) && mods.length > 0))
      ).subscribe((enabled) => {
        coordinateListener.enabled = enabled;
      });
    }
    async processDrawCoordinates(start, end, cause, tool, mods, style2, strokeId) {
      var _a2, _b2, _c2;
      this._logger.debug("Activating tool and applying mods", start, end);
      const eventId = Date.now();
      let lines = [{ from: [start[0], start[1]], to: [end[0], end[1]] }];
      let modStyle = structuredClone(style2);
      const pressure = end[2];
      for (const mod of mods) {
        const modLines = [];
        for (const line of lines) {
          const effect = await mod.applyEffect(line, pressure, line.styleOverride ?? modStyle, eventId, strokeId, cause);
          modLines.push(...effect.lines);
          modStyle = effect.style;
          this._logger.debug("Mod applied", mod);
        }
        lines = modLines;
      }
      if (modStyle.color !== style2.color) {
        this._logger.debug("Brush color changed by mods", modStyle.color);
        this._drawingService.setColor(modStyle.color);
      }
      const commands = [];
      if (tool instanceof TypoDrawTool) {
        for (let line of lines) {
          line = { from: [Math.floor(line.from[0]), Math.floor(line.from[1])], to: [Math.floor(line.to[0]), Math.floor(line.to[1])] };
          const lineCommands = await tool.createCommands(line, pressure, line.styleOverride ?? modStyle, eventId, strokeId, cause);
          if (lineCommands.length > 0) {
            commands.push(...lineCommands);
            this._logger.debug("Adding commands created by tool", tool, commands);
          } else {
            this._logger.debug("No draw commands created from tool", tool);
          }
        }
      } else if (tool === skribblTool.brush) {
        for (const line of lines) {
          const lineCommand = this._drawingService.createLineCommand(
            [...line.from, ...line.to],
            ((_a2 = line.styleOverride) == null ? void 0 : _a2.color) ?? modStyle.color,
            ((_b2 = line.styleOverride) == null ? void 0 : _b2.size) ?? modStyle.size,
            false
          );
          if (lineCommand !== void 0) commands.push(lineCommand);
        }
      } else if (tool === skribblTool.fill) {
        if (cause === "down") {
          for (const line of lines) {
            const pointCommand = this._drawingService.createFillCommand(
              [...line.from],
              ((_c2 = line.styleOverride) == null ? void 0 : _c2.color) ?? modStyle.color
            );
            commands.push(pointCommand);
          }
        }
      }
      this._logger.info("Pasting draw commands", commands);
      await this._drawingService.pasteDrawCommands(commands, false);
    }
    /**
     * Set the selected skribbl tool id in the game patch
     * @param tool
     * @private
     */
    setSkribblTool(tool) {
      this._logger.debug("Setting skribbl tool", tool);
      document.dispatchEvent(new CustomEvent("selectSkribblTool", { detail: tool }));
    }
    activateTool(tool) {
      this._logger.debug("Activating tool", tool);
      if (tool === this._activeTool$.value) {
        this._logger.debug("Tool already active", tool);
        return;
      }
      if (tool instanceof TypoDrawTool) {
        this.setSkribblTool(skribblTool.deselected);
      } else {
        this.setSkribblTool(tool);
      }
      this._activeTool$.next(tool);
      if (tool instanceof TypoDrawMod) tool.applyEffect({ from: [0, 0], to: [0, 0] }, void 0, { color: Color.fromHex("#000000").skribblCode, size: 1 }, 0, 0, "down");
      if (tool instanceof TypoDrawTool) tool.createCommands({ from: [0, 0], to: [0, 0] }, void 0, { color: Color.fromHex("#000000").skribblCode, size: 1 }, 0, 0, "down");
    }
    activateMod(mod) {
      this._logger.debug("Activating mod", mod);
      let mods = this._activeMods$.value;
      if (!(mod instanceof ConstantDrawMod)) {
        mods = mods.filter((m) => m instanceof ConstantDrawMod);
      }
      this._activeMods$.next([...mods, mod]);
    }
    removeMod(mod) {
      this._logger.debug("Removing mod", mod);
      const lengthBefore = this._activeMods$.value.length;
      const mods = this._activeMods$.value.filter((m) => m !== mod);
      if (lengthBefore != mods.length) {
        this._activeMods$.next(mods);
      }
    }
    get activeTool$() {
      return this._activeTool$.asObservable();
    }
    get activeMods$() {
      return this._activeMods$.asObservable();
    }
    get activeBrushStyle$() {
      return this._activeBrushStyle$.asObservable();
    }
    get lastPointerDownPosition$() {
      return this._lastPointerDownPosition$.asObservable();
    }
    resolveModOrTool(tool) {
      return this._extensionContainer.resolveService(tool);
    }
    insertStroke(stroke) {
      this._insertedStrokes$.next(stroke);
    }
  }, __name(_ya, "ToolsService"), _ya);
  __decorateClass$I([
    inject(PrioritizedCanvasEventsSetup)
  ], ToolsService.prototype, "_prioritizedCanvasEventsSetup", 2);
  __decorateClass$I([
    inject(DrawingService)
  ], ToolsService.prototype, "_drawingService", 2);
  __decorateClass$I([
    inject(ToolChangedEventListener)
  ], ToolsService.prototype, "_toolChangedListener", 2);
  __decorateClass$I([
    inject(ExtensionContainer)
  ], ToolsService.prototype, "_extensionContainer", 2);
  __decorateClass$I([
    inject(LobbyService)
  ], ToolsService.prototype, "_lobbyService", 2);
  __decorateClass$I([
    inject(SizeChangedEventListener)
  ], ToolsService.prototype, "_sizeChangedListener", 2);
  __decorateClass$I([
    inject(ColorChangedEventListener)
  ], ToolsService.prototype, "_colorChangedListener", 2);
  __decorateClass$I([
    inject(ElementsSetup)
  ], ToolsService.prototype, "_elementsSetup", 2);
  __decorateClass$I([
    postConstruct()
  ], ToolsService.prototype, "postConstruct", 1);
  ToolsService = __decorateClass$I([
    injectable(),
    __decorateParam$3(0, inject(loggerFactory))
  ], ToolsService);
  function create_fragment$17(ctx) {
    let t0;
    let br0;
    let t1;
    let br1;
    return {
      c() {
        t0 = text("Add a hotkey to quickly focus the chat input, so you can start guessing right away. ");
        br0 = element("br");
        t1 = text("\nIf the auto-focus setting is enabled, the chat input will be focused automatically when someone else starts drawing. ");
        br1 = element("br");
      },
      m(target, anchor) {
        insert(target, t0, anchor);
        insert(target, br0, anchor);
        insert(target, t1, anchor);
        insert(target, br1, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(br0);
          detach(t1);
          detach(br1);
        }
      }
    };
  }
  __name(create_fragment$17, "create_fragment$17");
  const _Drawing_color_tools_info = class _Drawing_color_tools_info extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment$17, safe_not_equal, {});
    }
  };
  __name(_Drawing_color_tools_info, "Drawing_color_tools_info");
  let Drawing_color_tools_info = _Drawing_color_tools_info;
  function create_fragment$16(ctx) {
    let div2;
    let div0;
    let t;
    let div1;
    let colorpickerbutton;
    let current;
    let mounted;
    let dispose;
    colorpickerbutton = new Color_picker_button({
      props: {
        color: (
          /*$color*/
          ctx[2]
        ),
        allowAlpha: false,
        useBackground: false,
        height: "auto",
        borderRadius: "0",
        colorChanged: (
          /*func*/
          ctx[6]
        ),
        description: "Warning: Only typo users can see custom colors."
      }
    });
    return {
      c() {
        div2 = element("div");
        div0 = element("div");
        t = space();
        div1 = element("div");
        create_component(colorpickerbutton.$$.fragment);
        attr(div0, "class", "pipette svelte-iqw7hb");
        toggle_class(
          div0,
          "selected",
          /*$selectedTool*/
          ctx[1] instanceof PipetteTool
        );
        attr(div1, "class", "picker svelte-iqw7hb");
        attr(div2, "class", "color-tools svelte-iqw7hb");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, div0);
        append(div2, t);
        append(div2, div1);
        mount_component(colorpickerbutton, div1, null);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              div0,
              "click",
              /*click_handler*/
              ctx[5]
            ),
            action_destroyer(
              /*feature*/
              ctx[0].createTooltip(div0, { title: "Pipette", lock: "Y" })
            ),
            action_destroyer(
              /*feature*/
              ctx[0].createTooltip(div1, { title: "Picker", lock: "Y" })
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (!current || dirty & /*$selectedTool*/
        2) {
          toggle_class(
            div0,
            "selected",
            /*$selectedTool*/
            ctx2[1] instanceof PipetteTool
          );
        }
        const colorpickerbutton_changes = {};
        if (dirty & /*$color*/
        4) colorpickerbutton_changes.color = /*$color*/
        ctx2[2];
        if (dirty & /*feature*/
        1) colorpickerbutton_changes.colorChanged = /*func*/
        ctx2[6];
        colorpickerbutton.$set(colorpickerbutton_changes);
      },
      i(local) {
        if (current) return;
        transition_in(colorpickerbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(colorpickerbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        destroy_component(colorpickerbutton);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$16, "create_fragment$16");
  function instance$10($$self, $$props, $$invalidate) {
    let $selectedTool;
    let $color;
    let { feature } = $$props;
    const selectedTool = feature.selectedToolStore;
    component_subscribe($$self, selectedTool, (value) => $$invalidate(1, $selectedTool = value));
    const color = feature.colorStore;
    component_subscribe($$self, color, (value) => $$invalidate(2, $color = value));
    const click_handler2 = /* @__PURE__ */ __name(() => feature.selectPipetteTool(), "click_handler");
    const func2 = /* @__PURE__ */ __name((c) => feature.updatePickedColor(c), "func");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [feature, $selectedTool, $color, selectedTool, color, click_handler2, func2];
  }
  __name(instance$10, "instance$10");
  const _Drawing_color_tools = class _Drawing_color_tools extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$10, create_fragment$16, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Drawing_color_tools, "Drawing_color_tools");
  let Drawing_color_tools = _Drawing_color_tools;
  var __defProp$H = Object.defineProperty;
  var __decorateClass$H = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$H(target, key2, result);
    return result;
  }, "__decorateClass$H");
  const _DrawingColorToolsFeature = class _DrawingColorToolsFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "elementsSetup");
      __publicField(this, "_toolsService");
      __publicField(this, "_drawingService");
      __publicField(this, "_colorChangedListener");
      __publicField(this, "name", "Color Tools");
      __publicField(this, "description", "Add a pipette and color picker to the toolbar");
      __publicField(this, "tags", [
        FeatureTag.DRAWING
      ]);
      __publicField(this, "featureId", 31);
      __publicField(this, "pipetteHotkey", this.useHotkey(new HotkeyAction(
        "activate_pipette",
        "Use Pipette",
        "Activate the pipette tool to select a color from the canvas",
        this,
        () => this.selectPipetteTool(),
        void 0
      )));
      __publicField(this, "_component");
      __publicField(this, "_pipetteTool");
      __publicField(this, "_colorChangeSubscription");
      __publicField(this, "_currentColor$", new Subject$1());
    }
    get featureInfoComponent() {
      return { componentType: Drawing_color_tools_info, props: {} };
    }
    async onActivate() {
      const elements2 = await this.elementsSetup.complete();
      this._pipetteTool = this._toolsService.resolveModOrTool(PipetteTool);
      this._colorChangedListener.events$.pipe(
        withLatestFrom(this._currentColor$.pipe(startWith(new Color(0, 0, 0)))),
        filter(([event, currentColor]) => event.data.hex !== currentColor.hex),
        map(([event]) => event)
      ).subscribe((event) => {
        this._currentColor$.next(event.data);
      });
      this._component = new Drawing_color_tools({
        target: elements2.skribblTools,
        anchor: elements2.skribblBrushTools,
        props: {
          feature: this
        }
      });
    }
    async onDestroy() {
      var _a2, _b2;
      (_a2 = this._component) == null ? void 0 : _a2.$destroy();
      this._component = void 0;
      (_b2 = this._colorChangeSubscription) == null ? void 0 : _b2.unsubscribe();
      this._colorChangeSubscription = void 0;
      this._pipetteTool = void 0;
    }
    selectPipetteTool() {
      if (!this._pipetteTool) {
        this._logger.error("Pipette tool not initialized");
        throw new Error("Pipette tool not initialized yet");
      }
      this._logger.info("Pipette tool selected");
      this._toolsService.activateTool(this._pipetteTool);
    }
    get selectedToolStore() {
      return fromObservable(this._toolsService.activeTool$, skribblTool.brush);
    }
    get colorStore() {
      return fromObservable(this._currentColor$, new Color(0, 0, 0));
    }
    updatePickedColor(color) {
      this._logger.info("Color picked", color);
      this._drawingService.setColor(color.skribblCode);
    }
  };
  __name(_DrawingColorToolsFeature, "DrawingColorToolsFeature");
  let DrawingColorToolsFeature = _DrawingColorToolsFeature;
  __decorateClass$H([
    inject(ElementsSetup)
  ], DrawingColorToolsFeature.prototype, "elementsSetup");
  __decorateClass$H([
    inject(ToolsService)
  ], DrawingColorToolsFeature.prototype, "_toolsService");
  __decorateClass$H([
    inject(DrawingService)
  ], DrawingColorToolsFeature.prototype, "_drawingService");
  __decorateClass$H([
    inject(ColorChangedEventListener)
  ], DrawingColorToolsFeature.prototype, "_colorChangedListener");
  const calculatePressurePoint = /* @__PURE__ */ __name((p, s, b) => {
    const A = 1 / (1 + Math.exp(b * s));
    const B = 1 / (1 + Math.exp(-s * (p - b)));
    const C = 1 / (1 + Math.exp(-s * (1 - b)));
    return (B - A) / (C - A);
  }, "calculatePressurePoint");
  const _PressureMod = class _PressureMod extends ConstantDrawMod {
    constructor() {
      super(...arguments);
      __publicField(this, "_maxSize", 40);
      __publicField(this, "_minSize", 4);
      __publicField(this, "_sensitivity", 6);
      __publicField(this, "_balance", 0.5);
    }
    /**
     * Set the brush size depending on the pressure
     * @param line
     * @param pressure
     * @param style
     * @param eventId
     * @param strokeId
     */
    async applyConstantEffect(line, pressure, style2) {
      if (pressure === void 0) {
        return {
          style: style2,
          line
        };
      }
      const point = calculatePressurePoint(pressure, this._sensitivity, this._balance);
      const size = Math.floor(this._minSize + (this._maxSize - this._minSize) * point);
      style2.size = size;
      return {
        style: style2,
        line
      };
    }
    /**
     * Set the sensitivity and balance of the pressure point function
     * @param sensitivity
     * @param balance
     */
    setParams(sensitivity, balance) {
      this._sensitivity = sensitivity;
      this._balance = balance;
    }
  };
  __name(_PressureMod, "PressureMod");
  let PressureMod = _PressureMod;
  function create_fragment$15(ctx) {
    let div;
    let p0;
    let t5;
    let br5;
    let t6;
    let b0;
    let t8;
    let p1;
    let t10;
    let br6;
    let t11;
    let b1;
    let t13;
    let p2;
    let t16;
    let br8;
    let t17;
    let canvas_1;
    return {
      c() {
        div = element("div");
        p0 = element("p");
        p0.innerHTML = `Typo modifies pressure so that you can use the full brush size range without switching brush sizes in skribbl.<br/>
    Additionally, you can customize the sensitivity of the pen pressure.<br/>
    By default, a performance mode is activated. This mode is recommended for devices with lower performance.<br/>
    The performance mode uses a simplified pressure function and does not work with the Brush Lab.<br/>
    To use pressure in combination with the typo brush laboratory, disable performance mode or enable the &quot;Disable performance in Lab&quot; to automatically disable performance mode whenever you&#39;re using the lab.<br/>`;
        t5 = space();
        br5 = element("br");
        t6 = space();
        b0 = element("b");
        b0.textContent = "Attention!";
        t8 = space();
        p1 = element("p");
        p1.textContent = 'The performance mode needs "Pressure Sensitivity" enabled in the skribbl settings.';
        t10 = space();
        br6 = element("br");
        t11 = space();
        b1 = element("b");
        b1.textContent = "Current sensitivity curve:";
        t13 = space();
        p2 = element("p");
        p2.innerHTML = `The sensitivity curve shows how the brush size changes depending on pen pressure.<br/>
    The x-axis represents the pressure (from light to hard), and the y-axis represents the brush size (small to big).`;
        t16 = space();
        br8 = element("br");
        t17 = space();
        canvas_1 = element("canvas");
        attr(canvas_1, "width", "100");
        attr(canvas_1, "height", "100");
        attr(canvas_1, "class", "svelte-18097wc");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, p0);
        append(div, t5);
        append(div, br5);
        append(div, t6);
        append(div, b0);
        append(div, t8);
        append(div, p1);
        append(div, t10);
        append(div, br6);
        append(div, t11);
        append(div, b1);
        append(div, t13);
        append(div, p2);
        append(div, t16);
        append(div, br8);
        append(div, t17);
        append(div, canvas_1);
        ctx[6](canvas_1);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        ctx[6](null);
      }
    };
  }
  __name(create_fragment$15, "create_fragment$15");
  function instance$$($$self, $$props, $$invalidate) {
    let $balance;
    let $sensitivity;
    let { feature } = $$props;
    const sensitivity = feature.sensitivitySettingStore;
    component_subscribe($$self, sensitivity, (value) => $$invalidate(5, $sensitivity = value));
    const balance = feature.balanceSettingStore;
    component_subscribe($$self, balance, (value) => $$invalidate(4, $balance = value));
    let canvas;
    function canvas_1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        canvas = $$value;
        $$invalidate(0, canvas);
      });
    }
    __name(canvas_1_binding, "canvas_1_binding");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(3, feature = $$props2.feature);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*$sensitivity, $balance, canvas*/
      49) {
        {
          let s = $sensitivity;
          let v = $balance;
          const ctx = canvas == null ? void 0 : canvas.getContext("2d");
          if (ctx) {
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, 100, 100);
            ctx.fillStyle = "white";
            ctx.lineWidth = 2;
            ctx.fillRect(0, 0, 100, 100);
            ctx.strokeStyle = "rgb(0, 0, 0)";
            ctx.beginPath();
            for (let x = 0; x < 100; x++) {
              ctx.lineTo(x, 100 - calculatePressurePoint(x / 100, s, v) * 100);
            }
            ctx.stroke();
          }
        }
      }
    };
    return [
      canvas,
      sensitivity,
      balance,
      feature,
      $balance,
      $sensitivity,
      canvas_1_binding
    ];
  }
  __name(instance$$, "instance$$");
  const _Drawing_pressure_info = class _Drawing_pressure_info extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$$, create_fragment$15, safe_not_equal, { feature: 3 });
    }
  };
  __name(_Drawing_pressure_info, "Drawing_pressure_info");
  let Drawing_pressure_info = _Drawing_pressure_info;
  var __defProp$G = Object.defineProperty;
  var __decorateClass$G = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$G(target, key2, result);
    return result;
  }, "__decorateClass$G");
  const _DrawingPressureFeature = class _DrawingPressureFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_toolsService");
      __publicField(this, "_drawingService");
      __publicField(this, "name", "Modified Pen Pressure");
      __publicField(this, "description", "Use the full size range and custom sensitivity for pen pressure");
      __publicField(this, "tags", [
        FeatureTag.DRAWING
      ]);
      __publicField(this, "featureId", 37);
      __publicField(this, "_currentPointerType", new Subject$1());
      __publicField(this, "_performanceEnabledSubscription");
      __publicField(this, "_currentPointerTypeSubscription");
      __publicField(this, "_pointerOverListener", this.handlePointerOver.bind(this));
      __publicField(this, "_performanceEnabledSetting", this.useSetting(
        new BooleanExtensionSetting("pressure_performance", true, this).withName("Performance Mode").withDescription("Better pressure support for less performant devices, but can't be used in combination with the brush laboratory.")
      ));
      __publicField(this, "_pressureParamSensitivitySetting", this.useSetting(
        new NumericExtensionSetting("pressure_sensitivity", 6, this).withName("Pressure Sensitivity").withDescription("The sensitivity of pressure change. A higher value means a more dense pressure range.").withBounds(1, 20).withSlider(1)
      ));
      __publicField(this, "_pressureParamBalanceSetting", this.useSetting(
        new NumericExtensionSetting("pressure_balance", 0.5, this).withName("Pressure Balance").withDescription("The balance of pressure increase. A higher value moves the size range to a higher pressure range.").withBounds(0, 1).withSlider(1 / 20)
      ));
      __publicField(this, "_disablePerformanceInBrushlabSetting", this.useSetting(
        new BooleanExtensionSetting("pressure_disable_performance_brushlab", false, this).withName("Disable Performance in Lab").withDescription("Automatically disables the performance mode (if active) when using the Brush Lab. This might cause lags on less performant devices.")
      ));
      __publicField(this, "_pressureMod");
    }
    handlePointerOver(e) {
      this._currentPointerType.next(e.pointerType);
    }
    get featureInfoComponent() {
      return { componentType: Drawing_pressure_info, props: { feature: this } };
    }
    async onActivate() {
      const overridePerformance$ = this._disablePerformanceInBrushlabSetting.changes$.pipe(
        combineLatestWith(this._toolsService.activeMods$, this._toolsService.activeTool$),
        map(([disable, mods, tool]) => disable && (tool instanceof TypoDrawTool || mods.filter((m) => !(m instanceof PressureMod)).length > 0))
      );
      this._performanceEnabledSubscription = this._performanceEnabledSetting.changes$.pipe(
        combineLatestWith(this._pressureParamSensitivitySetting.changes$, this._pressureParamBalanceSetting.changes$, overridePerformance$)
      ).subscribe(async ([performanceMode, sensitivity, balance, overridePerformance]) => {
        if (performanceMode && !overridePerformance) {
          if (this._pressureMod) {
            this._toolsService.removeMod(this._pressureMod);
            this._pressureMod = void 0;
          }
          document.documentElement.dataset["typo_pressure_performance"] = this.getPerformanceFunctionEval(sensitivity, balance);
        } else {
          if (!this._pressureMod) {
            this._pressureMod = this._toolsService.resolveModOrTool(PressureMod);
            this._toolsService.activateMod(this._pressureMod);
          }
          this._pressureMod.setParams(sensitivity, balance);
          document.documentElement.dataset["typo_pressure_performance"] = "";
        }
      });
      document.addEventListener("pointerover", this._pointerOverListener);
      this._currentPointerTypeSubscription = this._currentPointerType.pipe(
        distinctUntilChanged()
      ).subscribe((type) => {
        if (type === "pen") {
          this._logger.info("Pen detected, resetting size to 4");
          this._drawingService.setSize(4);
        }
      });
    }
    /**
     * An eval function which is used by the game patch to calculate the typo pressure
     * Probably not the most performant option (ironic), but good enough & prevents duplicating the function.
     * @param s
     * @param b
     * @private
     */
    getPerformanceFunctionEval(s, b) {
      return `(pressure) => (${calculatePressurePoint.toString()})(pressure, ${s}, ${b})`;
    }
    async onDestroy() {
      var _a2, _b2;
      if (this._pressureMod) {
        this._toolsService.removeMod(this._pressureMod);
        this._pressureMod = void 0;
      }
      document.documentElement.dataset["typo_pressure_performance"] = "";
      (_a2 = this._performanceEnabledSubscription) == null ? void 0 : _a2.unsubscribe();
      this._performanceEnabledSubscription = void 0;
      document.removeEventListener("pointerover", this._pointerOverListener);
      (_b2 = this._currentPointerTypeSubscription) == null ? void 0 : _b2.unsubscribe();
    }
    get balanceSettingStore() {
      return this._pressureParamBalanceSetting.store;
    }
    get sensitivitySettingStore() {
      return this._pressureParamSensitivitySetting.store;
    }
  };
  __name(_DrawingPressureFeature, "DrawingPressureFeature");
  let DrawingPressureFeature = _DrawingPressureFeature;
  __decorateClass$G([
    inject(ToolsService)
  ], DrawingPressureFeature.prototype, "_toolsService");
  __decorateClass$G([
    inject(DrawingService)
  ], DrawingPressureFeature.prototype, "_drawingService");
  const _ReceiverMethodSubscription = class _ReceiverMethodSubscription {
    constructor(connection, receiverMethod) {
      __publicField(this, "dispose", /* @__PURE__ */ __name(() => {
        for (const it of this.receiverMethod) {
          this.connection.off(it.methodName, it.method);
        }
      }, "dispose"));
      this.connection = connection;
      this.receiverMethod = receiverMethod;
    }
  };
  __name(_ReceiverMethodSubscription, "ReceiverMethodSubscription");
  let ReceiverMethodSubscription = _ReceiverMethodSubscription;
  const getHubProxyFactory = /* @__PURE__ */ __name((hubType) => {
    if (hubType === "IGuildLobbiesHub") {
      return IGuildLobbiesHub_HubProxyFactory.Instance;
    }
    if (hubType === "ILobbyHub") {
      return ILobbyHub_HubProxyFactory.Instance;
    }
    if (hubType === "IOnlineItemsHub") {
      return IOnlineItemsHub_HubProxyFactory.Instance;
    }
  }, "getHubProxyFactory");
  const getReceiverRegister = /* @__PURE__ */ __name((receiverType) => {
    if (receiverType === "IGuildLobbiesReceiver") {
      return IGuildLobbiesReceiver_Binder.Instance;
    }
    if (receiverType === "ILobbyReceiver") {
      return ILobbyReceiver_Binder.Instance;
    }
    if (receiverType === "IOnlineItemsReceiver") {
      return IOnlineItemsReceiver_Binder.Instance;
    }
  }, "getReceiverRegister");
  const _IGuildLobbiesHub_HubProxyFactory = class _IGuildLobbiesHub_HubProxyFactory {
    constructor() {
      __publicField(this, "createHubProxy", /* @__PURE__ */ __name((connection) => {
        return new IGuildLobbiesHub_HubProxy(connection);
      }, "createHubProxy"));
    }
  };
  __name(_IGuildLobbiesHub_HubProxyFactory, "IGuildLobbiesHub_HubProxyFactory");
  __publicField(_IGuildLobbiesHub_HubProxyFactory, "Instance", new _IGuildLobbiesHub_HubProxyFactory());
  let IGuildLobbiesHub_HubProxyFactory = _IGuildLobbiesHub_HubProxyFactory;
  const _IGuildLobbiesHub_HubProxy = class _IGuildLobbiesHub_HubProxy {
    constructor(connection) {
      __publicField(this, "subscribeGuildLobbies", /* @__PURE__ */ __name(async (guildId) => {
        return await this.connection.invoke("SubscribeGuildLobbies", guildId);
      }, "subscribeGuildLobbies"));
      this.connection = connection;
    }
  };
  __name(_IGuildLobbiesHub_HubProxy, "IGuildLobbiesHub_HubProxy");
  let IGuildLobbiesHub_HubProxy = _IGuildLobbiesHub_HubProxy;
  const _ILobbyHub_HubProxyFactory = class _ILobbyHub_HubProxyFactory {
    constructor() {
      __publicField(this, "createHubProxy", /* @__PURE__ */ __name((connection) => {
        return new ILobbyHub_HubProxy(connection);
      }, "createHubProxy"));
    }
  };
  __name(_ILobbyHub_HubProxyFactory, "ILobbyHub_HubProxyFactory");
  __publicField(_ILobbyHub_HubProxyFactory, "Instance", new _ILobbyHub_HubProxyFactory());
  let ILobbyHub_HubProxyFactory = _ILobbyHub_HubProxyFactory;
  const _ILobbyHub_HubProxy = class _ILobbyHub_HubProxy {
    constructor(connection) {
      __publicField(this, "lobbyDiscovered", /* @__PURE__ */ __name(async (lobbyDiscovery) => {
        return await this.connection.invoke("LobbyDiscovered", lobbyDiscovery);
      }, "lobbyDiscovered"));
      __publicField(this, "claimLobbyOwnership", /* @__PURE__ */ __name(async () => {
        return await this.connection.invoke("ClaimLobbyOwnership");
      }, "claimLobbyOwnership"));
      __publicField(this, "updateSkribblLobbyState", /* @__PURE__ */ __name(async (state) => {
        return await this.connection.invoke("UpdateSkribblLobbyState", state);
      }, "updateSkribblLobbyState"));
      __publicField(this, "updateTypoLobbySettings", /* @__PURE__ */ __name(async (typoSettings) => {
        return await this.connection.invoke("UpdateTypoLobbySettings", typoSettings);
      }, "updateTypoLobbySettings"));
      __publicField(this, "claimDrop", /* @__PURE__ */ __name(async (dropClaim) => {
        return await this.connection.invoke("ClaimDrop", dropClaim);
      }, "claimDrop"));
      __publicField(this, "giftAward", /* @__PURE__ */ __name(async (awardGift) => {
        return await this.connection.invoke("GiftAward", awardGift);
      }, "giftAward"));
      this.connection = connection;
    }
  };
  __name(_ILobbyHub_HubProxy, "ILobbyHub_HubProxy");
  let ILobbyHub_HubProxy = _ILobbyHub_HubProxy;
  const _IOnlineItemsHub_HubProxyFactory = class _IOnlineItemsHub_HubProxyFactory {
    constructor() {
      __publicField(this, "createHubProxy", /* @__PURE__ */ __name((connection) => {
        return new IOnlineItemsHub_HubProxy(connection);
      }, "createHubProxy"));
    }
  };
  __name(_IOnlineItemsHub_HubProxyFactory, "IOnlineItemsHub_HubProxyFactory");
  __publicField(_IOnlineItemsHub_HubProxyFactory, "Instance", new _IOnlineItemsHub_HubProxyFactory());
  let IOnlineItemsHub_HubProxyFactory = _IOnlineItemsHub_HubProxyFactory;
  const _IOnlineItemsHub_HubProxy = class _IOnlineItemsHub_HubProxy {
    constructor(connection) {
      this.connection = connection;
    }
  };
  __name(_IOnlineItemsHub_HubProxy, "IOnlineItemsHub_HubProxy");
  let IOnlineItemsHub_HubProxy = _IOnlineItemsHub_HubProxy;
  const _IGuildLobbiesReceiver_Binder = class _IGuildLobbiesReceiver_Binder {
    constructor() {
      __publicField(this, "register", /* @__PURE__ */ __name((connection, receiver) => {
        const __guildLobbiesUpdated = /* @__PURE__ */ __name((...args) => receiver.guildLobbiesUpdated(...args), "__guildLobbiesUpdated");
        connection.on("GuildLobbiesUpdated", __guildLobbiesUpdated);
        const methodList = [
          { methodName: "GuildLobbiesUpdated", method: __guildLobbiesUpdated }
        ];
        return new ReceiverMethodSubscription(connection, methodList);
      }, "register"));
    }
  };
  __name(_IGuildLobbiesReceiver_Binder, "IGuildLobbiesReceiver_Binder");
  __publicField(_IGuildLobbiesReceiver_Binder, "Instance", new _IGuildLobbiesReceiver_Binder());
  let IGuildLobbiesReceiver_Binder = _IGuildLobbiesReceiver_Binder;
  const _ILobbyReceiver_Binder = class _ILobbyReceiver_Binder {
    constructor() {
      __publicField(this, "register", /* @__PURE__ */ __name((connection, receiver) => {
        const __typoLobbySettingsUpdated = /* @__PURE__ */ __name((...args) => receiver.typoLobbySettingsUpdated(...args), "__typoLobbySettingsUpdated");
        const __lobbyOwnershipResigned = /* @__PURE__ */ __name(() => receiver.lobbyOwnershipResigned(), "__lobbyOwnershipResigned");
        const __dropAnnounced = /* @__PURE__ */ __name((...args) => receiver.dropAnnounced(...args), "__dropAnnounced");
        const __awardGifted = /* @__PURE__ */ __name((...args) => receiver.awardGifted(...args), "__awardGifted");
        const __dropClaimed = /* @__PURE__ */ __name((...args) => receiver.dropClaimed(...args), "__dropClaimed");
        const __dropCleared = /* @__PURE__ */ __name((...args) => receiver.dropCleared(...args), "__dropCleared");
        connection.on("TypoLobbySettingsUpdated", __typoLobbySettingsUpdated);
        connection.on("LobbyOwnershipResigned", __lobbyOwnershipResigned);
        connection.on("DropAnnounced", __dropAnnounced);
        connection.on("AwardGifted", __awardGifted);
        connection.on("DropClaimed", __dropClaimed);
        connection.on("DropCleared", __dropCleared);
        const methodList = [
          { methodName: "TypoLobbySettingsUpdated", method: __typoLobbySettingsUpdated },
          { methodName: "LobbyOwnershipResigned", method: __lobbyOwnershipResigned },
          { methodName: "DropAnnounced", method: __dropAnnounced },
          { methodName: "AwardGifted", method: __awardGifted },
          { methodName: "DropClaimed", method: __dropClaimed },
          { methodName: "DropCleared", method: __dropCleared }
        ];
        return new ReceiverMethodSubscription(connection, methodList);
      }, "register"));
    }
  };
  __name(_ILobbyReceiver_Binder, "ILobbyReceiver_Binder");
  __publicField(_ILobbyReceiver_Binder, "Instance", new _ILobbyReceiver_Binder());
  let ILobbyReceiver_Binder = _ILobbyReceiver_Binder;
  const _IOnlineItemsReceiver_Binder = class _IOnlineItemsReceiver_Binder {
    constructor() {
      __publicField(this, "register", /* @__PURE__ */ __name((connection, receiver) => {
        const __onlineItemsUpdated = /* @__PURE__ */ __name((...args) => receiver.onlineItemsUpdated(...args), "__onlineItemsUpdated");
        connection.on("OnlineItemsUpdated", __onlineItemsUpdated);
        const methodList = [
          { methodName: "OnlineItemsUpdated", method: __onlineItemsUpdated }
        ];
        return new ReceiverMethodSubscription(connection, methodList);
      }, "register"));
    }
  };
  __name(_IOnlineItemsReceiver_Binder, "IOnlineItemsReceiver_Binder");
  __publicField(_IOnlineItemsReceiver_Binder, "Instance", new _IOnlineItemsReceiver_Binder());
  let IOnlineItemsReceiver_Binder = _IOnlineItemsReceiver_Binder;
  const _HttpError = class _HttpError extends Error {
    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.
     *
     * @param {string} errorMessage A descriptive error message.
     * @param {number} statusCode The HTTP status code represented by this error.
     */
    constructor(errorMessage, statusCode) {
      const trueProto = new.target.prototype;
      super(`${errorMessage}: Status code '${statusCode}'`);
      this.statusCode = statusCode;
      this.__proto__ = trueProto;
    }
  };
  __name(_HttpError, "HttpError");
  let HttpError = _HttpError;
  const _TimeoutError = class _TimeoutError extends Error {
    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.
     *
     * @param {string} errorMessage A descriptive error message.
     */
    constructor(errorMessage = "A timeout occurred.") {
      const trueProto = new.target.prototype;
      super(errorMessage);
      this.__proto__ = trueProto;
    }
  };
  __name(_TimeoutError, "TimeoutError");
  let TimeoutError = _TimeoutError;
  const _AbortError = class _AbortError extends Error {
    /** Constructs a new instance of {@link AbortError}.
     *
     * @param {string} errorMessage A descriptive error message.
     */
    constructor(errorMessage = "An abort occurred.") {
      const trueProto = new.target.prototype;
      super(errorMessage);
      this.__proto__ = trueProto;
    }
  };
  __name(_AbortError, "AbortError");
  let AbortError = _AbortError;
  const _UnsupportedTransportError = class _UnsupportedTransportError extends Error {
    /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.
     *
     * @param {string} message A descriptive error message.
     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.
     */
    constructor(message, transport) {
      const trueProto = new.target.prototype;
      super(message);
      this.transport = transport;
      this.errorType = "UnsupportedTransportError";
      this.__proto__ = trueProto;
    }
  };
  __name(_UnsupportedTransportError, "UnsupportedTransportError");
  let UnsupportedTransportError = _UnsupportedTransportError;
  const _DisabledTransportError = class _DisabledTransportError extends Error {
    /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.
     *
     * @param {string} message A descriptive error message.
     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.
     */
    constructor(message, transport) {
      const trueProto = new.target.prototype;
      super(message);
      this.transport = transport;
      this.errorType = "DisabledTransportError";
      this.__proto__ = trueProto;
    }
  };
  __name(_DisabledTransportError, "DisabledTransportError");
  let DisabledTransportError = _DisabledTransportError;
  const _FailedToStartTransportError = class _FailedToStartTransportError extends Error {
    /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.
     *
     * @param {string} message A descriptive error message.
     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.
     */
    constructor(message, transport) {
      const trueProto = new.target.prototype;
      super(message);
      this.transport = transport;
      this.errorType = "FailedToStartTransportError";
      this.__proto__ = trueProto;
    }
  };
  __name(_FailedToStartTransportError, "FailedToStartTransportError");
  let FailedToStartTransportError = _FailedToStartTransportError;
  const _FailedToNegotiateWithServerError = class _FailedToNegotiateWithServerError extends Error {
    /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.
     *
     * @param {string} message A descriptive error message.
     */
    constructor(message) {
      const trueProto = new.target.prototype;
      super(message);
      this.errorType = "FailedToNegotiateWithServerError";
      this.__proto__ = trueProto;
    }
  };
  __name(_FailedToNegotiateWithServerError, "FailedToNegotiateWithServerError");
  let FailedToNegotiateWithServerError = _FailedToNegotiateWithServerError;
  const _AggregateErrors = class _AggregateErrors extends Error {
    /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.
     *
     * @param {string} message A descriptive error message.
     * @param {Error[]} innerErrors The collection of errors this error is aggregating.
     */
    constructor(message, innerErrors) {
      const trueProto = new.target.prototype;
      super(message);
      this.innerErrors = innerErrors;
      this.__proto__ = trueProto;
    }
  };
  __name(_AggregateErrors, "AggregateErrors");
  let AggregateErrors = _AggregateErrors;
  const _HttpResponse = class _HttpResponse {
    constructor(statusCode, statusText, content2) {
      this.statusCode = statusCode;
      this.statusText = statusText;
      this.content = content2;
    }
  };
  __name(_HttpResponse, "HttpResponse");
  let HttpResponse = _HttpResponse;
  const _HttpClient = class _HttpClient {
    get(url, options) {
      return this.send({
        ...options,
        method: "GET",
        url
      });
    }
    post(url, options) {
      return this.send({
        ...options,
        method: "POST",
        url
      });
    }
    delete(url, options) {
      return this.send({
        ...options,
        method: "DELETE",
        url
      });
    }
    /** Gets all cookies that apply to the specified URL.
     *
     * @param url The URL that the cookies are valid for.
     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.
     */
    // @ts-ignore
    getCookieString(url) {
      return "";
    }
  };
  __name(_HttpClient, "HttpClient");
  let HttpClient = _HttpClient;
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2[LogLevel2["Trace"] = 0] = "Trace";
    LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
    LogLevel2[LogLevel2["Information"] = 2] = "Information";
    LogLevel2[LogLevel2["Warning"] = 3] = "Warning";
    LogLevel2[LogLevel2["Error"] = 4] = "Error";
    LogLevel2[LogLevel2["Critical"] = 5] = "Critical";
    LogLevel2[LogLevel2["None"] = 6] = "None";
  })(LogLevel || (LogLevel = {}));
  const _NullLogger = class _NullLogger {
    constructor() {
    }
    /** @inheritDoc */
    // eslint-disable-next-line
    log(_logLevel, _message) {
    }
  };
  __name(_NullLogger, "NullLogger");
  let NullLogger = _NullLogger;
  NullLogger.instance = new NullLogger();
  const VERSION = "8.0.7";
  const _Arg = class _Arg {
    static isRequired(val, name) {
      if (val === null || val === void 0) {
        throw new Error(`The '${name}' argument is required.`);
      }
    }
    static isNotEmpty(val, name) {
      if (!val || val.match(/^\s*$/)) {
        throw new Error(`The '${name}' argument should not be empty.`);
      }
    }
    static isIn(val, values, name) {
      if (!(val in values)) {
        throw new Error(`Unknown ${name} value: ${val}.`);
      }
    }
  };
  __name(_Arg, "Arg");
  let Arg = _Arg;
  const _Platform = class _Platform {
    // react-native has a window but no document so we should check both
    static get isBrowser() {
      return !_Platform.isNode && typeof window === "object" && typeof window.document === "object";
    }
    // WebWorkers don't have a window object so the isBrowser check would fail
    static get isWebWorker() {
      return !_Platform.isNode && typeof self === "object" && "importScripts" in self;
    }
    // react-native has a window but no document
    static get isReactNative() {
      return !_Platform.isNode && typeof window === "object" && typeof window.document === "undefined";
    }
    // Node apps shouldn't have a window object, but WebWorkers don't either
    // so we need to check for both WebWorker and window
    static get isNode() {
      return typeof process !== "undefined" && process.release && process.release.name === "node";
    }
  };
  __name(_Platform, "Platform");
  let Platform = _Platform;
  function getDataDetail(data, includeContent) {
    let detail = "";
    if (isArrayBuffer(data)) {
      detail = `Binary data of length ${data.byteLength}`;
      if (includeContent) {
        detail += `. Content: '${formatArrayBuffer(data)}'`;
      }
    } else if (typeof data === "string") {
      detail = `String data of length ${data.length}`;
      if (includeContent) {
        detail += `. Content: '${data}'`;
      }
    }
    return detail;
  }
  __name(getDataDetail, "getDataDetail");
  function formatArrayBuffer(data) {
    const view = new Uint8Array(data);
    let str = "";
    view.forEach((num) => {
      const pad = num < 16 ? "0" : "";
      str += `0x${pad}${num.toString(16)} `;
    });
    return str.substr(0, str.length - 1);
  }
  __name(formatArrayBuffer, "formatArrayBuffer");
  function isArrayBuffer(val) {
    return val && typeof ArrayBuffer !== "undefined" && (val instanceof ArrayBuffer || // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof
    val.constructor && val.constructor.name === "ArrayBuffer");
  }
  __name(isArrayBuffer, "isArrayBuffer");
  async function sendMessage(logger, transportName, httpClient, url, content2, options) {
    const headers = {};
    const [name, value] = getUserAgentHeader();
    headers[name] = value;
    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content2, options.logMessageContent)}.`);
    const responseType = isArrayBuffer(content2) ? "arraybuffer" : "text";
    const response = await httpClient.post(url, {
      content: content2,
      headers: { ...headers, ...options.headers },
      responseType,
      timeout: options.timeout,
      withCredentials: options.withCredentials
    });
    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);
  }
  __name(sendMessage, "sendMessage");
  function createLogger(logger) {
    if (logger === void 0) {
      return new ConsoleLogger(LogLevel.Information);
    }
    if (logger === null) {
      return NullLogger.instance;
    }
    if (logger.log !== void 0) {
      return logger;
    }
    return new ConsoleLogger(logger);
  }
  __name(createLogger, "createLogger");
  const _SubjectSubscription = class _SubjectSubscription {
    constructor(subject, observer) {
      this._subject = subject;
      this._observer = observer;
    }
    dispose() {
      const index = this._subject.observers.indexOf(this._observer);
      if (index > -1) {
        this._subject.observers.splice(index, 1);
      }
      if (this._subject.observers.length === 0 && this._subject.cancelCallback) {
        this._subject.cancelCallback().catch((_) => {
        });
      }
    }
  };
  __name(_SubjectSubscription, "SubjectSubscription");
  let SubjectSubscription = _SubjectSubscription;
  const _ConsoleLogger = class _ConsoleLogger {
    constructor(minimumLogLevel) {
      this._minLevel = minimumLogLevel;
      this.out = console;
    }
    log(logLevel, message) {
      if (logLevel >= this._minLevel) {
        const msg = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${LogLevel[logLevel]}: ${message}`;
        switch (logLevel) {
          case LogLevel.Critical:
          case LogLevel.Error:
            this.out.error(msg);
            break;
          case LogLevel.Warning:
            this.out.warn(msg);
            break;
          case LogLevel.Information:
            this.out.info(msg);
            break;
          default:
            this.out.log(msg);
            break;
        }
      }
    }
  };
  __name(_ConsoleLogger, "ConsoleLogger");
  let ConsoleLogger = _ConsoleLogger;
  function getUserAgentHeader() {
    let userAgentHeaderName = "X-SignalR-User-Agent";
    if (Platform.isNode) {
      userAgentHeaderName = "User-Agent";
    }
    return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];
  }
  __name(getUserAgentHeader, "getUserAgentHeader");
  function constructUserAgent(version, os, runtime, runtimeVersion) {
    let userAgent = "Microsoft SignalR/";
    const majorAndMinor = version.split(".");
    userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;
    userAgent += ` (${version}; `;
    if (os && os !== "") {
      userAgent += `${os}; `;
    } else {
      userAgent += "Unknown OS; ";
    }
    userAgent += `${runtime}`;
    if (runtimeVersion) {
      userAgent += `; ${runtimeVersion}`;
    } else {
      userAgent += "; Unknown Runtime Version";
    }
    userAgent += ")";
    return userAgent;
  }
  __name(constructUserAgent, "constructUserAgent");
  function getOsName() {
    if (Platform.isNode) {
      switch (process.platform) {
        case "win32":
          return "Windows NT";
        case "darwin":
          return "macOS";
        case "linux":
          return "Linux";
        default:
          return process.platform;
      }
    } else {
      return "";
    }
  }
  __name(getOsName, "getOsName");
  function getRuntimeVersion() {
    if (Platform.isNode) {
      return process.versions.node;
    }
    return void 0;
  }
  __name(getRuntimeVersion, "getRuntimeVersion");
  function getRuntime() {
    if (Platform.isNode) {
      return "NodeJS";
    } else {
      return "Browser";
    }
  }
  __name(getRuntime, "getRuntime");
  function getErrorString(e) {
    if (e.stack) {
      return e.stack;
    } else if (e.message) {
      return e.message;
    }
    return `${e}`;
  }
  __name(getErrorString, "getErrorString");
  function getGlobalThis() {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw new Error("could not find global");
  }
  __name(getGlobalThis, "getGlobalThis");
  const _FetchHttpClient = class _FetchHttpClient extends HttpClient {
    constructor(logger) {
      super();
      this._logger = logger;
      if (typeof fetch === "undefined" || Platform.isNode) {
        const requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
        this._jar = new (requireFunc("tough-cookie")).CookieJar();
        if (typeof fetch === "undefined") {
          this._fetchType = requireFunc("node-fetch");
        } else {
          this._fetchType = fetch;
        }
        this._fetchType = requireFunc("fetch-cookie")(this._fetchType, this._jar);
      } else {
        this._fetchType = fetch.bind(getGlobalThis());
      }
      if (typeof AbortController === "undefined") {
        const requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
        this._abortControllerType = requireFunc("abort-controller");
      } else {
        this._abortControllerType = AbortController;
      }
    }
    /** @inheritDoc */
    async send(request) {
      if (request.abortSignal && request.abortSignal.aborted) {
        throw new AbortError();
      }
      if (!request.method) {
        throw new Error("No method defined.");
      }
      if (!request.url) {
        throw new Error("No url defined.");
      }
      const abortController = new this._abortControllerType();
      let error;
      if (request.abortSignal) {
        request.abortSignal.onabort = () => {
          abortController.abort();
          error = new AbortError();
        };
      }
      let timeoutId = null;
      if (request.timeout) {
        const msTimeout = request.timeout;
        timeoutId = setTimeout(() => {
          abortController.abort();
          this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);
          error = new TimeoutError();
        }, msTimeout);
      }
      if (request.content === "") {
        request.content = void 0;
      }
      if (request.content) {
        request.headers = request.headers || {};
        if (isArrayBuffer(request.content)) {
          request.headers["Content-Type"] = "application/octet-stream";
        } else {
          request.headers["Content-Type"] = "text/plain;charset=UTF-8";
        }
      }
      let response;
      try {
        response = await this._fetchType(request.url, {
          body: request.content,
          cache: "no-cache",
          credentials: request.withCredentials === true ? "include" : "same-origin",
          headers: {
            "X-Requested-With": "XMLHttpRequest",
            ...request.headers
          },
          method: request.method,
          mode: "cors",
          redirect: "follow",
          signal: abortController.signal
        });
      } catch (e) {
        if (error) {
          throw error;
        }
        this._logger.log(LogLevel.Warning, `Error from HTTP request. ${e}.`);
        throw e;
      } finally {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (request.abortSignal) {
          request.abortSignal.onabort = null;
        }
      }
      if (!response.ok) {
        const errorMessage = await deserializeContent(response, "text");
        throw new HttpError(errorMessage || response.statusText, response.status);
      }
      const content2 = deserializeContent(response, request.responseType);
      const payload = await content2;
      return new HttpResponse(response.status, response.statusText, payload);
    }
    getCookieString(url) {
      let cookies = "";
      if (Platform.isNode && this._jar) {
        this._jar.getCookies(url, (e, c) => cookies = c.join("; "));
      }
      return cookies;
    }
  };
  __name(_FetchHttpClient, "FetchHttpClient");
  let FetchHttpClient = _FetchHttpClient;
  function deserializeContent(response, responseType) {
    let content2;
    switch (responseType) {
      case "arraybuffer":
        content2 = response.arrayBuffer();
        break;
      case "text":
        content2 = response.text();
        break;
      case "blob":
      case "document":
      case "json":
        throw new Error(`${responseType} is not supported.`);
      default:
        content2 = response.text();
        break;
    }
    return content2;
  }
  __name(deserializeContent, "deserializeContent");
  const _XhrHttpClient = class _XhrHttpClient extends HttpClient {
    constructor(logger) {
      super();
      this._logger = logger;
    }
    /** @inheritDoc */
    send(request) {
      if (request.abortSignal && request.abortSignal.aborted) {
        return Promise.reject(new AbortError());
      }
      if (!request.method) {
        return Promise.reject(new Error("No method defined."));
      }
      if (!request.url) {
        return Promise.reject(new Error("No url defined."));
      }
      return new Promise((resolve2, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open(request.method, request.url, true);
        xhr.withCredentials = request.withCredentials === void 0 ? true : request.withCredentials;
        xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
        if (request.content === "") {
          request.content = void 0;
        }
        if (request.content) {
          if (isArrayBuffer(request.content)) {
            xhr.setRequestHeader("Content-Type", "application/octet-stream");
          } else {
            xhr.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
          }
        }
        const headers = request.headers;
        if (headers) {
          Object.keys(headers).forEach((header) => {
            xhr.setRequestHeader(header, headers[header]);
          });
        }
        if (request.responseType) {
          xhr.responseType = request.responseType;
        }
        if (request.abortSignal) {
          request.abortSignal.onabort = () => {
            xhr.abort();
            reject(new AbortError());
          };
        }
        if (request.timeout) {
          xhr.timeout = request.timeout;
        }
        xhr.onload = () => {
          if (request.abortSignal) {
            request.abortSignal.onabort = null;
          }
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve2(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));
          } else {
            reject(new HttpError(xhr.response || xhr.responseText || xhr.statusText, xhr.status));
          }
        };
        xhr.onerror = () => {
          this._logger.log(LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);
          reject(new HttpError(xhr.statusText, xhr.status));
        };
        xhr.ontimeout = () => {
          this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);
          reject(new TimeoutError());
        };
        xhr.send(request.content);
      });
    }
  };
  __name(_XhrHttpClient, "XhrHttpClient");
  let XhrHttpClient = _XhrHttpClient;
  const _DefaultHttpClient = class _DefaultHttpClient extends HttpClient {
    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */
    constructor(logger) {
      super();
      if (typeof fetch !== "undefined" || Platform.isNode) {
        this._httpClient = new FetchHttpClient(logger);
      } else if (typeof XMLHttpRequest !== "undefined") {
        this._httpClient = new XhrHttpClient(logger);
      } else {
        throw new Error("No usable HttpClient found.");
      }
    }
    /** @inheritDoc */
    send(request) {
      if (request.abortSignal && request.abortSignal.aborted) {
        return Promise.reject(new AbortError());
      }
      if (!request.method) {
        return Promise.reject(new Error("No method defined."));
      }
      if (!request.url) {
        return Promise.reject(new Error("No url defined."));
      }
      return this._httpClient.send(request);
    }
    getCookieString(url) {
      return this._httpClient.getCookieString(url);
    }
  };
  __name(_DefaultHttpClient, "DefaultHttpClient");
  let DefaultHttpClient = _DefaultHttpClient;
  const _TextMessageFormat = class _TextMessageFormat {
    static write(output) {
      return `${output}${_TextMessageFormat.RecordSeparator}`;
    }
    static parse(input) {
      if (input[input.length - 1] !== _TextMessageFormat.RecordSeparator) {
        throw new Error("Message is incomplete.");
      }
      const messages = input.split(_TextMessageFormat.RecordSeparator);
      messages.pop();
      return messages;
    }
  };
  __name(_TextMessageFormat, "TextMessageFormat");
  let TextMessageFormat = _TextMessageFormat;
  TextMessageFormat.RecordSeparatorCode = 30;
  TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);
  const _HandshakeProtocol = class _HandshakeProtocol {
    // Handshake request is always JSON
    writeHandshakeRequest(handshakeRequest) {
      return TextMessageFormat.write(JSON.stringify(handshakeRequest));
    }
    parseHandshakeResponse(data) {
      let messageData;
      let remainingData;
      if (isArrayBuffer(data)) {
        const binaryData = new Uint8Array(data);
        const separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);
        if (separatorIndex === -1) {
          throw new Error("Message is incomplete.");
        }
        const responseLength = separatorIndex + 1;
        messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));
        remainingData = binaryData.byteLength > responseLength ? binaryData.slice(responseLength).buffer : null;
      } else {
        const textData = data;
        const separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);
        if (separatorIndex === -1) {
          throw new Error("Message is incomplete.");
        }
        const responseLength = separatorIndex + 1;
        messageData = textData.substring(0, responseLength);
        remainingData = textData.length > responseLength ? textData.substring(responseLength) : null;
      }
      const messages = TextMessageFormat.parse(messageData);
      const response = JSON.parse(messages[0]);
      if (response.type) {
        throw new Error("Expected a handshake response from the server.");
      }
      const responseMessage = response;
      return [remainingData, responseMessage];
    }
  };
  __name(_HandshakeProtocol, "HandshakeProtocol");
  let HandshakeProtocol = _HandshakeProtocol;
  var MessageType;
  (function(MessageType2) {
    MessageType2[MessageType2["Invocation"] = 1] = "Invocation";
    MessageType2[MessageType2["StreamItem"] = 2] = "StreamItem";
    MessageType2[MessageType2["Completion"] = 3] = "Completion";
    MessageType2[MessageType2["StreamInvocation"] = 4] = "StreamInvocation";
    MessageType2[MessageType2["CancelInvocation"] = 5] = "CancelInvocation";
    MessageType2[MessageType2["Ping"] = 6] = "Ping";
    MessageType2[MessageType2["Close"] = 7] = "Close";
    MessageType2[MessageType2["Ack"] = 8] = "Ack";
    MessageType2[MessageType2["Sequence"] = 9] = "Sequence";
  })(MessageType || (MessageType = {}));
  const _Subject = class _Subject {
    constructor() {
      this.observers = [];
    }
    next(item) {
      for (const observer of this.observers) {
        observer.next(item);
      }
    }
    error(err) {
      for (const observer of this.observers) {
        if (observer.error) {
          observer.error(err);
        }
      }
    }
    complete() {
      for (const observer of this.observers) {
        if (observer.complete) {
          observer.complete();
        }
      }
    }
    subscribe(observer) {
      this.observers.push(observer);
      return new SubjectSubscription(this, observer);
    }
  };
  __name(_Subject, "Subject");
  let Subject = _Subject;
  const _MessageBuffer = class _MessageBuffer {
    constructor(protocol2, connection, bufferSize) {
      this._bufferSize = 1e5;
      this._messages = [];
      this._totalMessageCount = 0;
      this._waitForSequenceMessage = false;
      this._nextReceivingSequenceId = 1;
      this._latestReceivedSequenceId = 0;
      this._bufferedByteCount = 0;
      this._reconnectInProgress = false;
      this._protocol = protocol2;
      this._connection = connection;
      this._bufferSize = bufferSize;
    }
    async _send(message) {
      const serializedMessage = this._protocol.writeMessage(message);
      let backpressurePromise = Promise.resolve();
      if (this._isInvocationMessage(message)) {
        this._totalMessageCount++;
        let backpressurePromiseResolver = /* @__PURE__ */ __name(() => {
        }, "backpressurePromiseResolver");
        let backpressurePromiseRejector = /* @__PURE__ */ __name(() => {
        }, "backpressurePromiseRejector");
        if (isArrayBuffer(serializedMessage)) {
          this._bufferedByteCount += serializedMessage.byteLength;
        } else {
          this._bufferedByteCount += serializedMessage.length;
        }
        if (this._bufferedByteCount >= this._bufferSize) {
          backpressurePromise = new Promise((resolve2, reject) => {
            backpressurePromiseResolver = resolve2;
            backpressurePromiseRejector = reject;
          });
        }
        this._messages.push(new BufferedItem(serializedMessage, this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));
      }
      try {
        if (!this._reconnectInProgress) {
          await this._connection.send(serializedMessage);
        }
      } catch {
        this._disconnected();
      }
      await backpressurePromise;
    }
    _ack(ackMessage) {
      let newestAckedMessage = -1;
      for (let index = 0; index < this._messages.length; index++) {
        const element2 = this._messages[index];
        if (element2._id <= ackMessage.sequenceId) {
          newestAckedMessage = index;
          if (isArrayBuffer(element2._message)) {
            this._bufferedByteCount -= element2._message.byteLength;
          } else {
            this._bufferedByteCount -= element2._message.length;
          }
          element2._resolver();
        } else if (this._bufferedByteCount < this._bufferSize) {
          element2._resolver();
        } else {
          break;
        }
      }
      if (newestAckedMessage !== -1) {
        this._messages = this._messages.slice(newestAckedMessage + 1);
      }
    }
    _shouldProcessMessage(message) {
      if (this._waitForSequenceMessage) {
        if (message.type !== MessageType.Sequence) {
          return false;
        } else {
          this._waitForSequenceMessage = false;
          return true;
        }
      }
      if (!this._isInvocationMessage(message)) {
        return true;
      }
      const currentId = this._nextReceivingSequenceId;
      this._nextReceivingSequenceId++;
      if (currentId <= this._latestReceivedSequenceId) {
        if (currentId === this._latestReceivedSequenceId) {
          this._ackTimer();
        }
        return false;
      }
      this._latestReceivedSequenceId = currentId;
      this._ackTimer();
      return true;
    }
    _resetSequence(message) {
      if (message.sequenceId > this._nextReceivingSequenceId) {
        this._connection.stop(new Error("Sequence ID greater than amount of messages we've received."));
        return;
      }
      this._nextReceivingSequenceId = message.sequenceId;
    }
    _disconnected() {
      this._reconnectInProgress = true;
      this._waitForSequenceMessage = true;
    }
    async _resend() {
      const sequenceId = this._messages.length !== 0 ? this._messages[0]._id : this._totalMessageCount + 1;
      await this._connection.send(this._protocol.writeMessage({ type: MessageType.Sequence, sequenceId }));
      const messages = this._messages;
      for (const element2 of messages) {
        await this._connection.send(element2._message);
      }
      this._reconnectInProgress = false;
    }
    _dispose(error) {
      error !== null && error !== void 0 ? error : error = new Error("Unable to reconnect to server.");
      for (const element2 of this._messages) {
        element2._rejector(error);
      }
    }
    _isInvocationMessage(message) {
      switch (message.type) {
        case MessageType.Invocation:
        case MessageType.StreamItem:
        case MessageType.Completion:
        case MessageType.StreamInvocation:
        case MessageType.CancelInvocation:
          return true;
        case MessageType.Close:
        case MessageType.Sequence:
        case MessageType.Ping:
        case MessageType.Ack:
          return false;
      }
    }
    _ackTimer() {
      if (this._ackTimerHandle === void 0) {
        this._ackTimerHandle = setTimeout(async () => {
          try {
            if (!this._reconnectInProgress) {
              await this._connection.send(this._protocol.writeMessage({ type: MessageType.Ack, sequenceId: this._latestReceivedSequenceId }));
            }
          } catch {
          }
          clearTimeout(this._ackTimerHandle);
          this._ackTimerHandle = void 0;
        }, 1e3);
      }
    }
  };
  __name(_MessageBuffer, "MessageBuffer");
  let MessageBuffer = _MessageBuffer;
  const _BufferedItem = class _BufferedItem {
    constructor(message, id2, resolver, rejector) {
      this._message = message;
      this._id = id2;
      this._resolver = resolver;
      this._rejector = rejector;
    }
  };
  __name(_BufferedItem, "BufferedItem");
  let BufferedItem = _BufferedItem;
  const DEFAULT_TIMEOUT_IN_MS = 30 * 1e3;
  const DEFAULT_PING_INTERVAL_IN_MS = 15 * 1e3;
  const DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE = 1e5;
  var HubConnectionState;
  (function(HubConnectionState2) {
    HubConnectionState2["Disconnected"] = "Disconnected";
    HubConnectionState2["Connecting"] = "Connecting";
    HubConnectionState2["Connected"] = "Connected";
    HubConnectionState2["Disconnecting"] = "Disconnecting";
    HubConnectionState2["Reconnecting"] = "Reconnecting";
  })(HubConnectionState || (HubConnectionState = {}));
  const _HubConnection = class _HubConnection {
    /** @internal */
    // Using a public static factory method means we can have a private constructor and an _internal_
    // create method that can be used by HubConnectionBuilder. An "internal" constructor would just
    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a
    // public parameter-less constructor.
    static create(connection, logger, protocol2, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize) {
      return new _HubConnection(connection, logger, protocol2, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize);
    }
    constructor(connection, logger, protocol2, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize) {
      this._nextKeepAlive = 0;
      this._freezeEventListener = () => {
        this._logger.log(LogLevel.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep");
      };
      Arg.isRequired(connection, "connection");
      Arg.isRequired(logger, "logger");
      Arg.isRequired(protocol2, "protocol");
      this.serverTimeoutInMilliseconds = serverTimeoutInMilliseconds !== null && serverTimeoutInMilliseconds !== void 0 ? serverTimeoutInMilliseconds : DEFAULT_TIMEOUT_IN_MS;
      this.keepAliveIntervalInMilliseconds = keepAliveIntervalInMilliseconds !== null && keepAliveIntervalInMilliseconds !== void 0 ? keepAliveIntervalInMilliseconds : DEFAULT_PING_INTERVAL_IN_MS;
      this._statefulReconnectBufferSize = statefulReconnectBufferSize !== null && statefulReconnectBufferSize !== void 0 ? statefulReconnectBufferSize : DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE;
      this._logger = logger;
      this._protocol = protocol2;
      this.connection = connection;
      this._reconnectPolicy = reconnectPolicy;
      this._handshakeProtocol = new HandshakeProtocol();
      this.connection.onreceive = (data) => this._processIncomingData(data);
      this.connection.onclose = (error) => this._connectionClosed(error);
      this._callbacks = {};
      this._methods = {};
      this._closedCallbacks = [];
      this._reconnectingCallbacks = [];
      this._reconnectedCallbacks = [];
      this._invocationId = 0;
      this._receivedHandshakeResponse = false;
      this._connectionState = HubConnectionState.Disconnected;
      this._connectionStarted = false;
      this._cachedPingMessage = this._protocol.writeMessage({ type: MessageType.Ping });
    }
    /** Indicates the state of the {@link HubConnection} to the server. */
    get state() {
      return this._connectionState;
    }
    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either
     *  in the disconnected state or if the negotiation step was skipped.
     */
    get connectionId() {
      return this.connection ? this.connection.connectionId || null : null;
    }
    /** Indicates the url of the {@link HubConnection} to the server. */
    get baseUrl() {
      return this.connection.baseUrl || "";
    }
    /**
     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or
     * Reconnecting states.
     * @param {string} url The url to connect to.
     */
    set baseUrl(url) {
      if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {
        throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
      }
      if (!url) {
        throw new Error("The HubConnection url must be a valid url.");
      }
      this.connection.baseUrl = url;
    }
    /** Starts the connection.
     *
     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.
     */
    start() {
      this._startPromise = this._startWithStateTransitions();
      return this._startPromise;
    }
    async _startWithStateTransitions() {
      if (this._connectionState !== HubConnectionState.Disconnected) {
        return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
      }
      this._connectionState = HubConnectionState.Connecting;
      this._logger.log(LogLevel.Debug, "Starting HubConnection.");
      try {
        await this._startInternal();
        if (Platform.isBrowser) {
          window.document.addEventListener("freeze", this._freezeEventListener);
        }
        this._connectionState = HubConnectionState.Connected;
        this._connectionStarted = true;
        this._logger.log(LogLevel.Debug, "HubConnection connected successfully.");
      } catch (e) {
        this._connectionState = HubConnectionState.Disconnected;
        this._logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);
        return Promise.reject(e);
      }
    }
    async _startInternal() {
      this._stopDuringStartError = void 0;
      this._receivedHandshakeResponse = false;
      const handshakePromise = new Promise((resolve2, reject) => {
        this._handshakeResolver = resolve2;
        this._handshakeRejecter = reject;
      });
      await this.connection.start(this._protocol.transferFormat);
      try {
        let version = this._protocol.version;
        if (!this.connection.features.reconnect) {
          version = 1;
        }
        const handshakeRequest = {
          protocol: this._protocol.name,
          version
        };
        this._logger.log(LogLevel.Debug, "Sending handshake request.");
        await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));
        this._logger.log(LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`);
        this._cleanupTimeout();
        this._resetTimeoutPeriod();
        this._resetKeepAliveInterval();
        await handshakePromise;
        if (this._stopDuringStartError) {
          throw this._stopDuringStartError;
        }
        const useStatefulReconnect = this.connection.features.reconnect || false;
        if (useStatefulReconnect) {
          this._messageBuffer = new MessageBuffer(this._protocol, this.connection, this._statefulReconnectBufferSize);
          this.connection.features.disconnected = this._messageBuffer._disconnected.bind(this._messageBuffer);
          this.connection.features.resend = () => {
            if (this._messageBuffer) {
              return this._messageBuffer._resend();
            }
          };
        }
        if (!this.connection.features.inherentKeepAlive) {
          await this._sendMessage(this._cachedPingMessage);
        }
      } catch (e) {
        this._logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);
        this._cleanupTimeout();
        this._cleanupPingTimer();
        await this.connection.stop(e);
        throw e;
      }
    }
    /** Stops the connection.
     *
     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.
     */
    async stop() {
      const startPromise = this._startPromise;
      this.connection.features.reconnect = false;
      this._stopPromise = this._stopInternal();
      await this._stopPromise;
      try {
        await startPromise;
      } catch (e) {
      }
    }
    _stopInternal(error) {
      if (this._connectionState === HubConnectionState.Disconnected) {
        this._logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);
        return Promise.resolve();
      }
      if (this._connectionState === HubConnectionState.Disconnecting) {
        this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);
        return this._stopPromise;
      }
      const state = this._connectionState;
      this._connectionState = HubConnectionState.Disconnecting;
      this._logger.log(LogLevel.Debug, "Stopping HubConnection.");
      if (this._reconnectDelayHandle) {
        this._logger.log(LogLevel.Debug, "Connection stopped during reconnect delay. Done reconnecting.");
        clearTimeout(this._reconnectDelayHandle);
        this._reconnectDelayHandle = void 0;
        this._completeClose();
        return Promise.resolve();
      }
      if (state === HubConnectionState.Connected) {
        this._sendCloseMessage();
      }
      this._cleanupTimeout();
      this._cleanupPingTimer();
      this._stopDuringStartError = error || new AbortError("The connection was stopped before the hub handshake could complete.");
      return this.connection.stop(error);
    }
    async _sendCloseMessage() {
      try {
        await this._sendWithProtocol(this._createCloseMessage());
      } catch {
      }
    }
    /** Invokes a streaming hub method on the server using the specified name and arguments.
     *
     * @typeparam T The type of the items returned by the server.
     * @param {string} methodName The name of the server method to invoke.
     * @param {any[]} args The arguments used to invoke the server method.
     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.
     */
    stream(methodName, ...args) {
      const [streams, streamIds] = this._replaceStreamingParams(args);
      const invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);
      let promiseQueue;
      const subject = new Subject();
      subject.cancelCallback = () => {
        const cancelInvocation = this._createCancelInvocation(invocationDescriptor.invocationId);
        delete this._callbacks[invocationDescriptor.invocationId];
        return promiseQueue.then(() => {
          return this._sendWithProtocol(cancelInvocation);
        });
      };
      this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {
        if (error) {
          subject.error(error);
          return;
        } else if (invocationEvent) {
          if (invocationEvent.type === MessageType.Completion) {
            if (invocationEvent.error) {
              subject.error(new Error(invocationEvent.error));
            } else {
              subject.complete();
            }
          } else {
            subject.next(invocationEvent.item);
          }
        }
      };
      promiseQueue = this._sendWithProtocol(invocationDescriptor).catch((e) => {
        subject.error(e);
        delete this._callbacks[invocationDescriptor.invocationId];
      });
      this._launchStreams(streams, promiseQueue);
      return subject;
    }
    _sendMessage(message) {
      this._resetKeepAliveInterval();
      return this.connection.send(message);
    }
    /**
     * Sends a js object to the server.
     * @param message The js object to serialize and send.
     */
    _sendWithProtocol(message) {
      if (this._messageBuffer) {
        return this._messageBuffer._send(message);
      } else {
        return this._sendMessage(this._protocol.writeMessage(message));
      }
    }
    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.
     *
     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still
     * be processing the invocation.
     *
     * @param {string} methodName The name of the server method to invoke.
     * @param {any[]} args The arguments used to invoke the server method.
     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.
     */
    send(methodName, ...args) {
      const [streams, streamIds] = this._replaceStreamingParams(args);
      const sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));
      this._launchStreams(streams, sendPromise);
      return sendPromise;
    }
    /** Invokes a hub method on the server using the specified name and arguments.
     *
     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise
     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of
     * resolving the Promise.
     *
     * @typeparam T The expected return type.
     * @param {string} methodName The name of the server method to invoke.
     * @param {any[]} args The arguments used to invoke the server method.
     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.
     */
    invoke(methodName, ...args) {
      const [streams, streamIds] = this._replaceStreamingParams(args);
      const invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);
      const p = new Promise((resolve2, reject) => {
        this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {
          if (error) {
            reject(error);
            return;
          } else if (invocationEvent) {
            if (invocationEvent.type === MessageType.Completion) {
              if (invocationEvent.error) {
                reject(new Error(invocationEvent.error));
              } else {
                resolve2(invocationEvent.result);
              }
            } else {
              reject(new Error(`Unexpected message type: ${invocationEvent.type}`));
            }
          }
        };
        const promiseQueue = this._sendWithProtocol(invocationDescriptor).catch((e) => {
          reject(e);
          delete this._callbacks[invocationDescriptor.invocationId];
        });
        this._launchStreams(streams, promiseQueue);
      });
      return p;
    }
    on(methodName, newMethod) {
      if (!methodName || !newMethod) {
        return;
      }
      methodName = methodName.toLowerCase();
      if (!this._methods[methodName]) {
        this._methods[methodName] = [];
      }
      if (this._methods[methodName].indexOf(newMethod) !== -1) {
        return;
      }
      this._methods[methodName].push(newMethod);
    }
    off(methodName, method) {
      if (!methodName) {
        return;
      }
      methodName = methodName.toLowerCase();
      const handlers = this._methods[methodName];
      if (!handlers) {
        return;
      }
      if (method) {
        const removeIdx = handlers.indexOf(method);
        if (removeIdx !== -1) {
          handlers.splice(removeIdx, 1);
          if (handlers.length === 0) {
            delete this._methods[methodName];
          }
        }
      } else {
        delete this._methods[methodName];
      }
    }
    /** Registers a handler that will be invoked when the connection is closed.
     *
     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).
     */
    onclose(callback) {
      if (callback) {
        this._closedCallbacks.push(callback);
      }
    }
    /** Registers a handler that will be invoked when the connection starts reconnecting.
     *
     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).
     */
    onreconnecting(callback) {
      if (callback) {
        this._reconnectingCallbacks.push(callback);
      }
    }
    /** Registers a handler that will be invoked when the connection successfully reconnects.
     *
     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.
     */
    onreconnected(callback) {
      if (callback) {
        this._reconnectedCallbacks.push(callback);
      }
    }
    _processIncomingData(data) {
      this._cleanupTimeout();
      if (!this._receivedHandshakeResponse) {
        data = this._processHandshakeResponse(data);
        this._receivedHandshakeResponse = true;
      }
      if (data) {
        const messages = this._protocol.parseMessages(data, this._logger);
        for (const message of messages) {
          if (this._messageBuffer && !this._messageBuffer._shouldProcessMessage(message)) {
            continue;
          }
          switch (message.type) {
            case MessageType.Invocation:
              this._invokeClientMethod(message).catch((e) => {
                this._logger.log(LogLevel.Error, `Invoke client method threw error: ${getErrorString(e)}`);
              });
              break;
            case MessageType.StreamItem:
            case MessageType.Completion: {
              const callback = this._callbacks[message.invocationId];
              if (callback) {
                if (message.type === MessageType.Completion) {
                  delete this._callbacks[message.invocationId];
                }
                try {
                  callback(message);
                } catch (e) {
                  this._logger.log(LogLevel.Error, `Stream callback threw error: ${getErrorString(e)}`);
                }
              }
              break;
            }
            case MessageType.Ping:
              break;
            case MessageType.Close: {
              this._logger.log(LogLevel.Information, "Close message received from server.");
              const error = message.error ? new Error("Server returned an error on close: " + message.error) : void 0;
              if (message.allowReconnect === true) {
                this.connection.stop(error);
              } else {
                this._stopPromise = this._stopInternal(error);
              }
              break;
            }
            case MessageType.Ack:
              if (this._messageBuffer) {
                this._messageBuffer._ack(message);
              }
              break;
            case MessageType.Sequence:
              if (this._messageBuffer) {
                this._messageBuffer._resetSequence(message);
              }
              break;
            default:
              this._logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);
              break;
          }
        }
      }
      this._resetTimeoutPeriod();
    }
    _processHandshakeResponse(data) {
      let responseMessage;
      let remainingData;
      try {
        [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);
      } catch (e) {
        const message = "Error parsing handshake response: " + e;
        this._logger.log(LogLevel.Error, message);
        const error = new Error(message);
        this._handshakeRejecter(error);
        throw error;
      }
      if (responseMessage.error) {
        const message = "Server returned handshake error: " + responseMessage.error;
        this._logger.log(LogLevel.Error, message);
        const error = new Error(message);
        this._handshakeRejecter(error);
        throw error;
      } else {
        this._logger.log(LogLevel.Debug, "Server handshake complete.");
      }
      this._handshakeResolver();
      return remainingData;
    }
    _resetKeepAliveInterval() {
      if (this.connection.features.inherentKeepAlive) {
        return;
      }
      this._nextKeepAlive = (/* @__PURE__ */ new Date()).getTime() + this.keepAliveIntervalInMilliseconds;
      this._cleanupPingTimer();
    }
    _resetTimeoutPeriod() {
      if (!this.connection.features || !this.connection.features.inherentKeepAlive) {
        this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);
        if (this._pingServerHandle === void 0) {
          let nextPing = this._nextKeepAlive - (/* @__PURE__ */ new Date()).getTime();
          if (nextPing < 0) {
            nextPing = 0;
          }
          this._pingServerHandle = setTimeout(async () => {
            if (this._connectionState === HubConnectionState.Connected) {
              try {
                await this._sendMessage(this._cachedPingMessage);
              } catch {
                this._cleanupPingTimer();
              }
            }
          }, nextPing);
        }
      }
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    serverTimeout() {
      this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
    }
    async _invokeClientMethod(invocationMessage) {
      const methodName = invocationMessage.target.toLowerCase();
      const methods = this._methods[methodName];
      if (!methods) {
        this._logger.log(LogLevel.Warning, `No client method with the name '${methodName}' found.`);
        if (invocationMessage.invocationId) {
          this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);
          await this._sendWithProtocol(this._createCompletionMessage(invocationMessage.invocationId, "Client didn't provide a result.", null));
        }
        return;
      }
      const methodsCopy = methods.slice();
      const expectsResponse = invocationMessage.invocationId ? true : false;
      let res;
      let exception;
      let completionMessage;
      for (const m of methodsCopy) {
        try {
          const prevRes = res;
          res = await m.apply(this, invocationMessage.arguments);
          if (expectsResponse && res && prevRes) {
            this._logger.log(LogLevel.Error, `Multiple results provided for '${methodName}'. Sending error to server.`);
            completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `Client provided multiple results.`, null);
          }
          exception = void 0;
        } catch (e) {
          exception = e;
          this._logger.log(LogLevel.Error, `A callback for the method '${methodName}' threw error '${e}'.`);
        }
      }
      if (completionMessage) {
        await this._sendWithProtocol(completionMessage);
      } else if (expectsResponse) {
        if (exception) {
          completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `${exception}`, null);
        } else if (res !== void 0) {
          completionMessage = this._createCompletionMessage(invocationMessage.invocationId, null, res);
        } else {
          this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);
          completionMessage = this._createCompletionMessage(invocationMessage.invocationId, "Client didn't provide a result.", null);
        }
        await this._sendWithProtocol(completionMessage);
      } else {
        if (res) {
          this._logger.log(LogLevel.Error, `Result given for '${methodName}' method but server is not expecting a result.`);
        }
      }
    }
    _connectionClosed(error) {
      this._logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`);
      this._stopDuringStartError = this._stopDuringStartError || error || new AbortError("The underlying connection was closed before the hub handshake could complete.");
      if (this._handshakeResolver) {
        this._handshakeResolver();
      }
      this._cancelCallbacksWithError(error || new Error("Invocation canceled due to the underlying connection being closed."));
      this._cleanupTimeout();
      this._cleanupPingTimer();
      if (this._connectionState === HubConnectionState.Disconnecting) {
        this._completeClose(error);
      } else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {
        this._reconnect(error);
      } else if (this._connectionState === HubConnectionState.Connected) {
        this._completeClose(error);
      }
    }
    _completeClose(error) {
      if (this._connectionStarted) {
        this._connectionState = HubConnectionState.Disconnected;
        this._connectionStarted = false;
        if (this._messageBuffer) {
          this._messageBuffer._dispose(error !== null && error !== void 0 ? error : new Error("Connection closed."));
          this._messageBuffer = void 0;
        }
        if (Platform.isBrowser) {
          window.document.removeEventListener("freeze", this._freezeEventListener);
        }
        try {
          this._closedCallbacks.forEach((c) => c.apply(this, [error]));
        } catch (e) {
          this._logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);
        }
      }
    }
    async _reconnect(error) {
      const reconnectStartTime = Date.now();
      let previousReconnectAttempts = 0;
      let retryError = error !== void 0 ? error : new Error("Attempting to reconnect due to a unknown error.");
      let nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);
      if (nextRetryDelay === null) {
        this._logger.log(LogLevel.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.");
        this._completeClose(error);
        return;
      }
      this._connectionState = HubConnectionState.Reconnecting;
      if (error) {
        this._logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);
      } else {
        this._logger.log(LogLevel.Information, "Connection reconnecting.");
      }
      if (this._reconnectingCallbacks.length !== 0) {
        try {
          this._reconnectingCallbacks.forEach((c) => c.apply(this, [error]));
        } catch (e) {
          this._logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);
        }
        if (this._connectionState !== HubConnectionState.Reconnecting) {
          this._logger.log(LogLevel.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
          return;
        }
      }
      while (nextRetryDelay !== null) {
        this._logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);
        await new Promise((resolve2) => {
          this._reconnectDelayHandle = setTimeout(resolve2, nextRetryDelay);
        });
        this._reconnectDelayHandle = void 0;
        if (this._connectionState !== HubConnectionState.Reconnecting) {
          this._logger.log(LogLevel.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
          return;
        }
        try {
          await this._startInternal();
          this._connectionState = HubConnectionState.Connected;
          this._logger.log(LogLevel.Information, "HubConnection reconnected successfully.");
          if (this._reconnectedCallbacks.length !== 0) {
            try {
              this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));
            } catch (e) {
              this._logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);
            }
          }
          return;
        } catch (e) {
          this._logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);
          if (this._connectionState !== HubConnectionState.Reconnecting) {
            this._logger.log(LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);
            if (this._connectionState === HubConnectionState.Disconnecting) {
              this._completeClose();
            }
            return;
          }
          retryError = e instanceof Error ? e : new Error(e.toString());
          nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);
        }
      }
      this._logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);
      this._completeClose();
    }
    _getNextRetryDelay(previousRetryCount, elapsedMilliseconds, retryReason) {
      try {
        return this._reconnectPolicy.nextRetryDelayInMilliseconds({
          elapsedMilliseconds,
          previousRetryCount,
          retryReason
        });
      } catch (e) {
        this._logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);
        return null;
      }
    }
    _cancelCallbacksWithError(error) {
      const callbacks = this._callbacks;
      this._callbacks = {};
      Object.keys(callbacks).forEach((key2) => {
        const callback = callbacks[key2];
        try {
          callback(null, error);
        } catch (e) {
          this._logger.log(LogLevel.Error, `Stream 'error' callback called with '${error}' threw error: ${getErrorString(e)}`);
        }
      });
    }
    _cleanupPingTimer() {
      if (this._pingServerHandle) {
        clearTimeout(this._pingServerHandle);
        this._pingServerHandle = void 0;
      }
    }
    _cleanupTimeout() {
      if (this._timeoutHandle) {
        clearTimeout(this._timeoutHandle);
      }
    }
    _createInvocation(methodName, args, nonblocking, streamIds) {
      if (nonblocking) {
        if (streamIds.length !== 0) {
          return {
            arguments: args,
            streamIds,
            target: methodName,
            type: MessageType.Invocation
          };
        } else {
          return {
            arguments: args,
            target: methodName,
            type: MessageType.Invocation
          };
        }
      } else {
        const invocationId = this._invocationId;
        this._invocationId++;
        if (streamIds.length !== 0) {
          return {
            arguments: args,
            invocationId: invocationId.toString(),
            streamIds,
            target: methodName,
            type: MessageType.Invocation
          };
        } else {
          return {
            arguments: args,
            invocationId: invocationId.toString(),
            target: methodName,
            type: MessageType.Invocation
          };
        }
      }
    }
    _launchStreams(streams, promiseQueue) {
      if (streams.length === 0) {
        return;
      }
      if (!promiseQueue) {
        promiseQueue = Promise.resolve();
      }
      for (const streamId in streams) {
        streams[streamId].subscribe({
          complete: /* @__PURE__ */ __name(() => {
            promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId)));
          }, "complete"),
          error: /* @__PURE__ */ __name((err) => {
            let message;
            if (err instanceof Error) {
              message = err.message;
            } else if (err && err.toString) {
              message = err.toString();
            } else {
              message = "Unknown error";
            }
            promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId, message)));
          }, "error"),
          next: /* @__PURE__ */ __name((item) => {
            promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createStreamItemMessage(streamId, item)));
          }, "next")
        });
      }
    }
    _replaceStreamingParams(args) {
      const streams = [];
      const streamIds = [];
      for (let i = 0; i < args.length; i++) {
        const argument = args[i];
        if (this._isObservable(argument)) {
          const streamId = this._invocationId;
          this._invocationId++;
          streams[streamId] = argument;
          streamIds.push(streamId.toString());
          args.splice(i, 1);
        }
      }
      return [streams, streamIds];
    }
    _isObservable(arg) {
      return arg && arg.subscribe && typeof arg.subscribe === "function";
    }
    _createStreamInvocation(methodName, args, streamIds) {
      const invocationId = this._invocationId;
      this._invocationId++;
      if (streamIds.length !== 0) {
        return {
          arguments: args,
          invocationId: invocationId.toString(),
          streamIds,
          target: methodName,
          type: MessageType.StreamInvocation
        };
      } else {
        return {
          arguments: args,
          invocationId: invocationId.toString(),
          target: methodName,
          type: MessageType.StreamInvocation
        };
      }
    }
    _createCancelInvocation(id2) {
      return {
        invocationId: id2,
        type: MessageType.CancelInvocation
      };
    }
    _createStreamItemMessage(id2, item) {
      return {
        invocationId: id2,
        item,
        type: MessageType.StreamItem
      };
    }
    _createCompletionMessage(id2, error, result) {
      if (error) {
        return {
          error,
          invocationId: id2,
          type: MessageType.Completion
        };
      }
      return {
        invocationId: id2,
        result,
        type: MessageType.Completion
      };
    }
    _createCloseMessage() {
      return { type: MessageType.Close };
    }
  };
  __name(_HubConnection, "HubConnection");
  let HubConnection = _HubConnection;
  const DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2e3, 1e4, 3e4, null];
  const _DefaultReconnectPolicy = class _DefaultReconnectPolicy {
    constructor(retryDelays) {
      this._retryDelays = retryDelays !== void 0 ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;
    }
    nextRetryDelayInMilliseconds(retryContext) {
      return this._retryDelays[retryContext.previousRetryCount];
    }
  };
  __name(_DefaultReconnectPolicy, "DefaultReconnectPolicy");
  let DefaultReconnectPolicy = _DefaultReconnectPolicy;
  const _HeaderNames = class _HeaderNames {
  };
  __name(_HeaderNames, "HeaderNames");
  let HeaderNames = _HeaderNames;
  HeaderNames.Authorization = "Authorization";
  HeaderNames.Cookie = "Cookie";
  const _AccessTokenHttpClient = class _AccessTokenHttpClient extends HttpClient {
    constructor(innerClient, accessTokenFactory) {
      super();
      this._innerClient = innerClient;
      this._accessTokenFactory = accessTokenFactory;
    }
    async send(request) {
      let allowRetry = true;
      if (this._accessTokenFactory && (!this._accessToken || request.url && request.url.indexOf("/negotiate?") > 0)) {
        allowRetry = false;
        this._accessToken = await this._accessTokenFactory();
      }
      this._setAuthorizationHeader(request);
      const response = await this._innerClient.send(request);
      if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {
        this._accessToken = await this._accessTokenFactory();
        this._setAuthorizationHeader(request);
        return await this._innerClient.send(request);
      }
      return response;
    }
    _setAuthorizationHeader(request) {
      if (!request.headers) {
        request.headers = {};
      }
      if (this._accessToken) {
        request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`;
      } else if (this._accessTokenFactory) {
        if (request.headers[HeaderNames.Authorization]) {
          delete request.headers[HeaderNames.Authorization];
        }
      }
    }
    getCookieString(url) {
      return this._innerClient.getCookieString(url);
    }
  };
  __name(_AccessTokenHttpClient, "AccessTokenHttpClient");
  let AccessTokenHttpClient = _AccessTokenHttpClient;
  var HttpTransportType;
  (function(HttpTransportType2) {
    HttpTransportType2[HttpTransportType2["None"] = 0] = "None";
    HttpTransportType2[HttpTransportType2["WebSockets"] = 1] = "WebSockets";
    HttpTransportType2[HttpTransportType2["ServerSentEvents"] = 2] = "ServerSentEvents";
    HttpTransportType2[HttpTransportType2["LongPolling"] = 4] = "LongPolling";
  })(HttpTransportType || (HttpTransportType = {}));
  var TransferFormat;
  (function(TransferFormat2) {
    TransferFormat2[TransferFormat2["Text"] = 1] = "Text";
    TransferFormat2[TransferFormat2["Binary"] = 2] = "Binary";
  })(TransferFormat || (TransferFormat = {}));
  let AbortController$1 = (_za = class {
    constructor() {
      this._isAborted = false;
      this.onabort = null;
    }
    abort() {
      if (!this._isAborted) {
        this._isAborted = true;
        if (this.onabort) {
          this.onabort();
        }
      }
    }
    get signal() {
      return this;
    }
    get aborted() {
      return this._isAborted;
    }
  }, __name(_za, "AbortController"), _za);
  const _LongPollingTransport = class _LongPollingTransport {
    // This is an internal type, not exported from 'index' so this is really just internal.
    get pollAborted() {
      return this._pollAbort.aborted;
    }
    constructor(httpClient, logger, options) {
      this._httpClient = httpClient;
      this._logger = logger;
      this._pollAbort = new AbortController$1();
      this._options = options;
      this._running = false;
      this.onreceive = null;
      this.onclose = null;
    }
    async connect(url, transferFormat) {
      Arg.isRequired(url, "url");
      Arg.isRequired(transferFormat, "transferFormat");
      Arg.isIn(transferFormat, TransferFormat, "transferFormat");
      this._url = url;
      this._logger.log(LogLevel.Trace, "(LongPolling transport) Connecting.");
      if (transferFormat === TransferFormat.Binary && (typeof XMLHttpRequest !== "undefined" && typeof new XMLHttpRequest().responseType !== "string")) {
        throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
      }
      const [name, value] = getUserAgentHeader();
      const headers = { [name]: value, ...this._options.headers };
      const pollOptions = {
        abortSignal: this._pollAbort.signal,
        headers,
        timeout: 1e5,
        withCredentials: this._options.withCredentials
      };
      if (transferFormat === TransferFormat.Binary) {
        pollOptions.responseType = "arraybuffer";
      }
      const pollUrl = `${url}&_=${Date.now()}`;
      this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);
      const response = await this._httpClient.get(pollUrl, pollOptions);
      if (response.statusCode !== 200) {
        this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);
        this._closeError = new HttpError(response.statusText || "", response.statusCode);
        this._running = false;
      } else {
        this._running = true;
      }
      this._receiving = this._poll(this._url, pollOptions);
    }
    async _poll(url, pollOptions) {
      try {
        while (this._running) {
          try {
            const pollUrl = `${url}&_=${Date.now()}`;
            this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);
            const response = await this._httpClient.get(pollUrl, pollOptions);
            if (response.statusCode === 204) {
              this._logger.log(LogLevel.Information, "(LongPolling transport) Poll terminated by server.");
              this._running = false;
            } else if (response.statusCode !== 200) {
              this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);
              this._closeError = new HttpError(response.statusText || "", response.statusCode);
              this._running = false;
            } else {
              if (response.content) {
                this._logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this._options.logMessageContent)}.`);
                if (this.onreceive) {
                  this.onreceive(response.content);
                }
              } else {
                this._logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
              }
            }
          } catch (e) {
            if (!this._running) {
              this._logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);
            } else {
              if (e instanceof TimeoutError) {
                this._logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
              } else {
                this._closeError = e;
                this._running = false;
              }
            }
          }
        }
      } finally {
        this._logger.log(LogLevel.Trace, "(LongPolling transport) Polling complete.");
        if (!this.pollAborted) {
          this._raiseOnClose();
        }
      }
    }
    async send(data) {
      if (!this._running) {
        return Promise.reject(new Error("Cannot send until the transport is connected"));
      }
      return sendMessage(this._logger, "LongPolling", this._httpClient, this._url, data, this._options);
    }
    async stop() {
      this._logger.log(LogLevel.Trace, "(LongPolling transport) Stopping polling.");
      this._running = false;
      this._pollAbort.abort();
      try {
        await this._receiving;
        this._logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);
        const headers = {};
        const [name, value] = getUserAgentHeader();
        headers[name] = value;
        const deleteOptions = {
          headers: { ...headers, ...this._options.headers },
          timeout: this._options.timeout,
          withCredentials: this._options.withCredentials
        };
        let error;
        try {
          await this._httpClient.delete(this._url, deleteOptions);
        } catch (err) {
          error = err;
        }
        if (error) {
          if (error instanceof HttpError) {
            if (error.statusCode === 404) {
              this._logger.log(LogLevel.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.");
            } else {
              this._logger.log(LogLevel.Trace, `(LongPolling transport) Error sending a DELETE request: ${error}`);
            }
          }
        } else {
          this._logger.log(LogLevel.Trace, "(LongPolling transport) DELETE request accepted.");
        }
      } finally {
        this._logger.log(LogLevel.Trace, "(LongPolling transport) Stop finished.");
        this._raiseOnClose();
      }
    }
    _raiseOnClose() {
      if (this.onclose) {
        let logMessage = "(LongPolling transport) Firing onclose event.";
        if (this._closeError) {
          logMessage += " Error: " + this._closeError;
        }
        this._logger.log(LogLevel.Trace, logMessage);
        this.onclose(this._closeError);
      }
    }
  };
  __name(_LongPollingTransport, "LongPollingTransport");
  let LongPollingTransport = _LongPollingTransport;
  const _ServerSentEventsTransport = class _ServerSentEventsTransport {
    constructor(httpClient, accessToken, logger, options) {
      this._httpClient = httpClient;
      this._accessToken = accessToken;
      this._logger = logger;
      this._options = options;
      this.onreceive = null;
      this.onclose = null;
    }
    async connect(url, transferFormat) {
      Arg.isRequired(url, "url");
      Arg.isRequired(transferFormat, "transferFormat");
      Arg.isIn(transferFormat, TransferFormat, "transferFormat");
      this._logger.log(LogLevel.Trace, "(SSE transport) Connecting.");
      this._url = url;
      if (this._accessToken) {
        url += (url.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this._accessToken)}`;
      }
      return new Promise((resolve2, reject) => {
        let opened = false;
        if (transferFormat !== TransferFormat.Text) {
          reject(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
          return;
        }
        let eventSource;
        if (Platform.isBrowser || Platform.isWebWorker) {
          eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials });
        } else {
          const cookies = this._httpClient.getCookieString(url);
          const headers = {};
          headers.Cookie = cookies;
          const [name, value] = getUserAgentHeader();
          headers[name] = value;
          eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers } });
        }
        try {
          eventSource.onmessage = (e) => {
            if (this.onreceive) {
              try {
                this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`);
                this.onreceive(e.data);
              } catch (error) {
                this._close(error);
                return;
              }
            }
          };
          eventSource.onerror = (e) => {
            if (opened) {
              this._close();
            } else {
              reject(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."));
            }
          };
          eventSource.onopen = () => {
            this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);
            this._eventSource = eventSource;
            opened = true;
            resolve2();
          };
        } catch (e) {
          reject(e);
          return;
        }
      });
    }
    async send(data) {
      if (!this._eventSource) {
        return Promise.reject(new Error("Cannot send until the transport is connected"));
      }
      return sendMessage(this._logger, "SSE", this._httpClient, this._url, data, this._options);
    }
    stop() {
      this._close();
      return Promise.resolve();
    }
    _close(e) {
      if (this._eventSource) {
        this._eventSource.close();
        this._eventSource = void 0;
        if (this.onclose) {
          this.onclose(e);
        }
      }
    }
  };
  __name(_ServerSentEventsTransport, "ServerSentEventsTransport");
  let ServerSentEventsTransport = _ServerSentEventsTransport;
  const _WebSocketTransport = class _WebSocketTransport {
    constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {
      this._logger = logger;
      this._accessTokenFactory = accessTokenFactory;
      this._logMessageContent = logMessageContent;
      this._webSocketConstructor = webSocketConstructor;
      this._httpClient = httpClient;
      this.onreceive = null;
      this.onclose = null;
      this._headers = headers;
    }
    async connect(url, transferFormat) {
      Arg.isRequired(url, "url");
      Arg.isRequired(transferFormat, "transferFormat");
      Arg.isIn(transferFormat, TransferFormat, "transferFormat");
      this._logger.log(LogLevel.Trace, "(WebSockets transport) Connecting.");
      let token;
      if (this._accessTokenFactory) {
        token = await this._accessTokenFactory();
      }
      return new Promise((resolve2, reject) => {
        url = url.replace(/^http/, "ws");
        let webSocket;
        const cookies = this._httpClient.getCookieString(url);
        let opened = false;
        if (Platform.isNode || Platform.isReactNative) {
          const headers = {};
          const [name, value] = getUserAgentHeader();
          headers[name] = value;
          if (token) {
            headers[HeaderNames.Authorization] = `Bearer ${token}`;
          }
          if (cookies) {
            headers[HeaderNames.Cookie] = cookies;
          }
          webSocket = new this._webSocketConstructor(url, void 0, {
            headers: { ...headers, ...this._headers }
          });
        } else {
          if (token) {
            url += (url.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(token)}`;
          }
        }
        if (!webSocket) {
          webSocket = new this._webSocketConstructor(url);
        }
        if (transferFormat === TransferFormat.Binary) {
          webSocket.binaryType = "arraybuffer";
        }
        webSocket.onopen = (_event) => {
          this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);
          this._webSocket = webSocket;
          opened = true;
          resolve2();
        };
        webSocket.onerror = (event) => {
          let error = null;
          if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
            error = event.error;
          } else {
            error = "There was an error with the transport";
          }
          this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);
        };
        webSocket.onmessage = (message) => {
          this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);
          if (this.onreceive) {
            try {
              this.onreceive(message.data);
            } catch (error) {
              this._close(error);
              return;
            }
          }
        };
        webSocket.onclose = (event) => {
          if (opened) {
            this._close(event);
          } else {
            let error = null;
            if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
              error = event.error;
            } else {
              error = "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.";
            }
            reject(new Error(error));
          }
        };
      });
    }
    send(data) {
      if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {
        this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);
        this._webSocket.send(data);
        return Promise.resolve();
      }
      return Promise.reject("WebSocket is not in the OPEN state");
    }
    stop() {
      if (this._webSocket) {
        this._close(void 0);
      }
      return Promise.resolve();
    }
    _close(event) {
      if (this._webSocket) {
        this._webSocket.onclose = () => {
        };
        this._webSocket.onmessage = () => {
        };
        this._webSocket.onerror = () => {
        };
        this._webSocket.close();
        this._webSocket = void 0;
      }
      this._logger.log(LogLevel.Trace, "(WebSockets transport) socket closed.");
      if (this.onclose) {
        if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1e3)) {
          this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || "no reason given"}).`));
        } else if (event instanceof Error) {
          this.onclose(event);
        } else {
          this.onclose();
        }
      }
    }
    _isCloseEvent(event) {
      return event && typeof event.wasClean === "boolean" && typeof event.code === "number";
    }
  };
  __name(_WebSocketTransport, "WebSocketTransport");
  let WebSocketTransport = _WebSocketTransport;
  const MAX_REDIRECTS = 100;
  const _HttpConnection = class _HttpConnection {
    constructor(url, options = {}) {
      this._stopPromiseResolver = () => {
      };
      this.features = {};
      this._negotiateVersion = 1;
      Arg.isRequired(url, "url");
      this._logger = createLogger(options.logger);
      this.baseUrl = this._resolveUrl(url);
      options = options || {};
      options.logMessageContent = options.logMessageContent === void 0 ? false : options.logMessageContent;
      if (typeof options.withCredentials === "boolean" || options.withCredentials === void 0) {
        options.withCredentials = options.withCredentials === void 0 ? true : options.withCredentials;
      } else {
        throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
      }
      options.timeout = options.timeout === void 0 ? 100 * 1e3 : options.timeout;
      let webSocketModule = null;
      let eventSourceModule = null;
      if (Platform.isNode && typeof require !== "undefined") {
        const requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
        webSocketModule = requireFunc("ws");
        eventSourceModule = requireFunc("eventsource");
      }
      if (!Platform.isNode && typeof WebSocket !== "undefined" && !options.WebSocket) {
        options.WebSocket = WebSocket;
      } else if (Platform.isNode && !options.WebSocket) {
        if (webSocketModule) {
          options.WebSocket = webSocketModule;
        }
      }
      if (!Platform.isNode && typeof EventSource !== "undefined" && !options.EventSource) {
        options.EventSource = EventSource;
      } else if (Platform.isNode && !options.EventSource) {
        if (typeof eventSourceModule !== "undefined") {
          options.EventSource = eventSourceModule;
        }
      }
      this._httpClient = new AccessTokenHttpClient(options.httpClient || new DefaultHttpClient(this._logger), options.accessTokenFactory);
      this._connectionState = "Disconnected";
      this._connectionStarted = false;
      this._options = options;
      this.onreceive = null;
      this.onclose = null;
    }
    async start(transferFormat) {
      transferFormat = transferFormat || TransferFormat.Binary;
      Arg.isIn(transferFormat, TransferFormat, "transferFormat");
      this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);
      if (this._connectionState !== "Disconnected") {
        return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
      }
      this._connectionState = "Connecting";
      this._startInternalPromise = this._startInternal(transferFormat);
      await this._startInternalPromise;
      if (this._connectionState === "Disconnecting") {
        const message = "Failed to start the HttpConnection before stop() was called.";
        this._logger.log(LogLevel.Error, message);
        await this._stopPromise;
        return Promise.reject(new AbortError(message));
      } else if (this._connectionState !== "Connected") {
        const message = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
        this._logger.log(LogLevel.Error, message);
        return Promise.reject(new AbortError(message));
      }
      this._connectionStarted = true;
    }
    send(data) {
      if (this._connectionState !== "Connected") {
        return Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State."));
      }
      if (!this._sendQueue) {
        this._sendQueue = new TransportSendQueue(this.transport);
      }
      return this._sendQueue.send(data);
    }
    async stop(error) {
      if (this._connectionState === "Disconnected") {
        this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);
        return Promise.resolve();
      }
      if (this._connectionState === "Disconnecting") {
        this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);
        return this._stopPromise;
      }
      this._connectionState = "Disconnecting";
      this._stopPromise = new Promise((resolve2) => {
        this._stopPromiseResolver = resolve2;
      });
      await this._stopInternal(error);
      await this._stopPromise;
    }
    async _stopInternal(error) {
      this._stopError = error;
      try {
        await this._startInternalPromise;
      } catch (e) {
      }
      if (this.transport) {
        try {
          await this.transport.stop();
        } catch (e) {
          this._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);
          this._stopConnection();
        }
        this.transport = void 0;
      } else {
        this._logger.log(LogLevel.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
      }
    }
    async _startInternal(transferFormat) {
      let url = this.baseUrl;
      this._accessTokenFactory = this._options.accessTokenFactory;
      this._httpClient._accessTokenFactory = this._accessTokenFactory;
      try {
        if (this._options.skipNegotiation) {
          if (this._options.transport === HttpTransportType.WebSockets) {
            this.transport = this._constructTransport(HttpTransportType.WebSockets);
            await this._startTransport(url, transferFormat);
          } else {
            throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
          }
        } else {
          let negotiateResponse = null;
          let redirects = 0;
          do {
            negotiateResponse = await this._getNegotiationResponse(url);
            if (this._connectionState === "Disconnecting" || this._connectionState === "Disconnected") {
              throw new AbortError("The connection was stopped during negotiation.");
            }
            if (negotiateResponse.error) {
              throw new Error(negotiateResponse.error);
            }
            if (negotiateResponse.ProtocolVersion) {
              throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
            }
            if (negotiateResponse.url) {
              url = negotiateResponse.url;
            }
            if (negotiateResponse.accessToken) {
              const accessToken = negotiateResponse.accessToken;
              this._accessTokenFactory = () => accessToken;
              this._httpClient._accessToken = accessToken;
              this._httpClient._accessTokenFactory = void 0;
            }
            redirects++;
          } while (negotiateResponse.url && redirects < MAX_REDIRECTS);
          if (redirects === MAX_REDIRECTS && negotiateResponse.url) {
            throw new Error("Negotiate redirection limit exceeded.");
          }
          await this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);
        }
        if (this.transport instanceof LongPollingTransport) {
          this.features.inherentKeepAlive = true;
        }
        if (this._connectionState === "Connecting") {
          this._logger.log(LogLevel.Debug, "The HttpConnection connected successfully.");
          this._connectionState = "Connected";
        }
      } catch (e) {
        this._logger.log(LogLevel.Error, "Failed to start the connection: " + e);
        this._connectionState = "Disconnected";
        this.transport = void 0;
        this._stopPromiseResolver();
        return Promise.reject(e);
      }
    }
    async _getNegotiationResponse(url) {
      const headers = {};
      const [name, value] = getUserAgentHeader();
      headers[name] = value;
      const negotiateUrl = this._resolveNegotiateUrl(url);
      this._logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);
      try {
        const response = await this._httpClient.post(negotiateUrl, {
          content: "",
          headers: { ...headers, ...this._options.headers },
          timeout: this._options.timeout,
          withCredentials: this._options.withCredentials
        });
        if (response.statusCode !== 200) {
          return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));
        }
        const negotiateResponse = JSON.parse(response.content);
        if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {
          negotiateResponse.connectionToken = negotiateResponse.connectionId;
        }
        if (negotiateResponse.useStatefulReconnect && this._options._useStatefulReconnect !== true) {
          return Promise.reject(new FailedToNegotiateWithServerError("Client didn't negotiate Stateful Reconnect but the server did."));
        }
        return negotiateResponse;
      } catch (e) {
        let errorMessage = "Failed to complete negotiation with the server: " + e;
        if (e instanceof HttpError) {
          if (e.statusCode === 404) {
            errorMessage = errorMessage + " Either this is not a SignalR endpoint or there is a proxy blocking the connection.";
          }
        }
        this._logger.log(LogLevel.Error, errorMessage);
        return Promise.reject(new FailedToNegotiateWithServerError(errorMessage));
      }
    }
    _createConnectUrl(url, connectionToken) {
      if (!connectionToken) {
        return url;
      }
      return url + (url.indexOf("?") === -1 ? "?" : "&") + `id=${connectionToken}`;
    }
    async _createTransport(url, requestedTransport, negotiateResponse, requestedTransferFormat) {
      let connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);
      if (this._isITransport(requestedTransport)) {
        this._logger.log(LogLevel.Debug, "Connection was provided an instance of ITransport, using that directly.");
        this.transport = requestedTransport;
        await this._startTransport(connectUrl, requestedTransferFormat);
        this.connectionId = negotiateResponse.connectionId;
        return;
      }
      const transportExceptions = [];
      const transports = negotiateResponse.availableTransports || [];
      let negotiate = negotiateResponse;
      for (const endpoint of transports) {
        const transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat, (negotiate === null || negotiate === void 0 ? void 0 : negotiate.useStatefulReconnect) === true);
        if (transportOrError instanceof Error) {
          transportExceptions.push(`${endpoint.transport} failed:`);
          transportExceptions.push(transportOrError);
        } else if (this._isITransport(transportOrError)) {
          this.transport = transportOrError;
          if (!negotiate) {
            try {
              negotiate = await this._getNegotiationResponse(url);
            } catch (ex) {
              return Promise.reject(ex);
            }
            connectUrl = this._createConnectUrl(url, negotiate.connectionToken);
          }
          try {
            await this._startTransport(connectUrl, requestedTransferFormat);
            this.connectionId = negotiate.connectionId;
            return;
          } catch (ex) {
            this._logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);
            negotiate = void 0;
            transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, HttpTransportType[endpoint.transport]));
            if (this._connectionState !== "Connecting") {
              const message = "Failed to select transport before stop() was called.";
              this._logger.log(LogLevel.Debug, message);
              return Promise.reject(new AbortError(message));
            }
          }
        }
      }
      if (transportExceptions.length > 0) {
        return Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(" ")}`, transportExceptions));
      }
      return Promise.reject(new Error("None of the transports supported by the client are supported by the server."));
    }
    _constructTransport(transport) {
      switch (transport) {
        case HttpTransportType.WebSockets:
          if (!this._options.WebSocket) {
            throw new Error("'WebSocket' is not supported in your environment.");
          }
          return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});
        case HttpTransportType.ServerSentEvents:
          if (!this._options.EventSource) {
            throw new Error("'EventSource' is not supported in your environment.");
          }
          return new ServerSentEventsTransport(this._httpClient, this._httpClient._accessToken, this._logger, this._options);
        case HttpTransportType.LongPolling:
          return new LongPollingTransport(this._httpClient, this._logger, this._options);
        default:
          throw new Error(`Unknown transport: ${transport}.`);
      }
    }
    _startTransport(url, transferFormat) {
      this.transport.onreceive = this.onreceive;
      if (this.features.reconnect) {
        this.transport.onclose = async (e) => {
          let callStop = false;
          if (this.features.reconnect) {
            try {
              this.features.disconnected();
              await this.transport.connect(url, transferFormat);
              await this.features.resend();
            } catch {
              callStop = true;
            }
          } else {
            this._stopConnection(e);
            return;
          }
          if (callStop) {
            this._stopConnection(e);
          }
        };
      } else {
        this.transport.onclose = (e) => this._stopConnection(e);
      }
      return this.transport.connect(url, transferFormat);
    }
    _resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat, useStatefulReconnect) {
      const transport = HttpTransportType[endpoint.transport];
      if (transport === null || transport === void 0) {
        this._logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);
        return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);
      } else {
        if (transportMatches(requestedTransport, transport)) {
          const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);
          if (transferFormats.indexOf(requestedTransferFormat) >= 0) {
            if (transport === HttpTransportType.WebSockets && !this._options.WebSocket || transport === HttpTransportType.ServerSentEvents && !this._options.EventSource) {
              this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);
              return new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`, transport);
            } else {
              this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);
              try {
                this.features.reconnect = transport === HttpTransportType.WebSockets ? useStatefulReconnect : void 0;
                return this._constructTransport(transport);
              } catch (ex) {
                return ex;
              }
            }
          } else {
            this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);
            return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);
          }
        } else {
          this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);
          return new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`, transport);
        }
      }
    }
    _isITransport(transport) {
      return transport && typeof transport === "object" && "connect" in transport;
    }
    _stopConnection(error) {
      this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);
      this.transport = void 0;
      error = this._stopError || error;
      this._stopError = void 0;
      if (this._connectionState === "Disconnected") {
        this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);
        return;
      }
      if (this._connectionState === "Connecting") {
        this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);
        throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);
      }
      if (this._connectionState === "Disconnecting") {
        this._stopPromiseResolver();
      }
      if (error) {
        this._logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);
      } else {
        this._logger.log(LogLevel.Information, "Connection disconnected.");
      }
      if (this._sendQueue) {
        this._sendQueue.stop().catch((e) => {
          this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);
        });
        this._sendQueue = void 0;
      }
      this.connectionId = void 0;
      this._connectionState = "Disconnected";
      if (this._connectionStarted) {
        this._connectionStarted = false;
        try {
          if (this.onclose) {
            this.onclose(error);
          }
        } catch (e) {
          this._logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);
        }
      }
    }
    _resolveUrl(url) {
      if (url.lastIndexOf("https://", 0) === 0 || url.lastIndexOf("http://", 0) === 0) {
        return url;
      }
      if (!Platform.isBrowser) {
        throw new Error(`Cannot resolve '${url}'.`);
      }
      const aTag = window.document.createElement("a");
      aTag.href = url;
      this._logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);
      return aTag.href;
    }
    _resolveNegotiateUrl(url) {
      const negotiateUrl = new URL(url);
      if (negotiateUrl.pathname.endsWith("/")) {
        negotiateUrl.pathname += "negotiate";
      } else {
        negotiateUrl.pathname += "/negotiate";
      }
      const searchParams = new URLSearchParams(negotiateUrl.searchParams);
      if (!searchParams.has("negotiateVersion")) {
        searchParams.append("negotiateVersion", this._negotiateVersion.toString());
      }
      if (searchParams.has("useStatefulReconnect")) {
        if (searchParams.get("useStatefulReconnect") === "true") {
          this._options._useStatefulReconnect = true;
        }
      } else if (this._options._useStatefulReconnect === true) {
        searchParams.append("useStatefulReconnect", "true");
      }
      negotiateUrl.search = searchParams.toString();
      return negotiateUrl.toString();
    }
  };
  __name(_HttpConnection, "HttpConnection");
  let HttpConnection = _HttpConnection;
  function transportMatches(requestedTransport, actualTransport) {
    return !requestedTransport || (actualTransport & requestedTransport) !== 0;
  }
  __name(transportMatches, "transportMatches");
  const _TransportSendQueue = class _TransportSendQueue {
    constructor(_transport) {
      this._transport = _transport;
      this._buffer = [];
      this._executing = true;
      this._sendBufferedData = new PromiseSource();
      this._transportResult = new PromiseSource();
      this._sendLoopPromise = this._sendLoop();
    }
    send(data) {
      this._bufferData(data);
      if (!this._transportResult) {
        this._transportResult = new PromiseSource();
      }
      return this._transportResult.promise;
    }
    stop() {
      this._executing = false;
      this._sendBufferedData.resolve();
      return this._sendLoopPromise;
    }
    _bufferData(data) {
      if (this._buffer.length && typeof this._buffer[0] !== typeof data) {
        throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof data}`);
      }
      this._buffer.push(data);
      this._sendBufferedData.resolve();
    }
    async _sendLoop() {
      while (true) {
        await this._sendBufferedData.promise;
        if (!this._executing) {
          if (this._transportResult) {
            this._transportResult.reject("Connection stopped.");
          }
          break;
        }
        this._sendBufferedData = new PromiseSource();
        const transportResult = this._transportResult;
        this._transportResult = void 0;
        const data = typeof this._buffer[0] === "string" ? this._buffer.join("") : _TransportSendQueue._concatBuffers(this._buffer);
        this._buffer.length = 0;
        try {
          await this._transport.send(data);
          transportResult.resolve();
        } catch (error) {
          transportResult.reject(error);
        }
      }
    }
    static _concatBuffers(arrayBuffers) {
      const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const item of arrayBuffers) {
        result.set(new Uint8Array(item), offset);
        offset += item.byteLength;
      }
      return result.buffer;
    }
  };
  __name(_TransportSendQueue, "TransportSendQueue");
  let TransportSendQueue = _TransportSendQueue;
  const _PromiseSource = class _PromiseSource {
    constructor() {
      this.promise = new Promise((resolve2, reject) => [this._resolver, this._rejecter] = [resolve2, reject]);
    }
    resolve() {
      this._resolver();
    }
    reject(reason) {
      this._rejecter(reason);
    }
  };
  __name(_PromiseSource, "PromiseSource");
  let PromiseSource = _PromiseSource;
  const JSON_HUB_PROTOCOL_NAME = "json";
  const _JsonHubProtocol = class _JsonHubProtocol {
    constructor() {
      this.name = JSON_HUB_PROTOCOL_NAME;
      this.version = 2;
      this.transferFormat = TransferFormat.Text;
    }
    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.
     *
     * @param {string} input A string containing the serialized representation.
     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.
     */
    parseMessages(input, logger) {
      if (typeof input !== "string") {
        throw new Error("Invalid input for JSON hub protocol. Expected a string.");
      }
      if (!input) {
        return [];
      }
      if (logger === null) {
        logger = NullLogger.instance;
      }
      const messages = TextMessageFormat.parse(input);
      const hubMessages = [];
      for (const message of messages) {
        const parsedMessage = JSON.parse(message);
        if (typeof parsedMessage.type !== "number") {
          throw new Error("Invalid payload.");
        }
        switch (parsedMessage.type) {
          case MessageType.Invocation:
            this._isInvocationMessage(parsedMessage);
            break;
          case MessageType.StreamItem:
            this._isStreamItemMessage(parsedMessage);
            break;
          case MessageType.Completion:
            this._isCompletionMessage(parsedMessage);
            break;
          case MessageType.Ping:
            break;
          case MessageType.Close:
            break;
          case MessageType.Ack:
            this._isAckMessage(parsedMessage);
            break;
          case MessageType.Sequence:
            this._isSequenceMessage(parsedMessage);
            break;
          default:
            logger.log(LogLevel.Information, "Unknown message type '" + parsedMessage.type + "' ignored.");
            continue;
        }
        hubMessages.push(parsedMessage);
      }
      return hubMessages;
    }
    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.
     *
     * @param {HubMessage} message The message to write.
     * @returns {string} A string containing the serialized representation of the message.
     */
    writeMessage(message) {
      return TextMessageFormat.write(JSON.stringify(message));
    }
    _isInvocationMessage(message) {
      this._assertNotEmptyString(message.target, "Invalid payload for Invocation message.");
      if (message.invocationId !== void 0) {
        this._assertNotEmptyString(message.invocationId, "Invalid payload for Invocation message.");
      }
    }
    _isStreamItemMessage(message) {
      this._assertNotEmptyString(message.invocationId, "Invalid payload for StreamItem message.");
      if (message.item === void 0) {
        throw new Error("Invalid payload for StreamItem message.");
      }
    }
    _isCompletionMessage(message) {
      if (message.result && message.error) {
        throw new Error("Invalid payload for Completion message.");
      }
      if (!message.result && message.error) {
        this._assertNotEmptyString(message.error, "Invalid payload for Completion message.");
      }
      this._assertNotEmptyString(message.invocationId, "Invalid payload for Completion message.");
    }
    _isAckMessage(message) {
      if (typeof message.sequenceId !== "number") {
        throw new Error("Invalid SequenceId for Ack message.");
      }
    }
    _isSequenceMessage(message) {
      if (typeof message.sequenceId !== "number") {
        throw new Error("Invalid SequenceId for Sequence message.");
      }
    }
    _assertNotEmptyString(value, errorMessage) {
      if (typeof value !== "string" || value === "") {
        throw new Error(errorMessage);
      }
    }
  };
  __name(_JsonHubProtocol, "JsonHubProtocol");
  let JsonHubProtocol = _JsonHubProtocol;
  const LogLevelNameMapping = {
    trace: LogLevel.Trace,
    debug: LogLevel.Debug,
    info: LogLevel.Information,
    information: LogLevel.Information,
    warn: LogLevel.Warning,
    warning: LogLevel.Warning,
    error: LogLevel.Error,
    critical: LogLevel.Critical,
    none: LogLevel.None
  };
  function parseLogLevel(name) {
    const mapping = LogLevelNameMapping[name.toLowerCase()];
    if (typeof mapping !== "undefined") {
      return mapping;
    } else {
      throw new Error(`Unknown log level: ${name}`);
    }
  }
  __name(parseLogLevel, "parseLogLevel");
  const _HubConnectionBuilder = class _HubConnectionBuilder {
    configureLogging(logging) {
      Arg.isRequired(logging, "logging");
      if (isLogger(logging)) {
        this.logger = logging;
      } else if (typeof logging === "string") {
        const logLevel = parseLogLevel(logging);
        this.logger = new ConsoleLogger(logLevel);
      } else {
        this.logger = new ConsoleLogger(logging);
      }
      return this;
    }
    withUrl(url, transportTypeOrOptions) {
      Arg.isRequired(url, "url");
      Arg.isNotEmpty(url, "url");
      this.url = url;
      if (typeof transportTypeOrOptions === "object") {
        this.httpConnectionOptions = { ...this.httpConnectionOptions, ...transportTypeOrOptions };
      } else {
        this.httpConnectionOptions = {
          ...this.httpConnectionOptions,
          transport: transportTypeOrOptions
        };
      }
      return this;
    }
    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.
     *
     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.
     */
    withHubProtocol(protocol2) {
      Arg.isRequired(protocol2, "protocol");
      this.protocol = protocol2;
      return this;
    }
    withAutomaticReconnect(retryDelaysOrReconnectPolicy) {
      if (this.reconnectPolicy) {
        throw new Error("A reconnectPolicy has already been set.");
      }
      if (!retryDelaysOrReconnectPolicy) {
        this.reconnectPolicy = new DefaultReconnectPolicy();
      } else if (Array.isArray(retryDelaysOrReconnectPolicy)) {
        this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);
      } else {
        this.reconnectPolicy = retryDelaysOrReconnectPolicy;
      }
      return this;
    }
    /** Configures {@link @microsoft/signalr.HubConnection.serverTimeoutInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.
     *
     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.
     */
    withServerTimeout(milliseconds) {
      Arg.isRequired(milliseconds, "milliseconds");
      this._serverTimeoutInMilliseconds = milliseconds;
      return this;
    }
    /** Configures {@link @microsoft/signalr.HubConnection.keepAliveIntervalInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.
     *
     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.
     */
    withKeepAliveInterval(milliseconds) {
      Arg.isRequired(milliseconds, "milliseconds");
      this._keepAliveIntervalInMilliseconds = milliseconds;
      return this;
    }
    /** Enables and configures options for the Stateful Reconnect feature.
     *
     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.
     */
    withStatefulReconnect(options) {
      if (this.httpConnectionOptions === void 0) {
        this.httpConnectionOptions = {};
      }
      this.httpConnectionOptions._useStatefulReconnect = true;
      this._statefulReconnectBufferSize = options === null || options === void 0 ? void 0 : options.bufferSize;
      return this;
    }
    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.
     *
     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.
     */
    build() {
      const httpConnectionOptions = this.httpConnectionOptions || {};
      if (httpConnectionOptions.logger === void 0) {
        httpConnectionOptions.logger = this.logger;
      }
      if (!this.url) {
        throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
      }
      const connection = new HttpConnection(this.url, httpConnectionOptions);
      return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol(), this.reconnectPolicy, this._serverTimeoutInMilliseconds, this._keepAliveIntervalInMilliseconds, this._statefulReconnectBufferSize);
    }
  };
  __name(_HubConnectionBuilder, "HubConnectionBuilder");
  let HubConnectionBuilder = _HubConnectionBuilder;
  function isLogger(logger) {
    return logger.log !== void 0;
  }
  __name(isLogger, "isLogger");
  var __defProp$F = Object.defineProperty;
  var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
  var __decorateClass$F = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$F(target, key2, result);
    return result;
  }, "__decorateClass$F");
  var __decorateParam$2 = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$2");
  const hubTypeMap = {
    IGuildLobbiesHub: {
      url: "guildLobbies"
    },
    ILobbyHub: {
      url: "lobby"
    },
    IOnlineItemsHub: {
      url: "onlineItems"
    }
  };
  let SocketService = (_Aa = class {
    constructor(loggerFactory2, tokenService) {
      __publicField(this, "_logger");
      __publicField(
        this,
        "_baseUrl",
        /*"http://localhost:5001";*/
        "https://sockets.typo.rip"
      );
      __publicField(this, "_token", "");
      __publicField(this, "createHub", getHubProxyFactory);
      __publicField(this, "createReceiver", getReceiverRegister);
      this._logger = loggerFactory2(this);
      tokenService.token.subscribe((token) => this._token = token ?? "");
    }
    /**
     * creates a new signalr config based on set options
     * @private
     */
    createSignalRConfig() {
      return {
        withCredentials: false,
        accessTokenFactory: /* @__PURE__ */ __name(() => this._token, "accessTokenFactory")
      };
    }
    /**
     * create a new signalr client of given type
     * @returns
     * @param hubType
     * @param queryParams
     */
    createConnection(hubType) {
      const connection = new HubConnectionBuilder().withUrl(`${this._baseUrl}/${hubTypeMap[hubType].url}`, this.createSignalRConfig()).configureLogging({
        log: /* @__PURE__ */ __name((logLevel, message) => {
          if (logLevel == LogLevel.Trace || logLevel == LogLevel.Debug) this._logger.debug(message);
          if (logLevel == LogLevel.Information || logLevel == LogLevel.Warning) this._logger.info(message);
          if (logLevel == LogLevel.Critical) this._logger.warn(message);
          if (logLevel == LogLevel.Error) this._logger.error(message);
        }, "log")
      }).build();
      return connection;
    }
    /**
     * Set the base url which will be used for api calls
     * @param url
     */
    set baseUrl(url) {
      this._baseUrl = url;
    }
    reconnectOnUserInteraction(connection, builder) {
      const interactionListener = /* @__PURE__ */ __name(async () => {
        this._logger.info("User interaction detected, reconnecting...");
        await builder();
      }, "interactionListener");
      connection.onclose(() => {
        this._logger.info("Connection closed, waiting for user interaction to reconnect...");
        document.addEventListener("pointermove", interactionListener, { once: true });
      });
    }
  }, __name(_Aa, "SocketService"), _Aa);
  SocketService = __decorateClass$F([
    injectable(),
    __decorateParam$2(0, inject(loggerFactory)),
    __decorateParam$2(1, inject(TokenService))
  ], SocketService);
  var __defProp$E = Object.defineProperty;
  var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
  var __decorateClass$E = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$E(target, key2, result);
    return result;
  }, "__decorateClass$E");
  var __decorateParam$1 = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam$1");
  let LobbyConnectionService = (_Ba = class {
    constructor(loggerFactory2) {
      __publicField(this, "_socketService");
      __publicField(this, "_logger");
      __publicField(this, "_connection$", new BehaviorSubject(void 0));
      __publicField(this, "_existingTypoLobbyStates", /* @__PURE__ */ new Map());
      __publicField(this, "_abortConnecting");
      /** abort the connection while it is still in setup phase and _connection is still undefined */
      __publicField(this, "_dropAnnounced$", new Subject$1());
      __publicField(this, "_dropClaimed$", new Subject$1());
      __publicField(this, "_dropCleared$", new Subject$1());
      __publicField(this, "_awardGifted$", new Subject$1());
      __publicField(this, "_pausedSetting", new ExtensionSetting("pause_lobby_connection", false));
      this._logger = loggerFactory2(this);
    }
    async onFeatureActivate() {
      if (await this._pausedSetting.getValue()) {
        this._connection$.next("paused");
      }
    }
    async onFeatureDestroy() {
      await this.destroyConnection();
      this._existingTypoLobbyStates.clear();
    }
    get dropAnnounced$() {
      return this._dropAnnounced$.asObservable();
    }
    get dropClaimed$() {
      return this._dropClaimed$.asObservable();
    }
    get awardGifted$() {
      return this._awardGifted$.asObservable();
    }
    get dropCleared$() {
      return this._dropCleared$.asObservable();
    }
    /**
     * The current connection state
     * Throws if not connected
     * @private
     */
    get connection() {
      const connection = this._connection$.value;
      if (connection === void 0 || connection === "unauthorized" || connection === "paused") {
        this._logger.error("connection is not initialized");
        throw new Error("connection is not initialized");
      }
      return connection;
    }
    /**
     * Observable containing the current connection, emits when connection changed or settings updated
     */
    get connection$() {
      return this._connection$.asObservable();
    }
    /**
     * Whether the current connection is established
     * @private
     */
    get isConnected() {
      return this._connection$.value !== void 0 && this._connection$.value !== "unauthorized" && this._connection$.value !== "paused";
    }
    /**
     * Sets up the connection to the lobby hub and initializes the receiver
     * @private
     */
    async setupConnection(lobbyId, lobby, playerId, member) {
      var _a2;
      if (await this._pausedSetting.getValue()) {
        this._logger.warn("Tried to connect, but Connection is paused");
        this._connection$.next("paused");
        return "failed";
      }
      const claim = (_a2 = this._existingTypoLobbyStates.get(lobbyId)) == null ? void 0 : _a2.ownershipClaimToken;
      const connection = this._socketService.createConnection("ILobbyHub");
      const hub = this._socketService.createHub("ILobbyHub").createHubProxy(connection);
      this._socketService.createReceiver("ILobbyReceiver").register(connection, {
        lobbyOwnershipResigned: this.lobbyOwnershipResigned.bind(this),
        typoLobbySettingsUpdated: this.typoLobbySettingsUpdated.bind(this),
        dropAnnounced: /* @__PURE__ */ __name(async (drop) => this._dropAnnounced$.next(drop), "dropAnnounced"),
        dropClaimed: /* @__PURE__ */ __name(async (result) => this._dropClaimed$.next(result), "dropClaimed"),
        awardGifted: /* @__PURE__ */ __name(async (award) => this._awardGifted$.next(award), "awardGifted"),
        dropCleared: /* @__PURE__ */ __name(async (clear) => this._dropCleared$.next(clear), "dropCleared")
      });
      connection.onclose(async (error) => {
        this._logger.debug("SignalR Connection closed", error);
        this._connection$.next(void 0);
      });
      this._abortConnecting = async () => {
        this._logger.info("Aborting connection while still in setup phase");
        await connection.stop();
      };
      try {
        await connection.start();
      } catch (e) {
        this._logger.error("Failed to setup socket connection", e);
        await this.destroyConnection();
        this._connection$.next(void 0);
        return "failed";
      }
      const state = await hub.lobbyDiscovered({ ownerClaimToken: claim, lobby, playerId });
      this._logger.info("Lobby discovered", state);
      this._connection$.next({ connection, hub, typoLobbyState: state, member });
      this._existingTypoLobbyStates.set(state.lobbyId, state);
      this._abortConnecting = void 0;
      return claim ? "reconnected" : "connected";
    }
    /**
     * Destroys the current connection if it exists, aborts a current connection setup if it is in progress,
     * and closes the flyout if opened
     * @private
     */
    async destroyConnection(reason) {
      if (this._connection$.value !== void 0 && this._connection$.value !== "unauthorized" && this._connection$.value !== "paused") {
        await this._connection$.value.connection.stop();
      }
      if (this._abortConnecting) {
        this._abortConnecting();
      }
      if (reason === "unauthorized") this._connection$.next("unauthorized");
      else if (reason === "paused") this._connection$.next("paused");
      else this._connection$.next(void 0);
    }
    /**
     * Signalr event handler when typo lobby settings have been updated
     * Saves new properties to current connection info
     * @param state
     * @private
     */
    async typoLobbySettingsUpdated(state) {
      const savedSettings = this._existingTypoLobbyStates.get(this.connection.typoLobbyState.lobbyId);
      if (savedSettings) savedSettings.lobbySettings = state;
      this.connection.typoLobbyState.lobbySettings = state;
      this.connection.typoLobbyState.playerIsOwner = state.lobbyOwnershipClaim === this.connection.typoLobbyState.ownershipClaim;
      this._connection$.next(this.connection);
      this._logger.info("Lobby state updated", this.connection.typoLobbyState);
    }
    /**
     * Signalr event handler when lobby ownership has been resigned
     * Attempts to claim the lobby ownership as a reaction
     * @private
     */
    async lobbyOwnershipResigned() {
      this._logger.info("Lobby ownership resigned, claiming now");
      await this.connection.hub.claimLobbyOwnership();
    }
    async setPaused(paused) {
      await this._pausedSetting.setValue(paused);
      if (this.isConnected) {
        await this.destroyConnection("paused");
      } else if (!paused) {
        this._connection$.next(void 0);
      }
    }
  }, __name(_Ba, "LobbyConnectionService"), _Ba);
  __decorateClass$E([
    inject(SocketService)
  ], LobbyConnectionService.prototype, "_socketService", 2);
  LobbyConnectionService = __decorateClass$E([
    injectable(),
    __decorateParam$1(0, inject(loggerFactory))
  ], LobbyConnectionService);
  const parseSignalRError = /* @__PURE__ */ __name((error) => {
    if (!(error instanceof Error)) throw error;
    const matches = error == null ? void 0 : error.message.match(/.*'(.*)'.*\. (.*): (.*)/);
    if (matches) {
      if (matches.length < 3) throw error;
      const [, hub, exception, message] = matches;
      return {
        hub,
        exception,
        message
      };
    } else throw error;
  }, "parseSignalRError");
  function create_if_block$r(ctx) {
    let div;
    let mounted;
    let dispose;
    return {
      c() {
        div = element("div");
        attr(div, "class", "typo-drop svelte-15kb90n");
        set_style(div, "left", "calc((100% - 48px) * (" + /*$currentDrop*/
        ctx[1].drop.position + " / 100))");
        set_style(
          div,
          "background-image",
          /*getDropUrl*/
          ctx[3](
            /*$currentDrop*/
            ctx[1].drop.eventDropId,
            /*$currentDrop*/
            ctx[1].leagueMode
          )
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if (!mounted) {
          dispose = listen(
            div,
            "pointerdown",
            /*pointerdown_handler*/
            ctx[5]
          );
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*$currentDrop*/
        2) {
          set_style(div, "left", "calc((100% - 48px) * (" + /*$currentDrop*/
          ctx2[1].drop.position + " / 100))");
        }
        if (dirty & /*$currentDrop*/
        2) {
          set_style(
            div,
            "background-image",
            /*getDropUrl*/
            ctx2[3](
              /*$currentDrop*/
              ctx2[1].drop.eventDropId,
              /*$currentDrop*/
              ctx2[1].leagueMode
            )
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block$r, "create_if_block$r");
  function create_fragment$14(ctx) {
    let if_block_anchor;
    let if_block = (
      /*$currentDrop*/
      ctx[1] !== void 0 && /*$currentDrop*/
      ctx[1].ownClaimed === false && create_if_block$r(ctx)
    );
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (
          /*$currentDrop*/
          ctx2[1] !== void 0 && /*$currentDrop*/
          ctx2[1].ownClaimed === false
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$r(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
      }
    };
  }
  __name(create_fragment$14, "create_fragment$14");
  function instance$_($$self, $$props, $$invalidate) {
    let $currentDrop;
    let { feature } = $$props;
    let { drops } = $$props;
    const currentDrop = feature.currentDropStore;
    component_subscribe($$self, currentDrop, (value) => $$invalidate(1, $currentDrop = value));
    function getDropUrl(id2, leagueMode) {
      const drop = drops.find((drop2) => drop2.id === id2);
      return leagueMode ? "var(--file-img-drop-pink-gif)" : drop ? `url(${drop.url})` : "var(--file-img-drop-gif)";
    }
    __name(getDropUrl, "getDropUrl");
    const pointerdown_handler = /* @__PURE__ */ __name(async () => {
      if ($currentDrop) {
        const claim = await feature.claimDrop($currentDrop.drop, $currentDrop.timestamp);
        if (claim !== void 0) feature.processClaim(claim, true);
      }
    }, "pointerdown_handler");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
      if ("drops" in $$props2) $$invalidate(4, drops = $$props2.drops);
    };
    return [feature, $currentDrop, currentDrop, getDropUrl, drops, pointerdown_handler];
  }
  __name(instance$_, "instance$_");
  const _Drops = class _Drops extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$_, create_fragment$14, safe_not_equal, { feature: 0, drops: 4 });
    }
  };
  __name(_Drops, "Drops");
  let Drops = _Drops;
  function get_each_context$o(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[3] = list[i];
    return child_ctx;
  }
  __name(get_each_context$o, "get_each_context$o");
  function create_each_block$o(ctx) {
    let div;
    let b;
    let t0;
    let t1_value = (
      /*claim*/
      ctx[3].dropId + ""
    );
    let t1;
    let t2;
    let span0;
    let t3_value = new Date(
      /*claim*/
      ctx[3].dropId
    ).toLocaleTimeString() + "";
    let t3;
    let t4;
    let span1;
    let t5_value = (
      /*claim*/
      ctx[3].username + ""
    );
    let t5;
    let t6;
    let span2;
    let t7_value = (
      /*claim*/
      ctx[3].catchTime + ""
    );
    let t7;
    let t8;
    let t9;
    let span3;
    let t10_value = Math.round(
      /*claim*/
      ctx[3].leagueWeight * 100
    ) + "";
    let t10;
    let t11;
    return {
      c() {
        div = element("div");
        b = element("b");
        t0 = text("#");
        t1 = text(t1_value);
        t2 = space();
        span0 = element("span");
        t3 = text(t3_value);
        t4 = space();
        span1 = element("span");
        t5 = text(t5_value);
        t6 = space();
        span2 = element("span");
        t7 = text(t7_value);
        t8 = text("ms");
        t9 = space();
        span3 = element("span");
        t10 = text(t10_value);
        t11 = text("%");
        attr(div, "class", "typo-drop-claims-claim svelte-qhyy9");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, b);
        append(b, t0);
        append(b, t1);
        append(div, t2);
        append(div, span0);
        append(span0, t3);
        append(div, t4);
        append(div, span1);
        append(span1, t5);
        append(div, t6);
        append(div, span2);
        append(span2, t7);
        append(span2, t8);
        append(div, t9);
        append(div, span3);
        append(span3, t10);
        append(span3, t11);
      },
      p(ctx2, dirty) {
        if (dirty & /*$claims*/
        1 && t1_value !== (t1_value = /*claim*/
        ctx2[3].dropId + "")) set_data(t1, t1_value);
        if (dirty & /*$claims*/
        1 && t3_value !== (t3_value = new Date(
          /*claim*/
          ctx2[3].dropId
        ).toLocaleTimeString() + "")) set_data(t3, t3_value);
        if (dirty & /*$claims*/
        1 && t5_value !== (t5_value = /*claim*/
        ctx2[3].username + "")) set_data(t5, t5_value);
        if (dirty & /*$claims*/
        1 && t7_value !== (t7_value = /*claim*/
        ctx2[3].catchTime + "")) set_data(t7, t7_value);
        if (dirty & /*$claims*/
        1 && t10_value !== (t10_value = Math.round(
          /*claim*/
          ctx2[3].leagueWeight * 100
        ) + "")) set_data(t10, t10_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_each_block$o, "create_each_block$o");
  function create_if_block$q(ctx) {
    let p;
    return {
      c() {
        p = element("p");
        p.textContent = "No drop claims yet.";
      },
      m(target, anchor) {
        insert(target, p, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(p);
        }
      }
    };
  }
  __name(create_if_block$q, "create_if_block$q");
  function create_fragment$13(ctx) {
    let h3;
    let t1;
    let p;
    let t4;
    let br1;
    let t5;
    let div;
    let t6;
    let each_value = ensure_array_like(
      /*$claims*/
      ctx[0]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$o(get_each_context$o(ctx, each_value, i));
    }
    let if_block = (
      /*$claims*/
      ctx[0].length === 0 && create_if_block$q()
    );
    return {
      c() {
        h3 = element("h3");
        h3.textContent = "Drop Log";
        t1 = space();
        p = element("p");
        p.innerHTML = `In the drop log, you can find all drops claims that happened while you were in lobbies.<br/>
  To report a suspicious drop claim, copy the catch time and drop ID and send it on the typo server.`;
        t4 = space();
        br1 = element("br");
        t5 = space();
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t6 = space();
        if (if_block) if_block.c();
        attr(div, "class", "typo-drop-claims svelte-qhyy9");
      },
      m(target, anchor) {
        insert(target, h3, anchor);
        insert(target, t1, anchor);
        insert(target, p, anchor);
        insert(target, t4, anchor);
        insert(target, br1, anchor);
        insert(target, t5, anchor);
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
        append(div, t6);
        if (if_block) if_block.m(div, null);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*Math, $claims, Date*/
        1) {
          each_value = ensure_array_like(
            /*$claims*/
            ctx2[0]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$o(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$o(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div, t6);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
        if (
          /*$claims*/
          ctx2[0].length === 0
        ) {
          if (if_block) ;
          else {
            if_block = create_if_block$q();
            if_block.c();
            if_block.m(div, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(h3);
          detach(t1);
          detach(p);
          detach(t4);
          detach(br1);
          detach(t5);
          detach(div);
        }
        destroy_each(each_blocks, detaching);
        if (if_block) if_block.d();
      }
    };
  }
  __name(create_fragment$13, "create_fragment$13");
  function instance$Z($$self, $$props, $$invalidate) {
    let $claims;
    let { feature } = $$props;
    const claims = feature.recordedClaimsStore;
    component_subscribe($$self, claims, (value) => $$invalidate(0, $claims = value));
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(2, feature = $$props2.feature);
    };
    return [$claims, claims, feature];
  }
  __name(instance$Z, "instance$Z");
  const _Drops_info = class _Drops_info extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$Z, create_fragment$13, safe_not_equal, { feature: 2 });
    }
  };
  __name(_Drops_info, "Drops_info");
  let Drops_info = _Drops_info;
  var __defProp$D = Object.defineProperty;
  var __decorateClass$D = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$D(target, key2, result);
    return result;
  }, "__decorateClass$D");
  const _DropsFeature = class _DropsFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_apiDataSetup");
      __publicField(this, "_lobbyConnectionService");
      __publicField(this, "_chatService");
      __publicField(this, "_toastService");
      __publicField(this, "_lobbyLeftEventListener");
      __publicField(this, "_lobbyService");
      __publicField(this, "name", "Drops");
      __publicField(this, "description", "Show drops to collect extra bubbles when you're playing");
      __publicField(this, "tags", [
        FeatureTag.SOCIAL,
        FeatureTag.PALANTIR
      ]);
      __publicField(this, "featureId", 40);
      __publicField(this, "_component");
      __publicField(this, "_recordedClaims$", new BehaviorSubject([]));
      __publicField(this, "_currentDrop$", new Subject$1());
      __publicField(this, "_dropSummarySubscription");
      __publicField(this, "_dropAnnouncedSubscription");
      __publicField(this, "_enableDropSummary", this.useSetting(
        new BooleanExtensionSetting("drop_summary", true, this).withName("Drop Summary").withDescription("Show a chat message with all drop catches after a drop")
      ));
      __publicField(this, "_enableOtherDropNotifications", this.useSetting(
        new BooleanExtensionSetting("drop_notifications", true, this).withName("Drop Notifications").withDescription("Show a chat message when someone else catches a drop")
      ));
    }
    get featureManagementComponent() {
      return { componentType: Drops_info, props: { feature: this } };
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      const apiData = await this._apiDataSetup.complete();
      this._component = new Drops({
        target: elements2.canvasWrapper,
        props: {
          feature: this,
          drops: apiData.drops
        }
      });
      this._dropAnnouncedSubscription = this._lobbyConnectionService.dropAnnounced$.pipe(
        switchMap(
          (drop) => of(drop).pipe(
            mergeWith(
              /* set to undefined after timeout of 2s */
              this._lobbyConnectionService.dropCleared$.pipe(
                filter((clear) => clear.dropId === drop.dropId),
                tap(() => this._logger.info("Drop cleared by server event", drop)),
                map(() => void 0),
                delay(1e3)
              ),
              /* set to undefined when someone else clears */
              this._lobbyConnectionService.dropClaimed$.pipe(
                tap((claim) => this._logger.info("Other claim arrived", claim)),
                mergeMap(async (claim) => {
                  await this.processClaim(claim, false);
                  return claim;
                }),
                filter((claim) => claim.clearedDrop),
                map(() => void 0)
              ),
              /* clear on lobby leave */
              this._lobbyLeftEventListener.events$.pipe(
                map(() => void 0)
              )
            )
          )
        ),
        tap((drop) => this._logger.info("Setting drop", drop)),
        withLatestFrom(this._lobbyService.lobby$)
      ).subscribe(
        ([drop, lobby]) => this._currentDrop$.next(
          drop === void 0 ? void 0 : {
            drop,
            timestamp: Date.now(),
            ownClaimed: false,
            leagueMode: ((lobby == null ? void 0 : lobby.players.length) === 1 || (lobby == null ? void 0 : lobby.players.every((player) => player.score === 0))) ?? false
          }
        )
      );
      this._dropSummarySubscription = this._currentDrop$.pipe(
        startWith(void 0),
        distinctUntilChanged(),
        pairwise(),
        withLatestFrom(this._recordedClaims$, this._enableDropSummary.changes$)
      ).subscribe(([[prev, current], claims, summaryEnabled]) => {
        var _a2;
        if (!summaryEnabled) return;
        if (prev !== void 0 && current === void 0) {
          const getEmoji = /* @__PURE__ */ __name((claim) => {
            if (claim.clearedDrop && claim.firstClaim) return "💎🛡️";
            if (claim.clearedDrop) return "🛡️";
            if (claim.firstClaim) return "💎";
            if (claim.leagueMode) return "🧿";
            return "💧";
          }, "getEmoji");
          const previousDrop = prev;
          const currentClaims = claims.filter((c) => c.dropId === previousDrop.drop.dropId);
          const dropName = previousDrop.drop.eventDropId !== void 0 ? (_a2 = apiData.drops.find((d) => d.id === previousDrop.drop.eventDropId)) == null ? void 0 : _a2.name : void 0;
          const title = "Drop Summary" + (dropName !== void 0 ? `: (${dropName})` : "");
          const content2 = "\n" + (currentClaims.length === 0 ? "The drop timed out :(" : currentClaims.map(
            (c) => `${getEmoji(c)} ${c.username}: ${c.catchTime}ms (${Math.round(c.leagueWeight * 100)}%)`
          ).join("\n"));
          this._chatService.addChatMessage(content2, title, "info");
        }
      });
    }
    onDestroy() {
      var _a2, _b2, _c2;
      (_a2 = this._component) == null ? void 0 : _a2.$destroy();
      this._recordedClaims$.next([]);
      (_b2 = this._dropSummarySubscription) == null ? void 0 : _b2.unsubscribe();
      (_c2 = this._dropAnnouncedSubscription) == null ? void 0 : _c2.unsubscribe();
      this._dropSummarySubscription = void 0;
      this._dropAnnouncedSubscription = void 0;
    }
    get currentDropStore() {
      return fromObservable(this._currentDrop$, void 0);
    }
    get recordedClaimsStore() {
      return fromObservable(this._recordedClaims$, []);
    }
    /**
     * Send a drop claim and show an error if fails - probably timeout or already cleared
     * @param drop
     * @param timestamp
     */
    async claimDrop(drop, timestamp) {
      this._logger.info("Claiming drop after delay", Date.now() - timestamp);
      this._currentDrop$.next({ drop, ownClaimed: true, timestamp, leagueMode: false });
      try {
        const result = await this._lobbyConnectionService.connection.hub.claimDrop({
          dropToken: drop.dropToken
        });
        return result;
      } catch (e) {
        const error = parseSignalRError(e);
        this._logger.error("Failed to claim drop", error);
        await this._toastService.showToast(error.message);
        return void 0;
      }
    }
    /**
     * Add a claim to the recorded claims and show a chat message
     * @param claim
     * @param ownClaim
     */
    async processClaim(claim, ownClaim) {
      this._logger.debug("Processing claim", claim);
      const recordedClaims = [...this._recordedClaims$.value, { ...claim, own: ownClaim }];
      this._recordedClaims$.next(recordedClaims);
      const enabledOtherNotifications = await this._enableOtherDropNotifications.getValue();
      if (ownClaim || enabledOtherNotifications) {
        const previouslyClaimed = recordedClaims.some((c) => c.own);
        const title = ownClaim ? "Yeee!" : claim.clearedDrop && !previouslyClaimed ? "Oops.." : "";
        const message = ownClaim ? `You ${claim.clearedDrop ? "cleared" : "caught"} the drop after ${claim.catchTime}ms (${Math.round(claim.leagueWeight * 100)}%)` : claim.clearedDrop ? `${claim.username} cleared the drop after ${claim.catchTime}ms` : `${claim.username} caught the drop after ${claim.catchTime}ms`;
        await this._chatService.addChatMessage(message, title, "info");
      }
      if (ownClaim && claim.clearedDrop) this._currentDrop$.next(void 0);
    }
  };
  __name(_DropsFeature, "DropsFeature");
  let DropsFeature = _DropsFeature;
  __decorateClass$D([
    inject(ElementsSetup)
  ], DropsFeature.prototype, "_elementsSetup");
  __decorateClass$D([
    inject(ApiDataSetup)
  ], DropsFeature.prototype, "_apiDataSetup");
  __decorateClass$D([
    inject(LobbyConnectionService)
  ], DropsFeature.prototype, "_lobbyConnectionService");
  __decorateClass$D([
    inject(ChatService)
  ], DropsFeature.prototype, "_chatService");
  __decorateClass$D([
    inject(ToastService)
  ], DropsFeature.prototype, "_toastService");
  __decorateClass$D([
    inject(LobbyLeftEventListener)
  ], DropsFeature.prototype, "_lobbyLeftEventListener");
  __decorateClass$D([
    inject(LobbyService)
  ], DropsFeature.prototype, "_lobbyService");
  const BLANK = "_";
  const FILLER = "‎";
  const DIACRITICS = {
    "ä": "a",
    "ö": "o",
    "ü": "u",
    "à": "a",
    "â": "a",
    "ç": "c",
    "é": "e",
    "è": "e",
    "ê": "e",
    "ë": "e",
    "î": "i",
    "ï": "i",
    "ô": "o",
    "û": "u",
    "ù": "u",
    "ÿ": "y",
    "ñ": "n",
    "á": "a",
    "í": "i",
    "ó": "o",
    "ú": "u",
    "ą": "a",
    "ć": "c",
    "ę": "e",
    "ń": "n",
    "ś": "s",
    "ż": "z",
    "ź": "z"
  };
  function isTheSameLetter(char, otherChar) {
    char = char.toLowerCase();
    otherChar = otherChar.toLowerCase();
    char = DIACRITICS[char] ?? char;
    otherChar = DIACRITICS[otherChar] ?? otherChar;
    return char === otherChar;
  }
  __name(isTheSameLetter, "isTheSameLetter");
  function getOverlayContent(guess, hints) {
    guess = guess.replaceAll(" ", "").replaceAll("-", "");
    let result = "";
    let guessIndex = 0;
    for (let hintIndex = 0; hintIndex < hints.length; hintIndex++) {
      const guessChar = guess.charAt(guessIndex);
      const hintChar = hints.charAt(hintIndex);
      if (hintChar === " " || hintChar === "-") {
        result = result.concat(hintChar);
      } else if (isTheSameLetter(guessChar, hintChar)) {
        result = result.concat(hintChar);
        guessIndex++;
      } else if (guessChar === "") {
        result = result.concat(FILLER);
      } else {
        result = result.concat(guessChar);
        guessIndex++;
      }
    }
    return result;
  }
  __name(getOverlayContent, "getOverlayContent");
  function guessMatchesHint(character, index, hints) {
    return hints[index] === character || character === FILLER || hints[index] === BLANK;
  }
  __name(guessMatchesHint, "guessMatchesHint");
  function guessCorrectHint(character, index, hints) {
    return hints[index] === character && hints[index] !== BLANK;
  }
  __name(guessCorrectHint, "guessCorrectHint");
  function get_each_context$n(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[3] = list[i];
    return child_ctx;
  }
  __name(get_each_context$n, "get_each_context$n");
  function get_each_context_1$9(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[6] = list[i];
    child_ctx[8] = i;
    return child_ctx;
  }
  __name(get_each_context_1$9, "get_each_context_1$9");
  function create_if_block$p(ctx) {
    let each_1_anchor;
    let each_value_1 = ensure_array_like(
      /*$guess*/
      ctx[0].overlayContent
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1$9(get_each_context_1$9(ctx, each_value_1, i));
    }
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*$guess*/
        1) {
          each_value_1 = ensure_array_like(
            /*$guess*/
            ctx2[0].overlayContent
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$9(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_1$9(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_1.length;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_if_block$p, "create_if_block$p");
  function create_each_block_1$9(ctx) {
    let span;
    let t0_value = (
      /*guessCharacter*/
      ctx[6] + ""
    );
    let t0;
    let t1;
    return {
      c() {
        span = element("span");
        t0 = text(t0_value);
        t1 = space();
        attr(span, "class", "overlay-character svelte-dq3z80");
        toggle_class(span, "hidden", guessCorrectHint(
          /*guessCharacter*/
          ctx[6],
          /*index*/
          ctx[8],
          /*$guess*/
          ctx[0].hints
        ));
        toggle_class(span, "warning", !guessMatchesHint(
          /*guessCharacter*/
          ctx[6],
          /*index*/
          ctx[8],
          /*$guess*/
          ctx[0].hints
        ));
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t0);
        append(span, t1);
      },
      p(ctx2, dirty) {
        if (dirty & /*$guess*/
        1 && t0_value !== (t0_value = /*guessCharacter*/
        ctx2[6] + "")) set_data(t0, t0_value);
        if (dirty & /*$guess*/
        1) {
          toggle_class(span, "hidden", guessCorrectHint(
            /*guessCharacter*/
            ctx2[6],
            /*index*/
            ctx2[8],
            /*$guess*/
            ctx2[0].hints
          ));
        }
        if (dirty & /*$guess*/
        1) {
          toggle_class(span, "warning", !guessMatchesHint(
            /*guessCharacter*/
            ctx2[6],
            /*index*/
            ctx2[8],
            /*$guess*/
            ctx2[0].hints
          ));
        }
      },
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  __name(create_each_block_1$9, "create_each_block_1$9");
  function create_each_block$n(ctx) {
    let div;
    let t;
    let if_block = (
      /*$guess*/
      ctx[0] !== null && create_if_block$p(ctx)
    );
    return {
      c() {
        div = element("div");
        if (if_block) if_block.c();
        t = space();
        attr(div, "class", "typo-hints-overlay " + /*overlayType*/
        ctx[3] + " svelte-dq3z80");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if (if_block) if_block.m(div, null);
        append(div, t);
      },
      p(ctx2, dirty) {
        if (
          /*$guess*/
          ctx2[0] !== null
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$p(ctx2);
            if_block.c();
            if_block.m(div, t);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if (if_block) if_block.d();
      }
    };
  }
  __name(create_each_block$n, "create_each_block$n");
  function create_fragment$12(ctx) {
    let each_1_anchor;
    let each_value = ensure_array_like(["warning", "correct"]);
    let each_blocks = [];
    for (let i = 0; i < 2; i += 1) {
      each_blocks[i] = create_each_block$n(get_each_context$n(ctx, each_value, i));
    }
    return {
      c() {
        for (let i = 0; i < 2; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < 2; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*$guess*/
        1) {
          each_value = ensure_array_like(["warning", "correct"]);
          let i;
          for (i = 0; i < 2; i += 1) {
            const child_ctx = get_each_context$n(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$n(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          for (; i < 2; i += 1) {
            each_blocks[i].d(1);
          }
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_fragment$12, "create_fragment$12");
  function instance$Y($$self, $$props, $$invalidate) {
    let $guess;
    let { feature } = $$props;
    const guess = feature.guessChangedStore;
    component_subscribe($$self, guess, (value) => $$invalidate(0, $guess = value));
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(2, feature = $$props2.feature);
    };
    return [$guess, guess, feature];
  }
  __name(instance$Y, "instance$Y");
  const _Guess_check = class _Guess_check extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$Y, create_fragment$12, safe_not_equal, { feature: 2 });
    }
  };
  __name(_Guess_check, "Guess_check");
  let Guess_check = _Guess_check;
  var __defProp$C = Object.defineProperty;
  var __decorateClass$C = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$C(target, key2, result);
    return result;
  }, "__decorateClass$C");
  const _GuessCheckFeature = class _GuessCheckFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_chatTypedEventListener");
      __publicField(this, "_lobbyLeftEventListener");
      __publicField(this, "_drawingService");
      __publicField(this, "name", "Guess Check");
      __publicField(this, "description", "Shows an overlay over the word hints to compare your current guess");
      __publicField(this, "tags", [
        FeatureTag.GAMEPLAY
      ]);
      __publicField(this, "featureId", 18);
      __publicField(this, "_component");
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._component = new Guess_check({
        target: elements2.hints,
        props: {
          feature: this
        }
      });
    }
    onDestroy() {
      var _a2;
      (_a2 = this._component) == null ? void 0 : _a2.$destroy();
    }
    /**
     * emits data every time the user types or the hint changes
     */
    get guessChangedStore() {
      const events = this._chatTypedEventListener.events$.pipe(
        mergeWith(this._lobbyLeftEventListener.events$.pipe(
          /* reset when lobby left */
          map(() => null)
        )),
        map((event) => (event == null ? void 0 : event.data) ?? ""),
        distinctUntilChanged(),
        combineLatestWith(this._drawingService.imageState$.pipe(
          map((image) => {
            if (image === null || image.word.solution !== void 0) return null;
            return image.word.hints;
          }),
          distinctUntilChanged()
        )),
        map(([guess, hints]) => hints === null ? null : {
          guess,
          hints,
          overlayContent: getOverlayContent(guess, hints)
        }),
        tap((data) => this._logger.debug("Guess Check data update", data))
      );
      return fromObservable(events, null);
    }
  };
  __name(_GuessCheckFeature, "GuessCheckFeature");
  let GuessCheckFeature = _GuessCheckFeature;
  __decorateClass$C([
    inject(ElementsSetup)
  ], GuessCheckFeature.prototype, "_elementsSetup");
  __decorateClass$C([
    inject(ChatTypedEventListener)
  ], GuessCheckFeature.prototype, "_chatTypedEventListener");
  __decorateClass$C([
    inject(LobbyLeftEventListener)
  ], GuessCheckFeature.prototype, "_lobbyLeftEventListener");
  __decorateClass$C([
    inject(DrawingService)
  ], GuessCheckFeature.prototype, "_drawingService");
  const _HotkeysFeature = class _HotkeysFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "name", "Hotkeys");
      __publicField(this, "description", "Activate actions of features with key combinations");
      __publicField(this, "tags", [
        FeatureTag.GAMEPLAY
      ]);
      __publicField(this, "featureId", 25);
      __publicField(this, "_pressedKeys", /* @__PURE__ */ new Set());
      __publicField(this, "_releaseCandidates", /* @__PURE__ */ new Set());
      __publicField(this, "_keysReleased$", new Subject$1());
      __publicField(this, "_keysPressed$", new Subject$1());
      __publicField(this, "_pressedSubscription");
      __publicField(this, "_releasedSubscription");
      __publicField(this, "keydownListener", this.handleKeydown.bind(this));
      __publicField(this, "keyupListener", this.handleKeyup.bind(this));
      __publicField(this, "visibilityChangeListener", this.handleDocumentVisibilityChange.bind(this));
      __publicField(this, "inactiveListener", this.handleDocumentInactive.bind(this));
    }
    async onActivate() {
      document.addEventListener("keydown", this.keydownListener);
      document.addEventListener("keyup", this.keyupListener);
      document.addEventListener("visibilitychange", this.visibilityChangeListener);
      window.addEventListener("blur", this.inactiveListener);
      this._pressedSubscription = this._keysPressed$.pipe(
        tap((keys) => this._logger.debug("Keys pressed", keys)),
        distinctUntilChanged((a, b) => a.length === b.length && a.every((v, i) => v === b[i]))
      ).subscribe((keys) => {
        var _a2;
        this._logger.info("Keys pressed event", keys);
        const hotkeys = this._hotkeysService.registeredHotkeys;
        const inputActive = ((_a2 = document.activeElement) == null ? void 0 : _a2.tagName) === "INPUT";
        forkJoin(hotkeys.map((h) => this._releaseCandidates.has(h) ? of({ executed: false, hotkey: h }) : h.executeIfMatches(keys, inputActive).pipe(
          tap((executed) => {
            if (executed) {
              this._releaseCandidates.add(h);
            }
          }),
          map((executed) => ({ hotkey: h, executed }))
        ))).subscribe((result) => {
          const executed = result.filter((r) => r.executed);
          if (executed.length > 0) this._logger.info("Executed hotkeys", executed.map((r) => r.hotkey.name));
        });
      });
      this._releasedSubscription = this._keysReleased$.subscribe((keys) => {
        this._logger.info("Keys released", keys);
        this._releaseCandidates.forEach((hotkey) => {
          hotkey.releaseIfNotMatches(keys).subscribe((released) => {
            if (released) {
              this._releaseCandidates.delete(hotkey);
              this._logger.info("Released hotkey", hotkey.name);
            }
          });
        });
      });
    }
    async onDestroy() {
      var _a2, _b2;
      document.removeEventListener("keydown", this.keydownListener);
      document.removeEventListener("keyup", this.keyupListener);
      document.removeEventListener("visibilitychange", this.visibilityChangeListener);
      window.removeEventListener("blur", this.inactiveListener);
      window.removeEventListener("focusout", this.inactiveListener);
      (_a2 = this._pressedSubscription) == null ? void 0 : _a2.unsubscribe();
      this._pressedSubscription = void 0;
      (_b2 = this._releasedSubscription) == null ? void 0 : _b2.unsubscribe();
      this._releasedSubscription = void 0;
    }
    handleKeydown(event) {
      if (event.altKey) {
        this._logger.debug("Alt key pressed; preventing default");
        event.preventDefault();
      }
      this._logger.debug("Keydown", event.code);
      this._pressedKeys.add(event.code);
      this._keysPressed$.next([...this._pressedKeys]);
    }
    handleKeyup(event) {
      this._logger.debug("Keyup", event.code);
      this._pressedKeys.delete(event.code);
      this._keysReleased$.next([...this._pressedKeys]);
      this._keysPressed$.next([...this._pressedKeys]);
    }
    handleDocumentVisibilityChange() {
      if (!document.hidden) return;
      this._logger.info("Document hidden; releasing all keys");
      const released = [...this._pressedKeys];
      this._pressedKeys.clear();
      this._keysReleased$.next(released);
      this._keysPressed$.next([]);
    }
    handleDocumentInactive() {
      this._logger.info("Document inactive; releasing all keys");
      const released = [...this._pressedKeys];
      this._pressedKeys.clear();
      this._keysReleased$.next(released);
      this._keysPressed$.next([]);
    }
  };
  __name(_HotkeysFeature, "HotkeysFeature");
  let HotkeysFeature = _HotkeysFeature;
  function create_catch_block$2(ctx) {
    return {
      c: noop,
      m: noop,
      p: noop,
      i: noop,
      o: noop,
      d: noop
    };
  }
  __name(create_catch_block$2, "create_catch_block$2");
  function create_then_block$2(ctx) {
    let if_block_anchor;
    let if_block = (
      /*imageIndex*/
      ctx[1] !== void 0 && /*images*/
      ctx[2].length > 0 && create_if_block$o(ctx)
    );
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (
          /*imageIndex*/
          ctx2[1] !== void 0 && /*images*/
          ctx2[2].length > 0
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$o(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
      }
    };
  }
  __name(create_then_block$2, "create_then_block$2");
  function create_if_block$o(ctx) {
    let img;
    let img_src_value;
    let mounted;
    let dispose;
    function mousedown_handler(...args) {
      return (
        /*mousedown_handler*/
        ctx[8](
          /*images*/
          ctx[2],
          ...args
        )
      );
    }
    __name(mousedown_handler, "mousedown_handler");
    return {
      c() {
        var _a2;
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = /*images*/
        ((_a2 = ctx[2]) == null ? void 0 : _a2[
          /*imageIndex*/
          ctx[1] ?? 0
        ]) ?? "")) attr(img, "src", img_src_value);
        attr(img, "alt", "Image Agent Result");
        attr(img, "class", "svelte-z5nxkg");
      },
      m(target, anchor) {
        insert(target, img, anchor);
        if (!mounted) {
          dispose = [
            listen(img, "contextmenu", contextmenu_handler),
            listen(img, "mousedown", mousedown_handler)
          ];
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        var _a2;
        ctx = new_ctx;
        if (dirty & /*images, imageIndex*/
        6 && !src_url_equal(img.src, img_src_value = /*images*/
        ((_a2 = ctx[2]) == null ? void 0 : _a2[
          /*imageIndex*/
          ctx[1] ?? 0
        ]) ?? "")) {
          attr(img, "src", img_src_value);
        }
      },
      d(detaching) {
        if (detaching) {
          detach(img);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_if_block$o, "create_if_block$o");
  function create_pending_block$2(ctx) {
    let bounceload;
    let current;
    bounceload = new Bounceload({});
    return {
      c() {
        create_component(bounceload.$$.fragment);
      },
      m(target, anchor) {
        mount_component(bounceload, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(bounceload, detaching);
      }
    };
  }
  __name(create_pending_block$2, "create_pending_block$2");
  function create_fragment$11(ctx) {
    let div1;
    let div0;
    let input;
    let t;
    let promise;
    let current;
    let mounted;
    let dispose;
    let info = {
      ctx,
      current: null,
      token: null,
      hasCatch: false,
      pending: create_pending_block$2,
      then: create_then_block$2,
      catch: create_catch_block$2,
      value: 2,
      blocks: [, , ,]
    };
    handle_promise(promise = /*images*/
    ctx[2], info);
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        input = element("input");
        t = space();
        info.block.c();
        attr(input, "type", "text");
        attr(input, "class", "typo svelte-z5nxkg");
        attr(input, "placeholder", "Custom image name");
        attr(div0, "class", "agent-inputs svelte-z5nxkg");
        attr(div1, "class", "agent-content svelte-z5nxkg");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div0, input);
        set_input_value(
          input,
          /*textInput*/
          ctx[0]
        );
        append(div1, t);
        info.block.m(div1, info.anchor = null);
        info.mount = () => div1;
        info.anchor = null;
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              input,
              "input",
              /*input_input_handler*/
              ctx[6]
            ),
            listen(
              input,
              "keydown",
              /*keydown_handler*/
              ctx[7]
            )
          ];
          mounted = true;
        }
      },
      p(new_ctx, [dirty]) {
        ctx = new_ctx;
        if (dirty & /*textInput*/
        1 && input.value !== /*textInput*/
        ctx[0]) {
          set_input_value(
            input,
            /*textInput*/
            ctx[0]
          );
        }
        info.ctx = ctx;
        if (dirty & /*images*/
        4 && promise !== (promise = /*images*/
        ctx[2]) && handle_promise(promise, info)) ;
        else {
          update_await_block_branch(info, ctx, dirty);
        }
      },
      i(local) {
        if (current) return;
        transition_in(info.block);
        current = true;
      },
      o(local) {
        for (let i = 0; i < 3; i += 1) {
          const block2 = info.blocks[i];
          transition_out(block2);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        info.block.d();
        info.token = null;
        info = null;
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$11, "create_fragment$11");
  const contextmenu_handler = /* @__PURE__ */ __name((event) => event.preventDefault(), "contextmenu_handler");
  function instance$X($$self, $$props, $$invalidate) {
    let images;
    let $word;
    let { feature } = $$props;
    const word = feature.wordStore;
    component_subscribe($$self, word, (value) => $$invalidate(5, $word = value));
    let textInput = void 0;
    let imageIndex = void 0;
    function input_input_handler() {
      textInput = this.value;
      $$invalidate(0, textInput), $$invalidate(5, $word);
    }
    __name(input_input_handler, "input_input_handler");
    const keydown_handler2 = /* @__PURE__ */ __name((event) => {
      if (event.key === "Enter") word.set(textInput);
    }, "keydown_handler");
    const mousedown_handler = /* @__PURE__ */ __name((images2, event) => {
      if (imageIndex !== void 0 && event.button === 2) $$invalidate(1, imageIndex = imageIndex === 0 ? images2.length - 1 : imageIndex - 1);
      else if (imageIndex !== void 0 && event.button === 0) $$invalidate(1, imageIndex = imageIndex === images2.length - 1 ? 0 : imageIndex + 1);
    }, "mousedown_handler");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(4, feature = $$props2.feature);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*$word*/
      32) {
        $$invalidate(0, textInput = $word ?? void 0);
      }
      if ($$self.$$.dirty & /*$word*/
      32) {
        $$invalidate(1, imageIndex = $word ? 0 : 0);
      }
      if ($$self.$$.dirty & /*$word, feature*/
      48) {
        $$invalidate(2, images = $word ? feature.getImages($word) : []);
      }
    };
    return [
      textInput,
      imageIndex,
      images,
      word,
      feature,
      $word,
      input_input_handler,
      keydown_handler2,
      mousedown_handler
    ];
  }
  __name(instance$X, "instance$X");
  const _Image_agent_flyout = class _Image_agent_flyout extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$X, create_fragment$11, safe_not_equal, { feature: 4 });
    }
  };
  __name(_Image_agent_flyout, "Image_agent_flyout");
  let Image_agent_flyout = _Image_agent_flyout;
  var __defProp$B = Object.defineProperty;
  var __decorateClass$B = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$B(target, key2, result);
    return result;
  }, "__decorateClass$B");
  const _ImageAgentFeature = class _ImageAgentFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_lobbyService");
      __publicField(this, "_drawingService");
      __publicField(this, "_autoOpenOwnTurnSetting", new ExtensionSetting("autoOpenOwnTurn", true, this));
      __publicField(this, "_iconElement");
      __publicField(this, "_flyoutComponent");
      __publicField(this, "_iconClickSubscription");
      __publicField(this, "_flyoutSubscription");
      __publicField(this, "_activationSubscription");
      __publicField(this, "name", "Image Agent");
      __publicField(this, "description", "Displays a reference image of the word when it's your turn to draw");
      __publicField(this, "featureId", 14);
      __publicField(this, "tags", [
        FeatureTag.DRAWING
      ]);
      __publicField(this, "featureEnabledDefault", false);
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._iconElement = new Icon_button({
        target: elements2.chatControls,
        props: {
          icon: "file-img-light-gif",
          name: "Image Agent",
          order: 1,
          size: "2rem",
          hoverMove: false,
          greyscaleInactive: true,
          tooltipAction: this.createTooltip
        }
      });
      this._iconClickSubscription = this._iconElement.click$.pipe(
        withLatestFrom(this._drawingService.drawingState$)
        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
      ).subscribe(([, state]) => {
        this.setAgentVisibility(true);
        if (state === "drawing") this._autoOpenOwnTurnSetting.setValue(true);
      });
      this.listenForActivation();
    }
    onDestroy() {
      var _a2, _b2, _c2, _d2, _e2;
      (_a2 = this._flyoutComponent) == null ? void 0 : _a2.$destroy();
      this._flyoutComponent = void 0;
      (_b2 = this._iconElement) == null ? void 0 : _b2.$destroy();
      this._iconElement = void 0;
      (_c2 = this._iconClickSubscription) == null ? void 0 : _c2.unsubscribe();
      this._iconClickSubscription = void 0;
      (_d2 = this._flyoutSubscription) == null ? void 0 : _d2.unsubscribe();
      this._flyoutSubscription = void 0;
      (_e2 = this._activationSubscription) == null ? void 0 : _e2.unsubscribe();
      this._activationSubscription = void 0;
    }
    get isOpen() {
      return this._flyoutComponent !== void 0;
    }
    get wordStore() {
      const ownWordChanges = this._drawingService.drawingState$.pipe(
        delay(100),
        /* delay so that no race condition between latest occurs */
        withLatestFrom(this._lobbyService.lobby$, this._drawingService.imageState$),
        map(([state, lobby, image]) => {
          if (state === "idle" || lobby === null || image === null) return null;
          return image.word.solution ?? null;
        }),
        tap((word) => this._logger.debug("Word change", word))
      );
      return fromObservable(ownWordChanges, null);
    }
    async getImages(word) {
      return await (await fetch(`https://agent.typo.rip/${word}`)).json();
    }
    listenForActivation() {
      this._activationSubscription = this._drawingService.drawingState$.pipe(
        tap(() => this._logger.debug("Hidden setting changed")),
        withLatestFrom(this._lobbyService.lobby$, this._drawingService.imageState$, this._autoOpenOwnTurnSetting.changes$)
      ).subscribe(async ([state, lobby, image, autoOpen]) => {
        if (lobby === null || image === null || state === "idle") {
          await this.setAgentVisibility(false);
        }
        if (!this.isOpen) {
          if (autoOpen && state === "drawing") {
            await this.setAgentVisibility(true);
          }
        }
      });
    }
    async setAgentVisibility(visible) {
      var _a2;
      if (!visible) {
        if (this._flyoutComponent) {
          (_a2 = this._flyoutComponent) == null ? void 0 : _a2.close();
        }
      } else {
        const elements2 = await this._elementsSetup.complete();
        const flyoutContent = {
          componentType: Image_agent_flyout,
          props: {
            feature: this
          }
        };
        this._flyoutComponent = new Area_flyout({
          target: elements2.gameWrapper,
          props: {
            componentData: flyoutContent,
            areaName: "chat",
            maxHeight: "600px",
            maxWidth: "300px",
            title: "Image Agent",
            closeStrategy: "explicit",
            iconName: "file-img-light-gif",
            alignment: "top",
            contentPadding: false
          }
        });
        this._flyoutSubscription = this._flyoutComponent.closed$.subscribe(() => {
          var _a3, _b2;
          this._logger.info("Destroyed flyout");
          (_a3 = this._flyoutComponent) == null ? void 0 : _a3.$destroy();
          (_b2 = this._flyoutSubscription) == null ? void 0 : _b2.unsubscribe();
          this._flyoutComponent = void 0;
          this._autoOpenOwnTurnSetting.setValue(false);
        });
      }
    }
  };
  __name(_ImageAgentFeature, "ImageAgentFeature");
  let ImageAgentFeature = _ImageAgentFeature;
  __decorateClass$B([
    inject(ElementsSetup)
  ], ImageAgentFeature.prototype, "_elementsSetup");
  __decorateClass$B([
    inject(LobbyService)
  ], ImageAgentFeature.prototype, "_lobbyService");
  __decorateClass$B([
    inject(DrawingService)
  ], ImageAgentFeature.prototype, "_drawingService");
  function create_fragment$10(ctx) {
    let t0;
    let br0;
    let t1;
    let br1;
    let t2;
    let br2;
    let br3;
    let t3;
    let br4;
    let br5;
    let t4;
    let br6;
    return {
      c() {
        t0 = text("The Line Tool helps you draw perfectly straight lines on the canvas. ");
        br0 = element("br");
        t1 = text("\nTo start the tool, press the configured start hotkey and keep it down. ");
        br1 = element("br");
        t2 = text("\nThe tool can only be used when you are drawing. ");
        br2 = element("br");
        br3 = element("br");
        t3 = text("\nNow, you can drag lines onto the canvas by pressing the mouse button and releasing it somewhere else. ");
        br4 = element("br");
        br5 = element("br");
        t4 = text("\nYou can also use the Line Tool to connect click positions; to do so, simply click two or more points on the canvas with the mouse to connect them.");
        br6 = element("br");
      },
      m(target, anchor) {
        insert(target, t0, anchor);
        insert(target, br0, anchor);
        insert(target, t1, anchor);
        insert(target, br1, anchor);
        insert(target, t2, anchor);
        insert(target, br2, anchor);
        insert(target, br3, anchor);
        insert(target, t3, anchor);
        insert(target, br4, anchor);
        insert(target, br5, anchor);
        insert(target, t4, anchor);
        insert(target, br6, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(br0);
          detach(t1);
          detach(br1);
          detach(t2);
          detach(br2);
          detach(br3);
          detach(t3);
          detach(br4);
          detach(br5);
          detach(t4);
          detach(br6);
        }
      }
    };
  }
  __name(create_fragment$10, "create_fragment$10");
  const _Line_tool_info = class _Line_tool_info extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment$10, safe_not_equal, {});
    }
  };
  __name(_Line_tool_info, "Line_tool_info");
  let Line_tool_info = _Line_tool_info;
  var __defProp$A = Object.defineProperty;
  var __decorateClass$A = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$A(target, key2, result);
    return result;
  }, "__decorateClass$A");
  const _LineToolFeature = class _LineToolFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_toastService");
      __publicField(this, "_prioritizedCanvasEventsSetup");
      __publicField(this, "_elementsSetup");
      __publicField(this, "_lobbyService");
      __publicField(this, "_drawingService");
      __publicField(this, "_toolsService");
      __publicField(this, "name", "Line Tool");
      __publicField(this, "description", "Draw straight lines between two points");
      __publicField(this, "tags", [
        FeatureTag.DRAWING
      ]);
      __publicField(this, "featureId", 27);
      __publicField(this, "_startLineHotkey", this.useHotkey(
        new HotkeyAction(
          "start_line",
          "Start Line",
          "While pressed, straight lines can be drawn. Press twice to enable horizontal/vertical snap.",
          this,
          () => {
            this._originCoordinates$.next(void 0);
            this._targetCoordinates$.next(void 0);
            this._lineListenToggle$.next(true);
          },
          true,
          ["ShiftLeft"],
          () => {
            this._lineListenToggle$.next(false);
          }
        )
      ));
      __publicField(this, "_lineListenToggle$", new BehaviorSubject(false));
      __publicField(this, "_originCoordinates$", new BehaviorSubject(void 0));
      __publicField(this, "_targetCoordinates$", new BehaviorSubject(void 0));
      __publicField(this, "_lineAccept$", new Subject$1());
      __publicField(this, "_toastHandle");
      __publicField(this, "_lineStateSubscription");
      __publicField(this, "_linePreview");
      __publicField(this, "_canvasClickListener", this.onCanvasDown.bind(this));
      __publicField(this, "_canvasMoveListener", this.onCanvasMove.bind(this));
      __publicField(this, "_documentUpListener", this.onDocumentUp.bind(this));
    }
    get featureInfoComponent() {
      return { componentType: Line_tool_info, props: {} };
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._linePreview = document.createElement("canvas");
      this._linePreview.width = elements2.canvas.width;
      this._linePreview.height = elements2.canvas.height;
      this._linePreview.style.position = "absolute";
      this._linePreview.style.pointerEvents = "none";
      elements2.canvasWrapper.appendChild(this._linePreview);
      const { add } = await this._prioritizedCanvasEventsSetup.complete();
      add("preDraw")("pointerdown", this._canvasClickListener);
      add("preDraw")("pointermove", this._canvasMoveListener);
      document.addEventListener("pointerup", this._documentUpListener);
      const listenPipe$ = this._lineListenToggle$.pipe(
        exhaustMap((value) => {
          if (!value) return of("disabled");
          else
            return of("free").pipe(
              mergeWith(
                this._lineListenToggle$.pipe(
                  filter((v) => v),
                  skip(1),
                  take(1),
                  map(() => "snap"),
                  timeout(500),
                  catchError(
                    () => this._lineListenToggle$.pipe(
                      take(1),
                      map(
                        (state) => state ? "free" : "disabled"
                      )
                    )
                  )
                )
              )
            );
        }),
        distinctUntilChanged(),
        combineLatestWith(this._lobbyService.lobby$.pipe(map((lobby) => ((lobby == null ? void 0 : lobby.drawerId) ?? void 0) !== void 0 && (lobby == null ? void 0 : lobby.drawerId) === (lobby == null ? void 0 : lobby.meId)))),
        map(([mode, isDrawer]) => isDrawer ? mode : "disabled"),
        distinctUntilChanged(),
        tap((mode) => this._logger.info("Mode changed", mode))
      );
      const originPipe$ = this._originCoordinates$.pipe(
        withLatestFrom(this._lineListenToggle$),
        map(([origin, listening]) => listening ? origin : void 0),
        distinctUntilChanged(),
        tap((origin) => this._logger.debug("Origin changed", origin))
      );
      const targetPipe$ = this._targetCoordinates$.pipe(
        withLatestFrom(listenPipe$, originPipe$),
        map(
          ([target, mode, origin]) => mode == "disabled" || origin === void 0 || target === void 0 ? void 0 : mode === "free" ? target : this.calculateSnap(origin, target)
        ),
        distinctUntilChanged(),
        tap((target) => this._logger.debug("Target changed", target))
      );
      this._lineStateSubscription = listenPipe$.pipe(
        combineLatestWith(originPipe$, targetPipe$),
        startWith(["disabled", void 0, void 0]),
        pairwise(),
        /* update ui */
        withLatestFrom(this._toolsService.activeBrushStyle$),
        tap(([[prev, current], style2]) => this.processUiStateUpdate(prev, current, style2)),
        map(([[, current]]) => current),
        /* map to current and emit only when line accepted */
        debounce(() => this._lineAccept$.pipe(take(1), tap(() => this._logger.debug("Line accept debounce emitted")))),
        startWith(["disabled", void 0, void 0])
      ).pipe(
        pairwise(),
        tap((data) => this._logger.debug("Line accepted", data))
      ).subscribe(async ([[, prevOrigin, prevTarget], [listening, origin, target]]) => {
        if (!origin || listening === "disabled") {
          return;
        }
        this._logger.info("Line accepted", origin, target);
        if (target === void 0 || target[0] === origin[0] && target[1] === origin[1]) {
          this._logger.info(
            "Line accepted without or same target - connecting with last origin or target, if existing",
            origin,
            target
          );
          if (prevTarget) {
            this._logger.info("Connecting with last drag end", prevTarget);
            await this.drawLine(prevTarget, origin);
          } else if (prevOrigin) {
            this._logger.info("Connecting with last click", prevOrigin);
            await this.drawLine(prevOrigin, origin);
          } else {
            this._logger.info("No previous line to connect to; waiting for next");
          }
          this._originCoordinates$.next(void 0);
        } else {
          await this.drawLine(origin, target);
        }
      });
    }
    async onDestroy() {
      var _a2, _b2, _c2;
      const { remove } = await this._prioritizedCanvasEventsSetup.complete();
      remove("pointerdown", this._canvasClickListener);
      remove("pointermove", this._canvasMoveListener);
      document.removeEventListener("pointerup", this._documentUpListener);
      (_a2 = this._linePreview) == null ? void 0 : _a2.remove();
      this._linePreview = void 0;
      (_b2 = this._toastHandle) == null ? void 0 : _b2.close();
      (_c2 = this._lineStateSubscription) == null ? void 0 : _c2.unsubscribe();
      this._lineStateSubscription = void 0;
      this._toastHandle = void 0;
      this._lineListenToggle$.next(false);
      this._originCoordinates$.next(void 0);
      this._targetCoordinates$.next(void 0);
    }
    /**
     * Transforms a line to snap either on horizontal or vertical axis, depending on the longer distance
     * @param origin
     * @param target
     * @private
     */
    calculateSnap(origin, target) {
      const dx = target[0] - origin[0];
      const dy = target[1] - origin[1];
      if (Math.abs(dx) > 2 * Math.abs(dy)) {
        return [target[0], origin[1]];
      }
      if (Math.abs(dy) > 2 * Math.abs(dx)) {
        return [origin[0], target[1]];
      }
      if (Math.abs(dx) > Math.abs(dy)) {
        return [origin[0] + Math.sign(dx) * Math.abs(dy), origin[1] + dy];
      } else {
        return [origin[0] + dx, origin[1] + Math.sign(dy) * Math.abs(dx)];
      }
    }
    /**
     * Update the line preview canvas with the current line origin and target coordinates
     * @param coordinates
     * @param style
     * @private
     */
    async setPreview(coordinates, style2) {
      this._logger.debug("Updating preview", coordinates);
      if (this._linePreview === void 0) {
        this._logger.error("Line preview canvas not initialized");
        return;
      }
      if (coordinates === void 0 || coordinates[2] === void 0 || coordinates[3] === void 0) {
        this._linePreview.style.display = "none";
        return;
      }
      this._linePreview.style.display = "block";
      const ctx = this._linePreview.getContext("2d");
      if (ctx === null) {
        this._logger.error("Line preview context not found");
        return;
      }
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, this._linePreview.width, this._linePreview.height);
      ctx.lineWidth = style2.size;
      ctx.strokeStyle = Color.fromSkribblCode(style2.color).hex;
      ctx.beginPath();
      ctx.moveTo(coordinates[0], coordinates[1]);
      ctx.lineTo(coordinates[2], coordinates[3]);
      ctx.stroke();
    }
    /**
     * Listener when pointer clicked on canvas; sets current line origin
     * @param event
     * @private
     */
    onCanvasDown(event) {
      this._logger.debug("Canvas clicked", event);
      if (this._lineListenToggle$.value) {
        const canvas = event.target;
        canvas.setPointerCapture(event.pointerId);
        event.preventDefault();
        event.stopImmediatePropagation();
        const boundingRect = canvas.getBoundingClientRect();
        const realX = canvas.width * event.offsetX / boundingRect.width;
        const realY = canvas.height * event.offsetY / boundingRect.height;
        this._originCoordinates$.next([realX, realY]);
        return false;
      }
    }
    /**
     * Listener when pointer moved on document; updates current line target
     * @param event
     * @private
     */
    async onCanvasMove(event) {
      if (this._lineListenToggle$.value) {
        this._logger.debug("Document pointer moved", event);
        const canvas = (await this._elementsSetup.complete()).canvas;
        const boundingRect = canvas.getBoundingClientRect();
        const offsetX = canvas.width * (event.clientX - boundingRect.left) / boundingRect.width;
        const offsetY = canvas.height * (event.clientY - boundingRect.top) / boundingRect.height;
        this._targetCoordinates$.next([offsetX, offsetY]);
      }
    }
    /**
     * Listener when pointer released on document; accepts current line preview
     * @param event
     * @private
     */
    async onDocumentUp(event) {
      this._logger.debug("Document pointer up", event);
      this._lineAccept$.next(true);
    }
    /**
     * Update the toast ui depending on the tool state
     * @param prevListening
     * @param prevOrigin
     * @param prevTarget
     * @param listening
     * @param origin
     * @param target
     * @param style
     * @private
     */
    async processUiStateUpdate([prevListening, prevOrigin, prevTarget], [listening, origin, target], style2) {
      var _a2;
      this._logger.debug(
        "Line state processing",
        { prevListening, prevOrigin, prevTarget },
        { listening, origin, target },
        this._toastHandle
      );
      await this.setPreview(
        listening !== "disabled" && origin !== void 0 ? [...origin, ...target ?? [void 0, void 0]] : void 0,
        style2
      );
      if (prevListening === "disabled" && listening !== "disabled") {
        if (this._toastHandle) {
          this._logger.warn("Toast handle unexpected existing when entering line tool");
          this._toastHandle.close();
        }
        this._toastHandle = await this._toastService.showStickyToast(
          "Line Tool: " + (listening === "snap" ? "Snap" : "Free"),
          "Click to start line, release to finish"
        );
      } else if (prevListening !== "disabled" && listening !== "disabled" && listening !== prevListening) {
        if (!this._toastHandle) {
          this._logger.error("Toast handle unexpected not existing when changing mode", {
            prevListening,
            listening
          });
          return;
        }
        this._toastHandle.update(
          "Line Tool: " + (listening === "snap" ? "Snap" : "Free"),
          "Click to start line, release to finish"
        );
      } else if (prevListening !== "disabled" && listening === "disabled") {
        if (!this._toastHandle) {
          this._logger.warn("Toast handle unexpected not existing when exiting line tool");
        }
        (_a2 = this._toastHandle) == null ? void 0 : _a2.close();
        this._toastHandle = void 0;
      }
    }
    /**
     * Draw a line and reset current selected coordinates
     * @param origin
     * @param target
     * @private
     */
    async drawLine(origin, target) {
      if (!origin || !target) return;
      const strokeId = Date.now();
      this._toolsService.insertStroke({ from: origin, to: origin, stroke: strokeId, cause: "down" });
      this._toolsService.insertStroke({ from: origin, to: target, stroke: strokeId, cause: "move" });
      this._toolsService.insertStroke({ from: target, to: target, stroke: strokeId, cause: "up" });
      this._originCoordinates$.next(void 0);
      this._targetCoordinates$.next(void 0);
    }
  };
  __name(_LineToolFeature, "LineToolFeature");
  let LineToolFeature = _LineToolFeature;
  __decorateClass$A([
    inject(ToastService)
  ], LineToolFeature.prototype, "_toastService");
  __decorateClass$A([
    inject(PrioritizedCanvasEventsSetup)
  ], LineToolFeature.prototype, "_prioritizedCanvasEventsSetup");
  __decorateClass$A([
    inject(ElementsSetup)
  ], LineToolFeature.prototype, "_elementsSetup");
  __decorateClass$A([
    inject(LobbyService)
  ], LineToolFeature.prototype, "_lobbyService");
  __decorateClass$A([
    inject(DrawingService)
  ], LineToolFeature.prototype, "_drawingService");
  __decorateClass$A([
    inject(ToolsService)
  ], LineToolFeature.prototype, "_toolsService");
  function repeatAfterDelay(source$, delayMs) {
    return source$.pipe(
      // If no new value is emitted within the delay period, restart with the last emitted value
      timeout({ each: delayMs, with: /* @__PURE__ */ __name(() => source$.pipe(takeUntil(timer(delayMs))), "with") }),
      // Repeat when a timeout occurs
      repeat({ delay: /* @__PURE__ */ __name(() => timer(delayMs), "delay") })
    );
  }
  __name(repeatAfterDelay, "repeatAfterDelay");
  function get_each_context$m(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[16] = list[i];
    child_ctx[17] = list;
    child_ctx[18] = i;
    return child_ctx;
  }
  __name(get_each_context$m, "get_each_context$m");
  function create_else_block$e(ctx) {
    let flatbutton;
    let t0;
    let span;
    let current;
    flatbutton = new Flat_button({
      props: {
        content: "Pause Connection",
        color: "blue"
      }
    });
    flatbutton.$on(
      "click",
      /*click_handler_1*/
      ctx[9]
    );
    return {
      c() {
        create_component(flatbutton.$$.fragment);
        t0 = space();
        span = element("span");
        span.innerHTML = `<b>Lobby Connected:</b> Your lobby is connected to typo and will be visible on Discord.<br/>`;
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        insert(target, t0, anchor);
        insert(target, span, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(span);
        }
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_else_block$e, "create_else_block$e");
  function create_if_block_6(ctx) {
    let flatbutton;
    let t0;
    let span;
    let current;
    flatbutton = new Flat_button({
      props: {
        content: "Resume Connection",
        color: "blue"
      }
    });
    flatbutton.$on(
      "click",
      /*click_handler*/
      ctx[8]
    );
    return {
      c() {
        create_component(flatbutton.$$.fragment);
        t0 = space();
        span = element("span");
        span.innerHTML = `<b>Connection paused:</b>
        Your lobby is currently not visible on Discord.<br/>
        You are incognito and no data is sent, but your sprites and scenes won&#39;t show up.<br/>
        Drops won&#39;t appear and you won&#39;t be able to give or receive awards.`;
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        insert(target, t0, anchor);
        insert(target, span, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(span);
        }
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block_6, "create_if_block_6");
  function create_if_block_5$3(ctx) {
    let span;
    return {
      c() {
        span = element("span");
        span.innerHTML = `<b>Log-in required:</b> You need to log in with typo to use the lobby status feature.<br/>`;
      },
      m(target, anchor) {
        insert(target, span, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  __name(create_if_block_5$3, "create_if_block_5$3");
  function create_if_block_4$6(ctx) {
    let bounceload;
    let current;
    bounceload = new Bounceload({
      props: { content: "Connecting lobby..." }
    });
    return {
      c() {
        create_component(bounceload.$$.fragment);
      },
      m(target, anchor) {
        mount_component(bounceload, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(bounceload, detaching);
      }
    };
  }
  __name(create_if_block_4$6, "create_if_block_4$6");
  function create_if_block_3$6(ctx) {
    let div2;
    let span;
    let t1;
    let div0;
    let b0;
    let t3;
    let input;
    let t4;
    let div1;
    let b1;
    let t6;
    let checkbox;
    let updating_checked;
    let t7;
    let t8;
    let flatbutton;
    let current;
    let mounted;
    let dispose;
    function checkbox_checked_binding(value) {
      ctx[11](value);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    let checkbox_props = { description: "Share link on all servers" };
    if (
      /*lobbyDisableWhitelistAllowedServers*/
      ctx[2] !== void 0
    ) {
      checkbox_props.checked = /*lobbyDisableWhitelistAllowedServers*/
      ctx[2];
    }
    checkbox = new Checkbox({ props: checkbox_props });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
    let each_value = ensure_array_like(
      /*$connection*/
      ctx[4].member.guilds
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$m(get_each_context$m(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    flatbutton = new Flat_button({
      props: { content: "Save Settings", color: "green" }
    });
    flatbutton.$on(
      "click",
      /*click_handler_2*/
      ctx[13]
    );
    return {
      c() {
        div2 = element("div");
        span = element("span");
        span.textContent = "You are the typo lobby owner. Only you can change these settings.";
        t1 = space();
        div0 = element("div");
        b0 = element("b");
        b0.textContent = "Lobby Description:";
        t3 = space();
        input = element("input");
        t4 = space();
        div1 = element("div");
        b1 = element("b");
        b1.textContent = "Lobby Link Privacy:";
        t6 = space();
        create_component(checkbox.$$.fragment);
        t7 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t8 = space();
        create_component(flatbutton.$$.fragment);
        attr(input, "type", "text");
        attr(input, "placeholder", "Description in the Palantir Bot");
        attr(div2, "class", "status-settings svelte-1y63bp4");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, span);
        append(div2, t1);
        append(div2, div0);
        append(div0, b0);
        append(div0, t3);
        append(div0, input);
        set_input_value(
          input,
          /*lobbyDescription*/
          ctx[1]
        );
        append(div2, t4);
        append(div2, div1);
        append(div1, b1);
        append(div1, t6);
        mount_component(checkbox, div1, null);
        append(div1, t7);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div1, null);
          }
        }
        append(div2, t8);
        mount_component(flatbutton, div2, null);
        current = true;
        if (!mounted) {
          dispose = listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[10]
          );
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*lobbyDescription*/
        2 && input.value !== /*lobbyDescription*/
        ctx2[1]) {
          set_input_value(
            input,
            /*lobbyDescription*/
            ctx2[1]
          );
        }
        const checkbox_changes = {};
        if (!updating_checked && dirty & /*lobbyDisableWhitelistAllowedServers*/
        4) {
          updating_checked = true;
          checkbox_changes.checked = /*lobbyDisableWhitelistAllowedServers*/
          ctx2[2];
          add_flush_callback(() => updating_checked = false);
        }
        checkbox.$set(checkbox_changes);
        if (dirty & /*lobbyDisableWhitelistAllowedServers, $connection, lobbyAllowedServers*/
        28) {
          each_value = ensure_array_like(
            /*$connection*/
            ctx2[4].member.guilds
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$m(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$m(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div1, null);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(checkbox.$$.fragment, local);
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(checkbox.$$.fragment, local);
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        destroy_component(checkbox);
        destroy_each(each_blocks, detaching);
        destroy_component(flatbutton);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block_3$6, "create_if_block_3$6");
  function create_each_block$m(ctx) {
    let checkbox;
    let updating_checked;
    let current;
    function checkbox_checked_binding_1(value) {
      ctx[12](
        value,
        /*guild*/
        ctx[16]
      );
    }
    __name(checkbox_checked_binding_1, "checkbox_checked_binding_1");
    let checkbox_props = {
      disabled: (
        /*lobbyDisableWhitelistAllowedServers*/
        ctx[2]
      ),
      description: (
        /*guild*/
        ctx[16].guildName
      )
    };
    if (
      /*lobbyAllowedServers*/
      ctx[3][
        /*guild*/
        ctx[16].guildID
      ] !== void 0
    ) {
      checkbox_props.checked = /*lobbyAllowedServers*/
      ctx[3][
        /*guild*/
        ctx[16].guildID
      ];
    }
    checkbox = new Checkbox({ props: checkbox_props });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));
    return {
      c() {
        create_component(checkbox.$$.fragment);
      },
      m(target, anchor) {
        mount_component(checkbox, target, anchor);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        const checkbox_changes = {};
        if (dirty & /*lobbyDisableWhitelistAllowedServers*/
        4) checkbox_changes.disabled = /*lobbyDisableWhitelistAllowedServers*/
        ctx[2];
        if (dirty & /*$connection*/
        16) checkbox_changes.description = /*guild*/
        ctx[16].guildName;
        if (!updating_checked && dirty & /*lobbyAllowedServers, $connection*/
        24) {
          updating_checked = true;
          checkbox_changes.checked = /*lobbyAllowedServers*/
          ctx[3][
            /*guild*/
            ctx[16].guildID
          ];
          add_flush_callback(() => updating_checked = false);
        }
        checkbox.$set(checkbox_changes);
      },
      i(local) {
        if (current) return;
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(checkbox, detaching);
      }
    };
  }
  __name(create_each_block$m, "create_each_block$m");
  function create_if_block_1$b(ctx) {
    let div1;
    let t0;
    let div0;
    let b;
    let br;
    let t2;
    let t3_value = (
      /*$connection*/
      ctx[4].typoLobbyState.lobbySettings.whitelistAllowedServers ? "Only on selected servers by the lobby owner" : "On all servers"
    );
    let t3;
    let if_block = (
      /*$connection*/
      ctx[4].typoLobbyState.lobbySettings.description !== "" && create_if_block_2$9(ctx)
    );
    return {
      c() {
        div1 = element("div");
        if (if_block) if_block.c();
        t0 = space();
        div0 = element("div");
        b = element("b");
        b.textContent = "Lobby Link Privacy:";
        br = element("br");
        t2 = space();
        t3 = text(t3_value);
        attr(div1, "class", "status-settings svelte-1y63bp4");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        if (if_block) if_block.m(div1, null);
        append(div1, t0);
        append(div1, div0);
        append(div0, b);
        append(div0, br);
        append(div0, t2);
        append(div0, t3);
      },
      p(ctx2, dirty) {
        if (
          /*$connection*/
          ctx2[4].typoLobbyState.lobbySettings.description !== ""
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block_2$9(ctx2);
            if_block.c();
            if_block.m(div1, t0);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & /*$connection*/
        16 && t3_value !== (t3_value = /*$connection*/
        ctx2[4].typoLobbyState.lobbySettings.whitelistAllowedServers ? "Only on selected servers by the lobby owner" : "On all servers")) set_data(t3, t3_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if (if_block) if_block.d();
      }
    };
  }
  __name(create_if_block_1$b, "create_if_block_1$b");
  function create_if_block_2$9(ctx) {
    let b;
    let br;
    let t1;
    let t2_value = (
      /*$connection*/
      ctx[4].typoLobbyState.lobbySettings.description + ""
    );
    let t2;
    return {
      c() {
        b = element("b");
        b.textContent = "Lobby Description:";
        br = element("br");
        t1 = space();
        t2 = text(t2_value);
      },
      m(target, anchor) {
        insert(target, b, anchor);
        insert(target, br, anchor);
        insert(target, t1, anchor);
        insert(target, t2, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*$connection*/
        16 && t2_value !== (t2_value = /*$connection*/
        ctx2[4].typoLobbyState.lobbySettings.description + "")) set_data(t2, t2_value);
      },
      d(detaching) {
        if (detaching) {
          detach(b);
          detach(br);
          detach(t1);
          detach(t2);
        }
      }
    };
  }
  __name(create_if_block_2$9, "create_if_block_2$9");
  function create_if_block$n(ctx) {
    var _a2, _b2;
    let div1;
    let div0;
    let b0;
    let t1;
    let t2_value = (
      /*$connection*/
      (ctx[4] === void 0 ? "/" : (
        /*$connection*/
        ctx[4] === "unauthorized" ? "not logged in" : (
          /*$connection*/
          ctx[4] === "paused" ? "paused" : (
            /*$connection*/
            (_a2 = ctx[4]) == null ? void 0 : _a2.typoLobbyState.lobbyId
          )
        )
      )) + ""
    );
    let t2;
    let t3;
    let br;
    let t4;
    let b1;
    let t6;
    let t7_value = (
      /*$connection*/
      (ctx[4] === void 0 ? "/" : (
        /*$connection*/
        ctx[4] === "unauthorized" ? "not logged in" : (
          /*$connection*/
          ctx[4] === "paused" ? "paused" : (
            /*$connection*/
            (_b2 = ctx[4]) == null ? void 0 : _b2.typoLobbyState.ownershipClaim
          )
        )
      )) + ""
    );
    let t7;
    let t8;
    let flatbutton0;
    let t9;
    let flatbutton1;
    let current;
    flatbutton0 = new Flat_button({
      props: {
        content: "Reset Connection",
        color: "orange"
      }
    });
    flatbutton0.$on(
      "click",
      /*click_handler_3*/
      ctx[14]
    );
    flatbutton1 = new Flat_button({
      props: {
        content: "Trigger refresh",
        color: "orange"
      }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_4*/
      ctx[15]
    );
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        b0 = element("b");
        b0.textContent = "Lobby ID:";
        t1 = space();
        t2 = text(t2_value);
        t3 = space();
        br = element("br");
        t4 = space();
        b1 = element("b");
        b1.textContent = "Ownership Claim:";
        t6 = space();
        t7 = text(t7_value);
        t8 = space();
        create_component(flatbutton0.$$.fragment);
        t9 = space();
        create_component(flatbutton1.$$.fragment);
        attr(div1, "class", "status-settings svelte-1y63bp4");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div0, b0);
        append(div0, t1);
        append(div0, t2);
        append(div0, t3);
        append(div0, br);
        append(div0, t4);
        append(div0, b1);
        append(div0, t6);
        append(div0, t7);
        append(div1, t8);
        mount_component(flatbutton0, div1, null);
        append(div1, t9);
        mount_component(flatbutton1, div1, null);
        current = true;
      },
      p(ctx2, dirty) {
        var _a3, _b3;
        if ((!current || dirty & /*$connection*/
        16) && t2_value !== (t2_value = /*$connection*/
        (ctx2[4] === void 0 ? "/" : (
          /*$connection*/
          ctx2[4] === "unauthorized" ? "not logged in" : (
            /*$connection*/
            ctx2[4] === "paused" ? "paused" : (
              /*$connection*/
              (_a3 = ctx2[4]) == null ? void 0 : _a3.typoLobbyState.lobbyId
            )
          )
        )) + "")) set_data(t2, t2_value);
        if ((!current || dirty & /*$connection*/
        16) && t7_value !== (t7_value = /*$connection*/
        (ctx2[4] === void 0 ? "/" : (
          /*$connection*/
          ctx2[4] === "unauthorized" ? "not logged in" : (
            /*$connection*/
            ctx2[4] === "paused" ? "paused" : (
              /*$connection*/
              (_b3 = ctx2[4]) == null ? void 0 : _b3.typoLobbyState.ownershipClaim
            )
          )
        )) + "")) set_data(t7, t7_value);
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
      }
    };
  }
  __name(create_if_block$n, "create_if_block$n");
  function create_fragment$$(ctx) {
    let div1;
    let div0;
    let current_block_type_index;
    let if_block0;
    let t0;
    let t1;
    let t2;
    let current;
    const if_block_creators = [create_if_block_4$6, create_if_block_5$3, create_if_block_6, create_else_block$e];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*$connection*/
        ctx2[4] === void 0
      ) return 0;
      if (
        /*$connection*/
        ctx2[4] === "unauthorized"
      ) return 1;
      if (
        /*$connection*/
        ctx2[4] === "paused"
      ) return 2;
      return 3;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    let if_block1 = (
      /*$connection*/
      ctx[4] !== void 0 && /*$connection*/
      ctx[4] !== "unauthorized" && /*$connection*/
      ctx[4] !== "paused" && /*$connection*/
      ctx[4].typoLobbyState.playerIsOwner && create_if_block_3$6(ctx)
    );
    let if_block2 = (
      /*$connection*/
      ctx[4] !== void 0 && /*$connection*/
      ctx[4] !== "unauthorized" && /*$connection*/
      ctx[4] !== "paused" && /*$connection*/
      ctx[4].typoLobbyState.playerIsOwner === false && create_if_block_1$b(ctx)
    );
    let if_block3 = (
      /*$devmode*/
      ctx[5] === true && create_if_block$n(ctx)
    );
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        if_block0.c();
        t0 = space();
        if (if_block1) if_block1.c();
        t1 = space();
        if (if_block2) if_block2.c();
        t2 = space();
        if (if_block3) if_block3.c();
        attr(div0, "class", "status-info svelte-1y63bp4");
        attr(div1, "class", "typo-lobby-status-settings svelte-1y63bp4");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        if_blocks[current_block_type_index].m(div0, null);
        append(div1, t0);
        if (if_block1) if_block1.m(div1, null);
        append(div1, t1);
        if (if_block2) if_block2.m(div1, null);
        append(div1, t2);
        if (if_block3) if_block3.m(div1, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
        if (
          /*$connection*/
          ctx2[4] !== void 0 && /*$connection*/
          ctx2[4] !== "unauthorized" && /*$connection*/
          ctx2[4] !== "paused" && /*$connection*/
          ctx2[4].typoLobbyState.playerIsOwner
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty & /*$connection*/
            16) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_3$6(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(div1, t1);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
        if (
          /*$connection*/
          ctx2[4] !== void 0 && /*$connection*/
          ctx2[4] !== "unauthorized" && /*$connection*/
          ctx2[4] !== "paused" && /*$connection*/
          ctx2[4].typoLobbyState.playerIsOwner === false
        ) {
          if (if_block2) {
            if_block2.p(ctx2, dirty);
          } else {
            if_block2 = create_if_block_1$b(ctx2);
            if_block2.c();
            if_block2.m(div1, t2);
          }
        } else if (if_block2) {
          if_block2.d(1);
          if_block2 = null;
        }
        if (
          /*$devmode*/
          ctx2[5] === true
        ) {
          if (if_block3) {
            if_block3.p(ctx2, dirty);
            if (dirty & /*$devmode*/
            32) {
              transition_in(if_block3, 1);
            }
          } else {
            if_block3 = create_if_block$n(ctx2);
            if_block3.c();
            transition_in(if_block3, 1);
            if_block3.m(div1, null);
          }
        } else if (if_block3) {
          group_outros();
          transition_out(if_block3, 1, 1, () => {
            if_block3 = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block0);
        transition_in(if_block1);
        transition_in(if_block3);
        current = true;
      },
      o(local) {
        transition_out(if_block0);
        transition_out(if_block1);
        transition_out(if_block3);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if_blocks[current_block_type_index].d();
        if (if_block1) if_block1.d();
        if (if_block2) if_block2.d();
        if (if_block3) if_block3.d();
      }
    };
  }
  __name(create_fragment$$, "create_fragment$$");
  function instance$W($$self, $$props, $$invalidate) {
    let $connection;
    let $devmode;
    let { feature } = $$props;
    let lobbyDescription = "";
    let lobbyDisableWhitelistAllowedServers = false;
    let lobbyAllowedServers = {};
    const connection = feature.connectionStore;
    component_subscribe($$self, connection, (value) => $$invalidate(4, $connection = value));
    const devmode = feature.isDevmodeStore;
    component_subscribe($$self, devmode, (value) => $$invalidate(5, $devmode = value));
    connection.subscribe((conn) => {
      if (conn && conn !== "unauthorized" && conn !== "paused") {
        $$invalidate(1, lobbyDescription = conn.typoLobbyState.lobbySettings.description);
        $$invalidate(2, lobbyDisableWhitelistAllowedServers = !conn.typoLobbyState.lobbySettings.whitelistAllowedServers);
        $$invalidate(3, lobbyAllowedServers = Object.fromEntries(conn.typoLobbyState.lobbySettings.allowedServers.map((s) => [s, true])));
      }
    });
    const click_handler2 = /* @__PURE__ */ __name(() => feature.setPaused(false), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => feature.setPaused(true), "click_handler_1");
    function input_input_handler() {
      lobbyDescription = this.value;
      $$invalidate(1, lobbyDescription);
    }
    __name(input_input_handler, "input_input_handler");
    function checkbox_checked_binding(value) {
      lobbyDisableWhitelistAllowedServers = value;
      $$invalidate(2, lobbyDisableWhitelistAllowedServers);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    function checkbox_checked_binding_1(value, guild) {
      if ($$self.$$.not_equal(lobbyAllowedServers[guild.guildID], value)) {
        lobbyAllowedServers[guild.guildID] = value;
        $$invalidate(3, lobbyAllowedServers);
      }
    }
    __name(checkbox_checked_binding_1, "checkbox_checked_binding_1");
    const click_handler_2 = /* @__PURE__ */ __name(() => {
      feature.updateLobbySettings(lobbyDescription, !lobbyDisableWhitelistAllowedServers, lobbyAllowedServers);
    }, "click_handler_2");
    const click_handler_3 = /* @__PURE__ */ __name(() => {
      feature.resetConnection();
    }, "click_handler_3");
    const click_handler_4 = /* @__PURE__ */ __name(() => {
      feature.triggerManualRefresh();
    }, "click_handler_4");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      lobbyDescription,
      lobbyDisableWhitelistAllowedServers,
      lobbyAllowedServers,
      $connection,
      $devmode,
      connection,
      devmode,
      click_handler2,
      click_handler_1,
      input_input_handler,
      checkbox_checked_binding,
      checkbox_checked_binding_1,
      click_handler_2,
      click_handler_3,
      click_handler_4
    ];
  }
  __name(instance$W, "instance$W");
  const _Lobby_status = class _Lobby_status extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$W, create_fragment$$, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Lobby_status, "Lobby_status");
  let Lobby_status = _Lobby_status;
  var __defProp$z = Object.defineProperty;
  var __decorateClass$z = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$z(target, key2, result);
    return result;
  }, "__decorateClass$z");
  const _LobbyStatusFeature = class _LobbyStatusFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_lobbyService");
      __publicField(this, "_elementsSetup");
      __publicField(this, "_memberService");
      __publicField(this, "_toastService");
      __publicField(this, "_settingsService");
      __publicField(this, "_lobbyConnectionService");
      __publicField(this, "_privateLobbyWhitelistEnabledSetting", new ExtensionSetting(
        "private_whitelist_enabled",
        false,
        this
      ));
      __publicField(this, "_publicLobbyWhitelistEnabledSetting", new ExtensionSetting(
        "public_whitelist_enabled",
        false,
        this
      ));
      __publicField(this, "_privateLobbyWhitelistedServersSetting", new ExtensionSetting(
        "private_whitelisted_servers",
        [],
        this
      ));
      __publicField(this, "_publicLobbyWhitelistedServersSetting", new ExtensionSetting(
        "public_whitelisted_servers",
        [],
        this
      ));
      __publicField(this, "_lobbySubscription");
      __publicField(this, "_currentBackendProcessing");
      /** a promise that resolves when the current backend lobby update finished */
      __publicField(this, "_triggerManualRefresh$", new BehaviorSubject(void 0));
      __publicField(this, "_controlIcon");
      __publicField(this, "_controlIconSubscription");
      __publicField(this, "_flyoutComponent");
      __publicField(this, "_flyoutSubscription");
      __publicField(this, "_lobbyTypeSubscription");
      __publicField(this, "name", "Lobby Status");
      __publicField(this, "description", "Share your current lobby with typo to use avatar decorations, give awards and catch drops.");
      __publicField(this, "tags", [
        FeatureTag.SOCIAL,
        FeatureTag.PALANTIR
      ]);
      __publicField(this, "featureId", 19);
    }
    get boundServices() {
      return [this._lobbyConnectionService];
    }
    /**
     * A store containing the current connection state
     */
    get connectionStore() {
      return fromObservable(this._lobbyConnectionService.connection$, void 0);
    }
    /**
     * Store containing devmode state
     */
    get isDevmodeStore() {
      return this._settingsService.settings.devMode.store;
    }
    async onActivate() {
      this._lobbyTypeSubscription = this._lobbyService.lobby$.pipe(
        map(
          (lobby) => lobby === null ? null : lobby.id === null ? "practice" : lobby.private ? "custom" : "public"
        ),
        distinctUntilChanged(),
        combineLatestWith(this._lobbyConnectionService.connection$)
      ).subscribe(async ([type, connection]) => {
        var _a2, _b2;
        if ((type === "public" || type === "custom") && connection !== "unauthorized") {
          if (!this._controlIcon) await this.setupSettings();
          const open = connection !== "paused" && (connection == null ? void 0 : connection.typoLobbyState.lobbySettings.whitelistAllowedServers) === false;
          const icon = connection === void 0 ? "file-img-connection-loading-gif" : connection === "paused" ? "file-img-connection-paused-gif" : open ? "file-img-connection-gif" : "file-img-connection-secure-gif";
          const greyscale = connection !== void 0;
          (_a2 = this._controlIcon) == null ? void 0 : _a2.$set({
            icon,
            greyscaleInactive: greyscale
          });
        } else {
          this.destroySettings();
          (_b2 = this._flyoutComponent) == null ? void 0 : _b2.close();
        }
      });
      this._lobbySubscription = repeatAfterDelay(
        this._lobbyService.lobby$.pipe(
          combineLatestWith(this._triggerManualRefresh$),
          map(([lobby]) => lobby)
        ),
        30 * 1e3
      ).pipe(
        tap((data) => this._logger.debug("Lobby status update triggered", data)),
        debounce(() => this._lobbyConnectionService.isConnected ? of(null) : interval(2e3)),
        // start connection only after player has been in the lobby for 2s to avoid spamming
        combineLatestWith(this._memberService.member$),
        debounce(() => this._currentBackendProcessing ?? of(0))
        // allow only one backend processing at a time
      ).subscribe(
        ([lobby, member]) => this._currentBackendProcessing = (async () => {
          try {
            await this.processLobbyUpdate(lobby, member);
          } catch (e) {
            this._logger.error("Error in lobby status update", e);
          }
        })()
      );
      this._lobbySubscription.add(() => this._logger.info("Lobby status update sub stopped"));
      await this._lobbyConnectionService.setPaused(false);
    }
    async onDestroy() {
      var _a2, _b2;
      (_a2 = this._lobbySubscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._lobbyTypeSubscription) == null ? void 0 : _b2.unsubscribe();
      this.destroySettings();
    }
    /**
     * Sets up the lobby settings/status UI
     * @private
     */
    async setupSettings() {
      const elements2 = await this._elementsSetup.complete();
      this._controlIcon = new Icon_button({
        target: elements2.chatControls,
        props: {
          icon: "file-img-connection-gif",
          name: "Lobby Status",
          order: 2,
          size: "2rem",
          hoverMove: false,
          greyscaleInactive: true,
          tooltipAction: this.createTooltip
        }
      });
      this._controlIconSubscription = this._controlIcon.click$.subscribe(() => {
        if (this._flyoutComponent) {
          return;
        }
        const flyoutContent = {
          componentType: Lobby_status,
          props: {
            feature: this
          }
        };
        this._flyoutComponent = new Area_flyout({
          target: elements2.gameWrapper,
          props: {
            componentData: flyoutContent,
            areaName: "chat",
            maxHeight: "600px",
            maxWidth: "300px",
            title: "Lobby Status",
            closeStrategy: "explicit",
            iconName: "file-img-connection-gif",
            alignment: "top"
          }
        });
        this._flyoutSubscription = this._flyoutComponent.closed$.subscribe(() => {
          var _a2, _b2;
          this._logger.info("Destroyed flyout");
          (_a2 = this._flyoutComponent) == null ? void 0 : _a2.$destroy();
          (_b2 = this._flyoutSubscription) == null ? void 0 : _b2.unsubscribe();
          this._flyoutComponent = void 0;
        });
      });
    }
    /**
     * Destroys the lobby settings/status UI
     * @private
     */
    destroySettings() {
      var _a2, _b2, _c2, _d2;
      (_a2 = this._controlIcon) == null ? void 0 : _a2.$destroy();
      (_b2 = this._controlIconSubscription) == null ? void 0 : _b2.unsubscribe();
      this._controlIcon = void 0;
      (_c2 = this._flyoutComponent) == null ? void 0 : _c2.$destroy();
      (_d2 = this._flyoutSubscription) == null ? void 0 : _d2.unsubscribe();
      this._flyoutComponent = void 0;
    }
    /**
     * Processes a new lobby update
     * Connects to the server if in lobby and not yet connected, or disconnects if lobby left, or updates state if already connected
     * @param lobby the current lobby data
     * @param member the authenticated member data
     * @private
     */
    async processLobbyUpdate(lobby, member) {
      this._logger.info("processing lobby status update", lobby, member == null ? void 0 : member.userName);
      if (member === null || member === void 0) {
        await this._lobbyConnectionService.destroyConnection("unauthorized");
        return;
      }
      if (lobby === null || lobby.id === null) {
        await this._lobbyConnectionService.destroyConnection();
        return;
      }
      if (lobby && !this._lobbyConnectionService.isConnected) {
        const lobbyDto = this.mapLobbyToDto(lobby);
        const result = await this._lobbyConnectionService.setupConnection(
          lobby.id,
          lobbyDto,
          lobby.meId,
          member
        );
        if (result === "failed") {
          this._logger.error("Failed to setup connection, retrying in next update cycle");
          return;
        }
        const { typoLobbyState, hub } = this._lobbyConnectionService.connection;
        if (typoLobbyState.playerIsOwner && result === "connected") {
          const defaults2 = lobby.private ? {
            whitelistEnabled: await this._privateLobbyWhitelistEnabledSetting.getValue(),
            whitelist: await this._privateLobbyWhitelistedServersSetting.getValue()
          } : {
            whitelistEnabled: await this._publicLobbyWhitelistEnabledSetting.getValue(),
            whitelist: await this._publicLobbyWhitelistedServersSetting.getValue()
          };
          try {
            await hub.updateTypoLobbySettings({
              description: "",
              whitelistAllowedServers: defaults2.whitelistEnabled,
              allowedServers: defaults2.whitelist
            });
          } catch (e) {
            this._logger.error("Failed to set defaults", e);
          }
        }
      }
      if (lobby && this._lobbyConnectionService.isConnected) {
        if (lobby.id !== this._lobbyConnectionService.connection.typoLobbyState.lobbyId) {
          this._logger.info("Lobby changed, reconnecting");
          await this._lobbyConnectionService.destroyConnection();
          return this.processLobbyUpdate(lobby, member);
        } else
          await this._lobbyConnectionService.connection.hub.updateSkribblLobbyState(
            this.mapLobbyToDto(lobby)
          );
      }
      this._logger.info("Lobby status processed");
    }
    /**
     * Maps the current lobby state to a DTO
     * @param lobby
     * @private
     */
    mapLobbyToDto(lobby) {
      if (lobby.id === null) throw new Error("cannot map practice lobby to state dto");
      return {
        link: lobby.id,
        ownerId: lobby.ownerId ?? void 0,
        round: lobby.round,
        players: lobby.players.map((player) => ({
          name: player.name,
          isDrawing: player.id === lobby.drawerId,
          score: player.score,
          playerId: player.id,
          hasGuessed: player.guessed
        })),
        settings: {
          language: lobby.settings.language,
          players: lobby.settings.players,
          rounds: lobby.settings.rounds,
          drawTime: lobby.settings.drawTime
        }
      };
    }
    /**
     * Updates the settings of the current typo lobby
     * Requires the player to be the typo lobby owner
     * @param description The new description of the lobby to be shown in the palantir bot
     * @param whitelistAllowedServers Whether the lobby invite will be shown only in servers in the allowedServers list
     * @param allowedServers A list of server IDs which are allowed to show the lobby invite
     */
    async updateLobbySettings(description, whitelistAllowedServers, allowedServers) {
      const toast = await this._toastService.showLoadingToast("Updating lobby settings");
      this._lobbyService.lobby$.subscribe((lobby) => {
        if (!lobby) return;
        if (lobby.private) {
          this._privateLobbyWhitelistEnabledSetting.setValue(whitelistAllowedServers);
          this._privateLobbyWhitelistedServersSetting.setValue(
            Object.keys(allowedServers).filter((key2) => allowedServers[key2])
          );
        } else {
          this._publicLobbyWhitelistEnabledSetting.setValue(whitelistAllowedServers);
          this._publicLobbyWhitelistedServersSetting.setValue(
            Object.keys(allowedServers).filter((key2) => allowedServers[key2])
          );
        }
      });
      try {
        await this._lobbyConnectionService.connection.hub.updateTypoLobbySettings({
          description,
          whitelistAllowedServers,
          allowedServers: Object.entries(allowedServers).filter(([, value]) => value).map(([key2]) => key2)
        });
        toast.resolve();
      } catch (e) {
        this._logger.error("Failed to update lobby settings", e);
        toast.reject();
      }
    }
    /**
     * Disconnect the current lobby connection
     * The next lobby change event will reconnect as if lobby was first discovered
     */
    async resetConnection() {
      await this._lobbyConnectionService.destroyConnection();
      await this._toastService.showToast(
        void 0,
        "Connection reset; reconnecting in next update cycle"
      );
    }
    /**
     * Triggers a lobby update event with the last seen lobby data
     */
    async triggerManualRefresh() {
      this._triggerManualRefresh$.next(void 0);
      await this._toastService.showToast(void 0, "Manual refresh triggered");
    }
    async setPaused(paused) {
      await this._lobbyConnectionService.setPaused(paused);
      if (paused) {
        await this._toastService.showToast("You are now incognito!", "Lobby connection has been paused.\nYou will no longer be visible on discord.\nSprites, Scenes and Drops are paused as well.");
      } else {
        await this._toastService.showToast("Resumed Connection", "Your lobby will be visible on discord and sprites, scenes and drops will show up.");
      }
      this._triggerManualRefresh$.next(void 0);
    }
  };
  __name(_LobbyStatusFeature, "LobbyStatusFeature");
  let LobbyStatusFeature = _LobbyStatusFeature;
  __decorateClass$z([
    inject(LobbyService)
  ], LobbyStatusFeature.prototype, "_lobbyService");
  __decorateClass$z([
    inject(ElementsSetup)
  ], LobbyStatusFeature.prototype, "_elementsSetup");
  __decorateClass$z([
    inject(MemberService)
  ], LobbyStatusFeature.prototype, "_memberService");
  __decorateClass$z([
    inject(ToastService)
  ], LobbyStatusFeature.prototype, "_toastService");
  __decorateClass$z([
    inject(GlobalSettingsService)
  ], LobbyStatusFeature.prototype, "_settingsService");
  __decorateClass$z([
    inject(LobbyConnectionService)
  ], LobbyStatusFeature.prototype, "_lobbyConnectionService");
  function create_fragment$_(ctx) {
    let t;
    let br;
    return {
      c() {
        t = text("Adds a progress bar at the top of the canvas, visualizing the remaining time for selected actions. ");
        br = element("br");
      },
      m(target, anchor) {
        insert(target, t, anchor);
        insert(target, br, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(t);
          detach(br);
        }
      }
    };
  }
  __name(create_fragment$_, "create_fragment$_");
  const _Lobby_time_visualizer_info = class _Lobby_time_visualizer_info extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment$_, safe_not_equal, {});
    }
  };
  __name(_Lobby_time_visualizer_info, "Lobby_time_visualizer_info");
  let Lobby_time_visualizer_info = _Lobby_time_visualizer_info;
  var __defProp$y = Object.defineProperty;
  var __decorateClass$y = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$y(target, key2, result);
    return result;
  }, "__decorateClass$y");
  const _LobbyTimeVisualizerFeature = class _LobbyTimeVisualizerFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_lobbyStateChangedEventListener");
      __publicField(this, "_lobbyJoinedEventListener");
      __publicField(this, "_lobbyLeftEventListener");
      __publicField(this, "name", "Time Visualizer");
      __publicField(this, "description", "Shows a visual representation of time left to draw/choose");
      __publicField(this, "tags", [
        FeatureTag.INFORMATION,
        FeatureTag.GAMEPLAY
      ]);
      __publicField(this, "featureId", 30);
      __publicField(this, "_colorStartSetting", this.useSetting(new HexColorExtensionSetting("visualizer_color_start", "#46d536", this).withName("Color Start").withDescription("Start color of the visualizer bar")));
      __publicField(this, "_colorEndSetting", this.useSetting(new HexColorExtensionSetting("visualizer_color_end", "#fa2b08", this).withName("Color End").withDescription("End color of the visualizer bar")));
      __publicField(this, "_enableChooseVisualizer", this.useSetting(new BooleanExtensionSetting("choose_visualizer", true, this).withName("Choose Visualizer").withDescription("Show a visualizer of the remaining time to choose words")));
      __publicField(this, "_enableChooseVisualizerOnlyForYourself", this.useSetting(new BooleanExtensionSetting("choose_visualizer_self_only", false, this)).withName("Choose Visualizer Only For Yourself").withDescription("If the choose visualizer is enabled, this makes it so it only shows up when you're choosing your own word"));
      __publicField(this, "_enableDrawVisualizer", this.useSetting(new BooleanExtensionSetting("draw_visualizer", true, this).withName("Draw Visualizer").withDescription("Show a visualizer of the remaining time to draw a word")));
      __publicField(this, "_enableGuessVisualizer", this.useSetting(new BooleanExtensionSetting("guess_visualizer", true, this).withName("Guess Visualizer").withDescription("Show a visualizer of the remaining time to guess a word")));
      __publicField(this, "visualizerEventSubscription");
      __publicField(this, "_visualizerStyle");
    }
    get featureInfoComponent() {
      return { componentType: Lobby_time_visualizer_info, props: {} };
    }
    async onActivate() {
      this._visualizerStyle = createStylesheet();
      this._lobbyJoinedEventListener.events$.pipe(
        mergeWith(this._lobbyLeftEventListener.events$),
        map((event) => event.data),
        combineLatestWith(this._lobbyStateChangedEventListener.events$),
        withLatestFrom(
          this._enableDrawVisualizer.changes$,
          this._enableGuessVisualizer.changes$,
          this._enableChooseVisualizer.changes$,
          this._enableChooseVisualizerOnlyForYourself.changes$
        ),
        map(
          ([[lobby, event], draw, guess, choose, chooseYourselfOnly]) => {
            var _a2, _b2;
            return ((_a2 = event.data.timerSet) == null ? void 0 : _a2.time) !== 0 && lobby !== null && (draw && ((_b2 = event.data.drawingStarted) == null ? void 0 : _b2.drawerId) === lobby.meId || guess && event.data.drawingStarted !== void 0 && event.data.drawingStarted.drawerId !== lobby.meId || choose && event.data.drawerChoosingWord !== void 0 && (chooseYourselfOnly ? event.data.drawerChoosingWord.drawerId === lobby.meId : true)) ? { event, lobby } : event.data.timerSet ? { override: event.data.timerSet.time } : void 0;
          }
        ),
        map((data) => {
          if (data === void 0) return void 0;
          if (data.override) return { override: data.override };
          const { event, lobby } = data;
          if (event == null ? void 0 : event.data.drawingStarted) return { max: lobby.settings.drawTime, time: event.data.drawingStarted.maxTime };
          if (event == null ? void 0 : event.data.drawerChoosingWord) return { max: event.data.drawerChoosingWord.maxTime, time: event.data.drawerChoosingWord.maxTime };
          return void 0;
        }),
        startWith(void 0),
        pairwise(),
        map(([prev, current]) => {
          if (current === void 0) return void 0;
          if (current.override && (prev == null ? void 0 : prev.max)) return { time: current.override, max: prev.max };
          return current.time && current.max ? { time: current.time, max: current.max } : void 0;
        })
      ).subscribe((data) => {
        this.visualizeEvent(data);
      });
    }
    async onDestroy() {
      var _a2, _b2;
      (_a2 = this.visualizerEventSubscription) == null ? void 0 : _a2.unsubscribe();
      this.visualizerEventSubscription = void 0;
      (_b2 = this._visualizerStyle) == null ? void 0 : _b2.remove();
      this._visualizerStyle = void 0;
    }
    async visualizeEvent(data) {
      this._logger.debug("Visualize event", data);
      if (this._visualizerStyle === void 0) {
        this._logger.error("Visualizer style not set");
        return;
      }
      this._visualizerStyle.clear();
      if (data === void 0) return;
      const { time, max } = data;
      await firstValueFrom(of(1).pipe(delay(10)));
      const startColor = await this._colorStartSetting.getValue();
      const endColor = await this._colorEndSetting.getValue();
      this._visualizerStyle.replace(`  
      @keyframes countdown {
        0% { width: ${Math.floor(time * 100 / max)}%; background-color: ${startColor}; }
        50% { width: ${Math.floor(time * 50 / max)}%; background-color: ${startColor}; }
        100% { width: 0%; background-color: ${endColor}; }
      }
    
      #game-canvas:after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 0;
        height: .3rem;
        animation: countdown ${time * 1e3}ms linear;
      }
    `);
    }
    get enableChooseVisualizerStore() {
      return this._enableChooseVisualizer.store;
    }
    get enableDrawVisualizerStore() {
      return this._enableDrawVisualizer.store;
    }
    get enableGuessVisualizerStore() {
      return this._enableGuessVisualizer.store;
    }
  };
  __name(_LobbyTimeVisualizerFeature, "LobbyTimeVisualizerFeature");
  let LobbyTimeVisualizerFeature = _LobbyTimeVisualizerFeature;
  __decorateClass$y([
    inject(LobbyStateChangedEventListener)
  ], LobbyTimeVisualizerFeature.prototype, "_lobbyStateChangedEventListener");
  __decorateClass$y([
    inject(LobbyJoinedEventListener)
  ], LobbyTimeVisualizerFeature.prototype, "_lobbyJoinedEventListener");
  __decorateClass$y([
    inject(LobbyLeftEventListener)
  ], LobbyTimeVisualizerFeature.prototype, "_lobbyLeftEventListener");
  function get_each_context$l(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[15] = list[i];
    child_ctx[17] = i;
    return child_ctx;
  }
  __name(get_each_context$l, "get_each_context$l");
  function get_each_context_1$8(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[15] = list[i];
    child_ctx[17] = i;
    return child_ctx;
  }
  __name(get_each_context_1$8, "get_each_context_1$8");
  function create_else_block$d(ctx) {
    let div1;
    let div0;
    let t0;
    let t1;
    let if_block = (
      /*$scenePickerEnabled*/
      ctx[5] && create_if_block_3$5(ctx)
    );
    let each_value_1 = ensure_array_like({
      length: (
        /*$memberStore*/
        ctx[4].memberData.slots.unlockedSlots
      )
    });
    let each_blocks_1 = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks_1[i] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i));
    }
    let each_value = ensure_array_like({
      length: Math.max(9 - /*$memberStore*/
      ctx[4].memberData.slots.unlockedSlots, 3 - /*$memberStore*/
      ctx[4].memberData.slots.unlockedSlots % 3)
    });
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$l(get_each_context$l(ctx, each_value, i));
    }
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        if (if_block) if_block.c();
        t0 = space();
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].c();
        }
        t1 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div0, "class", "typo-cabin-picker svelte-10x5c2g");
        attr(div1, "class", "typo-cabin-scroll svelte-10x5c2g");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        if (if_block) if_block.m(div0, null);
        append(div0, t0);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          if (each_blocks_1[i]) {
            each_blocks_1[i].m(div0, null);
          }
        }
        append(div0, t1);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
      },
      p(ctx2, dirty) {
        if (
          /*$scenePickerEnabled*/
          ctx2[5]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block_3$5(ctx2);
            if_block.c();
            if_block.m(div0, t0);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & /*dndTrack, dndTargetSlot, undefined, Array, $memberStore, loading, feature, Number*/
        31) {
          each_value_1 = ensure_array_like({
            length: (
              /*$memberStore*/
              ctx2[4].memberData.slots.unlockedSlots
            )
          });
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$8(ctx2, each_value_1, i);
            if (each_blocks_1[i]) {
              each_blocks_1[i].p(child_ctx, dirty);
            } else {
              each_blocks_1[i] = create_each_block_1$8(child_ctx);
              each_blocks_1[i].c();
              each_blocks_1[i].m(div0, t1);
            }
          }
          for (; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d(1);
          }
          each_blocks_1.length = each_value_1.length;
        }
        if (dirty & /*$memberStore*/
        16) {
          each_value = ensure_array_like({
            length: Math.max(9 - /*$memberStore*/
            ctx2[4].memberData.slots.unlockedSlots, 3 - /*$memberStore*/
            ctx2[4].memberData.slots.unlockedSlots % 3)
          });
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$l(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$l(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div0, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if (if_block) if_block.d();
        destroy_each(each_blocks_1, detaching);
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_else_block$d, "create_else_block$d");
  function create_if_block_1$a(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        div.textContent = "You need to log in to use sprites.";
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_if_block_1$a, "create_if_block_1$a");
  function create_if_block$m(ctx) {
    let bounceload;
    let current;
    bounceload = new Bounceload({
      props: { content: "Loading inventory.." }
    });
    return {
      c() {
        create_component(bounceload.$$.fragment);
      },
      m(target, anchor) {
        mount_component(bounceload, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(bounceload, detaching);
      }
    };
  }
  __name(create_if_block$m, "create_if_block$m");
  function create_if_block_3$5(ctx) {
    let div;
    let mounted;
    let dispose;
    function select_block_type_1(ctx2, dirty) {
      if (
        /*$memberStore*/
        ctx2[4].scene && /*$memberStore*/
        ctx2[4].scene.scene
      ) return create_if_block_4$5;
      return create_else_block_2$1;
    }
    __name(select_block_type_1, "select_block_type_1");
    let current_block_type = select_block_type_1(ctx);
    let if_block = current_block_type(ctx);
    return {
      c() {
        div = element("div");
        if_block.c();
        attr(div, "class", "typo-cabin-scene svelte-10x5c2g");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_block.m(div, null);
        if (!mounted) {
          dispose = [
            listen(
              div,
              "click",
              /*click_handler*/
              ctx[8]
            ),
            listen(
              div,
              "contextmenu",
              /*contextmenu_handler*/
              ctx[9]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(div, null);
          }
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if_block.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_if_block_3$5, "create_if_block_3$5");
  function create_else_block_2$1(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        div.textContent = "No scene selected";
        attr(div, "class", "typo-cabin-scene-info visible svelte-10x5c2g");
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_else_block_2$1, "create_else_block_2$1");
  function create_if_block_4$5(ctx) {
    let div0;
    let t0_value = (
      /*$memberStore*/
      ctx[4].scene.scene.name + ""
    );
    let t0;
    let t1;
    let t2_value = (
      /*$memberStore*/
      ctx[4].scene.scene.id + ""
    );
    let t2;
    let t3;
    let t4;
    let div1;
    return {
      c() {
        div0 = element("div");
        t0 = text(t0_value);
        t1 = text(" (#");
        t2 = text(t2_value);
        t3 = text(")");
        t4 = space();
        div1 = element("div");
        attr(div0, "class", "typo-cabin-scene-info svelte-10x5c2g");
        attr(div1, "class", "typo-cabin-scene-thumb svelte-10x5c2g");
        set_style(div1, "background-image", "url(" + /*feature*/
        ctx[0].getItemThumbnailUrl(
          /*$memberStore*/
          ctx[4].scene.scene,
          /*$memberStore*/
          ctx[4].scene.shift
        ) + ")");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        append(div0, t0);
        append(div0, t1);
        append(div0, t2);
        append(div0, t3);
        insert(target, t4, anchor);
        insert(target, div1, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*$memberStore*/
        16 && t0_value !== (t0_value = /*$memberStore*/
        ctx2[4].scene.scene.name + "")) set_data(t0, t0_value);
        if (dirty & /*$memberStore*/
        16 && t2_value !== (t2_value = /*$memberStore*/
        ctx2[4].scene.scene.id + "")) set_data(t2, t2_value);
        if (dirty & /*feature, $memberStore*/
        17) {
          set_style(div1, "background-image", "url(" + /*feature*/
          ctx2[0].getItemThumbnailUrl(
            /*$memberStore*/
            ctx2[4].scene.scene,
            /*$memberStore*/
            ctx2[4].scene.shift
          ) + ")");
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t4);
          detach(div1);
        }
      }
    };
  }
  __name(create_if_block_4$5, "create_if_block_4$5");
  function create_else_block_1$2(ctx) {
    let div0;
    let t2;
    let div1;
    return {
      c() {
        div0 = element("div");
        div0.textContent = `Slot #${/*slot*/
      ctx[17] + 1}`;
        t2 = space();
        div1 = element("div");
        div1.textContent = "Empty";
        attr(div0, "class", "typo-cabin-slot-info visible svelte-10x5c2g");
        attr(div1, "class", "typo-cabin-slot-info visible svelte-10x5c2g");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        insert(target, t2, anchor);
        insert(target, div1, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t2);
          detach(div1);
        }
      }
    };
  }
  __name(create_else_block_1$2, "create_else_block_1$2");
  function create_if_block_2$8(ctx) {
    var _a2, _b2, _c2;
    let div0;
    let t2;
    let div1;
    let t3_value = (
      /*$memberStore*/
      (((_b2 = (_a2 = ctx[4].slots.get(
        /*slot*/
        ctx[17]
      )) == null ? void 0 : _a2.sprite) == null ? void 0 : _b2.name) ?? "Unknown") + ""
    );
    let t3;
    let t4;
    let t5_value = (
      /*$memberStore*/
      ((_c2 = ctx[4].slots.get(
        /*slot*/
        ctx[17]
      )) == null ? void 0 : _c2.spriteId) + ""
    );
    let t5;
    let t6;
    let t7;
    let div2;
    return {
      c() {
        var _a3, _b3;
        div0 = element("div");
        div0.textContent = `Slot #${/*slot*/
      ctx[17] + 1}`;
        t2 = space();
        div1 = element("div");
        t3 = text(t3_value);
        t4 = text("\n              (#");
        t5 = text(t5_value);
        t6 = text(")");
        t7 = space();
        div2 = element("div");
        attr(div0, "class", "typo-cabin-slot-info svelte-10x5c2g");
        attr(div1, "class", "typo-cabin-slot-info svelte-10x5c2g");
        attr(div2, "class", "typo-cabin-slot-thumb svelte-10x5c2g");
        set_style(div2, "background-image", "url(" + /*feature*/
        ctx[0].getItemThumbnailUrl(
          /*$memberStore*/
          (_a3 = ctx[4].slots.get(
            /*slot*/
            ctx[17]
          )) == null ? void 0 : _a3.sprite,
          /*$memberStore*/
          (_b3 = ctx[4].slots.get(
            /*slot*/
            ctx[17]
          )) == null ? void 0 : _b3.colorShift
        ) + ")");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        insert(target, t2, anchor);
        insert(target, div1, anchor);
        append(div1, t3);
        append(div1, t4);
        append(div1, t5);
        append(div1, t6);
        insert(target, t7, anchor);
        insert(target, div2, anchor);
      },
      p(ctx2, dirty) {
        var _a3, _b3, _c3, _d2, _e2;
        if (dirty & /*$memberStore*/
        16 && t3_value !== (t3_value = /*$memberStore*/
        (((_b3 = (_a3 = ctx2[4].slots.get(
          /*slot*/
          ctx2[17]
        )) == null ? void 0 : _a3.sprite) == null ? void 0 : _b3.name) ?? "Unknown") + "")) set_data(t3, t3_value);
        if (dirty & /*$memberStore*/
        16 && t5_value !== (t5_value = /*$memberStore*/
        ((_c3 = ctx2[4].slots.get(
          /*slot*/
          ctx2[17]
        )) == null ? void 0 : _c3.spriteId) + "")) set_data(t5, t5_value);
        if (dirty & /*feature, $memberStore*/
        17) {
          set_style(div2, "background-image", "url(" + /*feature*/
          ctx2[0].getItemThumbnailUrl(
            /*$memberStore*/
            (_d2 = ctx2[4].slots.get(
              /*slot*/
              ctx2[17]
            )) == null ? void 0 : _d2.sprite,
            /*$memberStore*/
            (_e2 = ctx2[4].slots.get(
              /*slot*/
              ctx2[17]
            )) == null ? void 0 : _e2.colorShift
          ) + ")");
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t2);
          detach(div1);
          detach(t7);
          detach(div2);
        }
      }
    };
  }
  __name(create_if_block_2$8, "create_if_block_2$8");
  function create_each_block_1$8(ctx) {
    let div;
    let show_if;
    let t;
    let mounted;
    let dispose;
    function select_block_type_2(ctx2, dirty) {
      if (dirty & /*$memberStore*/
      16) show_if = null;
      if (show_if == null) show_if = !!/*$memberStore*/
      ctx2[4].slots.has(
        /*slot*/
        ctx2[17]
      );
      if (show_if) return create_if_block_2$8;
      return create_else_block_1$2;
    }
    __name(select_block_type_2, "select_block_type_2");
    let current_block_type = select_block_type_2(ctx, -1);
    let if_block = current_block_type(ctx);
    function dragenter_handler(...args) {
      return (
        /*dragenter_handler*/
        ctx[10](
          /*slot*/
          ctx[17],
          ...args
        )
      );
    }
    __name(dragenter_handler, "dragenter_handler");
    function dragstart_handler() {
      return (
        /*dragstart_handler*/
        ctx[11](
          /*slot*/
          ctx[17]
        )
      );
    }
    __name(dragstart_handler, "dragstart_handler");
    function click_handler_1() {
      return (
        /*click_handler_1*/
        ctx[13](
          /*slot*/
          ctx[17]
        )
      );
    }
    __name(click_handler_1, "click_handler_1");
    function contextmenu_handler_1(...args) {
      return (
        /*contextmenu_handler_1*/
        ctx[14](
          /*slot*/
          ctx[17],
          ...args
        )
      );
    }
    __name(contextmenu_handler_1, "contextmenu_handler_1");
    return {
      c() {
        div = element("div");
        if_block.c();
        t = space();
        attr(div, "class", "typo-cabin-slot svelte-10x5c2g");
        attr(div, "role", "gridcell");
        attr(
          div,
          "tabindex",
          /*slot*/
          ctx[17]
        );
        attr(div, "draggable", "true");
        set_style(
          div,
          "order",
          /*dndTrack*/
          ctx[2] ? (
            /*dndTrack*/
            ctx[2][
              /*slot*/
              ctx[17]
            ]
          ) : (
            /*slot*/
            ctx[17]
          )
        );
        toggle_class(
          div,
          "dragging",
          /*dndTargetSlot*/
          ctx[1] !== void 0
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_block.m(div, null);
        append(div, t);
        if (!mounted) {
          dispose = [
            listen(div, "dragenter", dragenter_handler),
            listen(div, "dragstart", dragstart_handler),
            listen(
              div,
              "dragend",
              /*dragend_handler*/
              ctx[12]
            ),
            listen(div, "click", click_handler_1),
            listen(div, "contextmenu", contextmenu_handler_1)
          ];
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (current_block_type === (current_block_type = select_block_type_2(ctx, dirty)) && if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx);
          if (if_block) {
            if_block.c();
            if_block.m(div, t);
          }
        }
        if (dirty & /*dndTrack*/
        4) {
          set_style(
            div,
            "order",
            /*dndTrack*/
            ctx[2] ? (
              /*dndTrack*/
              ctx[2][
                /*slot*/
                ctx[17]
              ]
            ) : (
              /*slot*/
              ctx[17]
            )
          );
        }
        if (dirty & /*dndTargetSlot, undefined*/
        2) {
          toggle_class(
            div,
            "dragging",
            /*dndTargetSlot*/
            ctx[1] !== void 0
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if_block.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_each_block_1$8, "create_each_block_1$8");
  function create_each_block$l(ctx) {
    let div2;
    let div0;
    let t0;
    let t1_value = (
      /*slot*/
      ctx[17] + /*$memberStore*/
      ctx[4].memberData.slots.unlockedSlots + 1 + ""
    );
    let t1;
    let t2;
    let div1;
    let t4;
    return {
      c() {
        div2 = element("div");
        div0 = element("div");
        t0 = text("Slot #");
        t1 = text(t1_value);
        t2 = space();
        div1 = element("div");
        div1.textContent = "Locked";
        t4 = space();
        attr(div0, "class", "typo-cabin-slot-info svelte-10x5c2g");
        attr(div1, "class", "typo-cabin-slot-info svelte-10x5c2g");
        attr(div2, "class", "typo-cabin-slot locked svelte-10x5c2g");
        set_style(
          div2,
          "order",
          /*slot*/
          ctx[17] + /*$memberStore*/
          ctx[4].memberData.slots.unlockedSlots + 1
        );
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, div0);
        append(div0, t0);
        append(div0, t1);
        append(div2, t2);
        append(div2, div1);
        append(div2, t4);
      },
      p(ctx2, dirty) {
        if (dirty & /*$memberStore*/
        16 && t1_value !== (t1_value = /*slot*/
        ctx2[17] + /*$memberStore*/
        ctx2[4].memberData.slots.unlockedSlots + 1 + "")) set_data(t1, t1_value);
        if (dirty & /*$memberStore*/
        16) {
          set_style(
            div2,
            "order",
            /*slot*/
            ctx2[17] + /*$memberStore*/
            ctx2[4].memberData.slots.unlockedSlots + 1
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
      }
    };
  }
  __name(create_each_block$l, "create_each_block$l");
  function create_fragment$Z(ctx) {
    let div1;
    let div0;
    let bounceload;
    let t;
    let current_block_type_index;
    let if_block;
    let current;
    bounceload = new Bounceload({ props: { content: "Saving.." } });
    const if_block_creators = [create_if_block$m, create_if_block_1$a, create_else_block$d];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*$memberStore*/
        ctx2[4] === void 0
      ) return 0;
      if (
        /*$memberStore*/
        ctx2[4] === null
      ) return 1;
      return 2;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        create_component(bounceload.$$.fragment);
        t = space();
        if_block.c();
        attr(div0, "class", "typo-cabin-saving svelte-10x5c2g");
        attr(div1, "class", "typo-cabin svelte-10x5c2g");
        toggle_class(
          div1,
          "loading",
          /*loading*/
          ctx[3]
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        mount_component(bounceload, div0, null);
        append(div1, t);
        if_blocks[current_block_type_index].m(div1, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
        if (!current || dirty & /*loading*/
        8) {
          toggle_class(
            div1,
            "loading",
            /*loading*/
            ctx2[3]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_component(bounceload);
        if_blocks[current_block_type_index].d();
      }
    };
  }
  __name(create_fragment$Z, "create_fragment$Z");
  function instance$V($$self, $$props, $$invalidate) {
    let $memberStore;
    let $scenePickerEnabled;
    let { feature } = $$props;
    const memberStore = feature.memberStore;
    component_subscribe($$self, memberStore, (value) => $$invalidate(4, $memberStore = value));
    const scenePickerEnabled = feature.scenePickerSettingStore;
    component_subscribe($$self, scenePickerEnabled, (value) => $$invalidate(5, $scenePickerEnabled = value));
    let dndTargetSlot;
    let dndTrack;
    let loading = false;
    const click_handler2 = /* @__PURE__ */ __name(async () => {
      const scene = await feature.promptSceneSelection($memberStore.memberData.sceneInventory);
      if (scene !== void 0) {
        $$invalidate(3, loading = true);
        await feature.setScene((scene == null ? void 0 : scene.scene) ?? null, scene == null ? void 0 : scene.shift, $memberStore.memberData.member.userLogin);
        $$invalidate(3, loading = false);
      }
    }, "click_handler");
    const contextmenu_handler2 = /* @__PURE__ */ __name(async (event) => {
      event.preventDefault();
      $$invalidate(3, loading = true);
      await feature.setScene(null, void 0, $memberStore.memberData.member.userLogin);
      $$invalidate(3, loading = false);
    }, "contextmenu_handler");
    const dragenter_handler = /* @__PURE__ */ __name((slot, event) => {
      if (dndTargetSlot === slot || dndTrack === void 0 || dndTargetSlot === void 0) return;
      const newTrack = [...Array($memberStore.memberData.slots.unlockedSlots).keys()];
      for (let i = 0; i < dndTrack.length; i++) {
        if (i >= slot && i < dndTargetSlot) {
          newTrack[i] = i + 1;
        }
        if (i <= slot && i > dndTargetSlot) {
          newTrack[i] = i - 1;
        }
      }
      newTrack[dndTargetSlot] = dndTrack[slot];
      $$invalidate(2, dndTrack = newTrack);
    }, "dragenter_handler");
    const dragstart_handler = /* @__PURE__ */ __name((slot) => {
      $$invalidate(1, dndTargetSlot = slot);
      $$invalidate(2, dndTrack = [...Array($memberStore.memberData.slots.unlockedSlots).keys()]);
    }, "dragstart_handler");
    const dragend_handler = /* @__PURE__ */ __name(async () => {
      $$invalidate(3, loading = true);
      await feature.reorderSlots(dndTrack, $memberStore.memberData.spriteInventory, Number($memberStore.memberData.member.userLogin));
      $$invalidate(1, dndTargetSlot = void 0);
      $$invalidate(2, dndTrack = void 0);
      $$invalidate(3, loading = false);
    }, "dragend_handler");
    const click_handler_1 = /* @__PURE__ */ __name(async (slot) => {
      const sprite = await feature.promptSpriteSelection($memberStore.memberData.spriteInventory);
      if (sprite !== void 0) {
        $$invalidate(3, loading = true);
        await feature.setSpriteOnSlot(slot + 1, sprite, $memberStore.memberData.member.userLogin);
        $$invalidate(3, loading = false);
      }
    }, "click_handler_1");
    const contextmenu_handler_1 = /* @__PURE__ */ __name(async (slot, event) => {
      event.preventDefault();
      $$invalidate(3, loading = true);
      await feature.setSpriteOnSlot(slot + 1, null, $memberStore.memberData.member.userLogin);
      $$invalidate(3, loading = false);
    }, "contextmenu_handler_1");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      dndTargetSlot,
      dndTrack,
      loading,
      $memberStore,
      $scenePickerEnabled,
      memberStore,
      scenePickerEnabled,
      click_handler2,
      contextmenu_handler2,
      dragenter_handler,
      dragstart_handler,
      dragend_handler,
      click_handler_1,
      contextmenu_handler_1
    ];
  }
  __name(instance$V, "instance$V");
  const _Panel_cabin = class _Panel_cabin extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$V, create_fragment$Z, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Panel_cabin, "Panel_cabin");
  let Panel_cabin = _Panel_cabin;
  function get_each_context$k(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[11] = list[i];
    return child_ctx;
  }
  __name(get_each_context$k, "get_each_context$k");
  function create_if_block$l(ctx) {
    var _a2, _b2;
    let div1;
    let div0;
    let t0;
    let span0;
    let t1;
    let t2_value = (
      /*spritesMap*/
      ((_a2 = ctx[2].get(
        /*sprite*/
        ctx[11].spriteId
      )) == null ? void 0 : _a2.id) + ""
    );
    let t2;
    let t3;
    let span1;
    let t4_value = (
      /*spritesMap*/
      ((_b2 = ctx[2].get(
        /*sprite*/
        ctx[11].spriteId
      )) == null ? void 0 : _b2.name) + ""
    );
    let t4;
    let t5;
    let mounted;
    let dispose;
    function click_handler_1() {
      return (
        /*click_handler_1*/
        ctx[10](
          /*sprite*/
          ctx[11]
        )
      );
    }
    __name(click_handler_1, "click_handler_1");
    return {
      c() {
        var _a3;
        div1 = element("div");
        div0 = element("div");
        t0 = space();
        span0 = element("span");
        t1 = text("#");
        t2 = text(t2_value);
        t3 = space();
        span1 = element("span");
        t4 = text(t4_value);
        t5 = space();
        attr(div0, "class", "typo-sprite-picker-sprite-thumb svelte-1bcvdme");
        set_style(div0, "background-image", "url(" + /*spritesMap*/
        ((_a3 = ctx[2].get(
          /*sprite*/
          ctx[11].spriteId
        )) == null ? void 0 : _a3.url) + ")");
        attr(span0, "class", "svelte-1bcvdme");
        attr(span1, "class", "svelte-1bcvdme");
        attr(div1, "class", "typo-sprite-picker-sprite svelte-1bcvdme");
        set_style(
          div1,
          "order",
          /*sprite*/
          ctx[11].spriteId
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div1, t0);
        append(div1, span0);
        append(span0, t1);
        append(span0, t2);
        append(div1, t3);
        append(div1, span1);
        append(span1, t4);
        append(div1, t5);
        if (!mounted) {
          dispose = listen(div1, "click", click_handler_1);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        var _a3, _b3, _c2;
        ctx = new_ctx;
        if (dirty & /*spritesMap, inventory*/
        6) {
          set_style(div0, "background-image", "url(" + /*spritesMap*/
          ((_a3 = ctx[2].get(
            /*sprite*/
            ctx[11].spriteId
          )) == null ? void 0 : _a3.url) + ")");
        }
        if (dirty & /*spritesMap, inventory*/
        6 && t2_value !== (t2_value = /*spritesMap*/
        ((_b3 = ctx[2].get(
          /*sprite*/
          ctx[11].spriteId
        )) == null ? void 0 : _b3.id) + "")) set_data(t2, t2_value);
        if (dirty & /*spritesMap, inventory*/
        6 && t4_value !== (t4_value = /*spritesMap*/
        ((_c2 = ctx[2].get(
          /*sprite*/
          ctx[11].spriteId
        )) == null ? void 0 : _c2.name) + "")) set_data(t4, t4_value);
        if (dirty & /*inventory*/
        2) {
          set_style(
            div1,
            "order",
            /*sprite*/
            ctx[11].spriteId
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block$l, "create_if_block$l");
  function create_each_block$k(ctx) {
    let show_if = (
      /*sprite*/
      ctx[11].slot === void 0 && /*matchesFilter*/
      ctx[5](
        /*spritesMap*/
        ctx[2].get(
          /*sprite*/
          ctx[11].spriteId
        ),
        /*$filter*/
        ctx[3]
      )
    );
    let if_block_anchor;
    let if_block = show_if && create_if_block$l(ctx);
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*inventory, spritesMap, $filter*/
        14) show_if = /*sprite*/
        ctx2[11].slot === void 0 && /*matchesFilter*/
        ctx2[5](
          /*spritesMap*/
          ctx2[2].get(
            /*sprite*/
            ctx2[11].spriteId
          ),
          /*$filter*/
          ctx2[3]
        );
        if (show_if) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$l(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
      }
    };
  }
  __name(create_each_block$k, "create_each_block$k");
  function create_fragment$Y(ctx) {
    let div4;
    let span0;
    let t2;
    let div0;
    let span1;
    let t4;
    let input;
    let t5;
    let div3;
    let div2;
    let t8;
    let mounted;
    let dispose;
    let each_value = ensure_array_like(
      /*inventory*/
      ctx[1]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
    }
    return {
      c() {
        div4 = element("div");
        span0 = element("span");
        span0.innerHTML = `Choose a sprite from your inventory which will be used on the selected slot.<br/>
    You can only choose sprites that are not already in use.`;
        t2 = space();
        div0 = element("div");
        span1 = element("span");
        span1.textContent = "Filter sprites:";
        t4 = space();
        input = element("input");
        t5 = space();
        div3 = element("div");
        div2 = element("div");
        div2.innerHTML = `<div class="typo-sprite-picker-sprite-thumb svelte-1bcvdme"></div> <span class="svelte-1bcvdme">Empty</span>`;
        t8 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(span0, "class", "svelte-1bcvdme");
        attr(span1, "class", "svelte-1bcvdme");
        attr(input, "type", "text");
        attr(input, "placeholder", "Search for ID or name");
        attr(input, "class", "svelte-1bcvdme");
        attr(div0, "class", "typo-sprite-picker-filter svelte-1bcvdme");
        attr(div2, "class", "typo-sprite-picker-sprite svelte-1bcvdme");
        attr(div3, "class", "typo-sprite-picker-list color-scrollbar svelte-1bcvdme");
        attr(div4, "class", "typo-sprite-picker svelte-1bcvdme");
      },
      m(target, anchor) {
        insert(target, div4, anchor);
        append(div4, span0);
        append(div4, t2);
        append(div4, div0);
        append(div0, span1);
        append(div0, t4);
        append(div0, input);
        set_input_value(
          input,
          /*$filter*/
          ctx[3]
        );
        append(div4, t5);
        append(div4, div3);
        append(div3, div2);
        append(div3, t8);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div3, null);
          }
        }
        if (!mounted) {
          dispose = [
            listen(
              input,
              "input",
              /*input_input_handler*/
              ctx[8]
            ),
            listen(
              div2,
              "click",
              /*click_handler*/
              ctx[9]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*$filter*/
        8 && input.value !== /*$filter*/
        ctx2[3]) {
          set_input_value(
            input,
            /*$filter*/
            ctx2[3]
          );
        }
        if (dirty & /*inventory, onPick, spritesMap, undefined, matchesFilter, $filter*/
        47) {
          each_value = ensure_array_like(
            /*inventory*/
            ctx2[1]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$k(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$k(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div3, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div4);
        }
        destroy_each(each_blocks, detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$Y, "create_fragment$Y");
  function instance$U($$self, $$props, $$invalidate) {
    let $filter;
    let { feature } = $$props;
    let { onPick } = $$props;
    let { sprites } = $$props;
    let { inventory } = $$props;
    let filter2 = writable("");
    component_subscribe($$self, filter2, (value) => $$invalidate(3, $filter = value));
    const matchesFilter = /* @__PURE__ */ __name((sprite, filter3) => {
      if (!filter3 || sprite === void 0) return true;
      const lowerFilter = filter3.toLowerCase();
      return sprite.name.toLowerCase().includes(lowerFilter) || sprite.id.toString() === filter3;
    }, "matchesFilter");
    let spritesMap = /* @__PURE__ */ new Map();
    function input_input_handler() {
      $filter = this.value;
      filter2.set($filter);
    }
    __name(input_input_handler, "input_input_handler");
    const click_handler2 = /* @__PURE__ */ __name(() => onPick(null), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name((sprite) => onPick(spritesMap.get(sprite.spriteId)), "click_handler_1");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(6, feature = $$props2.feature);
      if ("onPick" in $$props2) $$invalidate(0, onPick = $$props2.onPick);
      if ("sprites" in $$props2) $$invalidate(7, sprites = $$props2.sprites);
      if ("inventory" in $$props2) $$invalidate(1, inventory = $$props2.inventory);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*sprites*/
      128) {
        {
          $$invalidate(2, spritesMap = new Map(sprites.map((sprite) => [sprite.id, sprite])));
        }
      }
    };
    return [
      onPick,
      inventory,
      spritesMap,
      $filter,
      filter2,
      matchesFilter,
      feature,
      sprites,
      input_input_handler,
      click_handler2,
      click_handler_1
    ];
  }
  __name(instance$U, "instance$U");
  const _Panel_cabin_sprite_picker = class _Panel_cabin_sprite_picker extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$U, create_fragment$Y, safe_not_equal, {
        feature: 6,
        onPick: 0,
        sprites: 7,
        inventory: 1
      });
    }
  };
  __name(_Panel_cabin_sprite_picker, "Panel_cabin_sprite_picker");
  let Panel_cabin_sprite_picker = _Panel_cabin_sprite_picker;
  function get_each_context$j(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[9] = list[i];
    return child_ctx;
  }
  __name(get_each_context$j, "get_each_context$j");
  function create_else_block$c(ctx) {
    var _a2, _b2;
    let div1;
    let div0;
    let t0;
    let span0;
    let t1;
    let t2_value = (
      /*scenesMap*/
      ((_a2 = ctx[3].get(
        /*scene*/
        ctx[9].sceneId
      )) == null ? void 0 : _a2.id) + ""
    );
    let t2;
    let t3;
    let span1;
    let t4_value = (
      /*scenesMap*/
      ((_b2 = ctx[3].get(
        /*scene*/
        ctx[9].sceneId
      )) == null ? void 0 : _b2.name) + ""
    );
    let t4;
    let t5;
    let mounted;
    let dispose;
    function click_handler_2() {
      return (
        /*click_handler_2*/
        ctx[8](
          /*scene*/
          ctx[9]
        )
      );
    }
    __name(click_handler_2, "click_handler_2");
    return {
      c() {
        var _a3;
        div1 = element("div");
        div0 = element("div");
        t0 = space();
        span0 = element("span");
        t1 = text("#");
        t2 = text(t2_value);
        t3 = space();
        span1 = element("span");
        t4 = text(t4_value);
        t5 = space();
        attr(div0, "class", "typo-scene-picker-scene-thumb svelte-1s2xvs0");
        set_style(div0, "background-image", "url(" + /*scenesMap*/
        ((_a3 = ctx[3].get(
          /*scene*/
          ctx[9].sceneId
        )) == null ? void 0 : _a3.url) + ")");
        attr(span0, "class", "id svelte-1s2xvs0");
        attr(span1, "class", "name svelte-1s2xvs0");
        attr(div1, "class", "typo-scene-picker-scene svelte-1s2xvs0");
        set_style(
          div1,
          "order",
          /*scene*/
          ctx[9].sceneId
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div1, t0);
        append(div1, span0);
        append(span0, t1);
        append(span0, t2);
        append(div1, t3);
        append(div1, span1);
        append(span1, t4);
        append(div1, t5);
        if (!mounted) {
          dispose = listen(div1, "click", click_handler_2);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        var _a3, _b3, _c2;
        ctx = new_ctx;
        if (dirty & /*scenesMap, inventory*/
        12) {
          set_style(div0, "background-image", "url(" + /*scenesMap*/
          ((_a3 = ctx[3].get(
            /*scene*/
            ctx[9].sceneId
          )) == null ? void 0 : _a3.url) + ")");
        }
        if (dirty & /*scenesMap, inventory*/
        12 && t2_value !== (t2_value = /*scenesMap*/
        ((_b3 = ctx[3].get(
          /*scene*/
          ctx[9].sceneId
        )) == null ? void 0 : _b3.id) + "")) set_data(t2, t2_value);
        if (dirty & /*scenesMap, inventory*/
        12 && t4_value !== (t4_value = /*scenesMap*/
        ((_c2 = ctx[3].get(
          /*scene*/
          ctx[9].sceneId
        )) == null ? void 0 : _c2.name) + "")) set_data(t4, t4_value);
        if (dirty & /*inventory*/
        4) {
          set_style(
            div1,
            "order",
            /*scene*/
            ctx[9].sceneId
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_else_block$c, "create_else_block$c");
  function create_if_block$k(ctx) {
    var _a2, _b2, _c2;
    let div1;
    let div0;
    let t0;
    let span0;
    let t1;
    let t2_value = (
      /*scenesMap*/
      ((_a2 = ctx[3].get(
        /*scene*/
        ctx[9].sceneId
      )) == null ? void 0 : _a2.id) + ""
    );
    let t2;
    let t3;
    let t4_value = (
      /*scene*/
      ctx[9].sceneShift + ""
    );
    let t4;
    let t5;
    let t6;
    let span1;
    let t7_value = (
      /*scenesMap*/
      ((_c2 = (_b2 = ctx[3].get(
        /*scene*/
        ctx[9].sceneId
      )) == null ? void 0 : _b2.themes.find(func2)) == null ? void 0 : _c2.name) + ""
    );
    let t7;
    let t8;
    let mounted;
    let dispose;
    function func2(...args) {
      return (
        /*func*/
        ctx[6](
          /*scene*/
          ctx[9],
          ...args
        )
      );
    }
    __name(func2, "func");
    function click_handler_1() {
      return (
        /*click_handler_1*/
        ctx[7](
          /*scene*/
          ctx[9]
        )
      );
    }
    __name(click_handler_1, "click_handler_1");
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        t0 = space();
        span0 = element("span");
        t1 = text("#");
        t2 = text(t2_value);
        t3 = text(" (color #");
        t4 = text(t4_value);
        t5 = text(")");
        t6 = space();
        span1 = element("span");
        t7 = text(t7_value);
        t8 = space();
        attr(div0, "class", "typo-scene-picker-scene-thumb svelte-1s2xvs0");
        set_style(div0, "background-image", "url(" + /*feature*/
        ctx[0].getItemThumbnailUrl(
          /*scenesMap*/
          ctx[3].get(
            /*scene*/
            ctx[9].sceneId
          ),
          /*scene*/
          ctx[9].sceneShift
        ) + ")");
        attr(span0, "class", "id svelte-1s2xvs0");
        attr(span1, "class", "name svelte-1s2xvs0");
        attr(div1, "class", "typo-scene-picker-scene svelte-1s2xvs0");
        set_style(
          div1,
          "order",
          /*scene*/
          ctx[9].sceneId
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div1, t0);
        append(div1, span0);
        append(span0, t1);
        append(span0, t2);
        append(span0, t3);
        append(span0, t4);
        append(span0, t5);
        append(div1, t6);
        append(div1, span1);
        append(span1, t7);
        insert(target, t8, anchor);
        if (!mounted) {
          dispose = listen(div1, "click", click_handler_1);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        var _a3, _b3, _c3;
        ctx = new_ctx;
        if (dirty & /*feature, scenesMap, inventory*/
        13) {
          set_style(div0, "background-image", "url(" + /*feature*/
          ctx[0].getItemThumbnailUrl(
            /*scenesMap*/
            ctx[3].get(
              /*scene*/
              ctx[9].sceneId
            ),
            /*scene*/
            ctx[9].sceneShift
          ) + ")");
        }
        if (dirty & /*scenesMap, inventory*/
        12 && t2_value !== (t2_value = /*scenesMap*/
        ((_a3 = ctx[3].get(
          /*scene*/
          ctx[9].sceneId
        )) == null ? void 0 : _a3.id) + "")) set_data(t2, t2_value);
        if (dirty & /*inventory*/
        4 && t4_value !== (t4_value = /*scene*/
        ctx[9].sceneShift + "")) set_data(t4, t4_value);
        if (dirty & /*scenesMap, inventory*/
        12 && t7_value !== (t7_value = /*scenesMap*/
        ((_c3 = (_b3 = ctx[3].get(
          /*scene*/
          ctx[9].sceneId
        )) == null ? void 0 : _b3.themes.find(func2)) == null ? void 0 : _c3.name) + "")) set_data(t7, t7_value);
        if (dirty & /*inventory*/
        4) {
          set_style(
            div1,
            "order",
            /*scene*/
            ctx[9].sceneId
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
          detach(t8);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block$k, "create_if_block$k");
  function create_each_block$j(ctx) {
    let if_block_anchor;
    function select_block_type(ctx2, dirty) {
      if (
        /*scene*/
        ctx2[9].sceneShift
      ) return create_if_block$k;
      return create_else_block$c;
    }
    __name(select_block_type, "select_block_type");
    let current_block_type = select_block_type(ctx);
    let if_block = current_block_type(ctx);
    return {
      c() {
        if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        }
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if_block.d(detaching);
      }
    };
  }
  __name(create_each_block$j, "create_each_block$j");
  function create_fragment$X(ctx) {
    let div3;
    let span0;
    let t1;
    let div2;
    let div1;
    let t4;
    let mounted;
    let dispose;
    let each_value = ensure_array_like(
      /*inventory*/
      ctx[2].scenes
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
    }
    return {
      c() {
        div3 = element("div");
        span0 = element("span");
        span0.textContent = "Choose a scene from your inventory which will be used as your avatar background.";
        t1 = space();
        div2 = element("div");
        div1 = element("div");
        div1.innerHTML = `<div class="typo-scene-picker-scene-thumb svelte-1s2xvs0"></div> <span class="svelte-1s2xvs0">Empty</span>`;
        t4 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(span0, "class", "svelte-1s2xvs0");
        attr(div1, "class", "typo-scene-picker-scene svelte-1s2xvs0");
        attr(div2, "class", "typo-scene-picker-list color-scrollbar svelte-1s2xvs0");
        attr(div3, "class", "typo-scene-picker svelte-1s2xvs0");
      },
      m(target, anchor) {
        insert(target, div3, anchor);
        append(div3, span0);
        append(div3, t1);
        append(div3, div2);
        append(div2, div1);
        append(div2, t4);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div2, null);
          }
        }
        if (!mounted) {
          dispose = listen(
            div1,
            "click",
            /*click_handler*/
            ctx[5]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*inventory, onPick, scenesMap, feature, undefined*/
        15) {
          each_value = ensure_array_like(
            /*inventory*/
            ctx2[2].scenes
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$j(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$j(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div2, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div3);
        }
        destroy_each(each_blocks, detaching);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$X, "create_fragment$X");
  function instance$T($$self, $$props, $$invalidate) {
    let { feature } = $$props;
    let { onPick } = $$props;
    let { scenes } = $$props;
    let { inventory } = $$props;
    let scenesMap = /* @__PURE__ */ new Map();
    const click_handler2 = /* @__PURE__ */ __name(() => onPick(null, void 0), "click_handler");
    const func2 = /* @__PURE__ */ __name((scene, t) => t.shift === scene.sceneShift, "func");
    const click_handler_1 = /* @__PURE__ */ __name((scene) => onPick(scenesMap.get(scene.sceneId), scene.sceneShift), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name((scene) => onPick(scenesMap.get(scene.sceneId), void 0), "click_handler_2");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
      if ("onPick" in $$props2) $$invalidate(1, onPick = $$props2.onPick);
      if ("scenes" in $$props2) $$invalidate(4, scenes = $$props2.scenes);
      if ("inventory" in $$props2) $$invalidate(2, inventory = $$props2.inventory);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*scenes*/
      16) {
        {
          $$invalidate(3, scenesMap = new Map(scenes.map((scene) => [scene.id, scene])));
        }
      }
    };
    return [
      feature,
      onPick,
      inventory,
      scenesMap,
      scenes,
      click_handler2,
      func2,
      click_handler_1,
      click_handler_2
    ];
  }
  __name(instance$T, "instance$T");
  const _Panel_cabin_scene_picker = class _Panel_cabin_scene_picker extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$T, create_fragment$X, safe_not_equal, {
        feature: 0,
        onPick: 1,
        scenes: 4,
        inventory: 2
      });
    }
  };
  __name(_Panel_cabin_scene_picker, "Panel_cabin_scene_picker");
  let Panel_cabin_scene_picker = _Panel_cabin_scene_picker;
  var __defProp$x = Object.defineProperty;
  var __decorateClass$x = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$x(target, key2, result);
    return result;
  }, "__decorateClass$x");
  const _PanelCabinFeature = class _PanelCabinFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elements");
      __publicField(this, "_apiDataSetup");
      __publicField(this, "_memberService");
      __publicField(this, "_apiService");
      __publicField(this, "_modalService");
      __publicField(this, "_toastService");
      __publicField(this, "_component");
      __publicField(this, "name", "Outfit Cabin");
      __publicField(this, "description", "Displays a drag-n-drop interface on the start page to customize your sprite combo");
      __publicField(this, "tags", [
        FeatureTag.PALANTIR
      ]);
      __publicField(this, "featureId", 3);
      __publicField(this, "_enableScenePickerSetting", this.useSetting(
        new BooleanExtensionSetting("enable_scene_picker", true, this).withName("Enable Scene Picker").withDescription("Show the scene picker at the top of the sprite cabin")
      ));
    }
    async onActivate() {
      const elements2 = await this._elements.complete();
      this._component = new Panel_cabin({
        target: elements2.cabinTab,
        props: {
          feature: this
        }
      });
    }
    onDestroy() {
      var _a2;
      (_a2 = this._component) == null ? void 0 : _a2.$destroy();
    }
    get scenePickerSettingStore() {
      return this._enableScenePickerSetting.store;
    }
    get memberStore() {
      return fromObservable(
        this._memberService.memberData$.pipe(
          /* map data into useful structure */
          switchMap(async (memberData) => {
            if (memberData === null || memberData === void 0) {
              return null;
            }
            const apiData = await this._apiDataSetup.complete();
            const slots = new Map(
              memberData.spriteInventory.filter((i) => i.slot !== void 0).map((i) => ({
                ...i,
                sprite: apiData.sprites.find((s) => s.id === i.spriteId)
              })).map((i) => [(i.slot ?? 0) - 1, i])
            );
            const scene = memberData.sceneInventory.activeId ? {
              id: memberData.sceneInventory.activeId,
              shift: memberData.sceneInventory.activeShift,
              scene: apiData.scenes.find((s) => s.id === memberData.sceneInventory.activeId)
            } : void 0;
            return { memberData, slots, scene };
          })
        ),
        void 0
      );
    }
    /**
     * Generates a url of a scene or sprite, optionally shifted if provided
     * @param item
     * @param shift
     */
    getItemThumbnailUrl(item, shift) {
      return item ? shift !== void 0 ? `https://static.typo.rip/sprites/rainbow/modulate.php?url=${item.url}&hue=${shift}` : item.url : "";
    }
    /**
     * Reorder the slots of a user
     * @param slotMap
     * @param inventory
     * @param login
     */
    async reorderSlots(slotMap, inventory, login) {
      this._logger.debug("Reordering slots", slotMap, inventory);
      if (slotMap.every((v, i) => v === i)) {
        this._logger.info("No change in slot order");
        return;
      }
      const slots = [];
      inventory.forEach((item) => {
        if (item.slot !== void 0) {
          slots.push({ slotId: slotMap[item.slot - 1] + 1, spriteId: item.spriteId });
        }
      });
      await this._apiService.getApi(InventoryApi).setMemberSpriteCombo({ login, spriteComboDto: { slots } });
      await this._memberService.refreshInventory();
      this._logger.info("Reordered slots", slots);
    }
    /**
     * Prompt the user to select a sprite
     * @param inventory
     */
    async promptSpriteSelection(inventory) {
      this._logger.debug("Opening sprite picker");
      const sprites = (await this._apiDataSetup.complete()).sprites;
      const pickerComponent = {
        componentType: Panel_cabin_sprite_picker,
        propsFactory: /* @__PURE__ */ __name((submit) => ({
          feature: this,
          inventory,
          sprites,
          onPick: submit.bind(this)
        }), "propsFactory")
      };
      const sprite = await this._modalService.showPrompt(
        pickerComponent.componentType,
        pickerComponent.propsFactory,
        "Sprite Picker",
        "document"
      );
      this._logger.debug("Sprite picker closed", sprite);
      return sprite;
    }
    /**
     * Set a sprite on a slot for a user
     * @param slot
     * @param sprite
     * @param login
     */
    async setSpriteOnSlot(slot, sprite, login) {
      this._logger.debug("Setting sprite on slot", slot, sprite);
      try {
        await this._apiService.getApi(InventoryApi).setMemberSpriteSlot({ login, spriteSlotDto: { slotId: slot, spriteId: (sprite == null ? void 0 : sprite.id) ?? 0 } });
        await this._memberService.refreshInventory();
      } catch (e) {
        this._logger.error("Failed to set sprite on slot", e);
        await this._toastService.showToast("Failed to set sprite on slot");
      }
    }
    /**
     * Prompt the user to select a scene
     * @param inventory
     */
    async promptSceneSelection(inventory) {
      this._logger.debug("Opening scene picker");
      const scenes = (await this._apiDataSetup.complete()).scenes;
      const pickerComponent = {
        componentType: Panel_cabin_scene_picker,
        propsFactory: /* @__PURE__ */ __name((submit) => ({
          feature: this,
          inventory,
          scenes,
          onPick: /* @__PURE__ */ __name((scene2, shift) => submit(scene2 ? { scene: scene2, shift } : scene2), "onPick")
        }), "propsFactory")
      };
      const scene = await this._modalService.showPrompt(
        pickerComponent.componentType,
        pickerComponent.propsFactory,
        "Scene Picker",
        "document"
      );
      this._logger.debug("Scene picker closed", scene);
      return scene;
    }
    /**
     * Set the scene of a user
     * @param scene
     * @param shift
     * @param login
     */
    async setScene(scene, shift, login) {
      this._logger.debug("Setting scene", scene, shift);
      try {
        await this._apiService.getApi(InventoryApi).setMemberScene({ login, setActiveSceneDto: { scene: scene ? { sceneId: scene.id, sceneShift: shift } : void 0 } });
        await this._memberService.refreshInventory();
      } catch (e) {
        this._logger.error("Failed to set scene", e);
        await this._toastService.showToast("Failed to set scene");
      }
    }
  };
  __name(_PanelCabinFeature, "PanelCabinFeature");
  let PanelCabinFeature = _PanelCabinFeature;
  __decorateClass$x([
    inject(ElementsSetup)
  ], PanelCabinFeature.prototype, "_elements");
  __decorateClass$x([
    inject(ApiDataSetup)
  ], PanelCabinFeature.prototype, "_apiDataSetup");
  __decorateClass$x([
    inject(MemberService)
  ], PanelCabinFeature.prototype, "_memberService");
  __decorateClass$x([
    inject(ApiService)
  ], PanelCabinFeature.prototype, "_apiService");
  __decorateClass$x([
    inject(ModalService)
  ], PanelCabinFeature.prototype, "_modalService");
  __decorateClass$x([
    inject(ToastService)
  ], PanelCabinFeature.prototype, "_toastService");
  function get_each_context$i(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[5] = list[i];
    return child_ctx;
  }
  __name(get_each_context$i, "get_each_context$i");
  function create_if_block_2$7(ctx) {
    let p;
    let t0;
    let t1_value = (
      /*feature*/
      ctx[0].getVersion() + ""
    );
    let t1;
    return {
      c() {
        p = element("p");
        t0 = text("Typo version: ");
        t1 = text(t1_value);
        attr(p, "class", "typo-version svelte-eh7e5t");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        append(p, t0);
        append(p, t1);
      },
      p(ctx2, dirty) {
        if (dirty & /*feature*/
        1 && t1_value !== (t1_value = /*feature*/
        ctx2[0].getVersion() + "")) set_data(t1, t1_value);
      },
      d(detaching) {
        if (detaching) {
          detach(p);
        }
      }
    };
  }
  __name(create_if_block_2$7, "create_if_block_2$7");
  function create_else_block$b(ctx) {
    let each_1_anchor;
    let each_value = ensure_array_like(
      /*changes*/
      ctx[1]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
    }
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*changes, feature, undefined, Date, Number*/
        3) {
          each_value = ensure_array_like(
            /*changes*/
            ctx2[1]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$i(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$i(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_else_block$b, "create_else_block$b");
  function create_if_block$j(ctx) {
    let bounceload;
    let current;
    bounceload = new Bounceload({
      props: { content: "Loading changelog.." }
    });
    return {
      c() {
        create_component(bounceload.$$.fragment);
      },
      m(target, anchor) {
        mount_component(bounceload, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(bounceload, detaching);
      }
    };
  }
  __name(create_if_block$j, "create_if_block$j");
  function create_if_block_1$9(ctx) {
    let span;
    return {
      c() {
        span = element("span");
        span.textContent = "Read more..";
        attr(span, "class", "details svelte-eh7e5t");
      },
      m(target, anchor) {
        insert(target, span, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  __name(create_if_block_1$9, "create_if_block_1$9");
  function create_each_block$i(ctx) {
    let div1;
    let div0;
    let b;
    let t0_value = (
      /*change*/
      ctx[5].title + ""
    );
    let t0;
    let t1;
    let span;
    let t2_value = (
      /*change*/
      ctx[5].affectedTypoVersion + ""
    );
    let t2;
    let t3;
    let t4_value = new Date(Number(
      /*change*/
      ctx[5].date
    )).toLocaleDateString() + "";
    let t4;
    let t5;
    let t6;
    let p;
    let t7_value = (
      /*change*/
      ctx[5].content + ""
    );
    let t7;
    let t8;
    let t9;
    let mounted;
    let dispose;
    let if_block = (
      /*change*/
      ctx[5].details !== void 0 && create_if_block_1$9()
    );
    function click_handler2() {
      return (
        /*click_handler*/
        ctx[4](
          /*change*/
          ctx[5]
        )
      );
    }
    __name(click_handler2, "click_handler");
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = space();
        span = element("span");
        t2 = text(t2_value);
        t3 = text(" (");
        t4 = text(t4_value);
        t5 = text(")");
        t6 = space();
        p = element("p");
        t7 = text(t7_value);
        t8 = space();
        if (if_block) if_block.c();
        t9 = space();
        attr(span, "class", "svelte-eh7e5t");
        attr(div0, "class", "title svelte-eh7e5t");
        attr(div1, "class", "change svelte-eh7e5t");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div0, b);
        append(b, t0);
        append(div0, t1);
        append(div0, span);
        append(span, t2);
        append(span, t3);
        append(span, t4);
        append(span, t5);
        append(div1, t6);
        append(div1, p);
        append(p, t7);
        append(div1, t8);
        if (if_block) if_block.m(div1, null);
        append(div1, t9);
        if (!mounted) {
          dispose = listen(div1, "click", click_handler2);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*changes*/
        2 && t0_value !== (t0_value = /*change*/
        ctx[5].title + "")) set_data(t0, t0_value);
        if (dirty & /*changes*/
        2 && t2_value !== (t2_value = /*change*/
        ctx[5].affectedTypoVersion + "")) set_data(t2, t2_value);
        if (dirty & /*changes*/
        2 && t4_value !== (t4_value = new Date(Number(
          /*change*/
          ctx[5].date
        )).toLocaleDateString() + "")) set_data(t4, t4_value);
        if (dirty & /*changes*/
        2 && t7_value !== (t7_value = /*change*/
        ctx[5].content + "")) set_data(t7, t7_value);
        if (
          /*change*/
          ctx[5].details !== void 0
        ) {
          if (if_block) ;
          else {
            if_block = create_if_block_1$9();
            if_block.c();
            if_block.m(div1, t9);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if (if_block) if_block.d();
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block$i, "create_each_block$i");
  function create_fragment$W(ctx) {
    let div1;
    let t;
    let div0;
    let current_block_type_index;
    let if_block1;
    let current;
    let if_block0 = (
      /*$devmode*/
      ctx[2] && create_if_block_2$7(ctx)
    );
    const if_block_creators = [create_if_block$j, create_else_block$b];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*changes*/
        ctx2[1] === void 0
      ) return 0;
      return 1;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div1 = element("div");
        if (if_block0) if_block0.c();
        t = space();
        div0 = element("div");
        if_block1.c();
        attr(div0, "class", "changelog svelte-eh7e5t");
        attr(div1, "class", "panel-changelog svelte-eh7e5t");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        if (if_block0) if_block0.m(div1, null);
        append(div1, t);
        append(div1, div0);
        if_blocks[current_block_type_index].m(div0, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (
          /*$devmode*/
          ctx2[2]
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_2$7(ctx2);
            if_block0.c();
            if_block0.m(div1, t);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block1);
        current = true;
      },
      o(local) {
        transition_out(if_block1);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if (if_block0) if_block0.d();
        if_blocks[current_block_type_index].d();
      }
    };
  }
  __name(create_fragment$W, "create_fragment$W");
  function instance$S($$self, $$props, $$invalidate) {
    let $devmode;
    let { feature } = $$props;
    let { changes = void 0 } = $$props;
    const devmode = feature.devmodeStore;
    component_subscribe($$self, devmode, (value) => $$invalidate(2, $devmode = value));
    const click_handler2 = /* @__PURE__ */ __name((change) => {
      if (change.details) feature.showDetailsModal(change);
    }, "click_handler");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
      if ("changes" in $$props2) $$invalidate(1, changes = $$props2.changes);
    };
    return [feature, changes, $devmode, devmode, click_handler2];
  }
  __name(instance$S, "instance$S");
  const _Panel_changelog = class _Panel_changelog extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$S, create_fragment$W, safe_not_equal, { feature: 0, changes: 1 });
    }
  };
  __name(_Panel_changelog, "Panel_changelog");
  let Panel_changelog = _Panel_changelog;
  function supressWarnings() {
    const origWarn = console.warn;
    console.warn = (message) => {
      if (message.includes("unknown prop")) return;
      if (message.includes("unexpected slot")) return;
      origWarn(message);
    };
    onMount(() => {
      console.warn = origWarn;
    });
  }
  __name(supressWarnings, "supressWarnings");
  function get_each_context_5(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[18] = list[i];
    return child_ctx;
  }
  __name(get_each_context_5, "get_each_context_5");
  function get_each_context_4(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[18] = list[i];
    return child_ctx;
  }
  __name(get_each_context_4, "get_each_context_4");
  function get_each_context_1$7(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[10] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1$7, "get_each_context_1$7");
  function get_each_context_2$3(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[13] = list[i];
    child_ctx[15] = i;
    return child_ctx;
  }
  __name(get_each_context_2$3, "get_each_context_2$3");
  function get_each_context_3$1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[16] = list[i];
    child_ctx[15] = i;
    return child_ctx;
  }
  __name(get_each_context_3$1, "get_each_context_3$1");
  function get_each_context$h(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[7] = list[i];
    return child_ctx;
  }
  __name(get_each_context$h, "get_each_context$h");
  function create_if_block_1$8(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block_2$6, create_if_block_3$4, create_else_block_1$1];
    const if_blocks = [];
    function select_block_type_1(ctx2, dirty) {
      if (
        /*type*/
        ctx2[0] === "table"
      ) return 0;
      if (
        /*type*/
        ctx2[0] === "list"
      ) return 1;
      return 2;
    }
    __name(select_block_type_1, "select_block_type_1");
    current_block_type_index = select_block_type_1(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if_blocks[current_block_type_index].m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type_1(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if_blocks[current_block_type_index].d(detaching);
      }
    };
  }
  __name(create_if_block_1$8, "create_if_block_1$8");
  function create_if_block$i(ctx) {
    let each_1_anchor;
    let current;
    let each_value = ensure_array_like(
      /*tokens*/
      ctx[1]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*tokens, renderers*/
        34) {
          each_value = ensure_array_like(
            /*tokens*/
            ctx2[1]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$h(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$h(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_if_block$i, "create_if_block$i");
  function create_else_block_1$1(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      /*$$restProps*/
      ctx[6]
    ];
    var switch_value = (
      /*renderers*/
      ctx[5][
        /*type*/
        ctx[0]
      ]
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {
        $$slots: { default: [create_default_slot_11] },
        $$scope: { ctx: ctx2 }
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*$$restProps*/
      64) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance) create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) mount_component(switch_instance, target, anchor);
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers, type*/
        33 && switch_value !== (switch_value = /*renderers*/
        ctx2[5][
          /*type*/
          ctx2[0]
        ])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*$$restProps*/
          64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
            /*$$restProps*/
            ctx2[6]
          )]) : {};
          if (dirty & /*$$scope, tokens, renderers, $$restProps*/
          8388706) {
            switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(switch_instance_anchor);
        }
        if (switch_instance) destroy_component(switch_instance, detaching);
      }
    };
  }
  __name(create_else_block_1$1, "create_else_block_1$1");
  function create_if_block_3$4(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block_4$4, create_else_block$a];
    const if_blocks = [];
    function select_block_type_2(ctx2, dirty) {
      if (
        /*ordered*/
        ctx2[4]
      ) return 0;
      return 1;
    }
    __name(select_block_type_2, "select_block_type_2");
    current_block_type_index = select_block_type_2(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if_blocks[current_block_type_index].m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type_2(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if_blocks[current_block_type_index].d(detaching);
      }
    };
  }
  __name(create_if_block_3$4, "create_if_block_3$4");
  function create_if_block_2$6(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    var switch_value = (
      /*renderers*/
      ctx[5].table
    );
    function switch_props(ctx2, dirty) {
      return {
        props: {
          $$slots: { default: [create_default_slot] },
          $$scope: { ctx: ctx2 }
        }
      };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance) create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) mount_component(switch_instance, target, anchor);
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers*/
        32 && switch_value !== (switch_value = /*renderers*/
        ctx2[5].table)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = {};
          if (dirty & /*$$scope, renderers, rows, $$restProps, header*/
          8388716) {
            switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(switch_instance_anchor);
        }
        if (switch_instance) destroy_component(switch_instance, detaching);
      }
    };
  }
  __name(create_if_block_2$6, "create_if_block_2$6");
  function create_else_block_2(ctx) {
    let t_value = (
      /*$$restProps*/
      ctx[6].raw + ""
    );
    let t;
    return {
      c() {
        t = text(t_value);
      },
      m(target, anchor) {
        insert(target, t, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*$$restProps*/
        64 && t_value !== (t_value = /*$$restProps*/
        ctx2[6].raw + "")) set_data(t, t_value);
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(t);
        }
      }
    };
  }
  __name(create_else_block_2, "create_else_block_2");
  function create_if_block_5$2(ctx) {
    let parser;
    let current;
    parser = new Parser$1({
      props: {
        tokens: (
          /*tokens*/
          ctx[1]
        ),
        renderers: (
          /*renderers*/
          ctx[5]
        )
      }
    });
    return {
      c() {
        create_component(parser.$$.fragment);
      },
      m(target, anchor) {
        mount_component(parser, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const parser_changes = {};
        if (dirty & /*tokens*/
        2) parser_changes.tokens = /*tokens*/
        ctx2[1];
        if (dirty & /*renderers*/
        32) parser_changes.renderers = /*renderers*/
        ctx2[5];
        parser.$set(parser_changes);
      },
      i(local) {
        if (current) return;
        transition_in(parser.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(parser.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(parser, detaching);
      }
    };
  }
  __name(create_if_block_5$2, "create_if_block_5$2");
  function create_default_slot_11(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block_5$2, create_else_block_2];
    const if_blocks = [];
    function select_block_type_3(ctx2, dirty) {
      if (
        /*tokens*/
        ctx2[1]
      ) return 0;
      return 1;
    }
    __name(select_block_type_3, "select_block_type_3");
    current_block_type_index = select_block_type_3(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if_blocks[current_block_type_index].m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type_3(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if_blocks[current_block_type_index].d(detaching);
      }
    };
  }
  __name(create_default_slot_11, "create_default_slot_11");
  function create_else_block$a(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      { ordered: (
        /*ordered*/
        ctx[4]
      ) },
      /*$$restProps*/
      ctx[6]
    ];
    var switch_value = (
      /*renderers*/
      ctx[5].list
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {
        $$slots: { default: [create_default_slot_9] },
        $$scope: { ctx: ctx2 }
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*ordered, $$restProps*/
      80) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
          dirty & /*ordered*/
          16 && { ordered: (
            /*ordered*/
            ctx2[4]
          ) },
          dirty & /*$$restProps*/
          64 && get_spread_object(
            /*$$restProps*/
            ctx2[6]
          )
        ]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance) create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) mount_component(switch_instance, target, anchor);
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers*/
        32 && switch_value !== (switch_value = /*renderers*/
        ctx2[5].list)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*ordered, $$restProps*/
          80 ? get_spread_update(switch_instance_spread_levels, [
            dirty & /*ordered*/
            16 && { ordered: (
              /*ordered*/
              ctx2[4]
            ) },
            dirty & /*$$restProps*/
            64 && get_spread_object(
              /*$$restProps*/
              ctx2[6]
            )
          ]) : {};
          if (dirty & /*$$scope, $$restProps, renderers*/
          8388704) {
            switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(switch_instance_anchor);
        }
        if (switch_instance) destroy_component(switch_instance, detaching);
      }
    };
  }
  __name(create_else_block$a, "create_else_block$a");
  function create_if_block_4$4(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      { ordered: (
        /*ordered*/
        ctx[4]
      ) },
      /*$$restProps*/
      ctx[6]
    ];
    var switch_value = (
      /*renderers*/
      ctx[5].list
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {
        $$slots: { default: [create_default_slot_7] },
        $$scope: { ctx: ctx2 }
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*ordered, $$restProps*/
      80) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
          dirty & /*ordered*/
          16 && { ordered: (
            /*ordered*/
            ctx2[4]
          ) },
          dirty & /*$$restProps*/
          64 && get_spread_object(
            /*$$restProps*/
            ctx2[6]
          )
        ]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance) create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) mount_component(switch_instance, target, anchor);
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers*/
        32 && switch_value !== (switch_value = /*renderers*/
        ctx2[5].list)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*ordered, $$restProps*/
          80 ? get_spread_update(switch_instance_spread_levels, [
            dirty & /*ordered*/
            16 && { ordered: (
              /*ordered*/
              ctx2[4]
            ) },
            dirty & /*$$restProps*/
            64 && get_spread_object(
              /*$$restProps*/
              ctx2[6]
            )
          ]) : {};
          if (dirty & /*$$scope, $$restProps, renderers*/
          8388704) {
            switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(switch_instance_anchor);
        }
        if (switch_instance) destroy_component(switch_instance, detaching);
      }
    };
  }
  __name(create_if_block_4$4, "create_if_block_4$4");
  function create_default_slot_10(ctx) {
    let parser;
    let t;
    let current;
    parser = new Parser$1({
      props: {
        tokens: (
          /*item*/
          ctx[18].tokens
        ),
        renderers: (
          /*renderers*/
          ctx[5]
        )
      }
    });
    return {
      c() {
        create_component(parser.$$.fragment);
        t = space();
      },
      m(target, anchor) {
        mount_component(parser, target, anchor);
        insert(target, t, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const parser_changes = {};
        if (dirty & /*$$restProps*/
        64) parser_changes.tokens = /*item*/
        ctx2[18].tokens;
        if (dirty & /*renderers*/
        32) parser_changes.renderers = /*renderers*/
        ctx2[5];
        parser.$set(parser_changes);
      },
      i(local) {
        if (current) return;
        transition_in(parser.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(parser.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t);
        }
        destroy_component(parser, detaching);
      }
    };
  }
  __name(create_default_slot_10, "create_default_slot_10");
  function create_each_block_5(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      /*item*/
      ctx[18]
    ];
    var switch_value = (
      /*renderers*/
      ctx[5].unorderedlistitem || /*renderers*/
      ctx[5].listitem
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {
        $$slots: { default: [create_default_slot_10] },
        $$scope: { ctx: ctx2 }
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*$$restProps*/
      64) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*item*/
          ctx2[18]
        )]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance) create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) mount_component(switch_instance, target, anchor);
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers*/
        32 && switch_value !== (switch_value = /*renderers*/
        ctx2[5].unorderedlistitem || /*renderers*/
        ctx2[5].listitem)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*$$restProps*/
          64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
            /*item*/
            ctx2[18]
          )]) : {};
          if (dirty & /*$$scope, $$restProps, renderers*/
          8388704) {
            switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(switch_instance_anchor);
        }
        if (switch_instance) destroy_component(switch_instance, detaching);
      }
    };
  }
  __name(create_each_block_5, "create_each_block_5");
  function create_default_slot_9(ctx) {
    let each_1_anchor;
    let current;
    let each_value_5 = ensure_array_like(
      /*$$restProps*/
      ctx[6].items
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_5.length; i += 1) {
      each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers, $$restProps*/
        96) {
          each_value_5 = ensure_array_like(
            /*$$restProps*/
            ctx2[6].items
          );
          let i;
          for (i = 0; i < each_value_5.length; i += 1) {
            const child_ctx = get_each_context_5(ctx2, each_value_5, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_5(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          group_outros();
          for (i = each_value_5.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value_5.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_default_slot_9, "create_default_slot_9");
  function create_default_slot_8(ctx) {
    let parser;
    let t;
    let current;
    parser = new Parser$1({
      props: {
        tokens: (
          /*item*/
          ctx[18].tokens
        ),
        renderers: (
          /*renderers*/
          ctx[5]
        )
      }
    });
    return {
      c() {
        create_component(parser.$$.fragment);
        t = space();
      },
      m(target, anchor) {
        mount_component(parser, target, anchor);
        insert(target, t, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const parser_changes = {};
        if (dirty & /*$$restProps*/
        64) parser_changes.tokens = /*item*/
        ctx2[18].tokens;
        if (dirty & /*renderers*/
        32) parser_changes.renderers = /*renderers*/
        ctx2[5];
        parser.$set(parser_changes);
      },
      i(local) {
        if (current) return;
        transition_in(parser.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(parser.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t);
        }
        destroy_component(parser, detaching);
      }
    };
  }
  __name(create_default_slot_8, "create_default_slot_8");
  function create_each_block_4(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      /*item*/
      ctx[18]
    ];
    var switch_value = (
      /*renderers*/
      ctx[5].orderedlistitem || /*renderers*/
      ctx[5].listitem
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {
        $$slots: { default: [create_default_slot_8] },
        $$scope: { ctx: ctx2 }
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*$$restProps*/
      64) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*item*/
          ctx2[18]
        )]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance) create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) mount_component(switch_instance, target, anchor);
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers*/
        32 && switch_value !== (switch_value = /*renderers*/
        ctx2[5].orderedlistitem || /*renderers*/
        ctx2[5].listitem)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*$$restProps*/
          64 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
            /*item*/
            ctx2[18]
          )]) : {};
          if (dirty & /*$$scope, $$restProps, renderers*/
          8388704) {
            switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(switch_instance_anchor);
        }
        if (switch_instance) destroy_component(switch_instance, detaching);
      }
    };
  }
  __name(create_each_block_4, "create_each_block_4");
  function create_default_slot_7(ctx) {
    let each_1_anchor;
    let current;
    let each_value_4 = ensure_array_like(
      /*$$restProps*/
      ctx[6].items
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_4.length; i += 1) {
      each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers, $$restProps*/
        96) {
          each_value_4 = ensure_array_like(
            /*$$restProps*/
            ctx2[6].items
          );
          let i;
          for (i = 0; i < each_value_4.length; i += 1) {
            const child_ctx = get_each_context_4(ctx2, each_value_4, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_4(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          group_outros();
          for (i = each_value_4.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value_4.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_default_slot_7, "create_default_slot_7");
  function create_default_slot_6(ctx) {
    let parser;
    let t;
    let current;
    parser = new Parser$1({
      props: {
        tokens: (
          /*headerItem*/
          ctx[16].tokens
        ),
        renderers: (
          /*renderers*/
          ctx[5]
        )
      }
    });
    return {
      c() {
        create_component(parser.$$.fragment);
        t = space();
      },
      m(target, anchor) {
        mount_component(parser, target, anchor);
        insert(target, t, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const parser_changes = {};
        if (dirty & /*header*/
        4) parser_changes.tokens = /*headerItem*/
        ctx2[16].tokens;
        if (dirty & /*renderers*/
        32) parser_changes.renderers = /*renderers*/
        ctx2[5];
        parser.$set(parser_changes);
      },
      i(local) {
        if (current) return;
        transition_in(parser.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(parser.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t);
        }
        destroy_component(parser, detaching);
      }
    };
  }
  __name(create_default_slot_6, "create_default_slot_6");
  function create_each_block_3$1(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    var switch_value = (
      /*renderers*/
      ctx[5].tablecell
    );
    function switch_props(ctx2, dirty) {
      return {
        props: {
          header: true,
          align: (
            /*$$restProps*/
            ctx2[6].align[
              /*i*/
              ctx2[15]
            ] || "center"
          ),
          $$slots: { default: [create_default_slot_6] },
          $$scope: { ctx: ctx2 }
        }
      };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance) create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) mount_component(switch_instance, target, anchor);
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers*/
        32 && switch_value !== (switch_value = /*renderers*/
        ctx2[5].tablecell)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = {};
          if (dirty & /*$$restProps*/
          64) switch_instance_changes.align = /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center";
          if (dirty & /*$$scope, header, renderers*/
          8388644) {
            switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(switch_instance_anchor);
        }
        if (switch_instance) destroy_component(switch_instance, detaching);
      }
    };
  }
  __name(create_each_block_3$1, "create_each_block_3$1");
  function create_default_slot_5(ctx) {
    let each_1_anchor;
    let current;
    let each_value_3 = ensure_array_like(
      /*header*/
      ctx[2]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_3.length; i += 1) {
      each_blocks[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers, $$restProps, header*/
        100) {
          each_value_3 = ensure_array_like(
            /*header*/
            ctx2[2]
          );
          let i;
          for (i = 0; i < each_value_3.length; i += 1) {
            const child_ctx = get_each_context_3$1(ctx2, each_value_3, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_3$1(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          group_outros();
          for (i = each_value_3.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value_3.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_default_slot_5, "create_default_slot_5");
  function create_default_slot_4(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    var switch_value = (
      /*renderers*/
      ctx[5].tablerow
    );
    function switch_props(ctx2, dirty) {
      return {
        props: {
          $$slots: { default: [create_default_slot_5] },
          $$scope: { ctx: ctx2 }
        }
      };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance) create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) mount_component(switch_instance, target, anchor);
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers*/
        32 && switch_value !== (switch_value = /*renderers*/
        ctx2[5].tablerow)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = {};
          if (dirty & /*$$scope, header, renderers, $$restProps*/
          8388708) {
            switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(switch_instance_anchor);
        }
        if (switch_instance) destroy_component(switch_instance, detaching);
      }
    };
  }
  __name(create_default_slot_4, "create_default_slot_4");
  function create_default_slot_3(ctx) {
    let parser;
    let current;
    parser = new Parser$1({
      props: {
        tokens: (
          /*cells*/
          ctx[13].tokens
        ),
        renderers: (
          /*renderers*/
          ctx[5]
        )
      }
    });
    return {
      c() {
        create_component(parser.$$.fragment);
      },
      m(target, anchor) {
        mount_component(parser, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const parser_changes = {};
        if (dirty & /*rows*/
        8) parser_changes.tokens = /*cells*/
        ctx2[13].tokens;
        if (dirty & /*renderers*/
        32) parser_changes.renderers = /*renderers*/
        ctx2[5];
        parser.$set(parser_changes);
      },
      i(local) {
        if (current) return;
        transition_in(parser.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(parser.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(parser, detaching);
      }
    };
  }
  __name(create_default_slot_3, "create_default_slot_3");
  function create_each_block_2$3(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    var switch_value = (
      /*renderers*/
      ctx[5].tablecell
    );
    function switch_props(ctx2, dirty) {
      return {
        props: {
          header: false,
          align: (
            /*$$restProps*/
            ctx2[6].align[
              /*i*/
              ctx2[15]
            ] || "center"
          ),
          $$slots: { default: [create_default_slot_3] },
          $$scope: { ctx: ctx2 }
        }
      };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance) create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) mount_component(switch_instance, target, anchor);
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers*/
        32 && switch_value !== (switch_value = /*renderers*/
        ctx2[5].tablecell)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = {};
          if (dirty & /*$$restProps*/
          64) switch_instance_changes.align = /*$$restProps*/
          ctx2[6].align[
            /*i*/
            ctx2[15]
          ] || "center";
          if (dirty & /*$$scope, rows, renderers*/
          8388648) {
            switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(switch_instance_anchor);
        }
        if (switch_instance) destroy_component(switch_instance, detaching);
      }
    };
  }
  __name(create_each_block_2$3, "create_each_block_2$3");
  function create_default_slot_2(ctx) {
    let t;
    let current;
    let each_value_2 = ensure_array_like(
      /*row*/
      ctx[10]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_2.length; i += 1) {
      each_blocks[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t = space();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, t, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers, $$restProps, rows*/
        104) {
          each_value_2 = ensure_array_like(
            /*row*/
            ctx2[10]
          );
          let i;
          for (i = 0; i < each_value_2.length; i += 1) {
            const child_ctx = get_each_context_2$3(ctx2, each_value_2, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_2$3(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(t.parentNode, t);
            }
          }
          group_outros();
          for (i = each_value_2.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value_2.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_default_slot_2, "create_default_slot_2");
  function create_each_block_1$7(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    var switch_value = (
      /*renderers*/
      ctx[5].tablerow
    );
    function switch_props(ctx2, dirty) {
      return {
        props: {
          $$slots: { default: [create_default_slot_2] },
          $$scope: { ctx: ctx2 }
        }
      };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance) create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) mount_component(switch_instance, target, anchor);
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers*/
        32 && switch_value !== (switch_value = /*renderers*/
        ctx2[5].tablerow)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = {};
          if (dirty & /*$$scope, rows, renderers, $$restProps*/
          8388712) {
            switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(switch_instance_anchor);
        }
        if (switch_instance) destroy_component(switch_instance, detaching);
      }
    };
  }
  __name(create_each_block_1$7, "create_each_block_1$7");
  function create_default_slot_1(ctx) {
    let each_1_anchor;
    let current;
    let each_value_1 = ensure_array_like(
      /*rows*/
      ctx[3]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers, rows, $$restProps*/
        104) {
          each_value_1 = ensure_array_like(
            /*rows*/
            ctx2[3]
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$7(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_1$7(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          group_outros();
          for (i = each_value_1.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value_1.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_default_slot_1, "create_default_slot_1");
  function create_default_slot(ctx) {
    let switch_instance0;
    let t;
    let switch_instance1;
    let switch_instance1_anchor;
    let current;
    var switch_value = (
      /*renderers*/
      ctx[5].tablehead
    );
    function switch_props(ctx2, dirty) {
      return {
        props: {
          $$slots: { default: [create_default_slot_4] },
          $$scope: { ctx: ctx2 }
        }
      };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
    }
    var switch_value_1 = (
      /*renderers*/
      ctx[5].tablebody
    );
    function switch_props_1(ctx2, dirty) {
      return {
        props: {
          $$slots: { default: [create_default_slot_1] },
          $$scope: { ctx: ctx2 }
        }
      };
    }
    __name(switch_props_1, "switch_props_1");
    if (switch_value_1) {
      switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
    }
    return {
      c() {
        if (switch_instance0) create_component(switch_instance0.$$.fragment);
        t = space();
        if (switch_instance1) create_component(switch_instance1.$$.fragment);
        switch_instance1_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance0) mount_component(switch_instance0, target, anchor);
        insert(target, t, anchor);
        if (switch_instance1) mount_component(switch_instance1, target, anchor);
        insert(target, switch_instance1_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*renderers*/
        32 && switch_value !== (switch_value = /*renderers*/
        ctx2[5].tablehead)) {
          if (switch_instance0) {
            group_outros();
            const old_component = switch_instance0;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx2));
            create_component(switch_instance0.$$.fragment);
            transition_in(switch_instance0.$$.fragment, 1);
            mount_component(switch_instance0, t.parentNode, t);
          } else {
            switch_instance0 = null;
          }
        } else if (switch_value) {
          const switch_instance0_changes = {};
          if (dirty & /*$$scope, renderers, header, $$restProps*/
          8388708) {
            switch_instance0_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance0.$set(switch_instance0_changes);
        }
        if (dirty & /*renderers*/
        32 && switch_value_1 !== (switch_value_1 = /*renderers*/
        ctx2[5].tablebody)) {
          if (switch_instance1) {
            group_outros();
            const old_component = switch_instance1;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value_1) {
            switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx2));
            create_component(switch_instance1.$$.fragment);
            transition_in(switch_instance1.$$.fragment, 1);
            mount_component(switch_instance1, switch_instance1_anchor.parentNode, switch_instance1_anchor);
          } else {
            switch_instance1 = null;
          }
        } else if (switch_value_1) {
          const switch_instance1_changes = {};
          if (dirty & /*$$scope, rows, renderers, $$restProps*/
          8388712) {
            switch_instance1_changes.$$scope = { dirty, ctx: ctx2 };
          }
          switch_instance1.$set(switch_instance1_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
        if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
        if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t);
          detach(switch_instance1_anchor);
        }
        if (switch_instance0) destroy_component(switch_instance0, detaching);
        if (switch_instance1) destroy_component(switch_instance1, detaching);
      }
    };
  }
  __name(create_default_slot, "create_default_slot");
  function create_each_block$h(ctx) {
    let parser;
    let current;
    const parser_spread_levels = [
      /*token*/
      ctx[7],
      { renderers: (
        /*renderers*/
        ctx[5]
      ) }
    ];
    let parser_props = {};
    for (let i = 0; i < parser_spread_levels.length; i += 1) {
      parser_props = assign(parser_props, parser_spread_levels[i]);
    }
    parser = new Parser$1({ props: parser_props });
    return {
      c() {
        create_component(parser.$$.fragment);
      },
      m(target, anchor) {
        mount_component(parser, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const parser_changes = dirty & /*tokens, renderers*/
        34 ? get_spread_update(parser_spread_levels, [
          dirty & /*tokens*/
          2 && get_spread_object(
            /*token*/
            ctx2[7]
          ),
          dirty & /*renderers*/
          32 && { renderers: (
            /*renderers*/
            ctx2[5]
          ) }
        ]) : {};
        parser.$set(parser_changes);
      },
      i(local) {
        if (current) return;
        transition_in(parser.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(parser.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(parser, detaching);
      }
    };
  }
  __name(create_each_block$h, "create_each_block$h");
  function create_fragment$V(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block$i, create_if_block_1$8];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (!/*type*/
      ctx2[0]) return 0;
      if (
        /*renderers*/
        ctx2[5][
          /*type*/
          ctx2[0]
        ]
      ) return 1;
      return -1;
    }
    __name(select_block_type, "select_block_type");
    if (~(current_block_type_index = select_block_type(ctx))) {
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    }
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].m(target, anchor);
        }
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if (~current_block_type_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          }
        } else {
          if (if_block) {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
          }
          if (~current_block_type_index) {
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          } else {
            if_block = null;
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].d(detaching);
        }
      }
    };
  }
  __name(create_fragment$V, "create_fragment$V");
  function instance$R($$self, $$props, $$invalidate) {
    const omit_props_names = ["type", "tokens", "header", "rows", "ordered", "renderers"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let { type = void 0 } = $$props;
    let { tokens = void 0 } = $$props;
    let { header = void 0 } = $$props;
    let { rows = void 0 } = $$props;
    let { ordered = false } = $$props;
    let { renderers } = $$props;
    supressWarnings();
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("type" in $$new_props) $$invalidate(0, type = $$new_props.type);
      if ("tokens" in $$new_props) $$invalidate(1, tokens = $$new_props.tokens);
      if ("header" in $$new_props) $$invalidate(2, header = $$new_props.header);
      if ("rows" in $$new_props) $$invalidate(3, rows = $$new_props.rows);
      if ("ordered" in $$new_props) $$invalidate(4, ordered = $$new_props.ordered);
      if ("renderers" in $$new_props) $$invalidate(5, renderers = $$new_props.renderers);
    };
    return [type, tokens, header, rows, ordered, renderers, $$restProps];
  }
  __name(instance$R, "instance$R");
  let Parser$1 = (_Ca = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$R, create_fragment$V, safe_not_equal, {
        type: 0,
        tokens: 1,
        header: 2,
        rows: 3,
        ordered: 4,
        renderers: 5
      });
    }
  }, __name(_Ca, "Parser"), _Ca);
  function getDefaults() {
    return {
      async: false,
      baseUrl: null,
      breaks: false,
      extensions: null,
      gfm: true,
      headerIds: true,
      headerPrefix: "",
      highlight: null,
      hooks: null,
      langPrefix: "language-",
      mangle: true,
      pedantic: false,
      renderer: null,
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartypants: false,
      tokenizer: null,
      walkTokens: null,
      xhtml: false
    };
  }
  __name(getDefaults, "getDefaults");
  let defaults = getDefaults();
  function changeDefaults(newDefaults) {
    defaults = newDefaults;
  }
  __name(changeDefaults, "changeDefaults");
  const escapeTest = /[&<>"']/;
  const escapeReplace = new RegExp(escapeTest.source, "g");
  const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
  const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
  const escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  const getEscapeReplacement = /* @__PURE__ */ __name((ch) => escapeReplacements[ch], "getEscapeReplacement");
  function escape(html, encode) {
    if (encode) {
      if (escapeTest.test(html)) {
        return html.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html)) {
        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html;
  }
  __name(escape, "escape");
  const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
  function unescape(html) {
    return html.replace(unescapeTest, (_, n) => {
      n = n.toLowerCase();
      if (n === "colon") return ":";
      if (n.charAt(0) === "#") {
        return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
      }
      return "";
    });
  }
  __name(unescape, "unescape");
  const caret = /(^|[^\[])\^/g;
  function edit(regex, opt) {
    regex = typeof regex === "string" ? regex : regex.source;
    opt = opt || "";
    const obj = {
      replace: /* @__PURE__ */ __name((name, val) => {
        val = val.source || val;
        val = val.replace(caret, "$1");
        regex = regex.replace(name, val);
        return obj;
      }, "replace"),
      getRegex: /* @__PURE__ */ __name(() => {
        return new RegExp(regex, opt);
      }, "getRegex")
    };
    return obj;
  }
  __name(edit, "edit");
  const nonWordAndColonTest = /[^\w:]/g;
  const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
  function cleanUrl(sanitize, base, href) {
    if (sanitize) {
      let prot;
      try {
        prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
      } catch (e) {
        return null;
      }
      if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
        return null;
      }
    }
    if (base && !originIndependentUrl.test(href)) {
      href = resolveUrl(base, href);
    }
    try {
      href = encodeURI(href).replace(/%25/g, "%");
    } catch (e) {
      return null;
    }
    return href;
  }
  __name(cleanUrl, "cleanUrl");
  const baseUrls = {};
  const justDomain = /^[^:]+:\/*[^/]*$/;
  const protocol = /^([^:]+:)[\s\S]*$/;
  const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
  function resolveUrl(base, href) {
    if (!baseUrls[" " + base]) {
      if (justDomain.test(base)) {
        baseUrls[" " + base] = base + "/";
      } else {
        baseUrls[" " + base] = rtrim(base, "/", true);
      }
    }
    base = baseUrls[" " + base];
    const relativeBase = base.indexOf(":") === -1;
    if (href.substring(0, 2) === "//") {
      if (relativeBase) {
        return href;
      }
      return base.replace(protocol, "$1") + href;
    } else if (href.charAt(0) === "/") {
      if (relativeBase) {
        return href;
      }
      return base.replace(domain, "$1") + href;
    } else {
      return base + href;
    }
  }
  __name(resolveUrl, "resolveUrl");
  const noopTest = { exec: /* @__PURE__ */ __name(function noopTest2() {
  }, "noopTest") };
  function splitCells(tableRow, count) {
    const row = tableRow.replace(/\|/g, (match, offset, str) => {
      let escaped = false, curr = offset;
      while (--curr >= 0 && str[curr] === "\\") escaped = !escaped;
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(/ \|/);
    let i = 0;
    if (!cells[0].trim()) {
      cells.shift();
    }
    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
      cells.pop();
    }
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count) cells.push("");
    }
    for (; i < cells.length; i++) {
      cells[i] = cells[i].trim().replace(/\\\|/g, "|");
    }
    return cells;
  }
  __name(splitCells, "splitCells");
  function rtrim(str, c, invert) {
    const l = str.length;
    if (l === 0) {
      return "";
    }
    let suffLen = 0;
    while (suffLen < l) {
      const currChar = str.charAt(l - suffLen - 1);
      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }
    return str.slice(0, l - suffLen);
  }
  __name(rtrim, "rtrim");
  function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
      return -1;
    }
    const l = str.length;
    let level = 0, i = 0;
    for (; i < l; i++) {
      if (str[i] === "\\") {
        i++;
      } else if (str[i] === b[0]) {
        level++;
      } else if (str[i] === b[1]) {
        level--;
        if (level < 0) {
          return i;
        }
      }
    }
    return -1;
  }
  __name(findClosingBracket, "findClosingBracket");
  function checkDeprecations(opt, callback) {
    if (!opt || opt.silent) {
      return;
    }
    if (callback) {
      console.warn("marked(): callback is deprecated since version 5.0.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/using_pro#async");
    }
    if (opt.sanitize || opt.sanitizer) {
      console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
    }
    if (opt.highlight || opt.langPrefix !== "language-") {
      console.warn("marked(): highlight and langPrefix parameters are deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-highlight.");
    }
    if (opt.mangle) {
      console.warn("marked(): mangle parameter is enabled by default, but is deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install https://www.npmjs.com/package/marked-mangle, or disable by setting `{mangle: false}`.");
    }
    if (opt.baseUrl) {
      console.warn("marked(): baseUrl parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-base-url.");
    }
    if (opt.smartypants) {
      console.warn("marked(): smartypants parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-smartypants.");
    }
    if (opt.xhtml) {
      console.warn("marked(): xhtml parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-xhtml.");
    }
    if (opt.headerIds || opt.headerPrefix) {
      console.warn("marked(): headerIds and headerPrefix parameters enabled by default, but are deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install  https://www.npmjs.com/package/marked-gfm-heading-id, or disable by setting `{headerIds: false}`.");
    }
  }
  __name(checkDeprecations, "checkDeprecations");
  function outputLink(cap, link, raw, lexer) {
    const href = link.href;
    const title = link.title ? escape(link.title) : null;
    const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
    if (cap[0].charAt(0) !== "!") {
      lexer.state.inLink = true;
      const token = {
        type: "link",
        raw,
        href,
        title,
        text: text2,
        tokens: lexer.inlineTokens(text2)
      };
      lexer.state.inLink = false;
      return token;
    }
    return {
      type: "image",
      raw,
      href,
      title,
      text: escape(text2)
    };
  }
  __name(outputLink, "outputLink");
  function indentCodeCompensation(raw, text2) {
    const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
    if (matchIndentToCode === null) {
      return text2;
    }
    const indentToCode = matchIndentToCode[1];
    return text2.split("\n").map((node) => {
      const matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) {
        return node;
      }
      const [indentInNode] = matchIndentInNode;
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  __name(indentCodeCompensation, "indentCodeCompensation");
  const _Tokenizer = class _Tokenizer {
    constructor(options) {
      this.options = options || defaults;
    }
    space(src) {
      const cap = this.rules.block.newline.exec(src);
      if (cap && cap[0].length > 0) {
        return {
          type: "space",
          raw: cap[0]
        };
      }
    }
    code(src) {
      const cap = this.rules.block.code.exec(src);
      if (cap) {
        const text2 = cap[0].replace(/^ {1,4}/gm, "");
        return {
          type: "code",
          raw: cap[0],
          codeBlockStyle: "indented",
          text: !this.options.pedantic ? rtrim(text2, "\n") : text2
        };
      }
    }
    fences(src) {
      const cap = this.rules.block.fences.exec(src);
      if (cap) {
        const raw = cap[0];
        const text2 = indentCodeCompensation(raw, cap[3] || "");
        return {
          type: "code",
          raw,
          lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
          text: text2
        };
      }
    }
    heading(src) {
      const cap = this.rules.block.heading.exec(src);
      if (cap) {
        let text2 = cap[2].trim();
        if (/#$/.test(text2)) {
          const trimmed = rtrim(text2, "#");
          if (this.options.pedantic) {
            text2 = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            text2 = trimmed.trim();
          }
        }
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[1].length,
          text: text2,
          tokens: this.lexer.inline(text2)
        };
      }
    }
    hr(src) {
      const cap = this.rules.block.hr.exec(src);
      if (cap) {
        return {
          type: "hr",
          raw: cap[0]
        };
      }
    }
    blockquote(src) {
      const cap = this.rules.block.blockquote.exec(src);
      if (cap) {
        const text2 = cap[0].replace(/^ *>[ \t]?/gm, "");
        const top = this.lexer.state.top;
        this.lexer.state.top = true;
        const tokens = this.lexer.blockTokens(text2);
        this.lexer.state.top = top;
        return {
          type: "blockquote",
          raw: cap[0],
          tokens,
          text: text2
        };
      }
    }
    list(src) {
      let cap = this.rules.block.list.exec(src);
      if (cap) {
        let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
        let bull = cap[1].trim();
        const isordered = bull.length > 1;
        const list = {
          type: "list",
          raw: "",
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : "",
          loose: false,
          items: []
        };
        bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
        if (this.options.pedantic) {
          bull = isordered ? bull : "[*+-]";
        }
        const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
        while (src) {
          endEarly = false;
          if (!(cap = itemRegex.exec(src))) {
            break;
          }
          if (this.rules.block.hr.test(src)) {
            break;
          }
          raw = cap[0];
          src = src.substring(raw.length);
          line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
          nextLine = src.split("\n", 1)[0];
          if (this.options.pedantic) {
            indent = 2;
            itemContents = line.trimLeft();
          } else {
            indent = cap[2].search(/[^ ]/);
            indent = indent > 4 ? 1 : indent;
            itemContents = line.slice(indent);
            indent += cap[1].length;
          }
          blankLine = false;
          if (!line && /^ *$/.test(nextLine)) {
            raw += nextLine + "\n";
            src = src.substring(nextLine.length + 1);
            endEarly = true;
          }
          if (!endEarly) {
            const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
            const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
            const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
            const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
            while (src) {
              rawLine = src.split("\n", 1)[0];
              nextLine = rawLine;
              if (this.options.pedantic) {
                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
              }
              if (fencesBeginRegex.test(nextLine)) {
                break;
              }
              if (headingBeginRegex.test(nextLine)) {
                break;
              }
              if (nextBulletRegex.test(nextLine)) {
                break;
              }
              if (hrRegex.test(src)) {
                break;
              }
              if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
                itemContents += "\n" + nextLine.slice(indent);
              } else {
                if (blankLine) {
                  break;
                }
                if (line.search(/[^ ]/) >= 4) {
                  break;
                }
                if (fencesBeginRegex.test(line)) {
                  break;
                }
                if (headingBeginRegex.test(line)) {
                  break;
                }
                if (hrRegex.test(line)) {
                  break;
                }
                itemContents += "\n" + nextLine;
              }
              if (!blankLine && !nextLine.trim()) {
                blankLine = true;
              }
              raw += rawLine + "\n";
              src = src.substring(rawLine.length + 1);
              line = nextLine.slice(indent);
            }
          }
          if (!list.loose) {
            if (endsWithBlankLine) {
              list.loose = true;
            } else if (/\n *\n *$/.test(raw)) {
              endsWithBlankLine = true;
            }
          }
          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.exec(itemContents);
            if (istask) {
              ischecked = istask[0] !== "[ ] ";
              itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
            }
          }
          list.items.push({
            type: "list_item",
            raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents
          });
          list.raw += raw;
        }
        list.items[list.items.length - 1].raw = raw.trimRight();
        list.items[list.items.length - 1].text = itemContents.trimRight();
        list.raw = list.raw.trimRight();
        const l = list.items.length;
        for (i = 0; i < l; i++) {
          this.lexer.state.top = false;
          list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
          if (!list.loose) {
            const spacers = list.items[i].tokens.filter((t) => t.type === "space");
            const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
            list.loose = hasMultipleLineBreaks;
          }
        }
        if (list.loose) {
          for (i = 0; i < l; i++) {
            list.items[i].loose = true;
          }
        }
        return list;
      }
    }
    html(src) {
      const cap = this.rules.block.html.exec(src);
      if (cap) {
        const token = {
          type: "html",
          block: true,
          raw: cap[0],
          pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
          text: cap[0]
        };
        if (this.options.sanitize) {
          const text2 = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
          token.type = "paragraph";
          token.text = text2;
          token.tokens = this.lexer.inline(text2);
        }
        return token;
      }
    }
    def(src) {
      const cap = this.rules.block.def.exec(src);
      if (cap) {
        const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
        const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
        const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
        return {
          type: "def",
          tag,
          raw: cap[0],
          href,
          title
        };
      }
    }
    table(src) {
      const cap = this.rules.block.table.exec(src);
      if (cap) {
        const item = {
          type: "table",
          header: splitCells(cap[1]).map((c) => {
            return { text: c };
          }),
          align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
          rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
        };
        if (item.header.length === item.align.length) {
          item.raw = cap[0];
          let l = item.align.length;
          let i, j, k, row;
          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = "right";
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = "center";
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = "left";
            } else {
              item.align[i] = null;
            }
          }
          l = item.rows.length;
          for (i = 0; i < l; i++) {
            item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
              return { text: c };
            });
          }
          l = item.header.length;
          for (j = 0; j < l; j++) {
            item.header[j].tokens = this.lexer.inline(item.header[j].text);
          }
          l = item.rows.length;
          for (j = 0; j < l; j++) {
            row = item.rows[j];
            for (k = 0; k < row.length; k++) {
              row[k].tokens = this.lexer.inline(row[k].text);
            }
          }
          return item;
        }
      }
    }
    lheading(src) {
      const cap = this.rules.block.lheading.exec(src);
      if (cap) {
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[2].charAt(0) === "=" ? 1 : 2,
          text: cap[1],
          tokens: this.lexer.inline(cap[1])
        };
      }
    }
    paragraph(src) {
      const cap = this.rules.block.paragraph.exec(src);
      if (cap) {
        const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
        return {
          type: "paragraph",
          raw: cap[0],
          text: text2,
          tokens: this.lexer.inline(text2)
        };
      }
    }
    text(src) {
      const cap = this.rules.block.text.exec(src);
      if (cap) {
        return {
          type: "text",
          raw: cap[0],
          text: cap[0],
          tokens: this.lexer.inline(cap[0])
        };
      }
    }
    escape(src) {
      const cap = this.rules.inline.escape.exec(src);
      if (cap) {
        return {
          type: "escape",
          raw: cap[0],
          text: escape(cap[1])
        };
      }
    }
    tag(src) {
      const cap = this.rules.inline.tag.exec(src);
      if (cap) {
        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
          this.lexer.state.inLink = false;
        }
        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = false;
        }
        return {
          type: this.options.sanitize ? "text" : "html",
          raw: cap[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          block: false,
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
        };
      }
    }
    link(src) {
      const cap = this.rules.inline.link.exec(src);
      if (cap) {
        const trimmedUrl = cap[2].trim();
        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          if (!/>$/.test(trimmedUrl)) {
            return;
          }
          const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          const lastParenIndex = findClosingBracket(cap[2], "()");
          if (lastParenIndex > -1) {
            const start = cap[0].indexOf("!") === 0 ? 5 : 4;
            const linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = "";
          }
        }
        let href = cap[2];
        let title = "";
        if (this.options.pedantic) {
          const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
          if (link) {
            href = link[1];
            title = link[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : "";
        }
        href = href.trim();
        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }
        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
          title: title ? title.replace(this.rules.inline._escapes, "$1") : title
        }, cap[0], this.lexer);
      }
    }
    reflink(src, links) {
      let cap;
      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
        link = links[link.toLowerCase()];
        if (!link) {
          const text2 = cap[0].charAt(0);
          return {
            type: "text",
            raw: text2,
            text: text2
          };
        }
        return outputLink(cap, link, cap[0], this.lexer);
      }
    }
    emStrong(src, maskedSrc, prevChar = "") {
      let match = this.rules.inline.emStrong.lDelim.exec(src);
      if (!match) return;
      if (match[3] && prevChar.match(/[\p{L}\p{N}]/u)) return;
      const nextChar = match[1] || match[2] || "";
      if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
        const lLength = match[0].length - 1;
        let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
        const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim) continue;
          rLength = rDelim.length;
          if (match[3] || match[4]) {
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue;
            }
          }
          delimTotal -= rLength;
          if (delimTotal > 0) continue;
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          const raw = src.slice(0, lLength + match.index + rLength + 1);
          if (Math.min(lLength, rLength) % 2) {
            const text3 = raw.slice(1, -1);
            return {
              type: "em",
              raw,
              text: text3,
              tokens: this.lexer.inlineTokens(text3)
            };
          }
          const text2 = raw.slice(2, -2);
          return {
            type: "strong",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
      }
    }
    codespan(src) {
      const cap = this.rules.inline.code.exec(src);
      if (cap) {
        let text2 = cap[2].replace(/\n/g, " ");
        const hasNonSpaceChars = /[^ ]/.test(text2);
        const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text2 = text2.substring(1, text2.length - 1);
        }
        text2 = escape(text2, true);
        return {
          type: "codespan",
          raw: cap[0],
          text: text2
        };
      }
    }
    br(src) {
      const cap = this.rules.inline.br.exec(src);
      if (cap) {
        return {
          type: "br",
          raw: cap[0]
        };
      }
    }
    del(src) {
      const cap = this.rules.inline.del.exec(src);
      if (cap) {
        return {
          type: "del",
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2])
        };
      }
    }
    autolink(src, mangle2) {
      const cap = this.rules.inline.autolink.exec(src);
      if (cap) {
        let text2, href;
        if (cap[2] === "@") {
          text2 = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
          href = "mailto:" + text2;
        } else {
          text2 = escape(cap[1]);
          href = text2;
        }
        return {
          type: "link",
          raw: cap[0],
          text: text2,
          href,
          tokens: [
            {
              type: "text",
              raw: text2,
              text: text2
            }
          ]
        };
      }
    }
    url(src, mangle2) {
      let cap;
      if (cap = this.rules.inline.url.exec(src)) {
        let text2, href;
        if (cap[2] === "@") {
          text2 = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
          href = "mailto:" + text2;
        } else {
          let prevCapZero;
          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
          } while (prevCapZero !== cap[0]);
          text2 = escape(cap[0]);
          if (cap[1] === "www.") {
            href = "http://" + cap[0];
          } else {
            href = cap[0];
          }
        }
        return {
          type: "link",
          raw: cap[0],
          text: text2,
          href,
          tokens: [
            {
              type: "text",
              raw: text2,
              text: text2
            }
          ]
        };
      }
    }
    inlineText(src, smartypants2) {
      const cap = this.rules.inline.text.exec(src);
      if (cap) {
        let text2;
        if (this.lexer.state.inRawBlock) {
          text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
        } else {
          text2 = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
        }
        return {
          type: "text",
          raw: cap[0],
          text: text2
        };
      }
    }
  };
  __name(_Tokenizer, "Tokenizer");
  let Tokenizer = _Tokenizer;
  const block = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
    html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
    def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
    table: noopTest,
    lheading: /^((?:(?!^bull ).|\n(?!\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    // regex template, placeholders will be replaced according to different paragraph
    // interruption rules of commonmark and the original markdown spec:
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
  block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
  block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
  block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block.lheading = edit(block.lheading).replace(/bull/g, block.bullet).getRegex();
  block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
  block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
  block.normal = { ...block };
  block.gfm = {
    ...block.normal,
    table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
    // Cells
  };
  block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
  block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
  block.pedantic = {
    ...block.normal,
    html: edit(
      `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
    ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
  };
  const inline = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest,
    tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
    // CDATA section
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(ref)\]/,
    nolink: /^!?\[(ref)\](?:\[\])?/,
    reflinkSearch: "reflink|nolink(?!\\()",
    emStrong: {
      lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
      //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
      //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a
      rDelimAst: /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
      rDelimUnd: /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/
      // ^- Not allowed for _
    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^((?![*_])[\spunctuation])/
  };
  inline._punctuation = "\\p{P}$+<=>`^|~";
  inline.punctuation = edit(inline.punctuation, "u").replace(/punctuation/g, inline._punctuation).getRegex();
  inline.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
  inline.anyPunctuation = /\\[punct]/g;
  inline._escapes = /\\([punct])/g;
  inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
  inline.emStrong.lDelim = edit(inline.emStrong.lDelim, "u").replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "gu").replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "gu").replace(/punct/g, inline._punctuation).getRegex();
  inline.anyPunctuation = edit(inline.anyPunctuation, "gu").replace(/punct/g, inline._punctuation).getRegex();
  inline._escapes = edit(inline._escapes, "gu").replace(/punct/g, inline._punctuation).getRegex();
  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
  inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
  inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
  inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
  inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
  inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
  inline.normal = { ...inline };
  inline.pedantic = {
    ...inline.normal,
    strong: {
      start: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      start: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
  };
  inline.gfm = {
    ...inline.normal,
    escape: edit(inline.escape).replace("])", "~|])").getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  };
  inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
  inline.breaks = {
    ...inline.gfm,
    br: edit(inline.br).replace("{2,}", "*").getRegex(),
    text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  };
  function smartypants(text2) {
    return text2.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
  }
  __name(smartypants, "smartypants");
  function mangle(text2) {
    let out = "", i, ch;
    const l = text2.length;
    for (i = 0; i < l; i++) {
      ch = text2.charCodeAt(i);
      if (Math.random() > 0.5) {
        ch = "x" + ch.toString(16);
      }
      out += "&#" + ch + ";";
    }
    return out;
  }
  __name(mangle, "mangle");
  const _Lexer = class _Lexer {
    constructor(options) {
      this.tokens = [];
      this.tokens.links = /* @__PURE__ */ Object.create(null);
      this.options = options || defaults;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      const rules = {
        block: block.normal,
        inline: inline.normal
      };
      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;
        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */
    static get rules() {
      return {
        block,
        inline
      };
    }
    /**
     * Static Lex Method
     */
    static lex(src, options) {
      const lexer = new _Lexer(options);
      return lexer.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    static lexInline(src, options) {
      const lexer = new _Lexer(options);
      return lexer.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    lex(src) {
      src = src.replace(/\r\n|\r/g, "\n");
      this.blockTokens(src, this.tokens);
      let next;
      while (next = this.inlineQueue.shift()) {
        this.inlineTokens(next.src, next.tokens);
      }
      return this.tokens;
    }
    /**
     * Lexing
     */
    blockTokens(src, tokens = []) {
      if (this.options.pedantic) {
        src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
      } else {
        src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
          return leading + "    ".repeat(tabs.length);
        });
      }
      let token, lastToken, cutSrc, lastParagraphClipped;
      while (src) {
        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);
          if (token.raw.length === 1 && tokens.length > 0) {
            tokens[tokens.length - 1].raw += "\n";
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.def(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.raw;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }
          continue;
        }
        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startBlock) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startBlock.forEach(function(getStartIndex) {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          lastToken = tokens[tokens.length - 1];
          if (lastParagraphClipped && lastToken.type === "paragraph") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token.raw.length);
          continue;
        }
        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      this.state.top = true;
      return tokens;
    }
    inline(src, tokens = []) {
      this.inlineQueue.push({ src, tokens });
      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    inlineTokens(src, tokens = []) {
      let token, lastToken, cutSrc;
      let maskedSrc = src;
      let match;
      let keepPrevChar, prevChar;
      if (this.tokens.links) {
        const links = Object.keys(this.tokens.links);
        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      }
      while (src) {
        if (!keepPrevChar) {
          prevChar = "";
        }
        keepPrevChar = false;
        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.tag(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.autolink(src, mangle)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startInline) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startInline.forEach(function(getStartIndex) {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
          src = src.substring(token.raw.length);
          if (token.raw.slice(-1) !== "_") {
            prevChar = token.raw.slice(-1);
          }
          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    }
  };
  __name(_Lexer, "Lexer");
  let Lexer = _Lexer;
  const _Renderer = class _Renderer {
    constructor(options) {
      this.options = options || defaults;
    }
    code(code, infostring, escaped) {
      const lang = (infostring || "").match(/\S*/)[0];
      if (this.options.highlight) {
        const out = this.options.highlight(code, lang);
        if (out != null && out !== code) {
          escaped = true;
          code = out;
        }
      }
      code = code.replace(/\n$/, "") + "\n";
      if (!lang) {
        return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    /**
     * @param {string} quote
     */
    blockquote(quote) {
      return `<blockquote>
${quote}</blockquote>
`;
    }
    html(html, block2) {
      return html;
    }
    /**
     * @param {string} text
     * @param {string} level
     * @param {string} raw
     * @param {any} slugger
     */
    heading(text2, level, raw, slugger) {
      if (this.options.headerIds) {
        const id2 = this.options.headerPrefix + slugger.slug(raw);
        return `<h${level} id="${id2}">${text2}</h${level}>
`;
      }
      return `<h${level}>${text2}</h${level}>
`;
    }
    hr() {
      return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
    }
    list(body, ordered, start) {
      const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
      return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
    }
    /**
     * @param {string} text
     */
    listitem(text2) {
      return `<li>${text2}</li>
`;
    }
    checkbox(checked) {
      return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
    }
    /**
     * @param {string} text
     */
    paragraph(text2) {
      return `<p>${text2}</p>
`;
    }
    /**
     * @param {string} header
     * @param {string} body
     */
    table(header, body) {
      if (body) body = `<tbody>${body}</tbody>`;
      return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
    }
    /**
     * @param {string} content
     */
    tablerow(content2) {
      return `<tr>
${content2}</tr>
`;
    }
    tablecell(content2, flags) {
      const type = flags.header ? "th" : "td";
      const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
      return tag + content2 + `</${type}>
`;
    }
    /**
     * span level renderer
     * @param {string} text
     */
    strong(text2) {
      return `<strong>${text2}</strong>`;
    }
    /**
     * @param {string} text
     */
    em(text2) {
      return `<em>${text2}</em>`;
    }
    /**
     * @param {string} text
     */
    codespan(text2) {
      return `<code>${text2}</code>`;
    }
    br() {
      return this.options.xhtml ? "<br/>" : "<br>";
    }
    /**
     * @param {string} text
     */
    del(text2) {
      return `<del>${text2}</del>`;
    }
    /**
     * @param {string} href
     * @param {string} title
     * @param {string} text
     */
    link(href, title, text2) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text2;
      }
      let out = '<a href="' + href + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += ">" + text2 + "</a>";
      return out;
    }
    /**
     * @param {string} href
     * @param {string} title
     * @param {string} text
     */
    image(href, title, text2) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text2;
      }
      let out = `<img src="${href}" alt="${text2}"`;
      if (title) {
        out += ` title="${title}"`;
      }
      out += this.options.xhtml ? "/>" : ">";
      return out;
    }
    text(text2) {
      return text2;
    }
  };
  __name(_Renderer, "Renderer");
  let Renderer = _Renderer;
  const _TextRenderer = class _TextRenderer {
    // no need for block level renderers
    strong(text2) {
      return text2;
    }
    em(text2) {
      return text2;
    }
    codespan(text2) {
      return text2;
    }
    del(text2) {
      return text2;
    }
    html(text2) {
      return text2;
    }
    text(text2) {
      return text2;
    }
    link(href, title, text2) {
      return "" + text2;
    }
    image(href, title, text2) {
      return "" + text2;
    }
    br() {
      return "";
    }
  };
  __name(_TextRenderer, "TextRenderer");
  let TextRenderer = _TextRenderer;
  const _Slugger = class _Slugger {
    constructor() {
      this.seen = {};
    }
    /**
     * @param {string} value
     */
    serialize(value) {
      return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
    }
    /**
     * Finds the next safe (unique) slug to use
     * @param {string} originalSlug
     * @param {boolean} isDryRun
     */
    getNextSafeSlug(originalSlug, isDryRun) {
      let slug = originalSlug;
      let occurenceAccumulator = 0;
      if (this.seen.hasOwnProperty(slug)) {
        occurenceAccumulator = this.seen[originalSlug];
        do {
          occurenceAccumulator++;
          slug = originalSlug + "-" + occurenceAccumulator;
        } while (this.seen.hasOwnProperty(slug));
      }
      if (!isDryRun) {
        this.seen[originalSlug] = occurenceAccumulator;
        this.seen[slug] = 0;
      }
      return slug;
    }
    /**
     * Convert string to unique id
     * @param {object} [options]
     * @param {boolean} [options.dryrun] Generates the next unique slug without
     * updating the internal accumulator.
     */
    slug(value, options = {}) {
      const slug = this.serialize(value);
      return this.getNextSafeSlug(slug, options.dryrun);
    }
  };
  __name(_Slugger, "Slugger");
  let Slugger = _Slugger;
  const _Parser = class _Parser {
    constructor(options) {
      this.options = options || defaults;
      this.options.renderer = this.options.renderer || new Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer();
      this.slugger = new Slugger();
    }
    /**
     * Static Parse Method
     */
    static parse(tokens, options) {
      const parser = new _Parser(options);
      return parser.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    static parseInline(tokens, options) {
      const parser = new _Parser(options);
      return parser.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    parse(tokens, top = true) {
      let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
      const l = tokens.length;
      for (i = 0; i < l; i++) {
        token = tokens[i];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
          if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
            out += ret || "";
            continue;
          }
        }
        switch (token.type) {
          case "space": {
            continue;
          }
          case "hr": {
            out += this.renderer.hr();
            continue;
          }
          case "heading": {
            out += this.renderer.heading(
              this.parseInline(token.tokens),
              token.depth,
              unescape(this.parseInline(token.tokens, this.textRenderer)),
              this.slugger
            );
            continue;
          }
          case "code": {
            out += this.renderer.code(
              token.text,
              token.lang,
              token.escaped
            );
            continue;
          }
          case "table": {
            header = "";
            cell = "";
            l2 = token.header.length;
            for (j = 0; j < l2; j++) {
              cell += this.renderer.tablecell(
                this.parseInline(token.header[j].tokens),
                { header: true, align: token.align[j] }
              );
            }
            header += this.renderer.tablerow(cell);
            body = "";
            l2 = token.rows.length;
            for (j = 0; j < l2; j++) {
              row = token.rows[j];
              cell = "";
              l3 = row.length;
              for (k = 0; k < l3; k++) {
                cell += this.renderer.tablecell(
                  this.parseInline(row[k].tokens),
                  { header: false, align: token.align[k] }
                );
              }
              body += this.renderer.tablerow(cell);
            }
            out += this.renderer.table(header, body);
            continue;
          }
          case "blockquote": {
            body = this.parse(token.tokens);
            out += this.renderer.blockquote(body);
            continue;
          }
          case "list": {
            ordered = token.ordered;
            start = token.start;
            loose = token.loose;
            l2 = token.items.length;
            body = "";
            for (j = 0; j < l2; j++) {
              item = token.items[j];
              checked = item.checked;
              task = item.task;
              itemBody = "";
              if (item.task) {
                checkbox = this.renderer.checkbox(checked);
                if (loose) {
                  if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                    item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                      item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                    }
                  } else {
                    item.tokens.unshift({
                      type: "text",
                      text: checkbox
                    });
                  }
                } else {
                  itemBody += checkbox;
                }
              }
              itemBody += this.parse(item.tokens, loose);
              body += this.renderer.listitem(itemBody, task, checked);
            }
            out += this.renderer.list(body, ordered, start);
            continue;
          }
          case "html": {
            out += this.renderer.html(token.text, token.block);
            continue;
          }
          case "paragraph": {
            out += this.renderer.paragraph(this.parseInline(token.tokens));
            continue;
          }
          case "text": {
            body = token.tokens ? this.parseInline(token.tokens) : token.text;
            while (i + 1 < l && tokens[i + 1].type === "text") {
              token = tokens[++i];
              body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
            }
            out += top ? this.renderer.paragraph(body) : body;
            continue;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
    /**
     * Parse Inline Tokens
     */
    parseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      let out = "", i, token, ret;
      const l = tokens.length;
      for (i = 0; i < l; i++) {
        token = tokens[i];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
          if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
            out += ret || "";
            continue;
          }
        }
        switch (token.type) {
          case "escape": {
            out += renderer.text(token.text);
            break;
          }
          case "html": {
            out += renderer.html(token.text);
            break;
          }
          case "link": {
            out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
            break;
          }
          case "image": {
            out += renderer.image(token.href, token.title, token.text);
            break;
          }
          case "strong": {
            out += renderer.strong(this.parseInline(token.tokens, renderer));
            break;
          }
          case "em": {
            out += renderer.em(this.parseInline(token.tokens, renderer));
            break;
          }
          case "codespan": {
            out += renderer.codespan(token.text);
            break;
          }
          case "br": {
            out += renderer.br();
            break;
          }
          case "del": {
            out += renderer.del(this.parseInline(token.tokens, renderer));
            break;
          }
          case "text": {
            out += renderer.text(token.text);
            break;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
  };
  __name(_Parser, "Parser");
  let Parser = _Parser;
  const _Hooks = class _Hooks {
    constructor(options) {
      this.options = options || defaults;
    }
    /**
     * Process markdown before marked
     */
    preprocess(markdown) {
      return markdown;
    }
    /**
     * Process HTML after marked is finished
     */
    postprocess(html) {
      return html;
    }
  };
  __name(_Hooks, "Hooks");
  __publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess"
  ]));
  let Hooks = _Hooks;
  const _Marked = class _Marked {
    constructor(...args) {
      __privateAdd(this, _Marked_instances);
      __publicField(this, "defaults", getDefaults());
      __publicField(this, "options", this.setOptions);
      __publicField(this, "parse", __privateMethod(this, _Marked_instances, parseMarkdown_fn).call(this, Lexer.lex, Parser.parse));
      __publicField(this, "parseInline", __privateMethod(this, _Marked_instances, parseMarkdown_fn).call(this, Lexer.lexInline, Parser.parseInline));
      __publicField(this, "Parser", Parser);
      __publicField(this, "parser", Parser.parse);
      __publicField(this, "Renderer", Renderer);
      __publicField(this, "TextRenderer", TextRenderer);
      __publicField(this, "Lexer", Lexer);
      __publicField(this, "lexer", Lexer.lex);
      __publicField(this, "Tokenizer", Tokenizer);
      __publicField(this, "Slugger", Slugger);
      __publicField(this, "Hooks", Hooks);
      this.use(...args);
    }
    walkTokens(tokens, callback) {
      let values = [];
      for (const token of tokens) {
        values = values.concat(callback.call(this, token));
        switch (token.type) {
          case "table": {
            for (const cell of token.header) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
            for (const row of token.rows) {
              for (const cell of row) {
                values = values.concat(this.walkTokens(cell.tokens, callback));
              }
            }
            break;
          }
          case "list": {
            values = values.concat(this.walkTokens(token.items, callback));
            break;
          }
          default: {
            if (this.defaults.extensions && this.defaults.extensions.childTokens && this.defaults.extensions.childTokens[token.type]) {
              this.defaults.extensions.childTokens[token.type].forEach((childTokens) => {
                values = values.concat(this.walkTokens(token[childTokens], callback));
              });
            } else if (token.tokens) {
              values = values.concat(this.walkTokens(token.tokens, callback));
            }
          }
        }
      }
      return values;
    }
    use(...args) {
      const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
      args.forEach((pack) => {
        const opts = { ...pack };
        opts.async = this.defaults.async || opts.async || false;
        if (pack.extensions) {
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if (ext.renderer) {
              const prevRenderer = extensions.renderers[ext.name];
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
          opts.extensions = extensions;
        }
        if (pack.renderer) {
          const renderer = this.defaults.renderer || new Renderer(this.defaults);
          for (const prop in pack.renderer) {
            const prevRenderer = renderer[prop];
            renderer[prop] = (...args2) => {
              let ret = pack.renderer[prop].apply(renderer, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args2);
              }
              return ret;
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = this.defaults.tokenizer || new Tokenizer(this.defaults);
          for (const prop in pack.tokenizer) {
            const prevTokenizer = tokenizer[prop];
            tokenizer[prop] = (...args2) => {
              let ret = pack.tokenizer[prop].apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.hooks) {
          const hooks = this.defaults.hooks || new Hooks();
          for (const prop in pack.hooks) {
            const prevHook = hooks[prop];
            if (Hooks.passThroughHooks.has(prop)) {
              hooks[prop] = (arg) => {
                if (this.defaults.async) {
                  return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret2) => {
                    return prevHook.call(hooks, ret2);
                  });
                }
                const ret = pack.hooks[prop].call(hooks, arg);
                return prevHook.call(hooks, ret);
              };
            } else {
              hooks[prop] = (...args2) => {
                let ret = pack.hooks[prop].apply(hooks, args2);
                if (ret === false) {
                  ret = prevHook.apply(hooks, args2);
                }
                return ret;
              };
            }
          }
          opts.hooks = hooks;
        }
        if (pack.walkTokens) {
          const walkTokens = this.defaults.walkTokens;
          opts.walkTokens = function(token) {
            let values = [];
            values.push(pack.walkTokens.call(this, token));
            if (walkTokens) {
              values = values.concat(walkTokens.call(this, token));
            }
            return values;
          };
        }
        this.defaults = { ...this.defaults, ...opts };
      });
      return this;
    }
    setOptions(opt) {
      this.defaults = { ...this.defaults, ...opt };
      return this;
    }
  };
  _Marked_instances = new WeakSet();
  parseMarkdown_fn = /* @__PURE__ */ __name(function(lexer, parser) {
    return (src, opt, callback) => {
      if (typeof opt === "function") {
        callback = opt;
        opt = null;
      }
      const origOpt = { ...opt };
      opt = { ...this.defaults, ...origOpt };
      const throwError = __privateMethod(this, _Marked_instances, onError_fn).call(this, opt.silent, opt.async, callback);
      if (typeof src === "undefined" || src === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
      }
      checkDeprecations(opt, callback);
      if (opt.hooks) {
        opt.hooks.options = opt;
      }
      if (callback) {
        const highlight = opt.highlight;
        let tokens;
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          tokens = lexer(src, opt);
        } catch (e) {
          return throwError(e);
        }
        const done = /* @__PURE__ */ __name((err) => {
          let out;
          if (!err) {
            try {
              if (opt.walkTokens) {
                this.walkTokens(tokens, opt.walkTokens);
              }
              out = parser(tokens, opt);
              if (opt.hooks) {
                out = opt.hooks.postprocess(out);
              }
            } catch (e) {
              err = e;
            }
          }
          opt.highlight = highlight;
          return err ? throwError(err) : callback(null, out);
        }, "done");
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!tokens.length) return done();
        let pending = 0;
        this.walkTokens(tokens, (token) => {
          if (token.type === "code") {
            pending++;
            setTimeout(() => {
              highlight(token.text, token.lang, (err, code) => {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token.text) {
                  token.text = code;
                  token.escaped = true;
                }
                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });
        if (pending === 0) {
          done();
        }
        return;
      }
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        const tokens = lexer(src, opt);
        if (opt.walkTokens) {
          this.walkTokens(tokens, opt.walkTokens);
        }
        let html = parser(tokens, opt);
        if (opt.hooks) {
          html = opt.hooks.postprocess(html);
        }
        return html;
      } catch (e) {
        return throwError(e);
      }
    };
  }, "#parseMarkdown");
  onError_fn = /* @__PURE__ */ __name(function(silent, async2, callback) {
    return (e) => {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        if (async2) {
          return Promise.resolve(msg);
        }
        if (callback) {
          callback(null, msg);
          return;
        }
        return msg;
      }
      if (async2) {
        return Promise.reject(e);
      }
      if (callback) {
        callback(e);
        return;
      }
      throw e;
    };
  }, "#onError");
  __name(_Marked, "Marked");
  let Marked = _Marked;
  const markedInstance = new Marked(defaults);
  function marked(src, opt, callback) {
    return markedInstance.parse(src, opt, callback);
  }
  __name(marked, "marked");
  marked.options = marked.setOptions = function(opt) {
    markedInstance.setOptions(opt);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.getDefaults = getDefaults;
  marked.defaults = defaults;
  marked.use = function(...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.walkTokens = function(tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
  };
  marked.parseInline = markedInstance.parseInline;
  marked.Parser = Parser;
  marked.parser = Parser.parse;
  marked.Renderer = Renderer;
  marked.TextRenderer = TextRenderer;
  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;
  marked.Tokenizer = Tokenizer;
  marked.Slugger = Slugger;
  marked.Hooks = Hooks;
  marked.parse = marked;
  marked.options;
  marked.setOptions;
  marked.use;
  marked.walkTokens;
  marked.parseInline;
  Parser.parse;
  Lexer.lex;
  const key = {};
  function create_else_block$9(ctx) {
    let t;
    return {
      c() {
        t = text(
          /*raw*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, t, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*raw*/
        2) set_data(
          t,
          /*raw*/
          ctx2[1]
        );
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(t);
        }
      }
    };
  }
  __name(create_else_block$9, "create_else_block$9");
  function create_if_block_5$1(ctx) {
    let h6;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[5].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[4],
      null
    );
    return {
      c() {
        h6 = element("h6");
        if (default_slot) default_slot.c();
        attr(
          h6,
          "id",
          /*id*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, h6, anchor);
        if (default_slot) {
          default_slot.m(h6, null);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          16)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[4],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[4]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[4],
                dirty,
                null
              ),
              null
            );
          }
        }
        if (!current || dirty & /*id*/
        4) {
          attr(
            h6,
            "id",
            /*id*/
            ctx2[2]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(h6);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_if_block_5$1, "create_if_block_5$1");
  function create_if_block_4$3(ctx) {
    let h5;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[5].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[4],
      null
    );
    return {
      c() {
        h5 = element("h5");
        if (default_slot) default_slot.c();
        attr(
          h5,
          "id",
          /*id*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, h5, anchor);
        if (default_slot) {
          default_slot.m(h5, null);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          16)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[4],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[4]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[4],
                dirty,
                null
              ),
              null
            );
          }
        }
        if (!current || dirty & /*id*/
        4) {
          attr(
            h5,
            "id",
            /*id*/
            ctx2[2]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(h5);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_if_block_4$3, "create_if_block_4$3");
  function create_if_block_3$3(ctx) {
    let h4;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[5].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[4],
      null
    );
    return {
      c() {
        h4 = element("h4");
        if (default_slot) default_slot.c();
        attr(
          h4,
          "id",
          /*id*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, h4, anchor);
        if (default_slot) {
          default_slot.m(h4, null);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          16)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[4],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[4]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[4],
                dirty,
                null
              ),
              null
            );
          }
        }
        if (!current || dirty & /*id*/
        4) {
          attr(
            h4,
            "id",
            /*id*/
            ctx2[2]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(h4);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_if_block_3$3, "create_if_block_3$3");
  function create_if_block_2$5(ctx) {
    let h3;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[5].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[4],
      null
    );
    return {
      c() {
        h3 = element("h3");
        if (default_slot) default_slot.c();
        attr(
          h3,
          "id",
          /*id*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, h3, anchor);
        if (default_slot) {
          default_slot.m(h3, null);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          16)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[4],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[4]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[4],
                dirty,
                null
              ),
              null
            );
          }
        }
        if (!current || dirty & /*id*/
        4) {
          attr(
            h3,
            "id",
            /*id*/
            ctx2[2]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(h3);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_if_block_2$5, "create_if_block_2$5");
  function create_if_block_1$7(ctx) {
    let h2;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[5].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[4],
      null
    );
    return {
      c() {
        h2 = element("h2");
        if (default_slot) default_slot.c();
        attr(
          h2,
          "id",
          /*id*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, h2, anchor);
        if (default_slot) {
          default_slot.m(h2, null);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          16)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[4],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[4]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[4],
                dirty,
                null
              ),
              null
            );
          }
        }
        if (!current || dirty & /*id*/
        4) {
          attr(
            h2,
            "id",
            /*id*/
            ctx2[2]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(h2);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_if_block_1$7, "create_if_block_1$7");
  function create_if_block$h(ctx) {
    let h1;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[5].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[4],
      null
    );
    return {
      c() {
        h1 = element("h1");
        if (default_slot) default_slot.c();
        attr(
          h1,
          "id",
          /*id*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, h1, anchor);
        if (default_slot) {
          default_slot.m(h1, null);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          16)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[4],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[4]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[4],
                dirty,
                null
              ),
              null
            );
          }
        }
        if (!current || dirty & /*id*/
        4) {
          attr(
            h1,
            "id",
            /*id*/
            ctx2[2]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(h1);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_if_block$h, "create_if_block$h");
  function create_fragment$U(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [
      create_if_block$h,
      create_if_block_1$7,
      create_if_block_2$5,
      create_if_block_3$3,
      create_if_block_4$3,
      create_if_block_5$1,
      create_else_block$9
    ];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*depth*/
        ctx2[0] === 1
      ) return 0;
      if (
        /*depth*/
        ctx2[0] === 2
      ) return 1;
      if (
        /*depth*/
        ctx2[0] === 3
      ) return 2;
      if (
        /*depth*/
        ctx2[0] === 4
      ) return 3;
      if (
        /*depth*/
        ctx2[0] === 5
      ) return 4;
      if (
        /*depth*/
        ctx2[0] === 6
      ) return 5;
      return 6;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if_blocks[current_block_type_index].m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if_blocks[current_block_type_index].d(detaching);
      }
    };
  }
  __name(create_fragment$U, "create_fragment$U");
  function instance$Q($$self, $$props, $$invalidate) {
    let id2;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { depth } = $$props;
    let { raw } = $$props;
    let { text: text2 } = $$props;
    const { slug, getOptions } = getContext(key);
    const options = getOptions();
    $$self.$$set = ($$props2) => {
      if ("depth" in $$props2) $$invalidate(0, depth = $$props2.depth);
      if ("raw" in $$props2) $$invalidate(1, raw = $$props2.raw);
      if ("text" in $$props2) $$invalidate(3, text2 = $$props2.text);
      if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*text*/
      8) {
        $$invalidate(2, id2 = options.headerIds ? options.headerPrefix + slug(text2) : void 0);
      }
    };
    return [depth, raw, id2, text2, $$scope, slots];
  }
  __name(instance$Q, "instance$Q");
  const _Heading = class _Heading extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$Q, create_fragment$U, safe_not_equal, { depth: 0, raw: 1, text: 3 });
    }
  };
  __name(_Heading, "Heading");
  let Heading = _Heading;
  function create_fragment$T(ctx) {
    let p;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[1].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[0],
      null
    );
    return {
      c() {
        p = element("p");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, p, anchor);
        if (default_slot) {
          default_slot.m(p, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          1)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[0],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[0]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[0],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(p);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$T, "create_fragment$T");
  function instance$P($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
    };
    return [$$scope, slots];
  }
  __name(instance$P, "instance$P");
  const _Paragraph = class _Paragraph extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$P, create_fragment$T, safe_not_equal, {});
    }
  };
  __name(_Paragraph, "Paragraph");
  let Paragraph = _Paragraph;
  function create_fragment$S(ctx) {
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[3].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[2],
      null
    );
    return {
      c() {
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          4)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[2],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[2]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[2],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$S, "create_fragment$S");
  function instance$O($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    let { text: text2 } = $$props;
    let { raw } = $$props;
    $$self.$$set = ($$props2) => {
      if ("text" in $$props2) $$invalidate(0, text2 = $$props2.text);
      if ("raw" in $$props2) $$invalidate(1, raw = $$props2.raw);
      if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
    };
    return [text2, raw, $$scope, slots];
  }
  __name(instance$O, "instance$O");
  const _Text = class _Text extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$O, create_fragment$S, safe_not_equal, { text: 0, raw: 1 });
    }
  };
  __name(_Text, "Text");
  let Text = _Text;
  function create_fragment$R(ctx) {
    let img;
    let img_src_value;
    return {
      c() {
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = /*href*/
        ctx[0])) attr(img, "src", img_src_value);
        attr(
          img,
          "title",
          /*title*/
          ctx[1]
        );
        attr(
          img,
          "alt",
          /*text*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, img, anchor);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*href*/
        1 && !src_url_equal(img.src, img_src_value = /*href*/
        ctx2[0])) {
          attr(img, "src", img_src_value);
        }
        if (dirty & /*title*/
        2) {
          attr(
            img,
            "title",
            /*title*/
            ctx2[1]
          );
        }
        if (dirty & /*text*/
        4) {
          attr(
            img,
            "alt",
            /*text*/
            ctx2[2]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(img);
        }
      }
    };
  }
  __name(create_fragment$R, "create_fragment$R");
  function instance$N($$self, $$props, $$invalidate) {
    let { href = "" } = $$props;
    let { title = void 0 } = $$props;
    let { text: text2 = "" } = $$props;
    $$self.$$set = ($$props2) => {
      if ("href" in $$props2) $$invalidate(0, href = $$props2.href);
      if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
      if ("text" in $$props2) $$invalidate(2, text2 = $$props2.text);
    };
    return [href, title, text2];
  }
  __name(instance$N, "instance$N");
  let Image$1 = (_Da = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$N, create_fragment$R, safe_not_equal, { href: 0, title: 1, text: 2 });
    }
  }, __name(_Da, "Image"), _Da);
  function create_fragment$Q(ctx) {
    let a;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[3].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[2],
      null
    );
    return {
      c() {
        a = element("a");
        if (default_slot) default_slot.c();
        attr(
          a,
          "href",
          /*href*/
          ctx[0]
        );
        attr(
          a,
          "title",
          /*title*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, a, anchor);
        if (default_slot) {
          default_slot.m(a, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          4)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[2],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[2]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[2],
                dirty,
                null
              ),
              null
            );
          }
        }
        if (!current || dirty & /*href*/
        1) {
          attr(
            a,
            "href",
            /*href*/
            ctx2[0]
          );
        }
        if (!current || dirty & /*title*/
        2) {
          attr(
            a,
            "title",
            /*title*/
            ctx2[1]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(a);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$Q, "create_fragment$Q");
  function instance$M($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    let { href = "" } = $$props;
    let { title = void 0 } = $$props;
    $$self.$$set = ($$props2) => {
      if ("href" in $$props2) $$invalidate(0, href = $$props2.href);
      if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
      if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
    };
    return [href, title, $$scope, slots];
  }
  __name(instance$M, "instance$M");
  const _Link = class _Link extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$M, create_fragment$Q, safe_not_equal, { href: 0, title: 1 });
    }
  };
  __name(_Link, "Link");
  let Link = _Link;
  function create_fragment$P(ctx) {
    let em;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[1].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[0],
      null
    );
    return {
      c() {
        em = element("em");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, em, anchor);
        if (default_slot) {
          default_slot.m(em, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          1)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[0],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[0]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[0],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(em);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$P, "create_fragment$P");
  function instance$L($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
    };
    return [$$scope, slots];
  }
  __name(instance$L, "instance$L");
  const _Em = class _Em extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$L, create_fragment$P, safe_not_equal, {});
    }
  };
  __name(_Em, "Em");
  let Em = _Em;
  function create_fragment$O(ctx) {
    let del;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[1].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[0],
      null
    );
    return {
      c() {
        del = element("del");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, del, anchor);
        if (default_slot) {
          default_slot.m(del, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          1)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[0],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[0]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[0],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(del);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$O, "create_fragment$O");
  function instance$K($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
    };
    return [$$scope, slots];
  }
  __name(instance$K, "instance$K");
  const _Del = class _Del extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$K, create_fragment$O, safe_not_equal, {});
    }
  };
  __name(_Del, "Del");
  let Del = _Del;
  function create_fragment$N(ctx) {
    let code;
    let t_value = (
      /*raw*/
      ctx[0].replace(/`/g, "") + ""
    );
    let t;
    return {
      c() {
        code = element("code");
        t = text(t_value);
      },
      m(target, anchor) {
        insert(target, code, anchor);
        append(code, t);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*raw*/
        1 && t_value !== (t_value = /*raw*/
        ctx2[0].replace(/`/g, "") + "")) set_data(t, t_value);
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(code);
        }
      }
    };
  }
  __name(create_fragment$N, "create_fragment$N");
  function instance$J($$self, $$props, $$invalidate) {
    let { raw } = $$props;
    $$self.$$set = ($$props2) => {
      if ("raw" in $$props2) $$invalidate(0, raw = $$props2.raw);
    };
    return [raw];
  }
  __name(instance$J, "instance$J");
  const _Codespan = class _Codespan extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$J, create_fragment$N, safe_not_equal, { raw: 0 });
    }
  };
  __name(_Codespan, "Codespan");
  let Codespan = _Codespan;
  function create_fragment$M(ctx) {
    let strong;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[1].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[0],
      null
    );
    return {
      c() {
        strong = element("strong");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, strong, anchor);
        if (default_slot) {
          default_slot.m(strong, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          1)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[0],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[0]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[0],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(strong);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$M, "create_fragment$M");
  function instance$I($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
    };
    return [$$scope, slots];
  }
  __name(instance$I, "instance$I");
  const _Strong = class _Strong extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$I, create_fragment$M, safe_not_equal, {});
    }
  };
  __name(_Strong, "Strong");
  let Strong = _Strong;
  function create_fragment$L(ctx) {
    let table;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[1].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[0],
      null
    );
    return {
      c() {
        table = element("table");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, table, anchor);
        if (default_slot) {
          default_slot.m(table, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          1)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[0],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[0]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[0],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(table);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$L, "create_fragment$L");
  function instance$H($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
    };
    return [$$scope, slots];
  }
  __name(instance$H, "instance$H");
  const _Table = class _Table extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$H, create_fragment$L, safe_not_equal, {});
    }
  };
  __name(_Table, "Table");
  let Table = _Table;
  function create_fragment$K(ctx) {
    let thead;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[1].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[0],
      null
    );
    return {
      c() {
        thead = element("thead");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, thead, anchor);
        if (default_slot) {
          default_slot.m(thead, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          1)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[0],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[0]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[0],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(thead);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$K, "create_fragment$K");
  function instance$G($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
    };
    return [$$scope, slots];
  }
  __name(instance$G, "instance$G");
  const _TableHead = class _TableHead extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$G, create_fragment$K, safe_not_equal, {});
    }
  };
  __name(_TableHead, "TableHead");
  let TableHead = _TableHead;
  function create_fragment$J(ctx) {
    let tbody;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[1].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[0],
      null
    );
    return {
      c() {
        tbody = element("tbody");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, tbody, anchor);
        if (default_slot) {
          default_slot.m(tbody, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          1)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[0],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[0]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[0],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(tbody);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$J, "create_fragment$J");
  function instance$F($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
    };
    return [$$scope, slots];
  }
  __name(instance$F, "instance$F");
  const _TableBody = class _TableBody extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$F, create_fragment$J, safe_not_equal, {});
    }
  };
  __name(_TableBody, "TableBody");
  let TableBody = _TableBody;
  function create_fragment$I(ctx) {
    let tr;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[1].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[0],
      null
    );
    return {
      c() {
        tr = element("tr");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, tr, anchor);
        if (default_slot) {
          default_slot.m(tr, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          1)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[0],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[0]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[0],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(tr);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$I, "create_fragment$I");
  function instance$E($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
    };
    return [$$scope, slots];
  }
  __name(instance$E, "instance$E");
  const _TableRow = class _TableRow extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$E, create_fragment$I, safe_not_equal, {});
    }
  };
  __name(_TableRow, "TableRow");
  let TableRow = _TableRow;
  function create_else_block$8(ctx) {
    let td;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[3].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[2],
      null
    );
    return {
      c() {
        td = element("td");
        if (default_slot) default_slot.c();
        attr(
          td,
          "align",
          /*align*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, td, anchor);
        if (default_slot) {
          default_slot.m(td, null);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          4)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[2],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[2]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[2],
                dirty,
                null
              ),
              null
            );
          }
        }
        if (!current || dirty & /*align*/
        2) {
          attr(
            td,
            "align",
            /*align*/
            ctx2[1]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(td);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_else_block$8, "create_else_block$8");
  function create_if_block$g(ctx) {
    let th;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[3].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[2],
      null
    );
    return {
      c() {
        th = element("th");
        if (default_slot) default_slot.c();
        attr(
          th,
          "align",
          /*align*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, th, anchor);
        if (default_slot) {
          default_slot.m(th, null);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          4)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[2],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[2]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[2],
                dirty,
                null
              ),
              null
            );
          }
        }
        if (!current || dirty & /*align*/
        2) {
          attr(
            th,
            "align",
            /*align*/
            ctx2[1]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(th);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_if_block$g, "create_if_block$g");
  function create_fragment$H(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block$g, create_else_block$8];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*header*/
        ctx2[0]
      ) return 0;
      return 1;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if_blocks[current_block_type_index].m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if_blocks[current_block_type_index].d(detaching);
      }
    };
  }
  __name(create_fragment$H, "create_fragment$H");
  function instance$D($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    let { header } = $$props;
    let { align } = $$props;
    $$self.$$set = ($$props2) => {
      if ("header" in $$props2) $$invalidate(0, header = $$props2.header);
      if ("align" in $$props2) $$invalidate(1, align = $$props2.align);
      if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
    };
    return [header, align, $$scope, slots];
  }
  __name(instance$D, "instance$D");
  const _TableCell = class _TableCell extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$D, create_fragment$H, safe_not_equal, { header: 0, align: 1 });
    }
  };
  __name(_TableCell, "TableCell");
  let TableCell = _TableCell;
  function create_else_block$7(ctx) {
    let ul;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[3].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[2],
      null
    );
    return {
      c() {
        ul = element("ul");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, ul, anchor);
        if (default_slot) {
          default_slot.m(ul, null);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          4)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[2],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[2]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[2],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(ul);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_else_block$7, "create_else_block$7");
  function create_if_block$f(ctx) {
    let ol;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[3].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[2],
      null
    );
    return {
      c() {
        ol = element("ol");
        if (default_slot) default_slot.c();
        attr(
          ol,
          "start",
          /*start*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, ol, anchor);
        if (default_slot) {
          default_slot.m(ol, null);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          4)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[2],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[2]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[2],
                dirty,
                null
              ),
              null
            );
          }
        }
        if (!current || dirty & /*start*/
        2) {
          attr(
            ol,
            "start",
            /*start*/
            ctx2[1]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(ol);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_if_block$f, "create_if_block$f");
  function create_fragment$G(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block$f, create_else_block$7];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*ordered*/
        ctx2[0]
      ) return 0;
      return 1;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if_blocks[current_block_type_index].m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if_blocks[current_block_type_index].d(detaching);
      }
    };
  }
  __name(create_fragment$G, "create_fragment$G");
  function instance$C($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    let { ordered } = $$props;
    let { start } = $$props;
    $$self.$$set = ($$props2) => {
      if ("ordered" in $$props2) $$invalidate(0, ordered = $$props2.ordered);
      if ("start" in $$props2) $$invalidate(1, start = $$props2.start);
      if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
    };
    return [ordered, start, $$scope, slots];
  }
  __name(instance$C, "instance$C");
  const _List = class _List extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$C, create_fragment$G, safe_not_equal, { ordered: 0, start: 1 });
    }
  };
  __name(_List, "List");
  let List = _List;
  function create_fragment$F(ctx) {
    let li;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[1].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[0],
      null
    );
    return {
      c() {
        li = element("li");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, li, anchor);
        if (default_slot) {
          default_slot.m(li, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          1)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[0],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[0]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[0],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(li);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$F, "create_fragment$F");
  function instance$B($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
    };
    return [$$scope, slots];
  }
  __name(instance$B, "instance$B");
  const _ListItem = class _ListItem extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$B, create_fragment$F, safe_not_equal, {});
    }
  };
  __name(_ListItem, "ListItem");
  let ListItem = _ListItem;
  function create_fragment$E(ctx) {
    let hr;
    return {
      c() {
        hr = element("hr");
      },
      m(target, anchor) {
        insert(target, hr, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(hr);
        }
      }
    };
  }
  __name(create_fragment$E, "create_fragment$E");
  const _Hr = class _Hr extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment$E, safe_not_equal, {});
    }
  };
  __name(_Hr, "Hr");
  let Hr = _Hr;
  function create_fragment$D(ctx) {
    let html_tag;
    let html_anchor;
    return {
      c() {
        html_tag = new HtmlTag(false);
        html_anchor = empty();
        html_tag.a = html_anchor;
      },
      m(target, anchor) {
        html_tag.m(
          /*text*/
          ctx[0],
          target,
          anchor
        );
        insert(target, html_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*text*/
        1) html_tag.p(
          /*text*/
          ctx2[0]
        );
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(html_anchor);
          html_tag.d();
        }
      }
    };
  }
  __name(create_fragment$D, "create_fragment$D");
  function instance$A($$self, $$props, $$invalidate) {
    let { text: text2 } = $$props;
    $$self.$$set = ($$props2) => {
      if ("text" in $$props2) $$invalidate(0, text2 = $$props2.text);
    };
    return [text2];
  }
  __name(instance$A, "instance$A");
  const _Html = class _Html extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$A, create_fragment$D, safe_not_equal, { text: 0 });
    }
  };
  __name(_Html, "Html");
  let Html = _Html;
  function create_fragment$C(ctx) {
    let blockquote;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[1].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[0],
      null
    );
    return {
      c() {
        blockquote = element("blockquote");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, blockquote, anchor);
        if (default_slot) {
          default_slot.m(blockquote, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          1)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[0],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[0]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[0],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(blockquote);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$C, "create_fragment$C");
  function instance$z($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
    };
    return [$$scope, slots];
  }
  __name(instance$z, "instance$z");
  const _Blockquote = class _Blockquote extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$z, create_fragment$C, safe_not_equal, {});
    }
  };
  __name(_Blockquote, "Blockquote");
  let Blockquote = _Blockquote;
  function create_fragment$B(ctx) {
    let pre;
    let code;
    let t;
    return {
      c() {
        pre = element("pre");
        code = element("code");
        t = text(
          /*text*/
          ctx[1]
        );
        attr(
          pre,
          "class",
          /*lang*/
          ctx[0]
        );
      },
      m(target, anchor) {
        insert(target, pre, anchor);
        append(pre, code);
        append(code, t);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*text*/
        2) set_data(
          t,
          /*text*/
          ctx2[1]
        );
        if (dirty & /*lang*/
        1) {
          attr(
            pre,
            "class",
            /*lang*/
            ctx2[0]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(pre);
        }
      }
    };
  }
  __name(create_fragment$B, "create_fragment$B");
  function instance$y($$self, $$props, $$invalidate) {
    let { lang } = $$props;
    let { text: text2 } = $$props;
    $$self.$$set = ($$props2) => {
      if ("lang" in $$props2) $$invalidate(0, lang = $$props2.lang);
      if ("text" in $$props2) $$invalidate(1, text2 = $$props2.text);
    };
    return [lang, text2];
  }
  __name(instance$y, "instance$y");
  const _Code = class _Code extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$y, create_fragment$B, safe_not_equal, { lang: 0, text: 1 });
    }
  };
  __name(_Code, "Code");
  let Code = _Code;
  function create_fragment$A(ctx) {
    let br;
    let current;
    const default_slot_template = (
      /*#slots*/
      ctx[1].default
    );
    const default_slot = create_slot(
      default_slot_template,
      ctx,
      /*$$scope*/
      ctx[0],
      null
    );
    return {
      c() {
        br = element("br");
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        insert(target, br, anchor);
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & /*$$scope*/
          1)) {
            update_slot_base(
              default_slot,
              default_slot_template,
              ctx2,
              /*$$scope*/
              ctx2[0],
              !current ? get_all_dirty_from_scope(
                /*$$scope*/
                ctx2[0]
              ) : get_slot_changes(
                default_slot_template,
                /*$$scope*/
                ctx2[0],
                dirty,
                null
              ),
              null
            );
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(br);
        }
        if (default_slot) default_slot.d(detaching);
      }
    };
  }
  __name(create_fragment$A, "create_fragment$A");
  function instance$x($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
    };
    return [$$scope, slots];
  }
  __name(instance$x, "instance$x");
  const _Br = class _Br extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$x, create_fragment$A, safe_not_equal, {});
    }
  };
  __name(_Br, "Br");
  let Br = _Br;
  const defaultRenderers = {
    heading: Heading,
    paragraph: Paragraph,
    text: Text,
    image: Image$1,
    link: Link,
    em: Em,
    strong: Strong,
    codespan: Codespan,
    del: Del,
    table: Table,
    tablehead: TableHead,
    tablebody: TableBody,
    tablerow: TableRow,
    tablecell: TableCell,
    list: List,
    orderedlistitem: null,
    unorderedlistitem: null,
    listitem: ListItem,
    hr: Hr,
    html: Html,
    blockquote: Blockquote,
    code: Code,
    br: Br
  };
  const defaultOptions = {
    baseUrl: null,
    breaks: false,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    tokenizer: null,
    xhtml: false
  };
  function create_fragment$z(ctx) {
    let parser;
    let current;
    parser = new Parser$1({
      props: {
        tokens: (
          /*tokens*/
          ctx[0]
        ),
        renderers: (
          /*combinedRenderers*/
          ctx[1]
        )
      }
    });
    return {
      c() {
        create_component(parser.$$.fragment);
      },
      m(target, anchor) {
        mount_component(parser, target, anchor);
        current = true;
      },
      p(ctx2, [dirty]) {
        const parser_changes = {};
        if (dirty & /*tokens*/
        1) parser_changes.tokens = /*tokens*/
        ctx2[0];
        if (dirty & /*combinedRenderers*/
        2) parser_changes.renderers = /*combinedRenderers*/
        ctx2[1];
        parser.$set(parser_changes);
      },
      i(local) {
        if (current) return;
        transition_in(parser.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(parser.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(parser, detaching);
      }
    };
  }
  __name(create_fragment$z, "create_fragment$z");
  function instance$w($$self, $$props, $$invalidate) {
    let preprocessed;
    let slugger;
    let combinedOptions;
    let combinedRenderers;
    let { source = [] } = $$props;
    let { renderers = {} } = $$props;
    let { options = {} } = $$props;
    let { isInline = false } = $$props;
    const dispatch = createEventDispatcher();
    let tokens;
    let lexer;
    let mounted;
    setContext(key, {
      slug: /* @__PURE__ */ __name((val) => slugger ? slugger.slug(val) : "", "slug"),
      getOptions: /* @__PURE__ */ __name(() => combinedOptions, "getOptions")
    });
    onMount(() => {
      $$invalidate(7, mounted = true);
    });
    $$self.$$set = ($$props2) => {
      if ("source" in $$props2) $$invalidate(2, source = $$props2.source);
      if ("renderers" in $$props2) $$invalidate(3, renderers = $$props2.renderers);
      if ("options" in $$props2) $$invalidate(4, options = $$props2.options);
      if ("isInline" in $$props2) $$invalidate(5, isInline = $$props2.isInline);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*source*/
      4) {
        $$invalidate(8, preprocessed = Array.isArray(source));
      }
      if ($$self.$$.dirty & /*source*/
      4) {
        slugger = source ? new Slugger() : void 0;
      }
      if ($$self.$$.dirty & /*options*/
      16) {
        $$invalidate(9, combinedOptions = { ...defaultOptions, ...options });
      }
      if ($$self.$$.dirty & /*preprocessed, source, combinedOptions, isInline, lexer, tokens*/
      869) {
        if (preprocessed) {
          $$invalidate(0, tokens = source);
        } else {
          $$invalidate(6, lexer = new Lexer(combinedOptions));
          $$invalidate(0, tokens = isInline ? lexer.inlineTokens(source) : lexer.lex(source));
          dispatch("parsed", { tokens });
        }
      }
      if ($$self.$$.dirty & /*renderers*/
      8) {
        $$invalidate(1, combinedRenderers = { ...defaultRenderers, ...renderers });
      }
      if ($$self.$$.dirty & /*mounted, preprocessed, tokens*/
      385) {
        mounted && !preprocessed && dispatch("parsed", { tokens });
      }
    };
    return [
      tokens,
      combinedRenderers,
      source,
      renderers,
      options,
      isInline,
      lexer,
      mounted,
      preprocessed,
      combinedOptions
    ];
  }
  __name(instance$w, "instance$w");
  const _SvelteMarkdown = class _SvelteMarkdown extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$w, create_fragment$z, safe_not_equal, {
        source: 2,
        renderers: 3,
        options: 4,
        isInline: 5
      });
    }
  };
  __name(_SvelteMarkdown, "SvelteMarkdown");
  let SvelteMarkdown = _SvelteMarkdown;
  function create_fragment$y(ctx) {
    let div0;
    let span0;
    let t0_value = new Date(Number(
      /*change*/
      ctx[0].date
    )).toDateString() + "";
    let t0;
    let t1;
    let span1;
    let t2;
    let t3_value = (
      /*change*/
      ctx[0].affectedTypoVersion + ""
    );
    let t3;
    let t4;
    let br;
    let t5;
    let div1;
    let sveltemarkdown;
    let current;
    sveltemarkdown = new SvelteMarkdown({
      props: { source: (
        /*change*/
        ctx[0].details
      ) }
    });
    return {
      c() {
        div0 = element("div");
        span0 = element("span");
        t0 = text(t0_value);
        t1 = space();
        span1 = element("span");
        t2 = text("Update changelog for v");
        t3 = text(t3_value);
        t4 = space();
        br = element("br");
        t5 = space();
        div1 = element("div");
        create_component(sveltemarkdown.$$.fragment);
        attr(div0, "class", "info svelte-mkybs6");
        attr(div1, "class", "details svelte-mkybs6");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        append(div0, span0);
        append(span0, t0);
        append(div0, t1);
        append(div0, span1);
        append(span1, t2);
        append(span1, t3);
        insert(target, t4, anchor);
        insert(target, br, anchor);
        insert(target, t5, anchor);
        insert(target, div1, anchor);
        mount_component(sveltemarkdown, div1, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        if ((!current || dirty & /*change*/
        1) && t0_value !== (t0_value = new Date(Number(
          /*change*/
          ctx2[0].date
        )).toDateString() + "")) set_data(t0, t0_value);
        if ((!current || dirty & /*change*/
        1) && t3_value !== (t3_value = /*change*/
        ctx2[0].affectedTypoVersion + "")) set_data(t3, t3_value);
        const sveltemarkdown_changes = {};
        if (dirty & /*change*/
        1) sveltemarkdown_changes.source = /*change*/
        ctx2[0].details;
        sveltemarkdown.$set(sveltemarkdown_changes);
      },
      i(local) {
        if (current) return;
        transition_in(sveltemarkdown.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(sveltemarkdown.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t4);
          detach(br);
          detach(t5);
          detach(div1);
        }
        destroy_component(sveltemarkdown);
      }
    };
  }
  __name(create_fragment$y, "create_fragment$y");
  function instance$v($$self, $$props, $$invalidate) {
    let { change } = $$props;
    $$self.$$set = ($$props2) => {
      if ("change" in $$props2) $$invalidate(0, change = $$props2.change);
    };
    return [change];
  }
  __name(instance$v, "instance$v");
  const _Panel_changelog_details = class _Panel_changelog_details extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$v, create_fragment$y, safe_not_equal, { change: 0 });
    }
  };
  __name(_Panel_changelog_details, "Panel_changelog_details");
  let Panel_changelog_details = _Panel_changelog_details;
  var __defProp$w = Object.defineProperty;
  var __decorateClass$w = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$w(target, key2, result);
    return result;
  }, "__decorateClass$w");
  const _PanelChangelogFeature = class _PanelChangelogFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elements");
      __publicField(this, "_apiDataSetup");
      __publicField(this, "_globalSettingsService");
      __publicField(this, "_modalService");
      __publicField(this, "_firstLoadSetting", new BooleanExtensionSetting("first_load", true, this));
      __publicField(this, "_lastReadVersionSetting", new ExtensionSetting("last_read_version", "0.0.0", this));
      __publicField(this, "_component");
      __publicField(this, "name", "Changelog");
      __publicField(this, "description", "Displays a list of changes since the last updates on the start page");
      __publicField(this, "tags", [
        FeatureTag.INFORMATION
      ]);
      __publicField(this, "featureId", 4);
      __publicField(this, "changelog", "I am the changelog :)");
    }
    async onActivate() {
      const elements2 = await this._elements.complete();
      this._component = new Panel_changelog({
        target: elements2.changelogTab,
        props: {
          feature: this
        }
      });
      const data = await this._apiDataSetup.complete();
      const changes = data.announcements.filter((announcement) => announcement.type === AnnouncementDtoTypeEnum.Changelog).sort((a, b) => Number(b.date) - Number(a.date));
      this._component.$set({ changes });
      const lastChange = changes[0];
      const currentVersion = typoRuntime.getReleaseDetails().version;
      const isFirstLoad = await this._firstLoadSetting.getValue();
      if (isFirstLoad) {
        await this._firstLoadSetting.setValue(false);
      } else if ((lastChange == null ? void 0 : lastChange.affectedTypoVersion) === currentVersion) {
        const lastReadVersion = await this._lastReadVersionSetting.getValue();
        if (lastReadVersion != currentVersion) {
          this.showDetailsModal(lastChange);
          await this._lastReadVersionSetting.setValue(currentVersion);
        }
      }
    }
    onDestroy() {
      var _a2;
      (_a2 = this._component) == null ? void 0 : _a2.$destroy();
    }
    get devmodeStore() {
      return this._globalSettingsService.settings.devMode.store;
    }
    versionIsBiggerThan(version) {
      const v1 = version.split(".").map(Number);
      const v2 = typoRuntime.getReleaseDetails().version.split(".").map(Number);
      for (let i = 0; i < Math.max(v1.length, v2.length); i++) {
        const a = v1[i] || 0;
        const b = v2[i] || 0;
        if (a > b) return true;
        if (a < b) return false;
      }
    }
    getVersion() {
      return typoRuntime.getReleaseDetails().versionName;
    }
    showDetailsModal(change) {
      if (change.details === void 0) {
        this._logger.warn("Change does not have details");
        throw new Error("Change does not have details");
      }
      const modalComponent = {
        componentType: Panel_changelog_details,
        props: {
          change
        }
      };
      this._modalService.showModal(modalComponent.componentType, modalComponent.props, change.title, "card");
    }
  };
  __name(_PanelChangelogFeature, "PanelChangelogFeature");
  let PanelChangelogFeature = _PanelChangelogFeature;
  __decorateClass$w([
    inject(ElementsSetup)
  ], PanelChangelogFeature.prototype, "_elements");
  __decorateClass$w([
    inject(ApiDataSetup)
  ], PanelChangelogFeature.prototype, "_apiDataSetup");
  __decorateClass$w([
    inject(GlobalSettingsService)
  ], PanelChangelogFeature.prototype, "_globalSettingsService");
  __decorateClass$w([
    inject(ModalService)
  ], PanelChangelogFeature.prototype, "_modalService");
  function get_each_context$g(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[9] = list[i];
    return child_ctx;
  }
  __name(get_each_context$g, "get_each_context$g");
  function get_each_context_1$6(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[9] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1$6, "get_each_context_1$6");
  function create_else_block$6(ctx) {
    let div;
    let t;
    let current;
    let each_value_1 = ensure_array_like(
      /*$lobbies*/
      ctx[1]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    let if_block = (
      /*$lobbies*/
      ctx[1].length === 0 && create_if_block_4$2()
    );
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t = space();
        if (if_block) if_block.c();
        attr(div, "class", "typo-lobbies-discord-buttons svelte-tkvjrc");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
        append(div, t);
        if (if_block) if_block.m(div, null);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*feature, $lobbies*/
        3) {
          each_value_1 = ensure_array_like(
            /*$lobbies*/
            ctx2[1]
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$6(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_1$6(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div, t);
            }
          }
          group_outros();
          for (i = each_value_1.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
        if (
          /*$lobbies*/
          ctx2[1].length === 0
        ) {
          if (if_block) ;
          else {
            if_block = create_if_block_4$2();
            if_block.c();
            if_block.m(div, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value_1.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_each(each_blocks, detaching);
        if (if_block) if_block.d();
      }
    };
  }
  __name(create_else_block$6, "create_else_block$6");
  function create_if_block_3$2(ctx) {
    let bounceload;
    let current;
    bounceload = new Bounceload({
      props: { content: "Loading connected servers.." }
    });
    return {
      c() {
        create_component(bounceload.$$.fragment);
      },
      m(target, anchor) {
        mount_component(bounceload, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(bounceload, detaching);
      }
    };
  }
  __name(create_if_block_3$2, "create_if_block_3$2");
  function create_if_block_2$4(ctx) {
    let span;
    return {
      c() {
        span = element("span");
        span.innerHTML = `You need to log in to see lobbies of your discord friends.<br/>`;
        attr(span, "class", "svelte-tkvjrc");
      },
      m(target, anchor) {
        insert(target, span, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  __name(create_if_block_2$4, "create_if_block_2$4");
  function create_each_block_1$6(ctx) {
    let div;
    let flatbutton;
    let feature_createTooltip_action;
    let current;
    let mounted;
    let dispose;
    function click_handler2() {
      return (
        /*click_handler*/
        ctx[7](
          /*lobby*/
          ctx[9]
        )
      );
    }
    __name(click_handler2, "click_handler");
    flatbutton = new Flat_button({
      props: {
        content: (
          /*lobby*/
          ctx[9].userName
        ),
        color: (
          /*lobby*/
          ctx[9].private ? "green" : "blue"
        )
      }
    });
    flatbutton.$on("click", click_handler2);
    return {
      c() {
        div = element("div");
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(flatbutton, div, null);
        current = true;
        if (!mounted) {
          dispose = action_destroyer(feature_createTooltip_action = /*feature*/
          ctx[0].createTooltip(div, {
            title: (
              /*feature*/
              ctx[0].buildButtonTooltip(
                /*lobby*/
                ctx[9]
              )
            ),
            lock: "Y"
          }));
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        const flatbutton_changes = {};
        if (dirty & /*$lobbies*/
        2) flatbutton_changes.content = /*lobby*/
        ctx[9].userName;
        if (dirty & /*$lobbies*/
        2) flatbutton_changes.color = /*lobby*/
        ctx[9].private ? "green" : "blue";
        flatbutton.$set(flatbutton_changes);
        if (feature_createTooltip_action && is_function(feature_createTooltip_action.update) && dirty & /*feature, $lobbies*/
        3) feature_createTooltip_action.update.call(null, {
          title: (
            /*feature*/
            ctx[0].buildButtonTooltip(
              /*lobby*/
              ctx[9]
            )
          ),
          lock: "Y"
        });
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(flatbutton);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block_1$6, "create_each_block_1$6");
  function create_if_block_4$2(ctx) {
    let span;
    return {
      c() {
        span = element("span");
        span.textContent = "None of your friends are online.";
        attr(span, "class", "svelte-tkvjrc");
      },
      m(target, anchor) {
        insert(target, span, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  __name(create_if_block_4$2, "create_if_block_4$2");
  function create_if_block$e(ctx) {
    let div1;
    let b;
    let t1;
    let t2;
    let div0;
    let if_block = (
      /*$discoveredLobbies*/
      ctx[3].length === 0 && create_if_block_1$6()
    );
    let each_value = ensure_array_like(
      /*$discoveredLobbies*/
      ctx[3]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    }
    return {
      c() {
        div1 = element("div");
        b = element("b");
        b.textContent = "Discovered Lobbies";
        t1 = space();
        if (if_block) if_block.c();
        t2 = space();
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(b, "class", "svelte-tkvjrc");
        attr(div0, "class", "typo-lobbies-discovered-buttons svelte-tkvjrc");
        attr(div1, "class", "typo-lobbies-discovered svelte-tkvjrc");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, b);
        append(div1, t1);
        if (if_block) if_block.m(div1, null);
        append(div1, t2);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
      },
      p(ctx2, dirty) {
        if (
          /*$discoveredLobbies*/
          ctx2[3].length === 0
        ) {
          if (if_block) ;
          else {
            if_block = create_if_block_1$6();
            if_block.c();
            if_block.m(div1, t2);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & /*$discoveredLobbies, feature, Date, Number*/
        9) {
          each_value = ensure_array_like(
            /*$discoveredLobbies*/
            ctx2[3]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$g(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$g(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div0, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if (if_block) if_block.d();
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_if_block$e, "create_if_block$e");
  function create_if_block_1$6(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        div.textContent = "Join a lobby to see it here afterwards.";
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_if_block_1$6, "create_if_block_1$6");
  function create_each_block$g(ctx) {
    let div;
    let b;
    let t0_value = new Date(Number(
      /*lobby*/
      ctx[9].seenAt
    )).toLocaleTimeString() + "";
    let t0;
    let t1;
    let span;
    let t2_value = (
      /*lobby*/
      ctx[9].players.map(func$3).join(", ") + ""
    );
    let t2;
    let t3;
    let mounted;
    let dispose;
    function click_handler_1() {
      return (
        /*click_handler_1*/
        ctx[8](
          /*lobby*/
          ctx[9]
        )
      );
    }
    __name(click_handler_1, "click_handler_1");
    return {
      c() {
        div = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = space();
        span = element("span");
        t2 = text(t2_value);
        t3 = space();
        attr(b, "class", "svelte-tkvjrc");
        attr(span, "class", "svelte-tkvjrc");
        set_style(
          div,
          "order",
          /*lobby*/
          ctx[9].seenAt % 1e8
        );
        attr(div, "class", "svelte-tkvjrc");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, b);
        append(b, t0);
        append(div, t1);
        append(div, span);
        append(span, t2);
        append(div, t3);
        if (!mounted) {
          dispose = listen(div, "click", click_handler_1);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*$discoveredLobbies*/
        8 && t0_value !== (t0_value = new Date(Number(
          /*lobby*/
          ctx[9].seenAt
        )).toLocaleTimeString() + "")) set_data(t0, t0_value);
        if (dirty & /*$discoveredLobbies*/
        8 && t2_value !== (t2_value = /*lobby*/
        ctx[9].players.map(func$3).join(", ") + "")) set_data(t2, t2_value);
        if (dirty & /*$discoveredLobbies*/
        8) {
          set_style(
            div,
            "order",
            /*lobby*/
            ctx[9].seenAt % 1e8
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block$g, "create_each_block$g");
  function create_fragment$x(ctx) {
    let div1;
    let div0;
    let b;
    let t1;
    let current_block_type_index;
    let if_block0;
    let t2;
    let current;
    const if_block_creators = [create_if_block_2$4, create_if_block_3$2, create_else_block$6];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*$lobbies*/
        ctx2[1] === null
      ) return 0;
      if (
        /*$lobbies*/
        ctx2[1] === void 0
      ) return 1;
      return 2;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    let if_block1 = (
      /*$showDiscovered*/
      ctx[2] && create_if_block$e(ctx)
    );
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        b = element("b");
        b.textContent = "Online Friends";
        t1 = space();
        if_block0.c();
        t2 = space();
        if (if_block1) if_block1.c();
        attr(b, "class", "svelte-tkvjrc");
        attr(div0, "class", "typo-lobbies-discord svelte-tkvjrc");
        attr(div1, "class", "svelte-tkvjrc");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div0, b);
        append(div0, t1);
        if_blocks[current_block_type_index].m(div0, null);
        append(div1, t2);
        if (if_block1) if_block1.m(div1, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
        if (
          /*$showDiscovered*/
          ctx2[2]
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
          } else {
            if_block1 = create_if_block$e(ctx2);
            if_block1.c();
            if_block1.m(div1, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block0);
        current = true;
      },
      o(local) {
        transition_out(if_block0);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if_blocks[current_block_type_index].d();
        if (if_block1) if_block1.d();
      }
    };
  }
  __name(create_fragment$x, "create_fragment$x");
  const func$3 = /* @__PURE__ */ __name((p) => p.name, "func$3");
  function instance$u($$self, $$props, $$invalidate) {
    let $lobbies;
    let $showDiscovered;
    let $discoveredLobbies;
    let { feature } = $$props;
    const lobbies = feature.lobbiesStore;
    component_subscribe($$self, lobbies, (value) => $$invalidate(1, $lobbies = value));
    const showDiscovered = feature.showDiscoveredLobbiesStore;
    component_subscribe($$self, showDiscovered, (value) => $$invalidate(2, $showDiscovered = value));
    const discoveredLobbies = feature.discoveredLobbiesStore;
    component_subscribe($$self, discoveredLobbies, (value) => $$invalidate(3, $discoveredLobbies = value));
    const click_handler2 = /* @__PURE__ */ __name((lobby) => feature.joinLobby(lobby.lobbyId, lobby.userName), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name((lobby) => feature.joinLobby(lobby.id ?? ""), "click_handler_1");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      $lobbies,
      $showDiscovered,
      $discoveredLobbies,
      lobbies,
      showDiscovered,
      discoveredLobbies,
      click_handler2,
      click_handler_1
    ];
  }
  __name(instance$u, "instance$u");
  const _Panel_lobbies = class _Panel_lobbies extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$u, create_fragment$x, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Panel_lobbies, "Panel_lobbies");
  let Panel_lobbies = _Panel_lobbies;
  var __defProp$v = Object.defineProperty;
  var __decorateClass$v = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$v(target, key2, result);
    return result;
  }, "__decorateClass$v");
  const _PanelLobbiesFeature = class _PanelLobbiesFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elements");
      __publicField(this, "_socketService");
      __publicField(this, "_memberService");
      __publicField(this, "_lobbyService");
      __publicField(this, "_toastService");
      __publicField(this, "_showDiscoveredLobbiesSetting", this.useSetting(
        new BooleanExtensionSetting("show_discovered", true, this).withName("Show discovered lobbies").withDescription("Shows a list of lobbies that you were in before")
      ));
      __publicField(this, "_lobbies$", new BehaviorSubject(void 0));
      __publicField(this, "_component");
      __publicField(this, "_connection");
      __publicField(this, "_memberSubscription");
      __publicField(this, "name", "Lobby List");
      __publicField(this, "description", "Displays online players from your connected discord servers on the start page");
      __publicField(this, "tags", [
        FeatureTag.SOCIAL,
        FeatureTag.PALANTIR
      ]);
      __publicField(this, "featureId", 6);
    }
    async onActivate() {
      const elements2 = await this._elements.complete();
      this._component = new Panel_lobbies({
        target: elements2.lobbiesTab,
        props: {
          feature: this
        }
      });
      this._memberSubscription = this._memberService.member$.subscribe((member) => this.processMemberChange(member));
    }
    onDestroy() {
      var _a2, _b2, _c2;
      (_a2 = this._component) == null ? void 0 : _a2.$destroy();
      (_b2 = this._connection) == null ? void 0 : _b2.stop();
      (_c2 = this._memberSubscription) == null ? void 0 : _c2.unsubscribe();
      this._memberSubscription = void 0;
    }
    get lobbiesStore() {
      return fromObservable(this._lobbies$.pipe(
        map((lobbies) => lobbies === null || lobbies === void 0 ? lobbies : this.mapLobbiesToPlayerList(lobbies)),
        tap((lobbies) => this._logger.info("Lobbies updated", lobbies))
      ), []);
    }
    get discoveredLobbiesStore() {
      return fromObservable(this._lobbyService.discoveredLobbies$, []);
    }
    get showDiscoveredLobbiesStore() {
      return this._showDiscoveredLobbiesSetting.store;
    }
    /**
     * Subscribe to guild lobbies of a member
     * @param member
     * @private
     */
    async processMemberChange(member) {
      var _a2;
      this._logger.debug("Member changed", member);
      (_a2 = this._connection) == null ? void 0 : _a2.stop();
      if (member === null || member === void 0) {
        this._lobbies$.next(member);
        return;
      }
      this._lobbies$.next(/* @__PURE__ */ new Map());
      const initConnection = /* @__PURE__ */ __name(async () => {
        const { connection: connection2, hubProxy } = await this.setupConnection();
        this._connection = connection2;
        await this.subscribeToLobbies(member, hubProxy);
        return connection2;
      }, "initConnection");
      const connection = await initConnection();
      this._socketService.reconnectOnUserInteraction(connection, () => initConnection());
    }
    /**
     * Connect to the guild lobby hub to receive updates
     * @private
     */
    async setupConnection() {
      const connection = this._socketService.createConnection("IGuildLobbiesHub");
      const hubProxy = this._socketService.createHub("IGuildLobbiesHub").createHubProxy(connection);
      this._socketService.createReceiver("IGuildLobbiesReceiver").register(connection, {
        guildLobbiesUpdated: this.onGuildLobbiesUpdated.bind(this)
      });
      await connection.start();
      return { connection, hubProxy };
    }
    async subscribeToLobbies(member, hub) {
      const promises = member.guilds.map(async (guild) => {
        const currentLobbies = await hub.subscribeGuildLobbies(guild.guildID);
        await this.onGuildLobbiesUpdated(currentLobbies);
      });
      await Promise.all(promises);
    }
    async onGuildLobbiesUpdated(lobbies) {
      this._logger.info("Received guild lobbies for guild", lobbies.guildId);
      const lastValue = this._lobbies$.value;
      if (lastValue === null || lastValue === void 0) {
        this._logger.warn("Received guild lobbies but lobbies are not initialized yet", lobbies);
        return;
      }
      lastValue.set(lobbies.guildId, lobbies.lobbies);
      this._lobbies$.next(lastValue);
    }
    mapLobbiesToPlayerList(lobbies) {
      const distinct = [];
      const list = Array.from(lobbies.values()).flat();
      list.forEach((lobby) => {
        if (!distinct.some((l) => l.lobbyId === lobby.lobbyId && l.userName === lobby.userName)) {
          distinct.push(lobby);
        }
      });
      return distinct;
    }
    buildButtonTooltip(lobby) {
      return `🔑  ${lobby.private ? "Custom" : "Public"}
👥 ${lobby.currentPlayers} Players
🏳️ ${lobby.language}`;
    }
    async joinLobby(id2, targetName) {
      const result = await this._lobbyService.joinLobby(id2);
      if (result) await this._toastService.showToast(targetName ? `Joined the lobby of ${targetName}` : "Joined discovered lobby");
      else await this._toastService.showToast(targetName ? `Failed to join the lobby of ${targetName}` : "Failed to join discovered lobby");
    }
  };
  __name(_PanelLobbiesFeature, "PanelLobbiesFeature");
  let PanelLobbiesFeature = _PanelLobbiesFeature;
  __decorateClass$v([
    inject(ElementsSetup)
  ], PanelLobbiesFeature.prototype, "_elements");
  __decorateClass$v([
    inject(SocketService)
  ], PanelLobbiesFeature.prototype, "_socketService");
  __decorateClass$v([
    inject(MemberService)
  ], PanelLobbiesFeature.prototype, "_memberService");
  __decorateClass$v([
    inject(LobbyService)
  ], PanelLobbiesFeature.prototype, "_lobbyService");
  __decorateClass$v([
    inject(ToastService)
  ], PanelLobbiesFeature.prototype, "_toastService");
  function get_each_context$f(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[2] = list[i];
    return child_ctx;
  }
  __name(get_each_context$f, "get_each_context$f");
  function create_else_block$5(ctx) {
    let each_1_anchor;
    let each_value = ensure_array_like(
      /*announcements*/
      ctx[0]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    }
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*announcements, Date, Number*/
        1) {
          each_value = ensure_array_like(
            /*announcements*/
            ctx2[0]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$f(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$f(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_else_block$5, "create_else_block$5");
  function create_if_block$d(ctx) {
    let bounceload;
    let current;
    bounceload = new Bounceload({ props: { content: "Loading news.." } });
    return {
      c() {
        create_component(bounceload.$$.fragment);
      },
      m(target, anchor) {
        mount_component(bounceload, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(bounceload, detaching);
      }
    };
  }
  __name(create_if_block$d, "create_if_block$d");
  function create_each_block$f(ctx) {
    let div1;
    let div0;
    let b;
    let t0_value = (
      /*announcement*/
      ctx[2].title + ""
    );
    let t0;
    let t1;
    let span;
    let t2_value = new Date(Number(
      /*announcement*/
      ctx[2].date
    )).toDateString() + "";
    let t2;
    let t3;
    let p;
    let t4_value = (
      /*announcement*/
      ctx[2].content + ""
    );
    let t4;
    let t5;
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = space();
        span = element("span");
        t2 = text(t2_value);
        t3 = space();
        p = element("p");
        t4 = text(t4_value);
        t5 = space();
        attr(span, "class", "svelte-1x3jcfi");
        attr(div0, "class", "title svelte-1x3jcfi");
        attr(div1, "class", "announcement svelte-1x3jcfi");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div0, b);
        append(b, t0);
        append(div0, t1);
        append(div0, span);
        append(span, t2);
        append(div1, t3);
        append(div1, p);
        append(p, t4);
        append(div1, t5);
      },
      p(ctx2, dirty) {
        if (dirty & /*announcements*/
        1 && t0_value !== (t0_value = /*announcement*/
        ctx2[2].title + "")) set_data(t0, t0_value);
        if (dirty & /*announcements*/
        1 && t2_value !== (t2_value = new Date(Number(
          /*announcement*/
          ctx2[2].date
        )).toDateString() + "")) set_data(t2, t2_value);
        if (dirty & /*announcements*/
        1 && t4_value !== (t4_value = /*announcement*/
        ctx2[2].content + "")) set_data(t4, t4_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
      }
    };
  }
  __name(create_each_block$f, "create_each_block$f");
  function create_fragment$w(ctx) {
    let div1;
    let div0;
    let current_block_type_index;
    let if_block;
    let current;
    const if_block_creators = [create_if_block$d, create_else_block$5];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*announcements*/
        ctx2[0] === void 0
      ) return 0;
      return 1;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        if_block.c();
        attr(div0, "class", "news svelte-1x3jcfi");
        attr(div1, "class", "typo-news svelte-1x3jcfi");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        if_blocks[current_block_type_index].m(div0, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if_blocks[current_block_type_index].d();
      }
    };
  }
  __name(create_fragment$w, "create_fragment$w");
  function instance$t($$self, $$props, $$invalidate) {
    let { feature } = $$props;
    let { announcements = void 0 } = $$props;
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(1, feature = $$props2.feature);
      if ("announcements" in $$props2) $$invalidate(0, announcements = $$props2.announcements);
    };
    return [announcements, feature];
  }
  __name(instance$t, "instance$t");
  const _Panel_news = class _Panel_news extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$t, create_fragment$w, safe_not_equal, { feature: 1, announcements: 0 });
    }
  };
  __name(_Panel_news, "Panel_news");
  let Panel_news = _Panel_news;
  var __defProp$u = Object.defineProperty;
  var __decorateClass$u = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$u(target, key2, result);
    return result;
  }, "__decorateClass$u");
  const _PanelNewsFeature = class _PanelNewsFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elements");
      __publicField(this, "_apiDataSetup");
      __publicField(this, "_component");
      __publicField(this, "name", "Typo News");
      __publicField(this, "description", "Displays updates and typo hints on the start page");
      __publicField(this, "tags", [
        FeatureTag.INFORMATION
      ]);
      __publicField(this, "featureId", 7);
    }
    async onActivate() {
      const elements2 = await this._elements.complete();
      this._component = new Panel_news({
        target: elements2.newsTab,
        props: {
          feature: this
        }
      });
      const data = await this._apiDataSetup.complete();
      const version = typoRuntime.getReleaseDetails().versionName;
      const announcements = data.announcements.filter(
        (announcement) => announcement.type === AnnouncementDtoTypeEnum.Announcement && (announcement.affectedTypoVersion === version || announcement.affectedTypoVersion === void 0)
      ).sort((a, b) => Number(b.date) - Number(a.date));
      this._component.$set({ announcements });
    }
    onDestroy() {
      var _a2;
      (_a2 = this._component) == null ? void 0 : _a2.$destroy();
    }
  };
  __name(_PanelNewsFeature, "PanelNewsFeature");
  let PanelNewsFeature = _PanelNewsFeature;
  __decorateClass$u([
    inject(ElementsSetup)
  ], PanelNewsFeature.prototype, "_elements");
  __decorateClass$u([
    inject(ApiDataSetup)
  ], PanelNewsFeature.prototype, "_apiDataSetup");
  var __defProp$t = Object.defineProperty;
  var __decorateClass$t = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$t(target, key2, result);
    return result;
  }, "__decorateClass$t");
  const _PlayerIdsFeature = class _PlayerIdsFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_playersService");
      __publicField(this, "name", "Player IDs");
      __publicField(this, "description", "Show player IDs in the lobby to execute commands like kick");
      __publicField(this, "tags", [
        FeatureTag.INFORMATION,
        FeatureTag.GAMEPLAY
      ]);
      __publicField(this, "featureId", 29);
      __publicField(this, "_revealIdsHotkey", this.useHotkey(
        new HotkeyAction(
          "reveal_id",
          "Reveal IDs",
          "Reveal the lobby player ID of all players",
          this,
          () => this.setRevealState(true),
          true,
          ["AltLeft"],
          () => this.setRevealState(false),
          false
        )
      ));
    }
    setRevealState(state) {
      this._playersService.players$.pipe(
        take(1)
      ).subscribe((players) => {
        for (const player of players) {
          player.viewPlayerId = state;
        }
      });
    }
    onDestroy() {
      this.setRevealState(false);
    }
  };
  __name(_PlayerIdsFeature, "PlayerIdsFeature");
  let PlayerIdsFeature = _PlayerIdsFeature;
  __decorateClass$t([
    inject(PlayersService)
  ], PlayerIdsFeature.prototype, "_playersService");
  function create_fragment$v(ctx) {
    let div1;
    let div0;
    let t0;
    let span;
    let t1;
    let div1_class_value;
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        t0 = space();
        span = element("span");
        t1 = text(
          /*title*/
          ctx[0]
        );
        attr(div0, "class", "typo-tooltip-arrow svelte-ffctjy");
        attr(span, "class", "svelte-ffctjy");
        attr(div1, "class", div1_class_value = "typo-tooltip " + /*direction*/
        ctx[1] + " svelte-ffctjy");
        set_style(
          div1,
          "top",
          /*anchorY*/
          ctx[3] + "px"
        );
        set_style(
          div1,
          "left",
          /*anchorX*/
          ctx[2] + "px"
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div1, t0);
        append(div1, span);
        append(span, t1);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*title*/
        1) set_data(
          t1,
          /*title*/
          ctx2[0]
        );
        if (dirty & /*direction*/
        2 && div1_class_value !== (div1_class_value = "typo-tooltip " + /*direction*/
        ctx2[1] + " svelte-ffctjy")) {
          attr(div1, "class", div1_class_value);
        }
        if (dirty & /*anchorY*/
        8) {
          set_style(
            div1,
            "top",
            /*anchorY*/
            ctx2[3] + "px"
          );
        }
        if (dirty & /*anchorX*/
        4) {
          set_style(
            div1,
            "left",
            /*anchorX*/
            ctx2[2] + "px"
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
      }
    };
  }
  __name(create_fragment$v, "create_fragment$v");
  function instance$s($$self, $$props, $$invalidate) {
    let { title } = $$props;
    let { direction } = $$props;
    let { anchorX } = $$props;
    let { anchorY } = $$props;
    $$self.$$set = ($$props2) => {
      if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
      if ("direction" in $$props2) $$invalidate(1, direction = $$props2.direction);
      if ("anchorX" in $$props2) $$invalidate(2, anchorX = $$props2.anchorX);
      if ("anchorY" in $$props2) $$invalidate(3, anchorY = $$props2.anchorY);
    };
    return [title, direction, anchorX, anchorY];
  }
  __name(instance$s, "instance$s");
  const _Tooltip = class _Tooltip extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$s, create_fragment$v, safe_not_equal, {
        title: 0,
        direction: 1,
        anchorX: 2,
        anchorY: 3
      });
    }
  };
  __name(_Tooltip, "Tooltip");
  let Tooltip = _Tooltip;
  const _TooltipsFeature = class _TooltipsFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "name", "Tooltips");
      __publicField(this, "description", "Show helpful information when hovering over icons and buttons");
      __publicField(this, "tags", [
        FeatureTag.INTERFACE
      ]);
      __publicField(this, "featureId", 35);
      __publicField(this, "_pointeroverListener", this.handlePointerover.bind(this));
      __publicField(this, "_currentTarget", new BehaviorSubject(null));
      __publicField(this, "_targetSubscription");
      __publicField(this, "_activeTooltips", /* @__PURE__ */ new Map());
    }
    async onActivate() {
      this._targetSubscription = this._currentTarget.pipe(
        combineLatestWith(this._tooltipsService.tooltips$)
      ).subscribe(([target, tooltips]) => {
        this.handleTooltipChange(target, tooltips);
      });
      document.addEventListener("pointerover", this._pointeroverListener);
    }
    async onDestroy() {
      var _a2;
      (_a2 = this._targetSubscription) == null ? void 0 : _a2.unsubscribe();
      this._targetSubscription = void 0;
      document.removeEventListener("pointerover", this._pointeroverListener);
      this._activeTooltips.forEach((t) => t.tooltip.remove());
      this._activeTooltips.clear();
    }
    /**
     * handle a DOM pointerover event and refresh the current target
     * @param event
     * @private
     */
    handlePointerover(event) {
      this._logger.debug("Pointerover", event.target);
      const target = event.target;
      if (target instanceof HTMLElement) {
        const targets = this._tooltipsService.getTooltipsUntilElement(target);
        if (targets.length >= 1) {
          const target2 = targets[0];
          if (target2 !== this._currentTarget.value) {
            this._logger.info("Found new target", targets);
            this._currentTarget.next(target2);
          }
        } else if (this._currentTarget.value !== null) {
          this._logger.info("Removed tooltip target", targets);
          this._currentTarget.next(null);
        }
      } else this._currentTarget.next(null);
    }
    /**
     * Refresh the currently displayed tooltips, after the target or registered tooltips changed
     * @param target
     * @param tooltips
     * @private
     */
    handleTooltipChange(target, tooltips) {
      this._logger.info("Tooltip change", target, tooltips);
      this._activeTooltips.forEach((t) => {
        if (t.registration.target !== target) {
          this._activeTooltips.delete(t.registration.target);
          t.tooltip.$destroy();
        }
      });
      if (target !== null && !this._activeTooltips.has(target)) {
        const registration = tooltips.find((t) => t.target === target);
        if (!registration) return;
        const tooltip = this.buildTooltip(registration);
        this._activeTooltips.set(target, { registration, tooltip });
      }
    }
    /**
     * Build a tooltip element and attach it to the DOM
     * @param tooltip
     * @private
     */
    buildTooltip(tooltip) {
      const coordinates = this.getVisibleDimensionsAndCoordinates(tooltip.target);
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const spaceTop = coordinates.top;
      const spaceBottom = viewportHeight - coordinates.top - coordinates.height;
      const spaceLeft = coordinates.left;
      const spaceRight = viewportWidth - coordinates.left - coordinates.width;
      let direction = tooltip.lock !== "Y" ? "E" : "N";
      let anchorX = tooltip.lock !== "Y" ? coordinates.left + coordinates.width : coordinates.left + coordinates.width / 2;
      let anchorY = tooltip.lock !== "Y" ? coordinates.top + coordinates.height / 2 : coordinates.top;
      if (tooltip.lock !== "X" && spaceTop > spaceBottom && (spaceTop > spaceLeft && spaceTop > spaceRight || tooltip.lock === "Y")) {
        direction = "N";
        anchorX = coordinates.left + coordinates.width / 2;
        anchorY = coordinates.top;
      } else if (tooltip.lock !== "X" && spaceBottom > spaceTop && (spaceBottom > spaceLeft && spaceBottom > spaceRight || tooltip.lock === "Y")) {
        direction = "S";
        anchorX = coordinates.left + coordinates.width / 2;
        anchorY = coordinates.top + coordinates.height;
      } else if (tooltip.lock !== "Y" && spaceLeft > spaceRight) {
        direction = "W";
        anchorX = coordinates.left;
        anchorY = coordinates.top + coordinates.height / 2;
      }
      const element2 = new Tooltip({
        target: document.body,
        props: {
          title: tooltip.title,
          anchorX,
          anchorY,
          direction
        }
      });
      return element2;
    }
    /**
     * Get the visible dimensions and coordinates of an element, considering overflow
     * Caution: Chatgpt
     * Prompt:
     * write me a ts function that gets the dimensions and coordinates of the visible area of an element.
     * consider that elements can be scrollable (higher than visible), may not be the element that produces the overflow (clientHeight/Width does not directly work), and that there may be multiple ensted scrollable containers.
     * if there is anything else that should be considered, do so.
     * @param element
     */
    getVisibleDimensionsAndCoordinates(element2) {
      const elementRect = element2.getBoundingClientRect();
      const visibleRect = {
        top: elementRect.top,
        left: elementRect.left,
        width: elementRect.width,
        height: elementRect.height
      };
      let currentElement = element2;
      while (currentElement !== null) {
        const parent = currentElement.parentElement;
        if (parent) {
          const parentRect = parent.getBoundingClientRect();
          const parentStyle = getComputedStyle(parent);
          if (parentStyle.overflow !== "visible") {
            visibleRect.top = Math.max(visibleRect.top, parentRect.top);
            visibleRect.left = Math.max(visibleRect.left, parentRect.left);
            visibleRect.width = Math.min(
              visibleRect.width,
              parentRect.right - visibleRect.left
            );
            visibleRect.height = Math.min(
              visibleRect.height,
              parentRect.bottom - visibleRect.top
            );
          }
        }
        currentElement = parent;
      }
      visibleRect.width = Math.min(visibleRect.width, window.innerWidth - visibleRect.left);
      visibleRect.height = Math.min(visibleRect.height, window.innerHeight - visibleRect.top);
      visibleRect.top = Math.max(visibleRect.top, 0);
      visibleRect.left = Math.max(visibleRect.left, 0);
      return {
        width: Math.max(0, visibleRect.width),
        height: Math.max(0, visibleRect.height),
        top: visibleRect.top,
        left: visibleRect.left
      };
    }
  };
  __name(_TooltipsFeature, "TooltipsFeature");
  let TooltipsFeature = _TooltipsFeature;
  function create_else_block$4(ctx) {
    let div0;
    let a0;
    let img;
    let img_src_value;
    let t0;
    let t1_value = (
      /*$member*/
      ctx[1].userName + ""
    );
    let t1;
    let t2;
    let a1;
    let t4;
    let span0;
    let t6;
    let div5;
    let div2;
    let div1;
    let span1;
    let span2;
    let t8_value = (
      /*$member*/
      ctx[1].bubbles + ""
    );
    let t8;
    let t9;
    let div4;
    let div3;
    let span3;
    let span4;
    let t11_value = Math.round(
      /*$member*/
      ctx[1].drops * 10
    ) / 10 + "";
    let t11;
    let t12;
    let if_block_anchor;
    let mounted;
    let dispose;
    let if_block = (
      /*$devmode*/
      ctx[2] && create_if_block_2$3(ctx)
    );
    return {
      c() {
        div0 = element("div");
        a0 = element("a");
        img = element("img");
        t0 = space();
        t1 = text(t1_value);
        t2 = space();
        a1 = element("a");
        a1.textContent = "Manage";
        t4 = space();
        span0 = element("span");
        span0.textContent = "Logout";
        t6 = space();
        div5 = element("div");
        div2 = element("div");
        div1 = element("div");
        span1 = element("span");
        span1.textContent = "Bubbles:";
        span2 = element("span");
        t8 = text(t8_value);
        t9 = space();
        div4 = element("div");
        div3 = element("div");
        span3 = element("span");
        span3.textContent = "Drops:";
        span4 = element("span");
        t11 = text(t11_value);
        t12 = space();
        if (if_block) if_block.c();
        if_block_anchor = empty();
        attr(img, "class", "typo-icon svelte-j680fu");
        attr(img, "alt", "typo icon");
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        attr(a0, "href", "https://www.typo.rip");
        attr(a0, "class", "svelte-j680fu");
        attr(a1, "href", "https://www.typo.rip/user");
        attr(a1, "class", "svelte-j680fu");
        attr(span0, "role", "button");
        attr(span0, "tabindex", "0");
        attr(span0, "class", "svelte-j680fu");
        attr(div0, "class", "member-info-header svelte-j680fu");
        attr(div1, "class", "stat-icon svelte-j680fu");
        set_style(div1, "content", "var(--file-img-palantir-gif)");
        attr(span1, "class", "svelte-j680fu");
        attr(span2, "class", "svelte-j680fu");
        attr(div2, "class", "svelte-j680fu");
        attr(div3, "class", "stat-icon svelte-j680fu");
        set_style(div3, "content", "var(--file-img-drop-gif)");
        attr(span3, "class", "svelte-j680fu");
        attr(span4, "class", "svelte-j680fu");
        attr(div4, "class", "svelte-j680fu");
        attr(div5, "class", "member-info-stats svelte-j680fu");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        append(div0, a0);
        append(a0, img);
        append(a0, t0);
        append(a0, t1);
        append(div0, t2);
        append(div0, a1);
        append(div0, t4);
        append(div0, span0);
        insert(target, t6, anchor);
        insert(target, div5, anchor);
        append(div5, div2);
        append(div2, div1);
        append(div2, span1);
        append(div2, span2);
        append(span2, t8);
        append(div5, t9);
        append(div5, div4);
        append(div4, div3);
        append(div4, span3);
        append(div4, span4);
        append(span4, t11);
        insert(target, t12, anchor);
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
        if (!mounted) {
          dispose = [
            listen(
              span0,
              "keydown",
              /*keydown_handler_1*/
              ctx[7]
            ),
            listen(
              span0,
              "click",
              /*click_handler_1*/
              ctx[8]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*$member*/
        2 && t1_value !== (t1_value = /*$member*/
        ctx2[1].userName + "")) set_data(t1, t1_value);
        if (dirty & /*$member*/
        2 && t8_value !== (t8_value = /*$member*/
        ctx2[1].bubbles + "")) set_data(t8, t8_value);
        if (dirty & /*$member*/
        2 && t11_value !== (t11_value = Math.round(
          /*$member*/
          ctx2[1].drops * 10
        ) / 10 + "")) set_data(t11, t11_value);
        if (
          /*$devmode*/
          ctx2[2]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block_2$3(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t6);
          detach(div5);
          detach(t12);
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_else_block$4, "create_else_block$4");
  function create_if_block_1$5(ctx) {
    let div;
    let bounceload;
    let current;
    bounceload = new Bounceload({ props: { content: "Loading..." } });
    return {
      c() {
        div = element("div");
        create_component(bounceload.$$.fragment);
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(bounceload, div, null);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(bounceload);
      }
    };
  }
  __name(create_if_block_1$5, "create_if_block_1$5");
  function create_if_block$c(ctx) {
    let div;
    let img;
    let img_src_value;
    let t0;
    let span;
    let mounted;
    let dispose;
    return {
      c() {
        div = element("div");
        img = element("img");
        t0 = space();
        span = element("span");
        span.textContent = "Log in with typo to collect bubbles and upgrade your avatar.";
        attr(img, "class", "typo-icon svelte-j680fu");
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        attr(img, "alt", "typo icon");
        attr(span, "role", "button");
        attr(span, "tabindex", "0");
        attr(div, "class", "member-login svelte-j680fu");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, img);
        append(div, t0);
        append(div, span);
        if (!mounted) {
          dispose = [
            listen(
              span,
              "keydown",
              /*keydown_handler*/
              ctx[5]
            ),
            listen(
              span,
              "click",
              /*click_handler*/
              ctx[6]
            )
          ];
          mounted = true;
        }
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_if_block$c, "create_if_block$c");
  function create_if_block_2$3(ctx) {
    let div1;
    let div0;
    let span0;
    let span1;
    let span2;
    let t1_value = (
      /*$member*/
      ctx[1].userLogin + ""
    );
    let t1;
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        span0 = element("span");
        span1 = element("span");
        span1.textContent = "Typo ID:";
        span2 = element("span");
        t1 = text(t1_value);
        attr(span0, "class", "svelte-j680fu");
        attr(span1, "class", "svelte-j680fu");
        attr(span2, "class", "svelte-j680fu");
        attr(div0, "class", "svelte-j680fu");
        attr(div1, "class", "member-info-stats svelte-j680fu");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div0, span0);
        append(div0, span1);
        append(div0, span2);
        append(span2, t1);
      },
      p(ctx2, dirty) {
        if (dirty & /*$member*/
        2 && t1_value !== (t1_value = /*$member*/
        ctx2[1].userLogin + "")) set_data(t1, t1_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
      }
    };
  }
  __name(create_if_block_2$3, "create_if_block_2$3");
  function create_fragment$u(ctx) {
    let div;
    let current_block_type_index;
    let if_block;
    let current;
    const if_block_creators = [create_if_block$c, create_if_block_1$5, create_else_block$4];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*$member*/
        ctx2[1] === null
      ) return 0;
      if (
        /*$member*/
        ctx2[1] === void 0
      ) return 1;
      return 2;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div = element("div");
        if_block.c();
        attr(div, "class", "member-info panel svelte-j680fu");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_blocks[current_block_type_index].m(div, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if_blocks[current_block_type_index].d();
      }
    };
  }
  __name(create_fragment$u, "create_fragment$u");
  function instance$r($$self, $$props, $$invalidate) {
    let $member;
    let $devmode;
    let { feature } = $$props;
    const member = feature.memberStore;
    component_subscribe($$self, member, (value) => $$invalidate(1, $member = value));
    const devmode = feature.devmodeStore;
    component_subscribe($$self, devmode, (value) => $$invalidate(2, $devmode = value));
    const keydown_handler2 = /* @__PURE__ */ __name(() => feature.login(), "keydown_handler");
    const click_handler2 = /* @__PURE__ */ __name(() => feature.login(), "click_handler");
    const keydown_handler_1 = /* @__PURE__ */ __name(() => feature.logout(), "keydown_handler_1");
    const click_handler_1 = /* @__PURE__ */ __name(() => feature.logout(), "click_handler_1");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      $member,
      $devmode,
      member,
      devmode,
      keydown_handler2,
      click_handler2,
      keydown_handler_1,
      click_handler_1
    ];
  }
  __name(instance$r, "instance$r");
  const _User_info = class _User_info extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$r, create_fragment$u, safe_not_equal, { feature: 0 });
    }
  };
  __name(_User_info, "User_info");
  let User_info = _User_info;
  var __defProp$s = Object.defineProperty;
  var __decorateClass$s = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$s(target, key2, result);
    return result;
  }, "__decorateClass$s");
  const _UserInfoFeature = class _UserInfoFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_memberService");
      __publicField(this, "_globalSettingsService");
      __publicField(this, "_element");
      __publicField(this, "name", "User Info");
      __publicField(this, "description", "Shows information about the logged-in user beneath the avatar selection");
      __publicField(this, "tags", [
        FeatureTag.INFORMATION,
        FeatureTag.PALANTIR
      ]);
      __publicField(this, "featureId", 13);
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._element = new User_info({
        target: elements2.avatarPanel,
        anchor: elements2.playButton,
        props: {
          feature: this
        }
      });
    }
    onDestroy() {
      var _a2;
      (_a2 = this._element) == null ? void 0 : _a2.$destroy();
    }
    get memberStore() {
      return fromObservable(this._memberService.member$, null);
    }
    get devmodeStore() {
      return this._globalSettingsService.settings.devMode.store;
    }
    login() {
      this._memberService.login();
    }
    logout() {
      this._memberService.logout();
    }
  };
  __name(_UserInfoFeature, "UserInfoFeature");
  let UserInfoFeature = _UserInfoFeature;
  __decorateClass$s([
    inject(ElementsSetup)
  ], UserInfoFeature.prototype, "_elementsSetup");
  __decorateClass$s([
    inject(MemberService)
  ], UserInfoFeature.prototype, "_memberService");
  __decorateClass$s([
    inject(GlobalSettingsService)
  ], UserInfoFeature.prototype, "_globalSettingsService");
  function create_fragment$t(ctx) {
    let img;
    let img_src_value;
    return {
      c() {
        img = element("img");
        attr(img, "class", "typo-onboarding-emote svelte-1593rkb");
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        set_style(
          img,
          "top",
          /*y*/
          ctx[1] + "px"
        );
        set_style(
          img,
          "left",
          /*x*/
          ctx[0] + "px"
        );
        set_style(img, "content", "var(--" + /*src*/
        ctx[2] + ")");
      },
      m(target, anchor) {
        insert(target, img, anchor);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*y*/
        2) {
          set_style(
            img,
            "top",
            /*y*/
            ctx2[1] + "px"
          );
        }
        if (dirty & /*x*/
        1) {
          set_style(
            img,
            "left",
            /*x*/
            ctx2[0] + "px"
          );
        }
        if (dirty & /*src*/
        4) {
          set_style(img, "content", "var(--" + /*src*/
          ctx2[2] + ")");
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(img);
        }
      }
    };
  }
  __name(create_fragment$t, "create_fragment$t");
  function instance$q($$self, $$props, $$invalidate) {
    let { x } = $$props;
    let { y } = $$props;
    let { src } = $$props;
    const hasEnoughDistance = /* @__PURE__ */ __name((x1, y1) => {
      const center = [x + 15, y + 15];
      const center1 = [x1 + 15, y1 + 15];
      const distance = Math.sqrt((center[0] - center1[0]) ** 2 + (center[1] - center1[1]) ** 2);
      return distance > 60;
    }, "hasEnoughDistance");
    $$self.$$set = ($$props2) => {
      if ("x" in $$props2) $$invalidate(0, x = $$props2.x);
      if ("y" in $$props2) $$invalidate(1, y = $$props2.y);
      if ("src" in $$props2) $$invalidate(2, src = $$props2.src);
    };
    return [x, y, src, hasEnoughDistance];
  }
  __name(instance$q, "instance$q");
  const _Controls_onboarding_emoji = class _Controls_onboarding_emoji extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$q, create_fragment$t, safe_not_equal, { x: 0, y: 1, src: 2, hasEnoughDistance: 3 });
    }
    get hasEnoughDistance() {
      return this.$$.ctx[3];
    }
  };
  __name(_Controls_onboarding_emoji, "Controls_onboarding_emoji");
  let Controls_onboarding_emoji = _Controls_onboarding_emoji;
  function create_fragment$s(ctx) {
    let h3;
    let t1;
    let div;
    return {
      c() {
        h3 = element("h3");
        h3.textContent = "Introducing the new Typo";
        t1 = space();
        div = element("div");
        div.innerHTML = `<p class="svelte-115f3km">Starting in April 2025, Typo is receiving its biggest update so far.<br class="svelte-115f3km"/>
    Typo still has the same features, but makes them much more user-friendly, accessible and customizable.<br class="svelte-115f3km"/>
    So far, Typo provided the tools, but now it&#39;s the whole workshop!</p> <h4 class="svelte-115f3km">A quick-start guide</h4> <p class="svelte-115f3km">All Typo features can now be customized, so you don&#39;t have anything that messes with your optimal skribbl experience.<br class="svelte-115f3km"/>
    To set up Typo to your preferences, click the wrench icon at the top left (unless customized to somewhere else ;).<br class="svelte-115f3km"/>
    There, you can:</p> <ul class="svelte-115f3km"><li class="svelte-115f3km">Enable or disable every feature</li> <li class="svelte-115f3km">Adjust feature settings to your likes</li> <li class="svelte-115f3km">Change and toggle hotkeys and chat commands of features</li> <li class="svelte-115f3km">View some extra info &amp; hints about features</li></ul> <p class="svelte-115f3km">To get started, you can browse through the list of features and view their details.<br class="svelte-115f3km"/>
    Features are also categorized by tags so you can easily find what you are looking for.<br class="svelte-115f3km"/>
    While you might see many features that you already know of, you could discover some that were newly added or features that you didn&#39;t notice yet!<br class="svelte-115f3km"/>
    To change general Typo settings, choose the &quot;Typo Settings&quot; feature in the Typo Features view.<br class="svelte-115f3km"/>
    You can reset all data or switch between profiles in the &quot;Typo Profiles&quot; feature.<br class="svelte-115f3km"/>
    If you have any questions or feedback, join the community on <a href="https://discord.com/invite/pAapmUmWAM" class="svelte-115f3km">Discord</a>!</p> <br/> <h4 class="svelte-115f3km">The most important changes</h4> <p class="svelte-115f3km"><b class="svelte-115f3km">➜ Typo Settings</b><br class="svelte-115f3km"/>
    Typo settings are now located directly on skribbl (read the quick-start-guide ;) instead of the extension popup menu.<br class="svelte-115f3km"/>
    You can customize everything that you&#39;re used to from the popup menu, now found in the respective feature dialog.<br class="svelte-115f3km"/></p> <p class="svelte-115f3km"><b class="svelte-115f3km">➜ Typo Pen Pressure</b><br class="svelte-115f3km"/>
    Typo pressure has now an improved adjustment system which allows more precise control.<br class="svelte-115f3km"/>
    You will notice that your previous setting has been reset.<br class="svelte-115f3km"/>
    To adjust the sensitivity, go to the &quot;Typo Settings&quot;, choose the &quot;Pressure&quot; feature, and adjust the sliders to your liking.<br class="svelte-115f3km"/></p> <p class="svelte-115f3km"><b class="svelte-115f3km">➜ Lobby Privacy</b><br class="svelte-115f3km"/>
    Instead of the lock icon at the very left side, a connection icon is displayed at the top-right corner of the chat.<br class="svelte-115f3km"/>
    An icon with a checkmark means that the lobby has privacy settings active (not visible to everyone).<br class="svelte-115f3km"/>
    If you&#39;re the lobby owner (first Typo player to join), you can change lobby settings there.<br class="svelte-115f3km"/></p> <p class="svelte-115f3km"><b class="svelte-115f3km">➜ Filter Search</b><br class="svelte-115f3km"/>
    To start a lobby search with filters, you need to use the &quot;Start Search&quot; button in the &quot;Filters&quot; tab on the home screen.<br class="svelte-115f3km"/>
    Clicking &quot;Play&quot; will always just join the next public/private lobby.<br class="svelte-115f3km"/></p> <p class="svelte-115f3km"><b class="svelte-115f3km">➜ Chat Commands</b><br class="svelte-115f3km"/>
    Chat commands received a massive facelift!<br class="svelte-115f3km"/>
    To start using commands, type a &quot;/&quot; in the chat box. <br class="svelte-115f3km"/>
    A popout with available commands will open; you can continue typing the command and arguments and submit the command with &quot;Enter&quot;.<br class="svelte-115f3km"/>
    You can also customize the &quot;/&quot; prefix to another character in the settings of the &quot;Chat Commands&quot; feature.<br class="svelte-115f3km"/></p> <p class="svelte-115f3km"><b class="svelte-115f3km">➜ QuickReact and Hotkeys</b><br class="svelte-115f3km"/>
    Hotkeys are now individually customizable for every feature and have changed here and there.<br class="svelte-115f3km"/>
    As an example, QuickReact now uses the right-hand side Ctrl key, exclusively.<br class="svelte-115f3km"/>
    To change hotkeys for any feature or check the current configuration, open its feature settings.<br class="svelte-115f3km"/>
    Hotkeys can also consist of combinations.<br class="svelte-115f3km"/></p> <p class="svelte-115f3km"><b class="svelte-115f3km">➜ Zoom Drawing</b><br class="svelte-115f3km"/>
    Zooming still uses the Ctrl hotkey, but now starts immediately at the last cursor position without clicking on the canvas.<br class="svelte-115f3km"/>
    To exit zoom, click Ctrl again.<br class="svelte-115f3km"/></p> <p class="svelte-115f3km"><b class="svelte-115f3km">➜ Custom Colors</b><br class="svelte-115f3km"/>
    When you use custom colors in public lobbies, Typo will now show the closest skribbl color for non-Typo users.<br class="svelte-115f3km"/>
    It is still recommended that you use custom colors only in lobbies with Typo players, because fill behavior might appear differently for non-Typo-users.<br class="svelte-115f3km"/></p> <p class="svelte-115f3km"><b class="svelte-115f3km">➜ Practice Lobby</b><br class="svelte-115f3km"/>
    Instead of clicking your avatar on the home screen, you can enter the offline free draw mode using the palette icon next to your avatar.<br class="svelte-115f3km"/></p> <p class="svelte-115f3km"><b class="svelte-115f3km">➜ Drop Catch Reports</b><br class="svelte-115f3km"/>
    When someone catches drops suspiciously fast, you could report the catch by revealing the drop ID in the drop message.<br class="svelte-115f3km"/>
    To report drops in the new Typo, open the &quot;Drops&quot; feature in the Typo setting, where you will find a log of all drop catches.<br class="svelte-115f3km"/>
    To report a drop, you can copy its ID and the catch time and send it on the Typo discord server.<br class="svelte-115f3km"/></p>`;
        attr(h3, "class", "svelte-115f3km");
      },
      m(target, anchor) {
        insert(target, h3, anchor);
        insert(target, t1, anchor);
        insert(target, div, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(h3);
          detach(t1);
          detach(div);
        }
      }
    };
  }
  __name(create_fragment$s, "create_fragment$s");
  const _Old_typo_onboarding = class _Old_typo_onboarding extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment$s, safe_not_equal, {});
    }
  };
  __name(_Old_typo_onboarding, "Old_typo_onboarding");
  let Old_typo_onboarding = _Old_typo_onboarding;
  function create_fragment$r(ctx) {
    let h3;
    let t1;
    let div;
    return {
      c() {
        h3 = element("h3");
        h3.textContent = "Credits & Imprint";
        t1 = space();
        div = element("div");
        div.innerHTML = `<p class="svelte-1d2n9p6">Glad to see you using Typo!<br/><br/>
    This extension grew with me and my coding skills over the years from a small script to a complex project.<br/>
    The awesome skribbl.io community (&amp; game ;) was my main drive to keep improving adding more and more features.<br/>
    Thanks so much to every user, beta tester and developer for making this passion of mine more than a hobby.<br/></p> <h4 class="svelte-1d2n9p6">Helpful links</h4> <ul class="svelte-1d2n9p6"><li><a href="https://typo.rip" class="svelte-1d2n9p6">typo.rip</a> - The official website with a bunch of tools and infos</li> <li><a href="https://discord.com/invite/pAapmUmWAM" class="svelte-1d2n9p6">Discord</a> - Join the community, talk about Typo &amp; skribbl or ask for feature support</li> <li><a href="https://www.patreon.com/skribbltypo" class="svelte-1d2n9p6">Patreon</a> - Feed the developer 💖</li> <li><a href="https://github.com/toobeeh/skribbltypo" class="svelte-1d2n9p6">GitHub</a> - Contribute to the project, view the sourcecode or report issues &amp; improvements</li></ul> <h4 class="svelte-1d2n9p6">Legal stuff &amp; rules</h4> <ul class="svelte-1d2n9p6"><li><a href="https://typo.rip/privacy" class="svelte-1d2n9p6">Privacy Policy</a> - How Typo handles your data</li> <li><a href="https://typo.rip/help/rules" class="svelte-1d2n9p6">Rules &amp; Fair Play</a> - How to behave using Typo</li> <li>I prefer to stay anonymous though :] - enjoy, tobeh</li></ul>`;
        attr(h3, "class", "svelte-1d2n9p6");
      },
      m(target, anchor) {
        insert(target, h3, anchor);
        insert(target, t1, anchor);
        insert(target, div, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(h3);
          detach(t1);
          detach(div);
        }
      }
    };
  }
  __name(create_fragment$r, "create_fragment$r");
  const _Typo_credits_onboarding = class _Typo_credits_onboarding extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment$r, safe_not_equal, {});
    }
  };
  __name(_Typo_credits_onboarding, "Typo_credits_onboarding");
  let Typo_credits_onboarding = _Typo_credits_onboarding;
  function get_each_context$e(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[30] = list[i];
    return child_ctx;
  }
  __name(get_each_context$e, "get_each_context$e");
  function get_each_context_1$5(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[34] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1$5, "get_each_context_1$5");
  function get_each_context_2$2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[34] = list[i];
    return child_ctx;
  }
  __name(get_each_context_2$2, "get_each_context_2$2");
  function create_if_block_4$1(ctx) {
    let p;
    let t2;
    let br1;
    let t3;
    let div10;
    let div1;
    let t7;
    let div3;
    let t11;
    let div5;
    let t15;
    let div7;
    let t19;
    let div9;
    let mounted;
    let dispose;
    return {
      c() {
        p = element("p");
        p.innerHTML = `To customize your experience, you can select from a variety of feature presets below.<br/>
      You can always activate, deactivate, or customize features in the settings (the wrench icon), or come back to this page (magic wand icon).`;
        t2 = space();
        br1 = element("br");
        t3 = space();
        div10 = element("div");
        div1 = element("div");
        div1.innerHTML = `<h3>Recommended</h3> <div>A set of the most popular typo features that will enhance your skribbl.io experience.</div>`;
        t7 = space();
        div3 = element("div");
        div3.innerHTML = `<h3>Phone</h3> <div>Activates only features that will - probably - work on mobile devices. Limited support!</div>`;
        t11 = space();
        div5 = element("div");
        div5.innerHTML = `<h3>Minimal</h3> <div>Skribbl looks as close to original as possible, but essential features are still present.</div>`;
        t15 = space();
        div7 = element("div");
        div7.innerHTML = `<h3>Everything</h3> <div>The full package; all nifty tools that Typo has to offer!</div>`;
        t19 = space();
        div9 = element("div");
        div9.innerHTML = `<h3>Nothing</h3> <div>Vanilla skribbl.io experience. You will only notice the settings button.</div>`;
        set_style(p, "text-align", "center");
        attr(div1, "class", "typo-onboarding-preset svelte-bu1e3");
        attr(div3, "class", "typo-onboarding-preset svelte-bu1e3");
        attr(div5, "class", "typo-onboarding-preset svelte-bu1e3");
        attr(div7, "class", "typo-onboarding-preset svelte-bu1e3");
        attr(div9, "class", "typo-onboarding-preset svelte-bu1e3");
        attr(div10, "class", "typo-onboarding-presets svelte-bu1e3");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        insert(target, t2, anchor);
        insert(target, br1, anchor);
        insert(target, t3, anchor);
        insert(target, div10, anchor);
        append(div10, div1);
        append(div10, t7);
        append(div10, div3);
        append(div10, t11);
        append(div10, div5);
        append(div10, t15);
        append(div10, div7);
        append(div10, t19);
        append(div10, div9);
        if (!mounted) {
          dispose = [
            listen(
              div1,
              "click",
              /*click_handler_4*/
              ctx[16]
            ),
            listen(
              div3,
              "click",
              /*click_handler_5*/
              ctx[17]
            ),
            listen(
              div5,
              "click",
              /*click_handler_6*/
              ctx[18]
            ),
            listen(
              div7,
              "click",
              /*click_handler_7*/
              ctx[19]
            ),
            listen(
              div9,
              "click",
              /*click_handler_8*/
              ctx[20]
            )
          ];
          mounted = true;
        }
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(p);
          detach(t2);
          detach(br1);
          detach(t3);
          detach(div10);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_if_block_4$1, "create_if_block_4$1");
  function create_if_block_1$4(ctx) {
    let await_block_anchor;
    let promise;
    let current;
    let info = {
      ctx,
      current: null,
      token: null,
      hasCatch: false,
      pending: create_pending_block$1,
      then: create_then_block$1,
      catch: create_catch_block$1,
      value: 33,
      blocks: [, , ,]
    };
    handle_promise(promise = /*feature*/
    ctx[0].getChecklist(), info);
    return {
      c() {
        await_block_anchor = empty();
        info.block.c();
      },
      m(target, anchor) {
        insert(target, await_block_anchor, anchor);
        info.block.m(target, info.anchor = anchor);
        info.mount = () => await_block_anchor.parentNode;
        info.anchor = await_block_anchor;
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        info.ctx = ctx;
        if (dirty[0] & /*feature*/
        1 && promise !== (promise = /*feature*/
        ctx[0].getChecklist()) && handle_promise(promise, info)) ;
        else {
          update_await_block_branch(info, ctx, dirty);
        }
      },
      i(local) {
        if (current) return;
        transition_in(info.block);
        current = true;
      },
      o(local) {
        for (let i = 0; i < 3; i += 1) {
          const block2 = info.blocks[i];
          transition_out(block2);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(await_block_anchor);
        }
        info.block.d(detaching);
        info.token = null;
        info = null;
      }
    };
  }
  __name(create_if_block_1$4, "create_if_block_1$4");
  function create_catch_block$1(ctx) {
    return {
      c: noop,
      m: noop,
      p: noop,
      i: noop,
      o: noop,
      d: noop
    };
  }
  __name(create_catch_block$1, "create_catch_block$1");
  function create_then_block$1(ctx) {
    let show_if;
    let t0;
    let div2;
    let div0;
    let t1;
    let div1;
    function select_block_type(ctx2, dirty) {
      if (dirty[0] & /*feature*/
      1) show_if = null;
      if (show_if == null) show_if = !!/*checklist*/
      ctx2[33].every(func$2);
      if (show_if) return create_if_block_3$1;
      return create_else_block_1;
    }
    __name(select_block_type, "select_block_type");
    let current_block_type = select_block_type(ctx, [-1, -1]);
    let if_block = current_block_type(ctx);
    let each_value_2 = ensure_array_like(
      /*checklist*/
      ctx[33].filter(func_1)
    );
    let each_blocks_1 = [];
    for (let i = 0; i < each_value_2.length; i += 1) {
      each_blocks_1[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    }
    let each_value_1 = ensure_array_like(
      /*checklist*/
      ctx[33].filter(func_2$1)
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    }
    return {
      c() {
        if_block.c();
        t0 = space();
        div2 = element("div");
        div0 = element("div");
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].c();
        }
        t1 = space();
        div1 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div0, "class", "typo-onboarding-checklist svelte-bu1e3");
        attr(div1, "class", "typo-onboarding-checklist svelte-bu1e3");
        attr(div2, "class", "typo-onboarding-checklist-wrapper svelte-bu1e3");
      },
      m(target, anchor) {
        if_block.m(target, anchor);
        insert(target, t0, anchor);
        insert(target, div2, anchor);
        append(div2, div0);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          if (each_blocks_1[i]) {
            each_blocks_1[i].m(div0, null);
          }
        }
        append(div2, t1);
        append(div2, div1);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div1, null);
          }
        }
      },
      p(ctx2, dirty) {
        if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(t0.parentNode, t0);
          }
        }
        if (dirty[0] & /*feature*/
        1) {
          each_value_2 = ensure_array_like(
            /*checklist*/
            ctx2[33].filter(func_1)
          );
          let i;
          for (i = 0; i < each_value_2.length; i += 1) {
            const child_ctx = get_each_context_2$2(ctx2, each_value_2, i);
            if (each_blocks_1[i]) {
              each_blocks_1[i].p(child_ctx, dirty);
            } else {
              each_blocks_1[i] = create_each_block_2$2(child_ctx);
              each_blocks_1[i].c();
              each_blocks_1[i].m(div0, null);
            }
          }
          for (; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d(1);
          }
          each_blocks_1.length = each_value_2.length;
        }
        if (dirty[0] & /*feature*/
        1) {
          each_value_1 = ensure_array_like(
            /*checklist*/
            ctx2[33].filter(func_2$1)
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$5(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_1$5(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div1, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_1.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(div2);
        }
        if_block.d(detaching);
        destroy_each(each_blocks_1, detaching);
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_then_block$1, "create_then_block$1");
  function create_else_block_1(ctx) {
    let span;
    return {
      c() {
        span = element("span");
        span.textContent = "You can complete following tasks to familiarize yourself with Typo:";
      },
      m(target, anchor) {
        insert(target, span, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  __name(create_else_block_1, "create_else_block_1");
  function create_if_block_3$1(ctx) {
    let span;
    return {
      c() {
        span = element("span");
        span.textContent = "Congrats, you have completed all tasks!";
      },
      m(target, anchor) {
        insert(target, span, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  __name(create_if_block_3$1, "create_if_block_3$1");
  function create_each_block_2$2(ctx) {
    let div2;
    let h4;
    let t0_value = (
      /*task*/
      ctx[34].name + ""
    );
    let t0;
    let t1;
    let div1;
    let img;
    let img_src_value;
    let t2;
    let div0;
    let t3_value = (
      /*task*/
      ctx[34].description + ""
    );
    let t3;
    let t4;
    let mounted;
    let dispose;
    function click_handler_9() {
      return (
        /*click_handler_9*/
        ctx[21](
          /*task*/
          ctx[34]
        )
      );
    }
    __name(click_handler_9, "click_handler_9");
    return {
      c() {
        div2 = element("div");
        h4 = element("h4");
        t0 = text(t0_value);
        t1 = space();
        div1 = element("div");
        img = element("img");
        t2 = space();
        div0 = element("div");
        t3 = text(t3_value);
        t4 = space();
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        set_style(img, "content", "var(--file-img-arrow-right-gif)");
        set_style(img, "height", "1.5rem");
        attr(div0, "class", "description svelte-bu1e3");
        attr(div1, "class", "details svelte-bu1e3");
        attr(div2, "class", "typo-onboarding-task svelte-bu1e3");
        set_style(
          div2,
          "order",
          /*task*/
          ctx[34].priority
        );
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, h4);
        append(h4, t0);
        append(div2, t1);
        append(div2, div1);
        append(div1, img);
        append(div1, t2);
        append(div1, div0);
        append(div0, t3);
        append(div2, t4);
        if (!mounted) {
          dispose = listen(div2, "click", click_handler_9);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty[0] & /*feature*/
        1 && t0_value !== (t0_value = /*task*/
        ctx[34].name + "")) set_data(t0, t0_value);
        if (dirty[0] & /*feature*/
        1 && t3_value !== (t3_value = /*task*/
        ctx[34].description + "")) set_data(t3, t3_value);
        if (dirty[0] & /*feature*/
        1) {
          set_style(
            div2,
            "order",
            /*task*/
            ctx[34].priority
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block_2$2, "create_each_block_2$2");
  function create_else_block$3(ctx) {
    let img;
    let img_src_value;
    return {
      c() {
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        set_style(img, "content", "var(--file-img-arrow-right-gif)");
        set_style(img, "height", "1.5rem");
      },
      m(target, anchor) {
        insert(target, img, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(img);
        }
      }
    };
  }
  __name(create_else_block$3, "create_else_block$3");
  function create_if_block_2$2(ctx) {
    let img;
    let img_src_value;
    let t0;
    let b;
    return {
      c() {
        img = element("img");
        t0 = space();
        b = element("b");
        b.textContent = "Done";
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        set_style(img, "content", "var(--file-img-enabled-gif)");
        set_style(img, "height", "1.5rem");
      },
      m(target, anchor) {
        insert(target, img, anchor);
        insert(target, t0, anchor);
        insert(target, b, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(img);
          detach(t0);
          detach(b);
        }
      }
    };
  }
  __name(create_if_block_2$2, "create_if_block_2$2");
  function create_each_block_1$5(ctx) {
    let div2;
    let h4;
    let t0_value = (
      /*task*/
      ctx[34].name + ""
    );
    let t0;
    let t1;
    let div1;
    let t2;
    let div0;
    let t3_value = (
      /*task*/
      ctx[34].description + ""
    );
    let t3;
    let t4;
    function select_block_type_1(ctx2, dirty) {
      if (
        /*task*/
        ctx2[34].completed
      ) return create_if_block_2$2;
      return create_else_block$3;
    }
    __name(select_block_type_1, "select_block_type_1");
    let current_block_type = select_block_type_1(ctx);
    let if_block = current_block_type(ctx);
    return {
      c() {
        div2 = element("div");
        h4 = element("h4");
        t0 = text(t0_value);
        t1 = space();
        div1 = element("div");
        if_block.c();
        t2 = space();
        div0 = element("div");
        t3 = text(t3_value);
        t4 = space();
        attr(div0, "class", "description svelte-bu1e3");
        attr(div1, "class", "details svelte-bu1e3");
        attr(div2, "class", "typo-onboarding-task done svelte-bu1e3");
        set_style(
          div2,
          "order",
          /*task*/
          ctx[34].priority
        );
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, h4);
        append(h4, t0);
        append(div2, t1);
        append(div2, div1);
        if_block.m(div1, null);
        append(div1, t2);
        append(div1, div0);
        append(div0, t3);
        append(div2, t4);
      },
      p(ctx2, dirty) {
        if (dirty[0] & /*feature*/
        1 && t0_value !== (t0_value = /*task*/
        ctx2[34].name + "")) set_data(t0, t0_value);
        if (current_block_type !== (current_block_type = select_block_type_1(ctx2))) {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(div1, t2);
          }
        }
        if (dirty[0] & /*feature*/
        1 && t3_value !== (t3_value = /*task*/
        ctx2[34].description + "")) set_data(t3, t3_value);
        if (dirty[0] & /*feature*/
        1) {
          set_style(
            div2,
            "order",
            /*task*/
            ctx2[34].priority
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        if_block.d();
      }
    };
  }
  __name(create_each_block_1$5, "create_each_block_1$5");
  function create_pending_block$1(ctx) {
    let bounceload;
    let current;
    bounceload = new Bounceload({
      props: { content: "Loading checklist.." }
    });
    return {
      c() {
        create_component(bounceload.$$.fragment);
      },
      m(target, anchor) {
        mount_component(bounceload, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(bounceload, detaching);
      }
    };
  }
  __name(create_pending_block$1, "create_pending_block$1");
  function create_if_block$b(ctx) {
    let div2;
    let div0;
    let t;
    let div1;
    let switch_instance;
    let current;
    let each_value = ensure_array_like(
      /*extraSections*/
      ctx[9]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    }
    var switch_value = (
      /*activeSection*/
      ctx[6].component
    );
    function switch_props(ctx2, dirty) {
      return {};
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props());
    }
    return {
      c() {
        div2 = element("div");
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t = space();
        div1 = element("div");
        if (switch_instance) create_component(switch_instance.$$.fragment);
        attr(div0, "class", "typo-onboarding-extras-sections svelte-bu1e3");
        attr(div1, "class", "typo-onboarding-extras-content svelte-bu1e3");
        attr(div2, "class", "typo-onboarding-extras svelte-bu1e3");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
        append(div2, t);
        append(div2, div1);
        if (switch_instance) mount_component(switch_instance, div1, null);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty[0] & /*activeSection, extraSections*/
        576) {
          each_value = ensure_array_like(
            /*extraSections*/
            ctx2[9]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$e(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$e(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div0, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
        if (dirty[0] & /*activeSection*/
        64 && switch_value !== (switch_value = /*activeSection*/
        ctx2[6].component)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props());
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, div1, null);
          } else {
            switch_instance = null;
          }
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        destroy_each(each_blocks, detaching);
        if (switch_instance) destroy_component(switch_instance);
      }
    };
  }
  __name(create_if_block$b, "create_if_block$b");
  function create_each_block$e(ctx) {
    let b;
    let mounted;
    let dispose;
    function click_handler_10() {
      return (
        /*click_handler_10*/
        ctx[22](
          /*section*/
          ctx[30]
        )
      );
    }
    __name(click_handler_10, "click_handler_10");
    return {
      c() {
        b = element("b");
        b.textContent = `${/*section*/
      ctx[30].name}`;
        attr(b, "class", "svelte-bu1e3");
        toggle_class(
          b,
          "active",
          /*activeSection*/
          ctx[6] === /*section*/
          ctx[30]
        );
      },
      m(target, anchor) {
        insert(target, b, anchor);
        if (!mounted) {
          dispose = listen(b, "click", click_handler_10);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty[0] & /*activeSection, extraSections*/
        576) {
          toggle_class(
            b,
            "active",
            /*activeSection*/
            ctx[6] === /*section*/
            ctx[30]
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(b);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block$e, "create_each_block$e");
  function create_fragment$q(ctx) {
    let div4;
    let div2;
    let div0;
    let h2;
    let t0_value = (
      /*firstLoad*/
      ctx[1] ? "Welcome to" : "Thanks for using"
    );
    let t0;
    let t1;
    let t2;
    let b;
    let t4;
    let div1;
    let div2_class_value;
    let t7;
    let div3;
    let h40;
    let t9;
    let h41;
    let t11;
    let h42;
    let t13;
    let br1;
    let t14;
    let t15;
    let t16;
    let current;
    let mounted;
    let dispose;
    let if_block0 = (
      /*activeTab*/
      ctx[4] === "presets" && create_if_block_4$1(ctx)
    );
    let if_block1 = (
      /*activeTab*/
      ctx[4] === "tasks" && create_if_block_1$4(ctx)
    );
    let if_block2 = (
      /*activeTab*/
      ctx[4] === "extras" && create_if_block$b(ctx)
    );
    return {
      c() {
        div4 = element("div");
        div2 = element("div");
        div0 = element("div");
        h2 = element("h2");
        t0 = text(t0_value);
        t1 = text(" typo ✨");
        t2 = space();
        b = element("b");
        b.textContent = "Typo is the toolbox for everything you need on skribbl.io";
        t4 = space();
        div1 = element("div");
        div1.innerHTML = `XOXO to all beta testers &lt;3<br/>Alpha, Foley, Hex, hunt3r, ibot, Max, Oivoo, shawty, Tuc, ShortM, XVIdevilIVX`;
        t7 = space();
        div3 = element("div");
        h40 = element("h4");
        h40.textContent = "Feature Presets";
        t9 = space();
        h41 = element("h4");
        h41.textContent = "Onboarding Tasks";
        t11 = space();
        h42 = element("h4");
        h42.textContent = "More Info";
        t13 = space();
        br1 = element("br");
        t14 = space();
        if (if_block0) if_block0.c();
        t15 = space();
        if (if_block1) if_block1.c();
        t16 = space();
        if (if_block2) if_block2.c();
        attr(div0, "class", "svelte-bu1e3");
        attr(div1, "class", "beta-credits svelte-bu1e3");
        attr(div2, "class", div2_class_value = "typo-onboarding-hero " + /*hideHero*/
        (ctx[5] ? "hidden" : "") + " svelte-bu1e3");
        attr(h40, "class", "svelte-bu1e3");
        toggle_class(
          h40,
          "active",
          /*activeTab*/
          ctx[4] === "presets"
        );
        attr(h41, "class", "svelte-bu1e3");
        toggle_class(
          h41,
          "active",
          /*activeTab*/
          ctx[4] === "tasks"
        );
        attr(h42, "class", "svelte-bu1e3");
        toggle_class(
          h42,
          "active",
          /*activeTab*/
          ctx[4] === "extras"
        );
        attr(div3, "class", "onboarding-tabs svelte-bu1e3");
        attr(div4, "class", "typo-onboarding-wrapper color-scrollbar svelte-bu1e3");
      },
      m(target, anchor) {
        insert(target, div4, anchor);
        append(div4, div2);
        append(div2, div0);
        append(div0, h2);
        append(h2, t0);
        append(h2, t1);
        append(div0, t2);
        append(div0, b);
        ctx[10](div0);
        append(div2, t4);
        append(div2, div1);
        ctx[11](div2);
        append(div4, t7);
        append(div4, div3);
        append(div3, h40);
        append(div3, t9);
        append(div3, h41);
        append(div3, t11);
        append(div3, h42);
        append(div4, t13);
        append(div4, br1);
        append(div4, t14);
        if (if_block0) if_block0.m(div4, null);
        append(div4, t15);
        if (if_block1) if_block1.m(div4, null);
        append(div4, t16);
        if (if_block2) if_block2.m(div4, null);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              div2,
              "click",
              /*click_handler*/
              ctx[12]
            ),
            listen(
              h40,
              "click",
              /*click_handler_1*/
              ctx[13]
            ),
            listen(
              h41,
              "click",
              /*click_handler_2*/
              ctx[14]
            ),
            listen(
              h42,
              "click",
              /*click_handler_3*/
              ctx[15]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if ((!current || dirty[0] & /*firstLoad*/
        2) && t0_value !== (t0_value = /*firstLoad*/
        ctx2[1] ? "Welcome to" : "Thanks for using")) set_data(t0, t0_value);
        if (!current || dirty[0] & /*hideHero*/
        32 && div2_class_value !== (div2_class_value = "typo-onboarding-hero " + /*hideHero*/
        (ctx2[5] ? "hidden" : "") + " svelte-bu1e3")) {
          attr(div2, "class", div2_class_value);
        }
        if (!current || dirty[0] & /*activeTab*/
        16) {
          toggle_class(
            h40,
            "active",
            /*activeTab*/
            ctx2[4] === "presets"
          );
        }
        if (!current || dirty[0] & /*activeTab*/
        16) {
          toggle_class(
            h41,
            "active",
            /*activeTab*/
            ctx2[4] === "tasks"
          );
        }
        if (!current || dirty[0] & /*activeTab*/
        16) {
          toggle_class(
            h42,
            "active",
            /*activeTab*/
            ctx2[4] === "extras"
          );
        }
        if (
          /*activeTab*/
          ctx2[4] === "presets"
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_4$1(ctx2);
            if_block0.c();
            if_block0.m(div4, t15);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        if (
          /*activeTab*/
          ctx2[4] === "tasks"
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty[0] & /*activeTab*/
            16) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_1$4(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(div4, t16);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
        if (
          /*activeTab*/
          ctx2[4] === "extras"
        ) {
          if (if_block2) {
            if_block2.p(ctx2, dirty);
            if (dirty[0] & /*activeTab*/
            16) {
              transition_in(if_block2, 1);
            }
          } else {
            if_block2 = create_if_block$b(ctx2);
            if_block2.c();
            transition_in(if_block2, 1);
            if_block2.m(div4, null);
          }
        } else if (if_block2) {
          group_outros();
          transition_out(if_block2, 1, 1, () => {
            if_block2 = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block1);
        transition_in(if_block2);
        current = true;
      },
      o(local) {
        transition_out(if_block1);
        transition_out(if_block2);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div4);
        }
        ctx[10](null);
        ctx[11](null);
        if (if_block0) if_block0.d();
        if (if_block1) if_block1.d();
        if (if_block2) if_block2.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$q, "create_fragment$q");
  const func$2 = /* @__PURE__ */ __name((task) => task.completed, "func$2");
  const func_1 = /* @__PURE__ */ __name((task) => !task.completed, "func_1");
  const func_2$1 = /* @__PURE__ */ __name((task) => task.completed, "func_2$1");
  function instance$p($$self, $$props, $$invalidate) {
    let { feature } = $$props;
    let { firstLoad } = $$props;
    let hero;
    let heading;
    const icons = [
      "file-img-challenge-gif",
      "file-img-light-gif",
      "file-img-letter-gif",
      "file-img-line-rainbow-gif",
      "file-img-cloud-gif",
      "file-img-award-gif",
      "file-img-wand-gif",
      "file-img-wrench-gif",
      "file-img-floppy-drive-gif",
      "file-img-palantir-gif",
      "file-img-mask-gif",
      "file-img-palette-gif",
      "file-img-typo-gif",
      "file-img-trash-gif",
      "file-img-line-random-color-gif",
      "file-img-discord-gif",
      "file-img-connection-gif",
      "file-img-tasks-gif",
      "file-img-coin-gif"
    ];
    let shuffledArray = icons.sort(() => Math.random() - 0.5);
    let currentIndex = 0;
    let currentIcons = [];
    let interval2;
    const addIcon = /* @__PURE__ */ __name(() => {
      const randomIcon = shuffledArray[currentIndex];
      currentIndex = (currentIndex + 1) % shuffledArray.length;
      const heroRect = hero.getBoundingClientRect();
      const headingRect = heading.getBoundingClientRect();
      const noSpawnX = headingRect.width + 50;
      const noSpawnY = headingRect.height + 50;
      let x = heroRect.width / 2;
      let y = heroRect.height / 2;
      let tries = 0;
      while (x > (heroRect.width - noSpawnX) / 2 && x < heroRect.width / 2 + noSpawnX && y > (heroRect.height - noSpawnY) / 2 && y < heroRect.height / 2 + noSpawnY || currentIcons.some((icon2) => !icon2.hasEnoughDistance(x, y))) {
        if (tries++ > 20) return;
        x = Math.random() * heroRect.width;
        y = Math.random() * heroRect.height;
      }
      const icon = new Controls_onboarding_emoji({
        target: hero,
        props: { x, y, src: randomIcon }
      });
      currentIcons.push(icon);
      setTimeout(
        () => {
          icon.$destroy();
          currentIcons = currentIcons.filter((i) => i !== icon);
        },
        3e3
      );
    }, "addIcon");
    const activateFeaturePreset = /* @__PURE__ */ __name((preset) => {
      feature.activateFeaturePreset(preset);
      if (firstLoad) useTab("tasks");
      else feature.closeOnboardingIfOpen();
    }, "activateFeaturePreset");
    let activeTab = firstLoad ? "presets" : "tasks";
    const activeTabFocus = feature.tabFocusRequestsStore;
    activeTabFocus.subscribe((v) => {
      if (v !== void 0) {
        useTab(v);
      }
    });
    let hideHero = false;
    const useTab = /* @__PURE__ */ __name((tab) => {
      $$invalidate(5, hideHero = true);
      $$invalidate(4, activeTab = tab);
      currentIcons.forEach((icon) => icon.$destroy());
      if (tab === "extras") feature.completeInfoTask();
    }, "useTab");
    let extraSections = [
      {
        name: "Introducing the new Typo",
        component: Old_typo_onboarding
      },
      {
        name: "Credits & Imprint",
        component: Typo_credits_onboarding
      }
    ];
    let activeSection = extraSections[0];
    onMount(() => {
      interval2 = setInterval(
        () => {
          addIcon();
        },
        250
      );
      for (let i = 0; i < 5; i++) {
        addIcon();
      }
    });
    onDestroy(() => {
      clearInterval(interval2);
    });
    function div0_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        heading = $$value;
        $$invalidate(3, heading);
      });
    }
    __name(div0_binding, "div0_binding");
    function div2_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        hero = $$value;
        $$invalidate(2, hero);
      });
    }
    __name(div2_binding, "div2_binding");
    const click_handler2 = /* @__PURE__ */ __name(() => useTab(activeTab), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => useTab("presets"), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(() => useTab("tasks"), "click_handler_2");
    const click_handler_3 = /* @__PURE__ */ __name(() => useTab("extras"), "click_handler_3");
    const click_handler_4 = /* @__PURE__ */ __name(() => activateFeaturePreset("recommended"), "click_handler_4");
    const click_handler_52 = /* @__PURE__ */ __name(() => activateFeaturePreset("mobile"), "click_handler_5");
    const click_handler_6 = /* @__PURE__ */ __name(() => activateFeaturePreset("minimal"), "click_handler_6");
    const click_handler_7 = /* @__PURE__ */ __name(() => activateFeaturePreset("all"), "click_handler_7");
    const click_handler_8 = /* @__PURE__ */ __name(() => activateFeaturePreset("none"), "click_handler_8");
    const click_handler_9 = /* @__PURE__ */ __name(async (task) => {
      const close = await task.start();
      if (close !== false) feature.closeOnboardingIfOpen();
    }, "click_handler_9");
    const click_handler_10 = /* @__PURE__ */ __name((section) => $$invalidate(6, activeSection = section), "click_handler_10");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
      if ("firstLoad" in $$props2) $$invalidate(1, firstLoad = $$props2.firstLoad);
    };
    return [
      feature,
      firstLoad,
      hero,
      heading,
      activeTab,
      hideHero,
      activeSection,
      activateFeaturePreset,
      useTab,
      extraSections,
      div0_binding,
      div2_binding,
      click_handler2,
      click_handler_1,
      click_handler_2,
      click_handler_3,
      click_handler_4,
      click_handler_52,
      click_handler_6,
      click_handler_7,
      click_handler_8,
      click_handler_9,
      click_handler_10
    ];
  }
  __name(instance$p, "instance$p");
  const _Controls_onboarding = class _Controls_onboarding extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$p, create_fragment$q, safe_not_equal, { feature: 0, firstLoad: 1 }, null, [-1, -1]);
    }
  };
  __name(_Controls_onboarding, "Controls_onboarding");
  let Controls_onboarding = _Controls_onboarding;
  var __defProp$r = Object.defineProperty;
  var __decorateClass$r = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$r(target, key2, result);
    return result;
  }, "__decorateClass$r");
  const _ControlsOnboardingFeature = (_Ea = class extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_modalService");
      __publicField(this, "_featuresService");
      __publicField(this, "_toastService");
      __publicField(this, "name", "Get Started");
      __publicField(this, "description", "Quickly set up typo to your likes");
      __publicField(this, "tags", [
        FeatureTag.INTERFACE,
        FeatureTag.INFORMATION
      ]);
      __publicField(this, "featureId", 47);
      __publicField(this, "_firstLoadSetting", new BooleanExtensionSetting("first_load", true, this));
      __publicField(this, "_finishOnboardingTask", this.useOnboardingTask({
        key: "finalize_onboarding",
        name: "Finish Onboarding",
        description: "Choose whether to disable 'Get Started'. This should be your last task! ;)",
        start: /* @__PURE__ */ __name(() => this.finalizeOnboarding(), "start"),
        priority: Number.MAX_SAFE_INTEGER
      }));
      __publicField(this, "_viewInfoTask", this.useOnboardingTask({
        key: "info_opened",
        name: "Read about the new typo",
        description: "Open the 'more info' tab to read an intro and changes of the new typo.",
        start: /* @__PURE__ */ __name(async () => {
          this._tabFocusRequests$.next("extras");
          return false;
        }, "start"),
        priority: 1
      }));
      __publicField(this, "_featurePresets", {
        recommended: {
          mode: "blacklist",
          features: [
            PlayerIdsFeature,
            DrawingColorPalettesFeature,
            ImageAgentFeature
          ]
        },
        minimal: {
          mode: "whitelist",
          features: [
            ChatRecallFeature,
            GuessCheckFeature,
            LobbyStatusFeature,
            ControlsCloudFeature,
            ChatEmojisFeature,
            ChatProfileLinkFeature,
            HotkeysFeature,
            CanvasZoomFeature,
            LineToolFeature,
            ChatFocusFeature,
            PlayerIdsFeature,
            LobbyTimeVisualizerFeature,
            DrawingColorPalettesFeature,
            ChatQuickReactFeature,
            ChatCopyFormattedFeature,
            DrawingPressureFeature,
            ChatCommandsFeature,
            DropsFeature,
            ChatClearFeature,
            ChatMessageSplitsFeature,
            CustomizerPracticeJoinFeature,
            CustomizerOutfitToggleFeature,
            _Ea,
            TooltipsFeature
          ]
        },
        none: {
          mode: "whitelist",
          features: []
        },
        all: {
          mode: "blacklist",
          features: []
        },
        mobile: {
          mode: "whitelist",
          features: [
            LobbyStatusFeature,
            ChatEmojisFeature,
            ChatProfileLinkFeature,
            LobbyTimeVisualizerFeature,
            DrawingPressureFeature,
            ChatClearFeature,
            CustomizerPracticeJoinFeature,
            CustomizerOutfitToggleFeature,
            _Ea,
            TooltipsFeature,
            ControlsThemesFeature,
            UserInfoFeature,
            PanelLobbiesFeature,
            PanelCabinFeature,
            PanelNewsFeature,
            PanelChangelogFeature,
            DrawingColorToolsFeature,
            CanvasRateIconsFeature
          ]
        }
      });
      __publicField(this, "_iconComponent");
      __publicField(this, "_iconClickSubscription");
      __publicField(this, "_currentModal");
      __publicField(this, "_taskCompletedSubscription");
      __publicField(this, "_tabFocusRequests$", new Subject$1());
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._iconComponent = new Icon_button({
        target: elements2.controls,
        props: {
          hoverMove: false,
          size: "48px",
          icon: "file-img-tasks-gif",
          name: "Get Started",
          order: 4,
          tooltipAction: this.createTooltip
        }
      });
      this._iconClickSubscription = this._iconComponent.click$.subscribe(() => {
        this.showOnboarding();
      });
      const firstLoad = await this._firstLoadSetting.getValue();
      if (firstLoad) {
        this.showOnboarding(true);
        await this._firstLoadSetting.setValue(false);
      }
      this._taskCompletedSubscription = this._onboardingService.taskCompleted$.subscribe((task) => {
        this._toastService.showToast("🎉 Congrats!", `You have completed the onboarding task "${task.name}"!`);
      });
    }
    async onDestroy() {
      var _a2, _b2, _c2;
      (_a2 = this._iconComponent) == null ? void 0 : _a2.$destroy();
      (_b2 = this._iconClickSubscription) == null ? void 0 : _b2.unsubscribe();
      this._iconClickSubscription = void 0;
      (_c2 = this._taskCompletedSubscription) == null ? void 0 : _c2.unsubscribe();
      this._taskCompletedSubscription = void 0;
    }
    get tabFocusRequestsStore() {
      return fromObservable(this._tabFocusRequests$, void 0);
    }
    showOnboarding(firstLoad = false) {
      var _a2;
      (_a2 = this._currentModal) == null ? void 0 : _a2.close();
      const onboardingComponent = {
        componentType: Controls_onboarding,
        props: {
          feature: this,
          firstLoad
        }
      };
      this._currentModal = this._modalService.showModal(onboardingComponent.componentType, onboardingComponent.props, firstLoad ? "" : "Get Started");
    }
    async activateFeaturePreset(preset) {
      this._logger.debug("Activating preset", preset);
      const toast = await this._toastService.showLoadingToast("Activating preset...");
      const presetData = this._featurePresets[preset];
      const availableFeatures = this._featuresService.features;
      const presetFeatures = presetData.mode === "blacklist" ? availableFeatures.filter((f) => !f.toggleEnabled || !presetData.features.some((disabled) => f instanceof disabled)) : availableFeatures.filter((f) => !f.toggleEnabled || presetData.features.some((disabled) => f instanceof disabled));
      const toggles = availableFeatures.map(async (feature) => {
        const enabled = await firstValueFrom(feature.activated$);
        const presetEnabled = presetFeatures.includes(feature);
        if (enabled && !presetEnabled) {
          await feature.destroy();
        }
        if (!enabled && presetEnabled) {
          await feature.activate();
        }
      });
      try {
        await Promise.all(toggles);
        toast.resolve("Preset activated");
      } catch (e) {
        this._logger.error("Failed to activate preset", e);
        toast.reject("Failed to activate preset");
        return;
      }
    }
    async getChecklist() {
      return this._onboardingService.getOnboardingTasks();
    }
    closeOnboardingIfOpen() {
      var _a2;
      (_a2 = this._currentModal) == null ? void 0 : _a2.close();
    }
    async finalizeOnboarding() {
      const task = await this._finishOnboardingTask;
      const tasks = await this._onboardingService.getOnboardingTasks();
      const allOtherCompleted = tasks.every((t) => t.completed || t.key === task.task.key);
      const title = allOtherCompleted ? "✨ You have completed all onboarding tasks!" : "Not all tasks completed yet!";
      const description = allOtherCompleted ? "Do you want to remove the onboarding icon?\nYou can always enable it again in the settings to read guides or select presets." : "You have not completed all onboarding tasks yet.\nDo you still want to disable onboarding?\nYou can always enable it again in the settings to read guides or select presets.";
      const confirm = await this._toastService.showConfirmToast(title, description, 3e4, { confirm: "Disable onboarding", cancel: "Keep enabled" });
      const result = await confirm.result;
      if (allOtherCompleted) {
        task.complete();
      }
      if (result) {
        this.destroy();
      }
      return false;
    }
    async completeInfoTask() {
      (await this._viewInfoTask).complete();
    }
  }, __name(_Ea, "_ControlsOnboardingFeature"), _Ea);
  __decorateClass$r([
    inject(ElementsSetup)
  ], _ControlsOnboardingFeature.prototype, "_elementsSetup");
  __decorateClass$r([
    inject(ModalService)
  ], _ControlsOnboardingFeature.prototype, "_modalService");
  __decorateClass$r([
    inject(FeaturesService)
  ], _ControlsOnboardingFeature.prototype, "_featuresService");
  __decorateClass$r([
    inject(ToastService)
  ], _ControlsOnboardingFeature.prototype, "_toastService");
  let ControlsOnboardingFeature = _ControlsOnboardingFeature;
  function get_each_context$d(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[6] = list[i];
    return child_ctx;
  }
  __name(get_each_context$d, "get_each_context$d");
  function create_catch_block(ctx) {
    return {
      c: noop,
      m: noop,
      p: noop,
      i: noop,
      o: noop,
      d: noop
    };
  }
  __name(create_catch_block, "create_catch_block");
  function create_then_block(ctx) {
    let h3;
    let t1;
    let p;
    let t4;
    let br1;
    let t5;
    let div;
    let current;
    let each_value = ensure_array_like(
      /*profiles*/
      ctx[5]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        h3 = element("h3");
        h3.textContent = "Saved Profiles";
        t1 = space();
        p = element("p");
        p.innerHTML = `Typo profiles let you save and switch the entire data of typo.<br/>
    Switching to a profile or deleting a profile will reload the page.`;
        t4 = space();
        br1 = element("br");
        t5 = space();
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div, "class", "typo-profiles svelte-16buojm");
      },
      m(target, anchor) {
        insert(target, h3, anchor);
        insert(target, t1, anchor);
        insert(target, p, anchor);
        insert(target, t4, anchor);
        insert(target, br1, anchor);
        insert(target, t5, anchor);
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*feature*/
        1) {
          each_value = ensure_array_like(
            /*profiles*/
            ctx2[5]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$d(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$d(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div, null);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(h3);
          detach(t1);
          detach(p);
          detach(t4);
          detach(br1);
          detach(t5);
          detach(div);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_then_block, "create_then_block");
  function create_each_block$d(ctx) {
    let div;
    let span;
    let t0_value = (
      /*profile*/
      ctx[6].name + ""
    );
    let t0;
    let t1;
    let iconbutton;
    let t2;
    let current;
    let mounted;
    let dispose;
    function click_handler2(...args) {
      return (
        /*click_handler*/
        ctx[1](
          /*profile*/
          ctx[6],
          ...args
        )
      );
    }
    __name(click_handler2, "click_handler");
    iconbutton = new Icon_button({
      props: {
        size: "1.5rem",
        icon: (
          /*profile*/
          ctx[6].active ? "file-img-enabled-gif" : "file-img-trash-gif"
        ),
        name: "Delete",
        hoverMove: false,
        greyscaleInactive: true
      }
    });
    iconbutton.$on("click", click_handler2);
    function click_handler_1() {
      return (
        /*click_handler_1*/
        ctx[2](
          /*profile*/
          ctx[6]
        )
      );
    }
    __name(click_handler_1, "click_handler_1");
    return {
      c() {
        div = element("div");
        span = element("span");
        t0 = text(t0_value);
        t1 = space();
        create_component(iconbutton.$$.fragment);
        t2 = space();
        attr(div, "class", "typo-profile svelte-16buojm");
        toggle_class(
          div,
          "active",
          /*profile*/
          ctx[6].active
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, span);
        append(span, t0);
        append(div, t1);
        mount_component(iconbutton, div, null);
        append(div, t2);
        current = true;
        if (!mounted) {
          dispose = listen(div, "click", click_handler_1);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if ((!current || dirty & /*feature*/
        1) && t0_value !== (t0_value = /*profile*/
        ctx[6].name + "")) set_data(t0, t0_value);
        const iconbutton_changes = {};
        if (dirty & /*feature*/
        1) iconbutton_changes.icon = /*profile*/
        ctx[6].active ? "file-img-enabled-gif" : "file-img-trash-gif";
        iconbutton.$set(iconbutton_changes);
        if (!current || dirty & /*feature*/
        1) {
          toggle_class(
            div,
            "active",
            /*profile*/
            ctx[6].active
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(iconbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(iconbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(iconbutton);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block$d, "create_each_block$d");
  function create_pending_block(ctx) {
    let bounceload;
    let current;
    bounceload = new Bounceload({ props: { content: "Loading Profiles" } });
    return {
      c() {
        create_component(bounceload.$$.fragment);
      },
      m(target, anchor) {
        mount_component(bounceload, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(bounceload.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(bounceload.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(bounceload, detaching);
      }
    };
  }
  __name(create_pending_block, "create_pending_block");
  function create_fragment$p(ctx) {
    let promise;
    let t0;
    let br0;
    let t1;
    let h30;
    let t3;
    let p0;
    let t6;
    let br2;
    let t7;
    let flatbutton0;
    let t8;
    let br3;
    let t9;
    let br4;
    let t10;
    let h31;
    let t12;
    let p1;
    let t15;
    let br6;
    let t16;
    let flatbutton1;
    let current;
    let info = {
      ctx,
      current: null,
      token: null,
      hasCatch: false,
      pending: create_pending_block,
      then: create_then_block,
      catch: create_catch_block,
      value: 5,
      blocks: [, , ,]
    };
    handle_promise(promise = /*feature*/
    ctx[0].getProfiles(), info);
    flatbutton0 = new Flat_button({
      props: {
        content: "Create profile",
        color: "green"
      }
    });
    flatbutton0.$on(
      "click",
      /*click_handler_2*/
      ctx[3]
    );
    flatbutton1 = new Flat_button({
      props: { content: "Reset typo", color: "orange" }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_3*/
      ctx[4]
    );
    return {
      c() {
        info.block.c();
        t0 = space();
        br0 = element("br");
        t1 = space();
        h30 = element("h3");
        h30.textContent = "Create new profile";
        t3 = space();
        p0 = element("p");
        p0.innerHTML = `A new empty profile will be added.<br/>
  This will reload the page.`;
        t6 = space();
        br2 = element("br");
        t7 = space();
        create_component(flatbutton0.$$.fragment);
        t8 = space();
        br3 = element("br");
        t9 = space();
        br4 = element("br");
        t10 = space();
        h31 = element("h3");
        h31.textContent = "Reset typo";
        t12 = space();
        p1 = element("p");
        p1.innerHTML = `Resetting typo will erase all data. Typo will behave like after a fresh installation.<br/>
  This is irreversible and will reload the page.`;
        t15 = space();
        br6 = element("br");
        t16 = space();
        create_component(flatbutton1.$$.fragment);
      },
      m(target, anchor) {
        info.block.m(target, info.anchor = anchor);
        info.mount = () => t0.parentNode;
        info.anchor = t0;
        insert(target, t0, anchor);
        insert(target, br0, anchor);
        insert(target, t1, anchor);
        insert(target, h30, anchor);
        insert(target, t3, anchor);
        insert(target, p0, anchor);
        insert(target, t6, anchor);
        insert(target, br2, anchor);
        insert(target, t7, anchor);
        mount_component(flatbutton0, target, anchor);
        insert(target, t8, anchor);
        insert(target, br3, anchor);
        insert(target, t9, anchor);
        insert(target, br4, anchor);
        insert(target, t10, anchor);
        insert(target, h31, anchor);
        insert(target, t12, anchor);
        insert(target, p1, anchor);
        insert(target, t15, anchor);
        insert(target, br6, anchor);
        insert(target, t16, anchor);
        mount_component(flatbutton1, target, anchor);
        current = true;
      },
      p(new_ctx, [dirty]) {
        ctx = new_ctx;
        info.ctx = ctx;
        if (dirty & /*feature*/
        1 && promise !== (promise = /*feature*/
        ctx[0].getProfiles()) && handle_promise(promise, info)) ;
        else {
          update_await_block_branch(info, ctx, dirty);
        }
      },
      i(local) {
        if (current) return;
        transition_in(info.block);
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        current = true;
      },
      o(local) {
        for (let i = 0; i < 3; i += 1) {
          const block2 = info.blocks[i];
          transition_out(block2);
        }
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(br0);
          detach(t1);
          detach(h30);
          detach(t3);
          detach(p0);
          detach(t6);
          detach(br2);
          detach(t7);
          detach(t8);
          detach(br3);
          detach(t9);
          detach(br4);
          detach(t10);
          detach(h31);
          detach(t12);
          detach(p1);
          detach(t15);
          detach(br6);
          detach(t16);
        }
        info.block.d(detaching);
        info.token = null;
        info = null;
        destroy_component(flatbutton0, detaching);
        destroy_component(flatbutton1, detaching);
      }
    };
  }
  __name(create_fragment$p, "create_fragment$p");
  function instance$o($$self, $$props, $$invalidate) {
    let { feature } = $$props;
    const click_handler2 = /* @__PURE__ */ __name((profile, e) => {
      e.stopImmediatePropagation();
      if (!profile.active) feature.deleteProfile(profile.name);
    }, "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name((profile) => {
      if (!profile.active) feature.switchToProfile(profile.name);
    }, "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(() => feature.createProfile(), "click_handler_2");
    const click_handler_3 = /* @__PURE__ */ __name(() => feature.resetTypo(), "click_handler_3");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [feature, click_handler2, click_handler_1, click_handler_2, click_handler_3];
  }
  __name(instance$o, "instance$o");
  const _Controls_profiles = class _Controls_profiles extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$o, create_fragment$p, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Controls_profiles, "Controls_profiles");
  let Controls_profiles = _Controls_profiles;
  var __defProp$q = Object.defineProperty;
  var __decorateClass$q = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$q(target, key2, result);
    return result;
  }, "__decorateClass$q");
  const _ControlsProfilesFeature = class _ControlsProfilesFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_toastService");
      __publicField(this, "name", "Typo Profiles");
      __publicField(this, "description", "Switch between different typo profiles.");
      __publicField(this, "tags", [
        FeatureTag.DEVELOPMENT
      ]);
      __publicField(this, "featureId", 48);
      __publicField(this, "toggleEnabled", false);
    }
    get featureManagementComponent() {
      return { componentType: Controls_profiles, props: { feature: this } };
    }
    async getProfiles() {
      const currentProfile = await typoRuntime.currentProfile();
      return (await typoRuntime.getProfiles()).map((profile) => ({ name: profile, active: profile === currentProfile }));
    }
    async deleteProfile(profile) {
      const currentProfile = await typoRuntime.currentProfile();
      if (profile === currentProfile) {
        this._logger.error("Cannot delete the current profile.");
        await this._toastService.showToast("Cannot delete the current profile " + profile);
        return;
      }
      const toast = await this._toastService.showConfirmToast(
        `Delete profile ${profile}?`,
        "Deleting a profile will reload the page.",
        1e4,
        { confirm: "Delete profile", cancel: "Cancel deletion" }
      );
      const result = await toast.result;
      if (!result) return;
      await typoRuntime.deleteProfile(profile);
      window.location.reload();
    }
    async switchToProfile(profile) {
      const toast = await this._toastService.showConfirmToast(
        `Switch to profile ${profile}?`,
        "Switching a profile will reload the page.",
        1e4,
        { confirm: "Switch now", cancel: "Cancel switch" }
      );
      const result = await toast.result;
      if (!result) return;
      await typoRuntime.switchToProfile(profile);
      window.location.reload();
    }
    async createProfile() {
      const toast = await this._toastService.showPromptToast("Create and activate profile", "Enter a name for the new profile");
      const result = await toast.result;
      if (result === null || result.length === 0) return;
      const profiles = await typoRuntime.getProfiles();
      if (profiles.includes(result)) {
        this._logger.error("Profile already exists");
        await this._toastService.showToast("Profile already exists", "A profile with the name " + result + " already exists.\nPlease choose a different name.");
        return;
      }
      await typoRuntime.createAndSwitchToProfile(result);
      window.location.reload();
    }
    async resetTypo() {
      const toast = await this._toastService.showConfirmToast(
        "Reset Typo?",
        "This will delete ALL saved data (themes, palettes, login, profiles, filters..) and reload the page.",
        1e4,
        { confirm: "Reset typo (think twice)", cancel: "Cancel reset (panic!)" }
      );
      const result = await toast.result;
      if (!result) return;
      await typoRuntime.resetTypo();
      window.location.reload();
    }
  };
  __name(_ControlsProfilesFeature, "ControlsProfilesFeature");
  let ControlsProfilesFeature = _ControlsProfilesFeature;
  __decorateClass$q([
    inject(ElementsSetup)
  ], ControlsProfilesFeature.prototype, "_elementsSetup");
  __decorateClass$q([
    inject(ToastService)
  ], ControlsProfilesFeature.prototype, "_toastService");
  function create_if_block$a(ctx) {
    let br;
    let span;
    return {
      c() {
        br = element("br");
        span = element("span");
        span.textContent = "Disabled in text inputs";
        attr(span, "class", "inputs-disabled-hint svelte-10zlzgr");
      },
      m(target, anchor) {
        insert(target, br, anchor);
        insert(target, span, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(br);
          detach(span);
        }
      }
    };
  }
  __name(create_if_block$a, "create_if_block$a");
  function create_fragment$o(ctx) {
    let div5;
    let h3;
    let t0_value = (
      /*hotkey*/
      ctx[0].name + ""
    );
    let t0;
    let t1;
    let div0;
    let t2_value = (
      /*hotkey*/
      ctx[0].description + ""
    );
    let t2;
    let t3;
    let t4;
    let div1;
    let flatbutton0;
    let t5;
    let div2;
    let flatbutton1;
    let t6;
    let div3;
    let checkbox;
    let updating_checked;
    let t7;
    let div4;
    let input;
    let input_value_value;
    let current;
    let mounted;
    let dispose;
    let if_block = (
      /*hotkey*/
      ctx[0].disabledOnInputs && create_if_block$a()
    );
    flatbutton0 = new Flat_button({
      props: {
        content: "Reset to default",
        color: "orange"
      }
    });
    flatbutton0.$on(
      "click",
      /*click_handler*/
      ctx[9]
    );
    flatbutton1 = new Flat_button({
      props: { content: "Save combo", color: "green" }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_1*/
      ctx[10]
    );
    function checkbox_checked_binding(value) {
      ctx[11](value);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    let checkbox_props = {
      disabled: (
        /*$comboStore*/
        ctx[2].length === 0
      ),
      description: (
        /*$enabledStore*/
        ctx[5] ? "Enabled" : "Disabled"
      )
    };
    if (
      /*$enabledStore*/
      ctx[5] !== void 0
    ) {
      checkbox_props.checked = /*$enabledStore*/
      ctx[5];
    }
    checkbox = new Checkbox({ props: checkbox_props });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
    return {
      c() {
        div5 = element("div");
        h3 = element("h3");
        t0 = text(t0_value);
        t1 = space();
        div0 = element("div");
        t2 = text(t2_value);
        t3 = space();
        if (if_block) if_block.c();
        t4 = space();
        div1 = element("div");
        create_component(flatbutton0.$$.fragment);
        t5 = space();
        div2 = element("div");
        create_component(flatbutton1.$$.fragment);
        t6 = space();
        div3 = element("div");
        create_component(checkbox.$$.fragment);
        t7 = space();
        div4 = element("div");
        input = element("input");
        attr(div1, "class", "button-container svelte-10zlzgr");
        attr(div2, "class", "button-container svelte-10zlzgr");
        input.value = input_value_value = /*recordedKeys*/
        ctx[4].join(" + ");
        attr(input, "type", "text");
        attr(input, "placeholder", "Press Keys");
        set_style(div4, "grid-column", "2 / span 3");
        attr(div5, "class", "typo-feature-settings-hotkey svelte-10zlzgr");
      },
      m(target, anchor) {
        insert(target, div5, anchor);
        append(div5, h3);
        append(h3, t0);
        append(div5, t1);
        append(div5, div0);
        append(div0, t2);
        append(div0, t3);
        if (if_block) if_block.m(div0, null);
        append(div5, t4);
        append(div5, div1);
        mount_component(flatbutton0, div1, null);
        append(div5, t5);
        append(div5, div2);
        mount_component(flatbutton1, div2, null);
        append(div5, t6);
        append(div5, div3);
        mount_component(checkbox, div3, null);
        append(div5, t7);
        append(div5, div4);
        append(div4, input);
        ctx[12](input);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              input,
              "click",
              /*click_handler_2*/
              ctx[13]
            ),
            listen(
              input,
              "keydown",
              /*keydown_handler*/
              ctx[14]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if ((!current || dirty & /*hotkey*/
        1) && t0_value !== (t0_value = /*hotkey*/
        ctx2[0].name + "")) set_data(t0, t0_value);
        if ((!current || dirty & /*hotkey*/
        1) && t2_value !== (t2_value = /*hotkey*/
        ctx2[0].description + "")) set_data(t2, t2_value);
        if (
          /*hotkey*/
          ctx2[0].disabledOnInputs
        ) {
          if (if_block) ;
          else {
            if_block = create_if_block$a();
            if_block.c();
            if_block.m(div0, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        const checkbox_changes = {};
        if (dirty & /*$comboStore*/
        4) checkbox_changes.disabled = /*$comboStore*/
        ctx2[2].length === 0;
        if (dirty & /*$enabledStore*/
        32) checkbox_changes.description = /*$enabledStore*/
        ctx2[5] ? "Enabled" : "Disabled";
        if (!updating_checked && dirty & /*$enabledStore*/
        32) {
          updating_checked = true;
          checkbox_changes.checked = /*$enabledStore*/
          ctx2[5];
          add_flush_callback(() => updating_checked = false);
        }
        checkbox.$set(checkbox_changes);
        if (!current || dirty & /*recordedKeys*/
        16 && input_value_value !== (input_value_value = /*recordedKeys*/
        ctx2[4].join(" + ")) && input.value !== input_value_value) {
          input.value = input_value_value;
        }
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div5);
        }
        if (if_block) if_block.d();
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
        destroy_component(checkbox);
        ctx[12](null);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$o, "create_fragment$o");
  function instance$n($$self, $$props, $$invalidate) {
    let $comboStore;
    let $enabledStore;
    let { hotkey } = $$props;
    let { feature } = $$props;
    const enabledStore = hotkey.enabledSetting.store;
    component_subscribe($$self, enabledStore, (value) => $$invalidate(5, $enabledStore = value));
    const comboStore = hotkey.comboSetting.store;
    component_subscribe($$self, comboStore, (value) => $$invalidate(2, $comboStore = value));
    let recordingElement;
    let recordedKeys;
    const getHotkeyComboHumanReadable = /* @__PURE__ */ __name(async (combo) => {
      var _a2;
      if ((_a2 = navigator == null ? void 0 : navigator.keyboard) == null ? void 0 : _a2.getLayoutMap) {
        const layoutMap = await navigator.keyboard.getLayoutMap();
        return combo.map((key2) => layoutMap.get(key2) || key2).join(" + ");
      } else {
        return combo.join(" + ");
      }
    }, "getHotkeyComboHumanReadable");
    const click_handler2 = /* @__PURE__ */ __name(async () => {
      const update2 = await feature.resetHotkeyCombo(hotkey);
      if (update2) {
        $$invalidate(4, recordedKeys = update2);
        $$invalidate(3, recordingElement.value = await getHotkeyComboHumanReadable(recordedKeys), recordingElement);
      }
    }, "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => {
      feature.setHotkeyCombo(hotkey, recordedKeys);
      if (recordedKeys.length > 0) {
        set_store_value(enabledStore, $enabledStore = true, $enabledStore);
      }
    }, "click_handler_1");
    function checkbox_checked_binding(value) {
      $enabledStore = value;
      enabledStore.set($enabledStore);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    function input_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        recordingElement = $$value;
        $$invalidate(3, recordingElement);
      });
    }
    __name(input_binding, "input_binding");
    const click_handler_2 = /* @__PURE__ */ __name(() => {
      $$invalidate(4, recordedKeys = []);
      $$invalidate(3, recordingElement.value = "", recordingElement);
    }, "click_handler_2");
    const keydown_handler2 = /* @__PURE__ */ __name(async (event) => {
      event.preventDefault();
      if (!recordedKeys.includes(event.code)) {
        recordedKeys.push(event.code);
        $$invalidate(3, recordingElement.value = await getHotkeyComboHumanReadable(recordedKeys), recordingElement);
      } else {
        $$invalidate(4, recordedKeys = recordedKeys.filter((key2) => key2 !== event.code));
        $$invalidate(3, recordingElement.value = await getHotkeyComboHumanReadable(recordedKeys), recordingElement);
      }
    }, "keydown_handler");
    $$self.$$set = ($$props2) => {
      if ("hotkey" in $$props2) $$invalidate(0, hotkey = $$props2.hotkey);
      if ("feature" in $$props2) $$invalidate(1, feature = $$props2.feature);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*$comboStore*/
      4) {
        {
          $$invalidate(4, recordedKeys = [...$comboStore]);
        }
      }
    };
    return [
      hotkey,
      feature,
      $comboStore,
      recordingElement,
      recordedKeys,
      $enabledStore,
      enabledStore,
      comboStore,
      getHotkeyComboHumanReadable,
      click_handler2,
      click_handler_1,
      checkbox_checked_binding,
      input_binding,
      click_handler_2,
      keydown_handler2
    ];
  }
  __name(instance$n, "instance$n");
  const _Controls_settings_hotkey = class _Controls_settings_hotkey extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$n, create_fragment$o, safe_not_equal, { hotkey: 0, feature: 1 });
    }
  };
  __name(_Controls_settings_hotkey, "Controls_settings_hotkey");
  let Controls_settings_hotkey = _Controls_settings_hotkey;
  function create_fragment$n(ctx) {
    let div5;
    let h3;
    let t0_value = (
      /*command*/
      ctx[0].name + ""
    );
    let t0;
    let t1;
    let div0;
    let t2_value = (
      /*command*/
      ctx[0].description + ""
    );
    let t2;
    let t3;
    let div1;
    let flatbutton0;
    let t4;
    let div2;
    let flatbutton1;
    let t5;
    let div3;
    let checkbox;
    let updating_checked;
    let t6;
    let div4;
    let input;
    let current;
    let mounted;
    let dispose;
    flatbutton0 = new Flat_button({
      props: { content: "Reset name", color: "orange" }
    });
    flatbutton0.$on(
      "click",
      /*click_handler*/
      ctx[7]
    );
    flatbutton1 = new Flat_button({
      props: { content: "Save name", color: "green" }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_1*/
      ctx[8]
    );
    function checkbox_checked_binding(value) {
      ctx[9](value);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    let checkbox_props = {
      description: (
        /*$enabledStore*/
        ctx[3] ? "Enabled" : "Disabled"
      )
    };
    if (
      /*$enabledStore*/
      ctx[3] !== void 0
    ) {
      checkbox_props.checked = /*$enabledStore*/
      ctx[3];
    }
    checkbox = new Checkbox({ props: checkbox_props });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
    return {
      c() {
        div5 = element("div");
        h3 = element("h3");
        t0 = text(t0_value);
        t1 = space();
        div0 = element("div");
        t2 = text(t2_value);
        t3 = space();
        div1 = element("div");
        create_component(flatbutton0.$$.fragment);
        t4 = space();
        div2 = element("div");
        create_component(flatbutton1.$$.fragment);
        t5 = space();
        div3 = element("div");
        create_component(checkbox.$$.fragment);
        t6 = space();
        div4 = element("div");
        input = element("input");
        attr(div1, "class", "button-container svelte-lvvgs4");
        attr(div2, "class", "button-container svelte-lvvgs4");
        attr(input, "type", "text");
        attr(input, "placeholder", "Enter command name");
        set_style(div4, "grid-column", "2 / span 3");
        attr(div5, "class", "typo-feature-settings-command svelte-lvvgs4");
      },
      m(target, anchor) {
        insert(target, div5, anchor);
        append(div5, h3);
        append(h3, t0);
        append(div5, t1);
        append(div5, div0);
        append(div0, t2);
        append(div5, t3);
        append(div5, div1);
        mount_component(flatbutton0, div1, null);
        append(div5, t4);
        append(div5, div2);
        mount_component(flatbutton1, div2, null);
        append(div5, t5);
        append(div5, div3);
        mount_component(checkbox, div3, null);
        append(div5, t6);
        append(div5, div4);
        append(div4, input);
        set_input_value(
          input,
          /*idInput*/
          ctx[2]
        );
        current = true;
        if (!mounted) {
          dispose = listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[10]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if ((!current || dirty & /*command*/
        1) && t0_value !== (t0_value = /*command*/
        ctx2[0].name + "")) set_data(t0, t0_value);
        if ((!current || dirty & /*command*/
        1) && t2_value !== (t2_value = /*command*/
        ctx2[0].description + "")) set_data(t2, t2_value);
        const checkbox_changes = {};
        if (dirty & /*$enabledStore*/
        8) checkbox_changes.description = /*$enabledStore*/
        ctx2[3] ? "Enabled" : "Disabled";
        if (!updating_checked && dirty & /*$enabledStore*/
        8) {
          updating_checked = true;
          checkbox_changes.checked = /*$enabledStore*/
          ctx2[3];
          add_flush_callback(() => updating_checked = false);
        }
        checkbox.$set(checkbox_changes);
        if (dirty & /*idInput*/
        4 && input.value !== /*idInput*/
        ctx2[2]) {
          set_input_value(
            input,
            /*idInput*/
            ctx2[2]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div5);
        }
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
        destroy_component(checkbox);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$n, "create_fragment$n");
  function instance$m($$self, $$props, $$invalidate) {
    let $idStore;
    let $enabledStore;
    let { command } = $$props;
    let { feature } = $$props;
    const enabledStore = command.enabledSetting.store;
    component_subscribe($$self, enabledStore, (value) => $$invalidate(3, $enabledStore = value));
    const idStore = command.idSetting.store;
    component_subscribe($$self, idStore, (value) => $$invalidate(1, $idStore = value));
    let idInput = "";
    const click_handler2 = /* @__PURE__ */ __name(() => {
      set_store_value(idStore, $idStore = command.defaultId, $idStore);
    }, "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => {
      set_store_value(idStore, $idStore = idInput.length === 0 ? command.defaultId : idInput, $idStore);
    }, "click_handler_1");
    function checkbox_checked_binding(value) {
      $enabledStore = value;
      enabledStore.set($enabledStore);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    function input_input_handler() {
      idInput = this.value;
      $$invalidate(2, idInput), $$invalidate(1, $idStore);
    }
    __name(input_input_handler, "input_input_handler");
    $$self.$$set = ($$props2) => {
      if ("command" in $$props2) $$invalidate(0, command = $$props2.command);
      if ("feature" in $$props2) $$invalidate(6, feature = $$props2.feature);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*$idStore*/
      2) {
        {
          $$invalidate(2, idInput = $idStore);
        }
      }
    };
    return [
      command,
      $idStore,
      idInput,
      $enabledStore,
      enabledStore,
      idStore,
      feature,
      click_handler2,
      click_handler_1,
      checkbox_checked_binding,
      input_input_handler
    ];
  }
  __name(instance$m, "instance$m");
  const _Controls_settings_command = class _Controls_settings_command extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$m, create_fragment$n, safe_not_equal, { command: 0, feature: 6 });
    }
  };
  __name(_Controls_settings_command, "Controls_settings_command");
  let Controls_settings_command = _Controls_settings_command;
  function get_each_context$c(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[9] = list[i];
    return child_ctx;
  }
  __name(get_each_context$c, "get_each_context$c");
  function get_each_context_1$4(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[12] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1$4, "get_each_context_1$4");
  function get_each_context_2$1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[15] = list[i];
    return child_ctx;
  }
  __name(get_each_context_2$1, "get_each_context_2$1");
  function create_if_block_5(ctx) {
    let div1;
    let h2;
    let t1;
    let div0;
    let switch_instance;
    let current;
    const switch_instance_spread_levels = [
      /*infoComponent*/
      ctx[4].props
    ];
    var switch_value = (
      /*infoComponent*/
      ctx[4].componentType
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {};
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*infoComponent*/
      16) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*infoComponent*/
          ctx2[4].props
        )]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        div1 = element("div");
        h2 = element("h2");
        h2.textContent = "Feature Information";
        t1 = space();
        div0 = element("div");
        if (switch_instance) create_component(switch_instance.$$.fragment);
        attr(h2, "class", "svelte-1njssi3");
        attr(div1, "class", "typo-feature-settings-info svelte-1njssi3");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, h2);
        append(div1, t1);
        append(div1, div0);
        if (switch_instance) mount_component(switch_instance, div0, null);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*infoComponent*/
        16 && switch_value !== (switch_value = /*infoComponent*/
        ctx2[4].componentType)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, div0, null);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*infoComponent*/
          16 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
            /*infoComponent*/
            ctx2[4].props
          )]) : {};
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if (switch_instance) destroy_component(switch_instance);
      }
    };
  }
  __name(create_if_block_5, "create_if_block_5");
  function create_if_block_4(ctx) {
    let div1;
    let h2;
    let t1;
    let div0;
    let current;
    let each_value_2 = ensure_array_like(
      /*feature*/
      ctx[1].settings
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_2.length; i += 1) {
      each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        div1 = element("div");
        h2 = element("h2");
        h2.textContent = "Feature Settings";
        t1 = space();
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(h2, "class", "svelte-1njssi3");
        attr(div0, "class", "typo-feature-settings-default-list svelte-1njssi3");
        attr(div1, "class", "typo-feature-settings-default svelte-1njssi3");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, h2);
        append(div1, t1);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*feature*/
        2) {
          each_value_2 = ensure_array_like(
            /*feature*/
            ctx2[1].settings
          );
          let i;
          for (i = 0; i < each_value_2.length; i += 1) {
            const child_ctx = get_each_context_2$1(ctx2, each_value_2, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_2$1(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div0, null);
            }
          }
          group_outros();
          for (i = each_value_2.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value_2.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_if_block_4, "create_if_block_4");
  function create_each_block_2$1(ctx) {
    let div;
    let switch_instance;
    let t;
    let current;
    const switch_instance_spread_levels = [
      /*setting*/
      ctx[15].componentData.props
    ];
    var switch_value = (
      /*setting*/
      ctx[15].componentData.componentType
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {};
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*feature*/
      2) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*setting*/
          ctx2[15].componentData.props
        )]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        div = element("div");
        if (switch_instance) create_component(switch_instance.$$.fragment);
        t = space();
        attr(div, "class", "typo-feature-settings-default-item svelte-1njssi3");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if (switch_instance) mount_component(switch_instance, div, null);
        append(div, t);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*feature*/
        2 && switch_value !== (switch_value = /*setting*/
        ctx2[15].componentData.componentType)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, div, t);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*feature*/
          2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
            /*setting*/
            ctx2[15].componentData.props
          )]) : {};
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if (switch_instance) destroy_component(switch_instance);
      }
    };
  }
  __name(create_each_block_2$1, "create_each_block_2$1");
  function create_if_block_3(ctx) {
    let div1;
    let h2;
    let t1;
    let div0;
    let switch_instance;
    let current;
    const switch_instance_spread_levels = [
      /*settingsComponent*/
      ctx[3].props
    ];
    var switch_value = (
      /*settingsComponent*/
      ctx[3].componentType
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {};
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*settingsComponent*/
      8) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*settingsComponent*/
          ctx2[3].props
        )]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        div1 = element("div");
        h2 = element("h2");
        h2.textContent = "Feature Management";
        t1 = space();
        div0 = element("div");
        if (switch_instance) create_component(switch_instance.$$.fragment);
        attr(h2, "class", "svelte-1njssi3");
        attr(div1, "class", "typo-feature-settings-management svelte-1njssi3");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, h2);
        append(div1, t1);
        append(div1, div0);
        if (switch_instance) mount_component(switch_instance, div0, null);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*settingsComponent*/
        8 && switch_value !== (switch_value = /*settingsComponent*/
        ctx2[3].componentType)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, div0, null);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*settingsComponent*/
          8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
            /*settingsComponent*/
            ctx2[3].props
          )]) : {};
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if (switch_instance) destroy_component(switch_instance);
      }
    };
  }
  __name(create_if_block_3, "create_if_block_3");
  function create_if_block_1$3(ctx) {
    let div1;
    let h2;
    let t1;
    let p;
    let t5;
    let t6;
    let br2;
    let t7;
    let div0;
    let current;
    let if_block = !/*supportskeyboardLayout*/
    ctx[7] && create_if_block_2$1();
    let each_value_1 = ensure_array_like(
      /*featureHotkeys*/
      ctx[5]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        div1 = element("div");
        h2 = element("h2");
        h2.textContent = "Feature Hotkeys";
        t1 = space();
        p = element("p");
        p.innerHTML = `Hotkeys are key combinations to quickly access feature functions. You can disable hotkeys that you don&#39;t need.<br/>
      To change a hotkey, click in the input field and press the desired key combination. To remove a key from the combination, press it again.<br/>
      Empty combinations will be disabled automatically.`;
        t5 = space();
        if (if_block) if_block.c();
        t6 = space();
        br2 = element("br");
        t7 = space();
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(h2, "class", "svelte-1njssi3");
        attr(div0, "class", "typo-feature-settings-hotkeys-list svelte-1njssi3");
        attr(div1, "class", "typo-feature-settings-hotkeys svelte-1njssi3");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, h2);
        append(div1, t1);
        append(div1, p);
        append(div1, t5);
        if (if_block) if_block.m(div1, null);
        append(div1, t6);
        append(div1, br2);
        append(div1, t7);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*featureHotkeys, settingsFeature*/
        36) {
          each_value_1 = ensure_array_like(
            /*featureHotkeys*/
            ctx2[5]
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$4(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_1$4(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div0, null);
            }
          }
          group_outros();
          for (i = each_value_1.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value_1.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        if (if_block) if_block.d();
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_if_block_1$3, "create_if_block_1$3");
  function create_if_block_2$1(ctx) {
    let p;
    return {
      c() {
        p = element("p");
        p.innerHTML = `Your browser does not support localized key names. Hotkeys will use US keyboard layout names.<br/>
        Switch to any Chrome-based browser to see the real key names.`;
      },
      m(target, anchor) {
        insert(target, p, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(p);
        }
      }
    };
  }
  __name(create_if_block_2$1, "create_if_block_2$1");
  function create_each_block_1$4(ctx) {
    let controlssettingshotkey;
    let current;
    controlssettingshotkey = new Controls_settings_hotkey({
      props: {
        hotkey: (
          /*hotkey*/
          ctx[12]
        ),
        feature: (
          /*settingsFeature*/
          ctx[2]
        )
      }
    });
    return {
      c() {
        create_component(controlssettingshotkey.$$.fragment);
      },
      m(target, anchor) {
        mount_component(controlssettingshotkey, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const controlssettingshotkey_changes = {};
        if (dirty & /*featureHotkeys*/
        32) controlssettingshotkey_changes.hotkey = /*hotkey*/
        ctx2[12];
        if (dirty & /*settingsFeature*/
        4) controlssettingshotkey_changes.feature = /*settingsFeature*/
        ctx2[2];
        controlssettingshotkey.$set(controlssettingshotkey_changes);
      },
      i(local) {
        if (current) return;
        transition_in(controlssettingshotkey.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(controlssettingshotkey.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(controlssettingshotkey, detaching);
      }
    };
  }
  __name(create_each_block_1$4, "create_each_block_1$4");
  function create_if_block$9(ctx) {
    let div1;
    let h2;
    let t1;
    let p;
    let t5;
    let br2;
    let t6;
    let div0;
    let current;
    let each_value = ensure_array_like(
      /*featureCommands*/
      ctx[6]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        div1 = element("div");
        h2 = element("h2");
        h2.textContent = "Feature Commands";
        t1 = space();
        p = element("p");
        p.innerHTML = `Commands are a quick way to execute actions of a feature from the chat.<br/>
      Here, you can toggle commands on or off and customize the command name.<br/>
      To use a command, type &quot;/&quot; and continue with the command name.`;
        t5 = space();
        br2 = element("br");
        t6 = space();
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(h2, "class", "svelte-1njssi3");
        attr(div0, "class", "typo-feature-settings-commands-list svelte-1njssi3");
        attr(div1, "class", "typo-feature-settings-hotkeys svelte-1njssi3");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, h2);
        append(div1, t1);
        append(div1, p);
        append(div1, t5);
        append(div1, br2);
        append(div1, t6);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*featureCommands, settingsFeature*/
        68) {
          each_value = ensure_array_like(
            /*featureCommands*/
            ctx2[6]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$c(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$c(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div0, null);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_if_block$9, "create_if_block$9");
  function create_each_block$c(ctx) {
    let controlssettingscommand;
    let current;
    controlssettingscommand = new Controls_settings_command({
      props: {
        command: (
          /*command*/
          ctx[9]
        ),
        feature: (
          /*settingsFeature*/
          ctx[2]
        )
      }
    });
    return {
      c() {
        create_component(controlssettingscommand.$$.fragment);
      },
      m(target, anchor) {
        mount_component(controlssettingscommand, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const controlssettingscommand_changes = {};
        if (dirty & /*featureCommands*/
        64) controlssettingscommand_changes.command = /*command*/
        ctx2[9];
        if (dirty & /*settingsFeature*/
        4) controlssettingscommand_changes.feature = /*settingsFeature*/
        ctx2[2];
        controlssettingscommand.$set(controlssettingscommand_changes);
      },
      i(local) {
        if (current) return;
        transition_in(controlssettingscommand.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(controlssettingscommand.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(controlssettingscommand, detaching);
      }
    };
  }
  __name(create_each_block$c, "create_each_block$c");
  function create_fragment$m(ctx) {
    let div2;
    let div0;
    let t1;
    let h1;
    let t2_value = (
      /*feature*/
      ctx[1].name + ""
    );
    let t2;
    let t3;
    let div1;
    let t5;
    let div3;
    let t6_value = (
      /*feature*/
      ctx[1].description + ""
    );
    let t6;
    let t7;
    let t8;
    let t9;
    let t10;
    let t11;
    let if_block4_anchor;
    let current;
    let mounted;
    let dispose;
    let if_block0 = (
      /*infoComponent*/
      ctx[4] && create_if_block_5(ctx)
    );
    let if_block1 = (
      /*feature*/
      ctx[1].settings.length > 0 && create_if_block_4(ctx)
    );
    let if_block2 = (
      /*settingsComponent*/
      ctx[3] && create_if_block_3(ctx)
    );
    let if_block3 = (
      /*featureHotkeys*/
      ctx[5].length > 0 && create_if_block_1$3(ctx)
    );
    let if_block4 = (
      /*featureCommands*/
      ctx[6].length > 0 && create_if_block$9(ctx)
    );
    return {
      c() {
        div2 = element("div");
        div0 = element("div");
        div0.textContent = "Feature Details";
        t1 = space();
        h1 = element("h1");
        t2 = text(t2_value);
        t3 = space();
        div1 = element("div");
        div1.textContent = "Back to Features ➜";
        t5 = space();
        div3 = element("div");
        t6 = text(t6_value);
        t7 = space();
        if (if_block0) if_block0.c();
        t8 = space();
        if (if_block1) if_block1.c();
        t9 = space();
        if (if_block2) if_block2.c();
        t10 = space();
        if (if_block3) if_block3.c();
        t11 = space();
        if (if_block4) if_block4.c();
        if_block4_anchor = empty();
        attr(div0, "class", "typo-feature-settings-hero svelte-1njssi3");
        attr(h1, "class", "svelte-1njssi3");
        attr(div1, "class", "typo-feature-settings-back svelte-1njssi3");
        attr(div2, "class", "typo-feature-settings-title svelte-1njssi3");
        attr(div3, "class", "typo-feature-settings-summary svelte-1njssi3");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, div0);
        append(div2, t1);
        append(div2, h1);
        append(h1, t2);
        append(div2, t3);
        append(div2, div1);
        insert(target, t5, anchor);
        insert(target, div3, anchor);
        append(div3, t6);
        insert(target, t7, anchor);
        if (if_block0) if_block0.m(target, anchor);
        insert(target, t8, anchor);
        if (if_block1) if_block1.m(target, anchor);
        insert(target, t9, anchor);
        if (if_block2) if_block2.m(target, anchor);
        insert(target, t10, anchor);
        if (if_block3) if_block3.m(target, anchor);
        insert(target, t11, anchor);
        if (if_block4) if_block4.m(target, anchor);
        insert(target, if_block4_anchor, anchor);
        current = true;
        if (!mounted) {
          dispose = listen(
            div1,
            "click",
            /*click_handler*/
            ctx[8]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if ((!current || dirty & /*feature*/
        2) && t2_value !== (t2_value = /*feature*/
        ctx2[1].name + "")) set_data(t2, t2_value);
        if ((!current || dirty & /*feature*/
        2) && t6_value !== (t6_value = /*feature*/
        ctx2[1].description + "")) set_data(t6, t6_value);
        if (
          /*infoComponent*/
          ctx2[4]
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty & /*infoComponent*/
            16) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_5(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(t8.parentNode, t8);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        if (
          /*feature*/
          ctx2[1].settings.length > 0
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty & /*feature*/
            2) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_4(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(t9.parentNode, t9);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
        if (
          /*settingsComponent*/
          ctx2[3]
        ) {
          if (if_block2) {
            if_block2.p(ctx2, dirty);
            if (dirty & /*settingsComponent*/
            8) {
              transition_in(if_block2, 1);
            }
          } else {
            if_block2 = create_if_block_3(ctx2);
            if_block2.c();
            transition_in(if_block2, 1);
            if_block2.m(t10.parentNode, t10);
          }
        } else if (if_block2) {
          group_outros();
          transition_out(if_block2, 1, 1, () => {
            if_block2 = null;
          });
          check_outros();
        }
        if (
          /*featureHotkeys*/
          ctx2[5].length > 0
        ) {
          if (if_block3) {
            if_block3.p(ctx2, dirty);
            if (dirty & /*featureHotkeys*/
            32) {
              transition_in(if_block3, 1);
            }
          } else {
            if_block3 = create_if_block_1$3(ctx2);
            if_block3.c();
            transition_in(if_block3, 1);
            if_block3.m(t11.parentNode, t11);
          }
        } else if (if_block3) {
          group_outros();
          transition_out(if_block3, 1, 1, () => {
            if_block3 = null;
          });
          check_outros();
        }
        if (
          /*featureCommands*/
          ctx2[6].length > 0
        ) {
          if (if_block4) {
            if_block4.p(ctx2, dirty);
            if (dirty & /*featureCommands*/
            64) {
              transition_in(if_block4, 1);
            }
          } else {
            if_block4 = create_if_block$9(ctx2);
            if_block4.c();
            transition_in(if_block4, 1);
            if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
          }
        } else if (if_block4) {
          group_outros();
          transition_out(if_block4, 1, 1, () => {
            if_block4 = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block0);
        transition_in(if_block1);
        transition_in(if_block2);
        transition_in(if_block3);
        transition_in(if_block4);
        current = true;
      },
      o(local) {
        transition_out(if_block0);
        transition_out(if_block1);
        transition_out(if_block2);
        transition_out(if_block3);
        transition_out(if_block4);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
          detach(t5);
          detach(div3);
          detach(t7);
          detach(t8);
          detach(t9);
          detach(t10);
          detach(t11);
          detach(if_block4_anchor);
        }
        if (if_block0) if_block0.d(detaching);
        if (if_block1) if_block1.d(detaching);
        if (if_block2) if_block2.d(detaching);
        if (if_block3) if_block3.d(detaching);
        if (if_block4) if_block4.d(detaching);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$m, "create_fragment$m");
  function instance$l($$self, $$props, $$invalidate) {
    var _a2;
    let { detailsClosed } = $$props;
    let { feature } = $$props;
    let { settingsFeature } = $$props;
    settingsFeature.completeOnboardingTask();
    let settingsComponent;
    let infoComponent;
    let featureHotkeys = [];
    let featureCommands = [];
    const supportskeyboardLayout = ((_a2 = navigator == null ? void 0 : navigator.keyboard) == null ? void 0 : _a2.getLayoutMap) !== void 0;
    const click_handler2 = /* @__PURE__ */ __name(() => detailsClosed(), "click_handler");
    $$self.$$set = ($$props2) => {
      if ("detailsClosed" in $$props2) $$invalidate(0, detailsClosed = $$props2.detailsClosed);
      if ("feature" in $$props2) $$invalidate(1, feature = $$props2.feature);
      if ("settingsFeature" in $$props2) $$invalidate(2, settingsFeature = $$props2.settingsFeature);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*feature*/
      2) {
        {
          $$invalidate(5, featureHotkeys = [...feature.hotkeys]);
          $$invalidate(6, featureCommands = [...feature.commands]);
          $$invalidate(3, settingsComponent = feature.featureManagementComponent);
          $$invalidate(4, infoComponent = feature.featureInfoComponent);
        }
      }
    };
    return [
      detailsClosed,
      feature,
      settingsFeature,
      settingsComponent,
      infoComponent,
      featureHotkeys,
      featureCommands,
      supportskeyboardLayout,
      click_handler2
    ];
  }
  __name(instance$l, "instance$l");
  const _Controls_settings_details = class _Controls_settings_details extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$l, create_fragment$m, safe_not_equal, {
        detailsClosed: 0,
        feature: 1,
        settingsFeature: 2
      });
    }
  };
  __name(_Controls_settings_details, "Controls_settings_details");
  let Controls_settings_details = _Controls_settings_details;
  function create_else_block$2(ctx) {
    let div;
    let t_value = (
      /*feature*/
      ctx[0].description + ""
    );
    let t;
    return {
      c() {
        div = element("div");
        t = text(t_value);
        attr(div, "class", "description svelte-xje42n");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, t);
      },
      p(ctx2, dirty) {
        if (dirty & /*feature*/
        1 && t_value !== (t_value = /*feature*/
        ctx2[0].description + "")) set_data(t, t_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_else_block$2, "create_else_block$2");
  function create_if_block$8(ctx) {
    let div;
    let img;
    let img_src_value;
    let img_alt_value;
    let t0;
    let span;
    let t1_value = (
      /*feature*/
      ctx[0].description + ""
    );
    let t1;
    let mounted;
    let dispose;
    return {
      c() {
        div = element("div");
        img = element("img");
        t0 = space();
        span = element("span");
        t1 = text(t1_value);
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        attr(img, "alt", img_alt_value = /*$featureState*/
        ctx[4] ? "enabled" : "disabled");
        set_style(img, "content", "var(--file-img-wrench-gif)");
        attr(img, "class", "svelte-xje42n");
        attr(span, "class", "svelte-xje42n");
        attr(div, "class", "description svelte-xje42n");
        attr(div, "role", "button");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, img);
        append(div, t0);
        append(div, span);
        append(span, t1);
        if (!mounted) {
          dispose = listen(
            div,
            "click",
            /*click_handler_1*/
            ctx[8]
          );
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*$featureState*/
        16 && img_alt_value !== (img_alt_value = /*$featureState*/
        ctx2[4] ? "enabled" : "disabled")) {
          attr(img, "alt", img_alt_value);
        }
        if (dirty & /*feature*/
        1 && t1_value !== (t1_value = /*feature*/
        ctx2[0].description + "")) set_data(t1, t1_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_if_block$8, "create_if_block$8");
  function create_fragment$l(ctx) {
    let div3;
    let div0;
    let img;
    let img_src_value;
    let img_alt_value;
    let t0;
    let span0;
    let t1_value = (
      /*feature*/
      ctx[0].name + ""
    );
    let t1;
    let t2;
    let span1;
    let t3_value = (
      /*$featureState*/
      ctx[4] ? "enabled" : "disabled"
    );
    let t3;
    let t4;
    let t5;
    let div1;
    let t6_value = (
      /*feature*/
      ctx[0].tags.map(func$1).join(" ") + ""
    );
    let t6;
    let t7;
    let div2;
    let t8;
    let t9_value = (
      /*feature*/
      ctx[0].featureId + ""
    );
    let t9;
    let mounted;
    let dispose;
    function select_block_type(ctx2, dirty) {
      if (
        /*feature*/
        ctx2[0].hasDetailComponents
      ) return create_if_block$8;
      return create_else_block$2;
    }
    __name(select_block_type, "select_block_type");
    let current_block_type = select_block_type(ctx);
    let if_block = current_block_type(ctx);
    return {
      c() {
        div3 = element("div");
        div0 = element("div");
        img = element("img");
        t0 = space();
        span0 = element("span");
        t1 = text(t1_value);
        t2 = space();
        span1 = element("span");
        t3 = text(t3_value);
        t4 = space();
        if_block.c();
        t5 = space();
        div1 = element("div");
        t6 = text(t6_value);
        t7 = space();
        div2 = element("div");
        t8 = text("#");
        t9 = text(t9_value);
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        attr(img, "alt", img_alt_value = /*$featureState*/
        ctx[4] ? "enabled" : "disabled");
        set_style(img, "content", "var(--" + /*$featureState*/
        (ctx[4] ? "file-img-enabled-gif" : "file-img-disabled-gif") + ")");
        attr(img, "class", "svelte-xje42n");
        attr(span0, "class", "svelte-xje42n");
        attr(span1, "class", "svelte-xje42n");
        attr(div0, "class", "name-toggle svelte-xje42n");
        attr(div0, "role", "button");
        attr(div0, "tabindex", "0");
        toggle_class(div0, "locked", !/*feature*/
        ctx[0].toggleEnabled);
        attr(div1, "class", "feature-tags svelte-xje42n");
        attr(div2, "class", "feature-id svelte-xje42n");
        attr(div3, "class", "typo-feature-item svelte-xje42n");
        toggle_class(
          div3,
          "devMode",
          /*devmodeEnabled*/
          ctx[1]
        );
        toggle_class(
          div3,
          "hidden",
          /*feature*/
          ctx[0].developerFeature && !/*devmodeEnabled*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, div3, anchor);
        append(div3, div0);
        append(div0, img);
        append(div0, t0);
        append(div0, span0);
        append(span0, t1);
        append(div0, t2);
        append(div0, span1);
        append(span1, t3);
        append(div3, t4);
        if_block.m(div3, null);
        append(div3, t5);
        append(div3, div1);
        append(div1, t6);
        append(div3, t7);
        append(div3, div2);
        append(div2, t8);
        append(div2, t9);
        if (!mounted) {
          dispose = [
            listen(
              div0,
              "click",
              /*click_handler*/
              ctx[6]
            ),
            listen(
              div0,
              "keypress",
              /*keypress_handler*/
              ctx[7]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*$featureState*/
        16 && img_alt_value !== (img_alt_value = /*$featureState*/
        ctx2[4] ? "enabled" : "disabled")) {
          attr(img, "alt", img_alt_value);
        }
        if (dirty & /*$featureState*/
        16) {
          set_style(img, "content", "var(--" + /*$featureState*/
          (ctx2[4] ? "file-img-enabled-gif" : "file-img-disabled-gif") + ")");
        }
        if (dirty & /*feature*/
        1 && t1_value !== (t1_value = /*feature*/
        ctx2[0].name + "")) set_data(t1, t1_value);
        if (dirty & /*$featureState*/
        16 && t3_value !== (t3_value = /*$featureState*/
        ctx2[4] ? "enabled" : "disabled")) set_data(t3, t3_value);
        if (dirty & /*feature*/
        1) {
          toggle_class(div0, "locked", !/*feature*/
          ctx2[0].toggleEnabled);
        }
        if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(div3, t5);
          }
        }
        if (dirty & /*feature*/
        1 && t6_value !== (t6_value = /*feature*/
        ctx2[0].tags.map(func$1).join(" ") + "")) set_data(t6, t6_value);
        if (dirty & /*feature*/
        1 && t9_value !== (t9_value = /*feature*/
        ctx2[0].featureId + "")) set_data(t9, t9_value);
        if (dirty & /*devmodeEnabled*/
        2) {
          toggle_class(
            div3,
            "devMode",
            /*devmodeEnabled*/
            ctx2[1]
          );
        }
        if (dirty & /*feature, devmodeEnabled*/
        3) {
          toggle_class(
            div3,
            "hidden",
            /*feature*/
            ctx2[0].developerFeature && !/*devmodeEnabled*/
            ctx2[1]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div3);
        }
        if_block.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$l, "create_fragment$l");
  const func$1 = /* @__PURE__ */ __name((t) => "#" + t, "func$1");
  function instance$k($$self, $$props, $$invalidate) {
    let $featureState, $$unsubscribe_featureState = noop, $$subscribe_featureState = /* @__PURE__ */ __name(() => ($$unsubscribe_featureState(), $$unsubscribe_featureState = subscribe(featureState, ($$value) => $$invalidate(4, $featureState = $$value)), featureState), "$$subscribe_featureState");
    $$self.$$.on_destroy.push(() => $$unsubscribe_featureState());
    let { devmodeEnabled } = $$props;
    let { feature } = $$props;
    let { featureSettingsClicked } = $$props;
    const toggleFeature = /* @__PURE__ */ __name(async (feature2) => {
      if (feature2.toggleEnabled === false) return feature2;
      const state = await firstValueFrom(feature2.activated$);
      if (!state) {
        await feature2.activate();
      } else {
        await feature2.destroy();
      }
      return feature2;
    }, "toggleFeature");
    let featureState;
    const click_handler2 = /* @__PURE__ */ __name(async () => $$invalidate(0, feature = await toggleFeature(feature)), "click_handler");
    const keypress_handler = /* @__PURE__ */ __name(async (key2) => {
      if (key2.key === "Enter") $$invalidate(0, feature = await toggleFeature(feature));
    }, "keypress_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => featureSettingsClicked(), "click_handler_1");
    $$self.$$set = ($$props2) => {
      if ("devmodeEnabled" in $$props2) $$invalidate(1, devmodeEnabled = $$props2.devmodeEnabled);
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
      if ("featureSettingsClicked" in $$props2) $$invalidate(2, featureSettingsClicked = $$props2.featureSettingsClicked);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*feature*/
      1) {
        {
          $$subscribe_featureState($$invalidate(3, featureState = fromObservable(feature.activated$, false)));
        }
      }
    };
    return [
      feature,
      devmodeEnabled,
      featureSettingsClicked,
      featureState,
      $featureState,
      toggleFeature,
      click_handler2,
      keypress_handler,
      click_handler_1
    ];
  }
  __name(instance$k, "instance$k");
  const _Controls_settings_feature = class _Controls_settings_feature extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$k, create_fragment$l, safe_not_equal, {
        devmodeEnabled: 1,
        feature: 0,
        featureSettingsClicked: 2
      });
    }
  };
  __name(_Controls_settings_feature, "Controls_settings_feature");
  let Controls_settings_feature = _Controls_settings_feature;
  function get_each_context$b(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[11] = list[i];
    return child_ctx;
  }
  __name(get_each_context$b, "get_each_context$b");
  function get_each_context_1$3(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[14] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1$3, "get_each_context_1$3");
  function create_each_block_1$3(ctx) {
    let span;
    let mounted;
    let dispose;
    function click_handler2() {
      return (
        /*click_handler*/
        ctx[6](
          /*tag*/
          ctx[14]
        )
      );
    }
    __name(click_handler2, "click_handler");
    return {
      c() {
        span = element("span");
        span.textContent = `#${/*tag*/
      ctx[14]}`;
        attr(span, "class", "filter svelte-1ly2c3r");
        toggle_class(
          span,
          "selected",
          /*filterTags*/
          ctx[2].includes(
            /*tag*/
            ctx[14]
          )
        );
      },
      m(target, anchor) {
        insert(target, span, anchor);
        if (!mounted) {
          dispose = listen(span, "click", click_handler2);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*filterTags*/
        4) {
          toggle_class(
            span,
            "selected",
            /*filterTags*/
            ctx[2].includes(
              /*tag*/
              ctx[14]
            )
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(span);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block_1$3, "create_each_block_1$3");
  function create_each_block$b(ctx) {
    let controlssettingsfeatureitem;
    let current;
    function func2() {
      return (
        /*func*/
        ctx[8](
          /*feat*/
          ctx[11]
        )
      );
    }
    __name(func2, "func");
    controlssettingsfeatureitem = new Controls_settings_feature({
      props: {
        feature: (
          /*feat*/
          ctx[11]
        ),
        devmodeEnabled: (
          /*$devMode*/
          ctx[4]
        ),
        featureSettingsClicked: func2
      }
    });
    return {
      c() {
        create_component(controlssettingsfeatureitem.$$.fragment);
      },
      m(target, anchor) {
        mount_component(controlssettingsfeatureitem, target, anchor);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        const controlssettingsfeatureitem_changes = {};
        if (dirty & /*feature, filterTags, filterContent*/
        13) controlssettingsfeatureitem_changes.feature = /*feat*/
        ctx[11];
        if (dirty & /*$devMode*/
        16) controlssettingsfeatureitem_changes.devmodeEnabled = /*$devMode*/
        ctx[4];
        if (dirty & /*selectedDetailsFeature, feature, filterTags, filterContent*/
        15) controlssettingsfeatureitem_changes.featureSettingsClicked = func2;
        controlssettingsfeatureitem.$set(controlssettingsfeatureitem_changes);
      },
      i(local) {
        if (current) return;
        transition_in(controlssettingsfeatureitem.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(controlssettingsfeatureitem.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(controlssettingsfeatureitem, detaching);
      }
    };
  }
  __name(create_each_block$b, "create_each_block$b");
  function create_if_block$7(ctx) {
    let controlssettingsdetails;
    let current;
    controlssettingsdetails = new Controls_settings_details({
      props: {
        feature: (
          /*selectedDetailsFeature*/
          ctx[1]
        ),
        detailsClosed: (
          /*func_1*/
          ctx[9]
        ),
        settingsFeature: (
          /*feature*/
          ctx[0]
        )
      }
    });
    return {
      c() {
        create_component(controlssettingsdetails.$$.fragment);
      },
      m(target, anchor) {
        mount_component(controlssettingsdetails, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const controlssettingsdetails_changes = {};
        if (dirty & /*selectedDetailsFeature*/
        2) controlssettingsdetails_changes.feature = /*selectedDetailsFeature*/
        ctx2[1];
        if (dirty & /*selectedDetailsFeature*/
        2) controlssettingsdetails_changes.detailsClosed = /*func_1*/
        ctx2[9];
        if (dirty & /*feature*/
        1) controlssettingsdetails_changes.settingsFeature = /*feature*/
        ctx2[0];
        controlssettingsdetails.$set(controlssettingsdetails_changes);
      },
      i(local) {
        if (current) return;
        transition_in(controlssettingsdetails.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(controlssettingsdetails.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(controlssettingsdetails, detaching);
      }
    };
  }
  __name(create_if_block$7, "create_if_block$7");
  function create_fragment$k(ctx) {
    let div6;
    let div4;
    let div0;
    let t3;
    let div2;
    let h30;
    let t5;
    let div1;
    let t6;
    let h31;
    let t8;
    let input;
    let t9;
    let div3;
    let t10;
    let div5;
    let current;
    let mounted;
    let dispose;
    let each_value_1 = ensure_array_like(featureTags);
    let each_blocks_1 = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks_1[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    }
    let each_value = ensure_array_like(
      /*feature*/
      ctx[0].searchFeatures(
        /*feature*/
        ctx[0].features,
        /*filterTags*/
        ctx[2],
        /*filterContent*/
        ctx[3]
      )
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    let if_block = (
      /*selectedDetailsFeature*/
      ctx[1] && create_if_block$7(ctx)
    );
    return {
      c() {
        div6 = element("div");
        div4 = element("div");
        div0 = element("div");
        div0.innerHTML = `All features of skribbltypo can be managed here.<br/>
      You can click on a feature name to toggle it. To open feature settings, click the settings icon.<br/>
      If you are unsure how a feature works, you can have a look at the typo website or join the typo discord server and get help there!`;
        t3 = space();
        div2 = element("div");
        h30 = element("h3");
        h30.textContent = "Filter by tags:";
        t5 = space();
        div1 = element("div");
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].c();
        }
        t6 = space();
        h31 = element("h3");
        h31.textContent = "Filter by text:";
        t8 = space();
        input = element("input");
        t9 = space();
        div3 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t10 = space();
        div5 = element("div");
        if (if_block) if_block.c();
        attr(div0, "class", "typo-features-info svelte-1ly2c3r");
        attr(div1, "class", "filters svelte-1ly2c3r");
        attr(input, "type", "text");
        attr(input, "placeholder", "Search for feature/hotkey/command/setting name or description");
        attr(div2, "class", "typo-features-filter svelte-1ly2c3r");
        attr(div3, "class", "typo-features-list color-scrollbar svelte-1ly2c3r");
        attr(div4, "class", "typo-features svelte-1ly2c3r");
        toggle_class(
          div4,
          "settingsVisible",
          /*selectedDetailsFeature*/
          ctx[1] !== void 0
        );
        attr(div5, "class", "typo-feature-settings color-scrollbar svelte-1ly2c3r");
        toggle_class(
          div5,
          "settingsVisible",
          /*selectedDetailsFeature*/
          ctx[1] !== void 0
        );
        attr(div6, "class", "typo-features-container svelte-1ly2c3r");
      },
      m(target, anchor) {
        insert(target, div6, anchor);
        append(div6, div4);
        append(div4, div0);
        append(div4, t3);
        append(div4, div2);
        append(div2, h30);
        append(div2, t5);
        append(div2, div1);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          if (each_blocks_1[i]) {
            each_blocks_1[i].m(div1, null);
          }
        }
        append(div2, t6);
        append(div2, h31);
        append(div2, t8);
        append(div2, input);
        set_input_value(
          input,
          /*filterContent*/
          ctx[3]
        );
        append(div4, t9);
        append(div4, div3);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div3, null);
          }
        }
        append(div6, t10);
        append(div6, div5);
        if (if_block) if_block.m(div5, null);
        current = true;
        if (!mounted) {
          dispose = listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[7]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*filterTags*/
        4) {
          each_value_1 = ensure_array_like(featureTags);
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$3(ctx2, each_value_1, i);
            if (each_blocks_1[i]) {
              each_blocks_1[i].p(child_ctx, dirty);
            } else {
              each_blocks_1[i] = create_each_block_1$3(child_ctx);
              each_blocks_1[i].c();
              each_blocks_1[i].m(div1, null);
            }
          }
          for (; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d(1);
          }
          each_blocks_1.length = each_value_1.length;
        }
        if (dirty & /*filterContent*/
        8 && input.value !== /*filterContent*/
        ctx2[3]) {
          set_input_value(
            input,
            /*filterContent*/
            ctx2[3]
          );
        }
        if (dirty & /*feature, filterTags, filterContent, $devMode, selectedDetailsFeature*/
        31) {
          each_value = ensure_array_like(
            /*feature*/
            ctx2[0].searchFeatures(
              /*feature*/
              ctx2[0].features,
              /*filterTags*/
              ctx2[2],
              /*filterContent*/
              ctx2[3]
            )
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$b(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$b(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div3, null);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
        if (!current || dirty & /*selectedDetailsFeature, undefined*/
        2) {
          toggle_class(
            div4,
            "settingsVisible",
            /*selectedDetailsFeature*/
            ctx2[1] !== void 0
          );
        }
        if (
          /*selectedDetailsFeature*/
          ctx2[1]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & /*selectedDetailsFeature*/
            2) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block$7(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(div5, null);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
        if (!current || dirty & /*selectedDetailsFeature, undefined*/
        2) {
          toggle_class(
            div5,
            "settingsVisible",
            /*selectedDetailsFeature*/
            ctx2[1] !== void 0
          );
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        transition_in(if_block);
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div6);
        }
        destroy_each(each_blocks_1, detaching);
        destroy_each(each_blocks, detaching);
        if (if_block) if_block.d();
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$k, "create_fragment$k");
  function instance$j($$self, $$props, $$invalidate) {
    let $devMode;
    let { feature } = $$props;
    const devMode = feature.devModeStore;
    component_subscribe($$self, devMode, (value) => $$invalidate(4, $devMode = value));
    let selectedDetailsFeature;
    let filterTags = [];
    let filterContent = "";
    const click_handler2 = /* @__PURE__ */ __name((tag) => {
      if (filterTags.includes(tag)) {
        $$invalidate(2, filterTags = filterTags.filter((t) => t !== tag));
      } else {
        $$invalidate(2, filterTags = [...filterTags, tag]);
      }
    }, "click_handler");
    function input_input_handler() {
      filterContent = this.value;
      $$invalidate(3, filterContent);
    }
    __name(input_input_handler, "input_input_handler");
    const func2 = /* @__PURE__ */ __name((feat) => $$invalidate(1, selectedDetailsFeature = feat), "func");
    const func_12 = /* @__PURE__ */ __name(() => $$invalidate(1, selectedDetailsFeature = void 0), "func_1");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      selectedDetailsFeature,
      filterTags,
      filterContent,
      $devMode,
      devMode,
      click_handler2,
      input_input_handler,
      func2,
      func_12
    ];
  }
  __name(instance$j, "instance$j");
  const _Controls_settings = class _Controls_settings extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$j, create_fragment$k, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Controls_settings, "Controls_settings");
  let Controls_settings = _Controls_settings;
  var __defProp$p = Object.defineProperty;
  var __decorateClass$p = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$p(target, key2, result);
    return result;
  }, "__decorateClass$p");
  const _ControlsSettingsFeature = class _ControlsSettingsFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_modalService");
      __publicField(this, "_toastService");
      __publicField(this, "_featuresService");
      __publicField(this, "_settingsService");
      __publicField(this, "name", "Typo Settings");
      __publicField(this, "description", "Customize Typo to your liking");
      __publicField(this, "tags", [
        FeatureTag.INFORMATION,
        FeatureTag.DEVELOPMENT
      ]);
      __publicField(this, "toggleEnabled", false);
      __publicField(this, "featureId", 1);
      __publicField(this, "_onboardingTask", this.useOnboardingTask({
        key: "feature_opened",
        name: "Open settings of a feature",
        description: "Click the wrench icon and open the settings of a typo feature to adjust it to your liking.",
        start: /* @__PURE__ */ __name(() => this.openSettingsPopup(), "start"),
        priority: 2
      }));
      __publicField(this, "_iconComponent");
      __publicField(this, "_iconClickSubscription");
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._iconComponent = new Icon_button({
        target: elements2.controls,
        props: {
          hoverMove: false,
          size: "48px",
          icon: "file-img-wrench-gif",
          name: "Typo Features",
          order: 1,
          tooltipAction: this.createTooltip
        }
      });
      this._iconClickSubscription = this._iconComponent.click$.subscribe(() => {
        this.openSettingsPopup();
      });
    }
    openSettingsPopup() {
      const settingsComponent = {
        componentType: Controls_settings,
        props: {
          feature: this
        }
      };
      this._modalService.showModal(
        settingsComponent.componentType,
        settingsComponent.props,
        "Typo Features"
      );
    }
    postConstruct() {
      this._settingsService.globalHotkeysList.forEach((hotkey) => this.useHotkey(hotkey));
      this.useSetting(this._settingsService.settings.devMode);
      this.useSetting(this._settingsService.settings.controlsPosition);
      this.useSetting(this._settingsService.settings.controlsDirection);
      this.useSetting(this._settingsService.settings.showLandingOutfit);
    }
    onDestroy() {
      var _a2, _b2;
      (_a2 = this._iconClickSubscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._iconComponent) == null ? void 0 : _b2.$destroy();
    }
    get hotkeys() {
      return this._settingsService.globalHotkeysList;
    }
    get features() {
      return this._featuresService.features;
    }
    get devModeStore() {
      return fromObservable(this._settingsService.settings.devMode.changes$, false);
    }
    /**
     * Set the hotkey combo for a hotkey action
     * @param hotkey
     * @param value
     */
    async setHotkeyCombo(hotkey, value) {
      const toast = await this._toastService.showLoadingToast(
        `Updating hotkey ${hotkey.name} to ${value.join(" + ")}`
      );
      try {
        await this._hotkeysService.setHotkeyCombo(hotkey, value);
      } catch {
        toast.reject();
        return;
      }
      toast.resolve();
    }
    /**
     * Resets the hotkey combo to the default value
     * @param hotkey
     */
    async resetHotkeyCombo(hotkey) {
      var _a2;
      const toast = await this._toastService.showLoadingToast(
        `Resetting hotkey ${hotkey.name} to default ${((_a2 = hotkey.defaultCombo) == null ? void 0 : _a2.join(" + ")) ?? "(disabled)"}`
      );
      let newCombo;
      try {
        newCombo = await this._hotkeysService.resetHotkeyCombo(hotkey);
      } catch {
        toast.reject();
        return;
      }
      toast.resolve();
      return newCombo;
    }
    featureImportance(tags) {
      if (tags.includes(FeatureTag.DRAWING)) return 7;
      if (tags.includes(FeatureTag.GAMEPLAY)) return 6;
      if (tags.includes(FeatureTag.INTERFACE)) return 6;
      if (tags.includes(FeatureTag.SOCIAL)) return 4;
      if (tags.includes(FeatureTag.PALANTIR)) return 3;
      if (tags.includes(FeatureTag.INFORMATION)) return 2;
      if (tags.includes(FeatureTag.DEVELOPMENT)) return 1;
      return 0;
    }
    featureContainsText(feature, content2) {
      const search = content2.toLowerCase();
      return feature.name.toLowerCase().includes(search) || feature.description.toLowerCase().includes(search) || feature.settings.some((s) => {
        var _a2, _b2;
        return ((_a2 = s.name) == null ? void 0 : _a2.toLowerCase().includes(search)) || ((_b2 = s.description) == null ? void 0 : _b2.toLowerCase().includes(search));
      }) || feature.commands.some((c) => {
        var _a2, _b2;
        return ((_a2 = c.name) == null ? void 0 : _a2.toLowerCase().includes(search)) || ((_b2 = c.description) == null ? void 0 : _b2.toLowerCase().includes(search));
      }) || feature.hotkeys.some((h) => {
        var _a2, _b2;
        return ((_a2 = h.name) == null ? void 0 : _a2.toLowerCase().includes(search)) || ((_b2 = h.description) == null ? void 0 : _b2.toLowerCase().includes(search));
      });
    }
    searchFeatures(features, filterTags, content2) {
      return features.filter((f) => filterTags.length === 0 || f.tags.some((t) => filterTags.includes(t))).filter((f) => content2.length === 0 || this.featureContainsText(f, content2)).sort((a, b) => this.featureImportance(b.tags) - this.featureImportance(a.tags));
    }
    async completeOnboardingTask() {
      (await this._onboardingTask).complete();
    }
  };
  __name(_ControlsSettingsFeature, "ControlsSettingsFeature");
  let ControlsSettingsFeature = _ControlsSettingsFeature;
  __decorateClass$p([
    inject(ElementsSetup)
  ], ControlsSettingsFeature.prototype, "_elementsSetup");
  __decorateClass$p([
    inject(ModalService)
  ], ControlsSettingsFeature.prototype, "_modalService");
  __decorateClass$p([
    inject(ToastService)
  ], ControlsSettingsFeature.prototype, "_toastService");
  __decorateClass$p([
    inject(FeaturesService)
  ], ControlsSettingsFeature.prototype, "_featuresService");
  __decorateClass$p([
    inject(GlobalSettingsService)
  ], ControlsSettingsFeature.prototype, "_settingsService");
  var __defProp$o = Object.defineProperty;
  var __decorateClass$o = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$o(target, key2, result);
    return result;
  }, "__decorateClass$o");
  const _MandalaMod = class _MandalaMod extends TypoDrawMod {
    constructor() {
      super(...arguments);
      __publicField(this, "_toolsService");
      __publicField(this, "description", "Draws an additional mirrored line to create a mandala effect.");
      __publicField(this, "icon", "var(--file-img-line-mandala-gif)");
      __publicField(this, "name", "Mandala");
      __publicField(this, "_mirrorCenterSetting", new ChoiceExtensionSetting("brushlab.mandala.center", "center").withName("Mandala Mirror Center").withDescription("The center of the mandala mirroring effect").withChoices([{ choice: "click", name: "At last click" }, { choice: "center", name: "At canvas center" }]));
      __publicField(this, "_axisSetting", new ChoiceExtensionSetting("brushlab.mandala.axis", "xy").withName("Mandala Mirror Axis").withDescription("The axis where the mandala line will be mirrored on").withChoices([{ choice: "x", name: "Horizontal" }, { choice: "y", name: "Vertical" }, { choice: "xy", name: "Both" }]));
      __publicField(this, "settings", [
        this._mirrorCenterSetting,
        this._axisSetting
      ]);
    }
    /**
     * Set the brush size depending on the pressure
     * @param line
     * @param pressure
     * @param style
     */
    async applyEffect(line, pressure, style2) {
      const axis = await firstValueFrom(this._axisSetting.changes$);
      const mirrorCenter = await firstValueFrom(this._mirrorCenterSetting.changes$);
      let center = [400, 300];
      if (mirrorCenter === "click") {
        const event = await firstValueFrom(this._toolsService.lastPointerDownPosition$);
        if (!event) center = line.from;
        else center = [event.offsetX, event.offsetY];
      }
      const mirrored = this.calculateMirroredLine(axis, center, line.from, line.to);
      return {
        style: style2,
        lines: [line, mirrored]
      };
    }
    calculateMirroredLine(axis, center, from2, to) {
      if (axis === "y") {
        return {
          from: [center[0] - (from2[0] - center[0]), from2[1]],
          to: [center[0] - (to[0] - center[0]), to[1]]
        };
      } else if (axis === "x") {
        return {
          from: [from2[0], center[1] - (from2[1] - center[1])],
          to: [to[0], center[1] - (to[1] - center[1])]
        };
      } else {
        return {
          from: [center[0] - (from2[0] - center[0]), center[1] - (from2[1] - center[1])],
          to: [center[0] - (to[0] - center[0]), center[1] - (to[1] - center[1])]
        };
      }
    }
  };
  __name(_MandalaMod, "MandalaMod");
  let MandalaMod = _MandalaMod;
  __decorateClass$o([
    inject(ToolsService)
  ], MandalaMod.prototype, "_toolsService");
  const _NoiseMod = class _NoiseMod extends ConstantDrawMod {
    constructor() {
      super(...arguments);
      __publicField(this, "description", "Randomly adds noise to drawn lines.");
      __publicField(this, "icon", "var(--file-img-line-noise-gif)");
      __publicField(this, "name", "Noise");
      __publicField(this, "_scaleSetting", new NumericExtensionSetting("brushlab.noise.scale", 5).withName("Noise Scale").withDescription("Select how much noise is added to the line").withSlider(1).withBounds(1, 100));
      __publicField(this, "settings", [
        this._scaleSetting
      ]);
    }
    async applyConstantEffect(line, pressure, style2) {
      const scale = await firstValueFrom(this._scaleSetting.changes$);
      const randomRotate = (Math.random() - 0.5) * Math.PI;
      const randomScale = 1 + (Math.random() - 0.5) * scale * style2.size / 40;
      const centerX = (line.from[0] + line.to[0]) / 2;
      const centerY = (line.from[1] + line.to[1]) / 2;
      const rotatePoint = /* @__PURE__ */ __name((x, y, angle) => {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return [
          cos * (x - centerX) - sin * (y - centerY) + centerX,
          sin * (x - centerX) + cos * (y - centerY) + centerY
        ];
      }, "rotatePoint");
      const from2 = rotatePoint(line.from[0], line.from[1], randomRotate);
      const to = rotatePoint(line.to[0], line.to[1], randomRotate);
      from2[0] = centerX + (from2[0] - centerX) * randomScale;
      from2[1] = centerY + (from2[1] - centerY) * randomScale;
      to[0] = centerX + (to[0] - centerX) * randomScale;
      to[1] = centerY + (to[1] - centerY) * randomScale;
      return {
        style: style2,
        line: { from: from2, to }
      };
    }
  };
  __name(_NoiseMod, "NoiseMod");
  let NoiseMod = _NoiseMod;
  const _ParallelLineMod = class _ParallelLineMod extends TypoDrawMod {
    constructor() {
      super(...arguments);
      __publicField(this, "description", "Draws additional parallel lines in a angle and distance. In public lobbies, a max of 1 parallel line should be used.");
      __publicField(this, "icon", "var(--file-img-line-parallel-gif)");
      __publicField(this, "name", "Parallel");
      __publicField(this, "_distanceSetting", new NumericExtensionSetting("brushlab.parallel.distance", 20).withName("Line Distance").withDescription("The distance between the lines").withSlider(1).withBounds(1, 100));
      __publicField(this, "_distanceDependencySetting", new BooleanExtensionSetting("brushlab.parallel.dependency", false).withName("Size Dependency").withDescription("Make line distance proportionally dependent on brush size"));
      __publicField(this, "_angleSetting", new NumericExtensionSetting("brushlab.parallel.angle", 180).withName("Line Angle").withDescription("The clockwise angle where the parallel lines are drawn with the distance offset").withSlider(1).withBounds(1, 360));
      __publicField(this, "_lineCountSetting", new NumericExtensionSetting("brushlab.parallel.count", 1).withName("Line Count").withDescription("The amount of parallel lines drawn").withSlider(1).withBounds(1, 4));
      __publicField(this, "settings", [
        this._distanceSetting,
        this._distanceDependencySetting,
        this._angleSetting,
        this._lineCountSetting
      ]);
    }
    /**
     * Set the brush size depending on the pressure
     * @param line
     * @param pressure
     * @param style
     */
    async applyEffect(line, pressure, style2) {
      const distance = await firstValueFrom(this._distanceSetting.changes$);
      const angle = await firstValueFrom(this._angleSetting.changes$);
      const count = await firstValueFrom(this._lineCountSetting.changes$);
      const dependency = await firstValueFrom(this._distanceDependencySetting.changes$);
      const lines = [];
      const offset = this.getOffset(distance, angle);
      if (dependency) {
        offset[0] *= style2.size / 40;
        offset[1] *= style2.size / 40;
      }
      for (let i = 0; i < count; i++) {
        const offsetLine = {
          from: [line.from[0] + offset[0] * (i + 1), line.from[1] + offset[1] * (i + 1)],
          to: [line.to[0] + offset[0] * (i + 1), line.to[1] + offset[1] * (i + 1)]
        };
        lines.push(offsetLine);
      }
      return {
        style: style2,
        lines: [line, ...lines]
      };
    }
    getOffset(distance, angle) {
      const angleRad = angle * Math.PI / 180;
      const x = Math.cos(angleRad) * distance;
      const y = Math.sin(angleRad) * distance;
      return [x, y];
    }
  };
  __name(_ParallelLineMod, "ParallelLineMod");
  let ParallelLineMod = _ParallelLineMod;
  const _RainbowMod = class _RainbowMod extends ConstantDrawMod {
    constructor() {
      super(...arguments);
      __publicField(this, "description", "Switches colors while drawing to create a rainbow effect.");
      __publicField(this, "icon", "var(--file-img-line-rainbow-gif)");
      __publicField(this, "name", "Rainbow");
      __publicField(this, "_rainbowModeSetting", new ChoiceExtensionSetting("brushlab.rainbow.mode", "light").withName("Rainbow Colors").withDescription("Choose between the rainbow color shades").withChoices([{ choice: "light", name: "Light Colors" }, { choice: "dark", name: "Dark Colors" }]));
      __publicField(this, "_colorSwitchSetting", new NumericExtensionSetting("brushlab.rainbow.distance", 20).withName("Color Switch Distance").withDescription("The distance between the color switches").withSlider(1).withBounds(1, 100));
      __publicField(this, "lastSwitch");
      __publicField(this, "settings", [
        this._rainbowModeSetting,
        this._colorSwitchSetting
      ]);
    }
    async applyConstantEffect(line, pressure, style2, eventId, strokeId) {
      var _a2;
      const mode = await firstValueFrom(this._rainbowModeSetting.changes$);
      const distance = await firstValueFrom(this._colorSwitchSetting.changes$);
      const colors = Color.skribblColors.filter((color, index) => index % 2 === 0 ? mode === "light" : mode === "dark");
      if (this.lastSwitch === void 0 || this.lastSwitch.strokeId !== strokeId || this.lastSwitch.eventId !== eventId && this.getDistance(this.lastSwitch.position, line.from) > style2.size / 10 * distance) {
        let index = ((((_a2 = this.lastSwitch) == null ? void 0 : _a2.index) ?? -1) + 1) % (colors.length - 1);
        if (index < 2) index = 2;
        style2.color = index * 2 + (mode === "light" ? 0 : 1);
        this.lastSwitch = {
          eventId,
          position: line.from,
          index,
          strokeId
        };
      }
      return {
        style: style2,
        line
      };
    }
    getDistance(from2, to) {
      return Math.sqrt(Math.pow(to[0] - from2[0], 2) + Math.pow(to[1] - from2[1], 2));
    }
  };
  __name(_RainbowMod, "RainbowMod");
  let RainbowMod = _RainbowMod;
  var __defProp$n = Object.defineProperty;
  var __decorateClass$n = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$n(target, key2, result);
    return result;
  }, "__decorateClass$n");
  const _RandomColorMod = class _RandomColorMod extends ConstantDrawMod {
    constructor() {
      super(...arguments);
      __publicField(this, "_colorsService");
      __publicField(this, "description", "Switches colors of the current palette randomly while drawing.");
      __publicField(this, "icon", "var(--file-img-line-random-color-gif)");
      __publicField(this, "name", "Random Colors");
      __publicField(this, "_colorSwitchSetting", new NumericExtensionSetting("brushlab.rainbow.distance", 20).withName("Color Switch Distance").withDescription("The distance between the color switches").withSlider(1).withBounds(1, 100));
      __publicField(this, "lastSwitch");
      __publicField(this, "settings", [
        this._colorSwitchSetting
      ]);
    }
    async applyConstantEffect(line, pressure, style2, eventId, strokeId) {
      const distance = await firstValueFrom(this._colorSwitchSetting.changes$);
      const colors = await firstValueFrom(this._colorsService.pickerColors$) ?? defaultPalettes.skribblPalette;
      if (this.lastSwitch === void 0 || this.lastSwitch.strokeId !== strokeId || this.lastSwitch.eventId !== eventId && this.getDistance(this.lastSwitch.position, line.from) > style2.size / 10 * distance) {
        const index = Math.floor(Math.random() * colors.colorHexCodes.length);
        const color = Color.fromHex(colors.colorHexCodes[index]);
        style2.color = color.typoCode;
        this.lastSwitch = {
          eventId,
          position: line.from,
          strokeId
        };
      }
      return {
        style: style2,
        line
      };
    }
    getDistance(from2, to) {
      return Math.sqrt(Math.pow(to[0] - from2[0], 2) + Math.pow(to[1] - from2[1], 2));
    }
  };
  __name(_RandomColorMod, "RandomColorMod");
  let RandomColorMod = _RandomColorMod;
  __decorateClass$n([
    inject(ColorsService)
  ], RandomColorMod.prototype, "_colorsService");
  var __defProp$m = Object.defineProperty;
  var __decorateClass$m = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$m(target, key2, result);
    return result;
  }, "__decorateClass$m");
  const _SculptMod = class _SculptMod extends TypoDrawMod {
    constructor() {
      super(...arguments);
      __publicField(this, "_toolsService");
      __publicField(this, "description", "Creates a figure by mirroring and connecting the line on a axis.");
      __publicField(this, "icon", "var(--file-img-line-sculpt-gif)");
      __publicField(this, "name", "Sculpt");
      __publicField(this, "_mirrorCenterSetting", new ChoiceExtensionSetting("brushlab.sculpt.center", "center").withName("Sculpt Mirror Center").withDescription("The center of the sculpt figure mirroring effect").withChoices([{ choice: "click", name: "At last click" }, { choice: "center", name: "At canvas center" }]));
      __publicField(this, "_axisSetting", new ChoiceExtensionSetting("brushlab.sculpt.axis", "xy").withName("Sculpt Mirror Axis").withDescription("The axis where the sculpt figure will be mirrored on").withChoices([{ choice: "x", name: "Horizontal" }, { choice: "y", name: "Vertical" }, { choice: "xy", name: "Both" }]));
      __publicField(this, "settings", [
        this._mirrorCenterSetting,
        this._axisSetting
      ]);
    }
    async applyEffect(line, pressure, style2) {
      const axis = await firstValueFrom(this._axisSetting.changes$);
      const mirrorCenter = await firstValueFrom(this._mirrorCenterSetting.changes$);
      let center = [400, 300];
      if (mirrorCenter === "click") {
        const event = await firstValueFrom(this._toolsService.lastPointerDownPosition$);
        if (!event) center = line.from;
        else center = [event.offsetX, event.offsetY];
      }
      const originalLineCenter = [(line.from[0] + line.to[0]) / 2, (line.from[1] + line.to[1]) / 2];
      const mirroredLineCenter = this.calculateMirroredPoint(center, originalLineCenter, axis);
      return {
        style: style2,
        lines: [
          { from: line.from, to: mirroredLineCenter },
          { from: mirroredLineCenter, to: line.to }
        ]
      };
    }
    calculateMirroredPoint(center, point, axis) {
      if (axis === "x") {
        return [point[0], 2 * center[1] - point[1]];
      } else if (axis === "y") {
        return [2 * center[0] - point[0], point[1]];
      } else {
        return [2 * center[0] - point[0], 2 * center[1] - point[1]];
      }
    }
  };
  __name(_SculptMod, "SculptMod");
  let SculptMod = _SculptMod;
  __decorateClass$m([
    inject(ToolsService)
  ], SculptMod.prototype, "_toolsService");
  const _TiltMod = class _TiltMod extends ConstantDrawMod {
    constructor() {
      super(...arguments);
      __publicField(this, "description", "Tilt the line into a direction.");
      __publicField(this, "icon", "var(--file-img-line-tilt-gif)");
      __publicField(this, "name", "Tilt");
      __publicField(this, "_distanceSetting", new NumericExtensionSetting("brushlab.tilt.size", 20).withName("Tilt Size").withDescription("The size of the tilted line").withSlider(1).withBounds(1, 100));
      __publicField(this, "_distanceDependencySetting", new BooleanExtensionSetting("brushlab.tilt.dependency", false).withName("Size Dependency").withDescription("Make tilt size proportionally dependent on brush size"));
      __publicField(this, "_angleSetting", new NumericExtensionSetting("brushlab.tilt.angle", 180).withName("Tilt Angle").withDescription("The clockwise angle where the tilt lines created").withSlider(1).withBounds(1, 360));
      __publicField(this, "settings", [
        this._distanceSetting,
        this._distanceDependencySetting,
        this._angleSetting
      ]);
    }
    async applyConstantEffect(line, pressure, style2) {
      const distance = await firstValueFrom(this._distanceSetting.changes$);
      const angle = await firstValueFrom(this._angleSetting.changes$);
      const dependency = await firstValueFrom(this._distanceDependencySetting.changes$);
      const offset = this.getOffset(distance, angle - 90);
      if (dependency) {
        offset[0] *= style2.size / 40;
        offset[1] *= style2.size / 40;
      }
      const offsetLine = {
        from: line.from,
        to: [line.to[0] + offset[0], line.to[1] + offset[1]]
      };
      return {
        style: style2,
        line: offsetLine
      };
    }
    getOffset(distance, angle) {
      const angleRad = angle * Math.PI / 180;
      const x = Math.cos(angleRad) * distance;
      const y = Math.sin(angleRad) * distance;
      return [x, y];
    }
  };
  __name(_TiltMod, "TiltMod");
  let TiltMod = _TiltMod;
  const _DashTool = class _DashTool extends TypoDrawTool {
    constructor() {
      super(...arguments);
      __publicField(this, "name", "Dashed Lines");
      __publicField(this, "description", "Draw dashed lines with a customizable interval and blank size");
      __publicField(this, "icon", "var(--file-img-line-dash-gif)");
      __publicField(this, "_intervalSetting", new NumericExtensionSetting("brushlab.dash.interval", 10).withName("Dash Interval").withDescription("The time interval between making line blanks in milliseconds").withSlider(1).withBounds(1, 300));
      __publicField(this, "_blankSizeSetting", new NumericExtensionSetting("brushlab.dash.blank", 20).withName("Blank Size").withDescription("The size of the blanks between dashes, depending on brush size").withSlider(1).withBounds(1, 100));
      __publicField(this, "settings", [
        this._intervalSetting,
        this._blankSizeSetting
      ]);
      __publicField(this, "dashStart");
      __publicField(this, "lineStart");
      __publicField(this, "applyConstantEffect", this.noConstantEffect);
    }
    createCursor(style2) {
      return this.createSkribblLikeCursor(style2);
    }
    async createCommands(line, pressure, style2, eventId) {
      const interval2 = await firstValueFrom(this._intervalSetting.changes$);
      const blankSize = await firstValueFrom(this._blankSizeSetting.changes$);
      const now = Date.now();
      if (this.dashStart !== void 0) {
        if (this.getDistance(this.dashStart.position, line.from) > style2.size / 10 * blankSize) {
          this.dashStart = void 0;
        }
        return [];
      }
      if (this.lineStart !== void 0 && now - this.lineStart.time > interval2) {
        this.lineStart = void 0;
        this.dashStart = { eventId, position: line.to };
        return [];
      }
      if (this.lineStart === void 0) {
        this.lineStart = { eventId, time: now };
      }
      return [[0, style2.color, style2.size, ...line.from, ...line.to]];
    }
    getDistance(from2, to) {
      return Math.sqrt(Math.pow(to[0] - from2[0], 2) + Math.pow(to[1] - from2[1], 2));
    }
  };
  __name(_DashTool, "DashTool");
  let DashTool = _DashTool;
  const _DotTool = class _DotTool extends TypoDrawTool {
    constructor() {
      super(...arguments);
      __publicField(this, "name", "Dotted Lines");
      __publicField(this, "description", "Draw dotted lines with a customizable interval");
      __publicField(this, "icon", "var(--file-img-line-dot-gif)");
      __publicField(this, "_intervalSetting", new NumericExtensionSetting("brushlab.dot.interval", 10).withName("Dot Interval").withDescription("The time interval between making dots in milliseconds").withSlider(1).withBounds(1, 1e3));
      __publicField(this, "settings", [this._intervalSetting]);
      __publicField(this, "lastDown", { eventId: 0, time: Date.now() });
      __publicField(this, "applyConstantEffect", this.noConstantEffect);
    }
    createCursor(style2) {
      return this.createSkribblLikeCursor(style2);
    }
    async createCommands(line, pressure, style2, eventId) {
      const interval2 = await firstValueFrom(this._intervalSetting.changes$);
      const now = Date.now();
      if (this.lastDown.eventId === eventId) {
        return [[0, style2.color, style2.size, ...line.to, ...line.to]];
      } else if (now - this.lastDown.time > interval2) {
        this.lastDown.time = now;
        this.lastDown.eventId = eventId;
        return [[0, style2.color, style2.size, ...line.to, ...line.to]];
      }
      return [];
    }
  };
  __name(_DotTool, "DotTool");
  let DotTool = _DotTool;
  var __defProp$l = Object.defineProperty;
  var __decorateClass$l = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$l(target, key2, result);
    return result;
  }, "__decorateClass$l");
  const _GridTool = class _GridTool extends TypoDrawTool {
    constructor() {
      super(...arguments);
      __publicField(this, "_toolsService");
      __publicField(this, "name", "Grid Generator");
      __publicField(this, "description", "Click anywhere on the canvas to create a grid");
      __publicField(this, "icon", "var(--file-img-line-grid-gif)");
      __publicField(this, "_rowsSetting", new NumericExtensionSetting("brushlab.grid.rows", 6).withName("Row Count").withDescription("The amount of rows in the grid").withSlider(1).withBounds(1, 30));
      __publicField(this, "_columnsSetting", new NumericExtensionSetting("brushlab.grid.columns", 8).withName("Column Count").withDescription("The amount of columns in the grid").withSlider(1).withBounds(1, 30));
      __publicField(this, "settings", [
        this._rowsSetting,
        this._columnsSetting
      ]);
      __publicField(this, "_lastDownEvent", null);
      __publicField(this, "applyConstantEffect", this.noConstantEffect);
    }
    createCursor() {
      return { source: "var(--file-img-grid_cur-png)", x: 7, y: 37 };
    }
    async createCommands(line, pressure, style2) {
      const lastPointerDown = await firstValueFrom(this._toolsService.lastPointerDownPosition$);
      if (lastPointerDown === null || this._lastDownEvent === lastPointerDown) {
        return [];
      }
      this._lastDownEvent = lastPointerDown;
      const canvasWidth = 800;
      const canvasHeight = 600;
      const rows = await firstValueFrom(this._rowsSetting.changes$);
      const columns = await firstValueFrom(this._columnsSetting.changes$);
      const rowHeight = Math.ceil(canvasHeight / rows);
      const columnWidth = Math.ceil(canvasWidth / columns);
      const commands = [];
      for (let i = 1; i < rows; i++) {
        commands.push([0, style2.color, style2.size, 0, i * rowHeight, canvasWidth, i * rowHeight]);
      }
      for (let i = 1; i < columns; i++) {
        commands.push([0, style2.color, style2.size, i * columnWidth, 0, i * columnWidth, canvasHeight]);
      }
      return commands;
    }
  };
  __name(_GridTool, "GridTool");
  let GridTool = _GridTool;
  __decorateClass$l([
    inject(ToolsService)
  ], GridTool.prototype, "_toolsService");
  function create_fragment$j(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        div.innerHTML = ``;
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_fragment$j, "create_fragment$j");
  function instance$i($$self, $$props, $$invalidate) {
    let { feature } = $$props;
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [feature];
  }
  __name(instance$i, "instance$i");
  const _Drawing_brush_lab_info = class _Drawing_brush_lab_info extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$i, create_fragment$j, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Drawing_brush_lab_info, "Drawing_brush_lab_info");
  let Drawing_brush_lab_info = _Drawing_brush_lab_info;
  function create_fragment$i(ctx) {
    let div1;
    let mounted;
    let dispose;
    return {
      c() {
        div1 = element("div");
        div1.innerHTML = `<div class="icon" style="background-image: var(--file-img-wand-gif)"></div>`;
        attr(div1, "class", "typo-brush-lab-switch tool clickable");
        toggle_class(
          div1,
          "expanded",
          /*expanded*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        if (!mounted) {
          dispose = [
            listen(
              div1,
              "click",
              /*click_handler*/
              ctx[3]
            ),
            action_destroyer(
              /*feature*/
              ctx[0].createTooltip(div1, { title: "Toggle Brush Lab", lock: "Y" })
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*expanded*/
        2) {
          toggle_class(
            div1,
            "expanded",
            /*expanded*/
            ctx2[1]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$i, "create_fragment$i");
  function instance$h($$self, $$props, $$invalidate) {
    const toggle = /* @__PURE__ */ __name(() => {
      $$invalidate(1, expanded = !expanded);
    }, "toggle");
    let { feature } = $$props;
    let expanded = false;
    const click_handler2 = /* @__PURE__ */ __name(() => $$invalidate(1, expanded = !expanded), "click_handler");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [feature, expanded, toggle, click_handler2];
  }
  __name(instance$h, "instance$h");
  const _Drawing_brush_lab_switch = class _Drawing_brush_lab_switch extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$h, create_fragment$i, safe_not_equal, { toggle: 2, feature: 0 });
    }
    get toggle() {
      return this.$$.ctx[2];
    }
  };
  __name(_Drawing_brush_lab_switch, "Drawing_brush_lab_switch");
  let Drawing_brush_lab_switch = _Drawing_brush_lab_switch;
  function get_each_context$a(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[6] = list[i];
    return child_ctx;
  }
  __name(get_each_context$a, "get_each_context$a");
  function get_each_context_1$2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[9] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1$2, "get_each_context_1$2");
  function create_each_block_1$2(ctx) {
    let div1;
    let div0;
    let t;
    let feature_createTooltip_action;
    let mounted;
    let dispose;
    function click_handler_1() {
      return (
        /*click_handler_1*/
        ctx[4](
          /*mod*/
          ctx[9]
        )
      );
    }
    __name(click_handler_1, "click_handler_1");
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        t = space();
        attr(div0, "class", "icon");
        set_style(
          div0,
          "background-image",
          /*mod*/
          ctx[9].item.icon
        );
        attr(div1, "class", "tool clickable");
        toggle_class(
          div1,
          "selected",
          /*mod*/
          ctx[9].active
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div1, t);
        if (!mounted) {
          dispose = [
            action_destroyer(feature_createTooltip_action = /*feature*/
            ctx[0].createTooltip(div1, {
              title: (
                /*mod*/
                ctx[9].item.name
              ),
              lock: "Y"
            })),
            listen(div1, "click", click_handler_1)
          ];
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*$tools*/
        2) {
          set_style(
            div0,
            "background-image",
            /*mod*/
            ctx[9].item.icon
          );
        }
        if (feature_createTooltip_action && is_function(feature_createTooltip_action.update) && dirty & /*$tools*/
        2) feature_createTooltip_action.update.call(null, {
          title: (
            /*mod*/
            ctx[9].item.name
          ),
          lock: "Y"
        });
        if (dirty & /*$tools*/
        2) {
          toggle_class(
            div1,
            "selected",
            /*mod*/
            ctx[9].active
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_each_block_1$2, "create_each_block_1$2");
  function create_each_block$a(ctx) {
    let div1;
    let div0;
    let t;
    let feature_createTooltip_action;
    let mounted;
    let dispose;
    function click_handler_2() {
      return (
        /*click_handler_2*/
        ctx[5](
          /*tool*/
          ctx[6]
        )
      );
    }
    __name(click_handler_2, "click_handler_2");
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        t = space();
        attr(div0, "class", "icon");
        set_style(
          div0,
          "background-image",
          /*tool*/
          ctx[6].item.icon
        );
        attr(div1, "class", "tool clickable");
        toggle_class(
          div1,
          "selected",
          /*tool*/
          ctx[6].active
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div1, t);
        if (!mounted) {
          dispose = [
            action_destroyer(feature_createTooltip_action = /*feature*/
            ctx[0].createTooltip(div1, {
              title: (
                /*tool*/
                ctx[6].item.name
              ),
              lock: "Y"
            })),
            listen(div1, "click", click_handler_2)
          ];
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*$tools*/
        2) {
          set_style(
            div0,
            "background-image",
            /*tool*/
            ctx[6].item.icon
          );
        }
        if (feature_createTooltip_action && is_function(feature_createTooltip_action.update) && dirty & /*$tools*/
        2) feature_createTooltip_action.update.call(null, {
          title: (
            /*tool*/
            ctx[6].item.name
          ),
          lock: "Y"
        });
        if (dirty & /*$tools*/
        2) {
          toggle_class(
            div1,
            "selected",
            /*tool*/
            ctx[6].active
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_each_block$a, "create_each_block$a");
  function create_fragment$h(ctx) {
    let div5;
    let div2;
    let div1;
    let t0;
    let div3;
    let t1;
    let div4;
    let mounted;
    let dispose;
    let each_value_1 = ensure_array_like(
      /*$tools*/
      ctx[1].mods
    );
    let each_blocks_1 = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    }
    let each_value = ensure_array_like(
      /*$tools*/
      ctx[1].tools
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    }
    return {
      c() {
        div5 = element("div");
        div2 = element("div");
        div1 = element("div");
        div1.innerHTML = `<div class="icon" style="background-image: var(--file-img-wrench-gif)"></div>`;
        t0 = space();
        div3 = element("div");
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].c();
        }
        t1 = space();
        div4 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div1, "class", "tool clickable");
        attr(div2, "class", "typo-brush-lab-settings");
        attr(div3, "class", "typo-brush-lab-mods svelte-p5jc91");
        attr(div4, "class", "typo-brush-lab-tools svelte-p5jc91");
        attr(div5, "class", "typo-brush-lab-group svelte-p5jc91");
      },
      m(target, anchor) {
        insert(target, div5, anchor);
        append(div5, div2);
        append(div2, div1);
        append(div5, t0);
        append(div5, div3);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          if (each_blocks_1[i]) {
            each_blocks_1[i].m(div3, null);
          }
        }
        append(div5, t1);
        append(div5, div4);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div4, null);
          }
        }
        if (!mounted) {
          dispose = [
            action_destroyer(
              /*feature*/
              ctx[0].createTooltip(div1, { title: "Brush Lab Settings", lock: "Y" })
            ),
            listen(
              div1,
              "click",
              /*click_handler*/
              ctx[3]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*$tools, feature*/
        3) {
          each_value_1 = ensure_array_like(
            /*$tools*/
            ctx2[1].mods
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$2(ctx2, each_value_1, i);
            if (each_blocks_1[i]) {
              each_blocks_1[i].p(child_ctx, dirty);
            } else {
              each_blocks_1[i] = create_each_block_1$2(child_ctx);
              each_blocks_1[i].c();
              each_blocks_1[i].m(div3, null);
            }
          }
          for (; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d(1);
          }
          each_blocks_1.length = each_value_1.length;
        }
        if (dirty & /*$tools, feature*/
        3) {
          each_value = ensure_array_like(
            /*$tools*/
            ctx2[1].tools
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$a(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$a(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div4, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div5);
        }
        destroy_each(each_blocks_1, detaching);
        destroy_each(each_blocks, detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$h, "create_fragment$h");
  function instance$g($$self, $$props, $$invalidate) {
    let $tools;
    let { feature } = $$props;
    const tools = feature.toolbarItemsStore;
    component_subscribe($$self, tools, (value) => $$invalidate(1, $tools = value));
    const click_handler2 = /* @__PURE__ */ __name(() => feature.openBrushLabSettings(), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name((mod) => {
      if (!mod.active) {
        feature.activateMod(mod.item);
      } else {
        feature.removeMod(mod.item);
      }
    }, "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name((tool) => {
      if (!tool.active) {
        feature.activateTool(tool.item);
      } else {
        feature.activateTool(skribblTool.brush);
      }
    }, "click_handler_2");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [feature, $tools, tools, click_handler2, click_handler_1, click_handler_2];
  }
  __name(instance$g, "instance$g");
  const _Drawing_brush_lab_group = class _Drawing_brush_lab_group extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$g, create_fragment$h, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Drawing_brush_lab_group, "Drawing_brush_lab_group");
  let Drawing_brush_lab_group = _Drawing_brush_lab_group;
  function get_each_context$9(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[9] = list[i];
    return child_ctx;
  }
  __name(get_each_context$9, "get_each_context$9");
  function get_each_context_1$1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[12] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1$1, "get_each_context_1$1");
  function get_each_context_2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[12] = list[i];
    return child_ctx;
  }
  __name(get_each_context_2, "get_each_context_2");
  function get_each_context_3(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[17] = list[i];
    return child_ctx;
  }
  __name(get_each_context_3, "get_each_context_3");
  function create_each_block_3(ctx) {
    let div;
    let img;
    let img_src_value;
    let t0;
    let b;
    let t1_value = (
      /*tool*/
      ctx[17].item.name + ""
    );
    let t1;
    let mounted;
    let dispose;
    function click_handler2() {
      return (
        /*click_handler*/
        ctx[4](
          /*tool*/
          ctx[17]
        )
      );
    }
    __name(click_handler2, "click_handler");
    return {
      c() {
        div = element("div");
        img = element("img");
        t0 = space();
        b = element("b");
        t1 = text(t1_value);
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        set_style(
          img,
          "content",
          /*tool*/
          ctx[17].item.icon
        );
        attr(img, "alt", "icon");
        attr(img, "class", "svelte-15vhuqn");
        attr(b, "class", "svelte-15vhuqn");
        attr(div, "class", "item-sidebar-entry svelte-15vhuqn");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, img);
        append(div, t0);
        append(div, b);
        append(b, t1);
        if (!mounted) {
          dispose = listen(div, "click", click_handler2);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*$items*/
        1) {
          set_style(
            img,
            "content",
            /*tool*/
            ctx[17].item.icon
          );
        }
        if (dirty & /*$items*/
        1 && t1_value !== (t1_value = /*tool*/
        ctx[17].item.name + "")) set_data(t1, t1_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block_3, "create_each_block_3");
  function create_each_block_2(ctx) {
    let div;
    let img;
    let img_src_value;
    let t0;
    let b;
    let t1_value = (
      /*mod*/
      ctx[12].item.name + ""
    );
    let t1;
    let mounted;
    let dispose;
    function click_handler_1() {
      return (
        /*click_handler_1*/
        ctx[6](
          /*mod*/
          ctx[12]
        )
      );
    }
    __name(click_handler_1, "click_handler_1");
    return {
      c() {
        div = element("div");
        img = element("img");
        t0 = space();
        b = element("b");
        t1 = text(t1_value);
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        set_style(
          img,
          "content",
          /*mod*/
          ctx[12].item.icon
        );
        attr(img, "alt", "icon");
        attr(img, "class", "svelte-15vhuqn");
        attr(b, "class", "svelte-15vhuqn");
        attr(div, "class", "item-sidebar-entry svelte-15vhuqn");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, img);
        append(div, t0);
        append(div, b);
        append(b, t1);
        if (!mounted) {
          dispose = listen(div, "click", click_handler_1);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*$items*/
        1) {
          set_style(
            img,
            "content",
            /*mod*/
            ctx[12].item.icon
          );
        }
        if (dirty & /*$items*/
        1 && t1_value !== (t1_value = /*mod*/
        ctx[12].item.name + "")) set_data(t1, t1_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block_2, "create_each_block_2");
  function create_each_block_1$1(ctx) {
    let div;
    let img;
    let img_src_value;
    let t0;
    let b;
    let t1_value = (
      /*mod*/
      ctx[12].item.name + ""
    );
    let t1;
    let t2;
    let mounted;
    let dispose;
    function click_handler_2() {
      return (
        /*click_handler_2*/
        ctx[8](
          /*mod*/
          ctx[12]
        )
      );
    }
    __name(click_handler_2, "click_handler_2");
    return {
      c() {
        div = element("div");
        img = element("img");
        t0 = space();
        b = element("b");
        t1 = text(t1_value);
        t2 = space();
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        set_style(
          img,
          "content",
          /*mod*/
          ctx[12].item.icon
        );
        attr(img, "alt", "icon");
        attr(img, "class", "svelte-15vhuqn");
        attr(b, "class", "svelte-15vhuqn");
        attr(div, "class", "item-sidebar-entry svelte-15vhuqn");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, img);
        append(div, t0);
        append(div, b);
        append(b, t1);
        append(div, t2);
        if (!mounted) {
          dispose = listen(div, "click", click_handler_2);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*$items*/
        1) {
          set_style(
            img,
            "content",
            /*mod*/
            ctx[12].item.icon
          );
        }
        if (dirty & /*$items*/
        1 && t1_value !== (t1_value = /*mod*/
        ctx[12].item.name + "")) set_data(t1, t1_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block_1$1, "create_each_block_1$1");
  function create_if_block$6(ctx) {
    let div;
    let current;
    let each_value = ensure_array_like(
      /*selectedItem*/
      ctx[1].settings
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div, "class", "item-details-settings-list svelte-15vhuqn");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*selectedItem*/
        2) {
          each_value = ensure_array_like(
            /*selectedItem*/
            ctx2[1].settings
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$9(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$9(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div, null);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_if_block$6, "create_if_block$6");
  function create_each_block$9(ctx) {
    let div;
    let switch_instance;
    let t;
    let current;
    const switch_instance_spread_levels = [
      /*setting*/
      ctx[9].componentData.props
    ];
    var switch_value = (
      /*setting*/
      ctx[9].componentData.componentType
    );
    function switch_props(ctx2, dirty) {
      let switch_instance_props = {};
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      if (dirty !== void 0 && dirty & /*selectedItem*/
      2) {
        switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*setting*/
          ctx2[9].componentData.props
        )]));
      }
      return { props: switch_instance_props };
    }
    __name(switch_props, "switch_props");
    if (switch_value) {
      switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    }
    return {
      c() {
        div = element("div");
        if (switch_instance) create_component(switch_instance.$$.fragment);
        t = space();
        attr(div, "class", "item-details-settings-item svelte-15vhuqn");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if (switch_instance) mount_component(switch_instance, div, null);
        append(div, t);
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*selectedItem*/
        2 && switch_value !== (switch_value = /*setting*/
        ctx2[9].componentData.componentType)) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, div, t);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          const switch_instance_changes = dirty & /*selectedItem*/
          2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
            /*setting*/
            ctx2[9].componentData.props
          )]) : {};
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current) return;
        if (switch_instance) transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance) transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if (switch_instance) destroy_component(switch_instance);
      }
    };
  }
  __name(create_each_block$9, "create_each_block$9");
  function create_fragment$g(ctx) {
    var _a2, _b2;
    let p0;
    let t3;
    let div3;
    let div0;
    let h30;
    let t5;
    let t6;
    let h31;
    let t8;
    let t9;
    let h32;
    let t11;
    let t12;
    let div2;
    let div1;
    let img;
    let img_src_value;
    let t13;
    let h2;
    let t14_value = (
      /*selectedItem*/
      ((_a2 = ctx[1]) == null ? void 0 : _a2.name) + ""
    );
    let t14;
    let t15;
    let b;
    let t16;
    let t17_value = (
      /*selectedItem*/
      ctx[1] instanceof ConstantDrawMod ? (
        /*selectedItem*/
        ctx[1] instanceof TypoDrawTool ? "TOOL" : "COMBO MOD"
      ) : "MOD"
    );
    let t17;
    let t18;
    let t19;
    let p1;
    let t20_value = (
      /*selectedItem*/
      ((_b2 = ctx[1]) == null ? void 0 : _b2.description) + ""
    );
    let t20;
    let t21;
    let current;
    let each_value_3 = ensure_array_like(
      /*$items*/
      ctx[0].tools
    );
    let each_blocks_2 = [];
    for (let i = 0; i < each_value_3.length; i += 1) {
      each_blocks_2[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    }
    let each_value_2 = ensure_array_like(
      /*$items*/
      ctx[0].mods.filter(
        /*func*/
        ctx[5]
      )
    );
    let each_blocks_1 = [];
    for (let i = 0; i < each_value_2.length; i += 1) {
      each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    }
    let each_value_1 = ensure_array_like(
      /*$items*/
      ctx[0].mods.filter(
        /*func_1*/
        ctx[7]
      )
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    }
    let if_block = (
      /*selectedItem*/
      ctx[1] !== void 0 && /*selectedItem*/
      ctx[1].settings.length > 0 && create_if_block$6(ctx)
    );
    return {
      c() {
        var _a3;
        p0 = element("p");
        p0.innerHTML = `The Brush Laboratory has many mods and tools to create unique masterpices.<br/>
  Below, you can find all available tools and mods and their settings.<br/>
  Additionally to a tool, you can select one mod and multiple combo mods.`;
        t3 = space();
        div3 = element("div");
        div0 = element("div");
        h30 = element("h3");
        h30.textContent = "Tools";
        t5 = space();
        for (let i = 0; i < each_blocks_2.length; i += 1) {
          each_blocks_2[i].c();
        }
        t6 = space();
        h31 = element("h3");
        h31.textContent = "Mods";
        t8 = space();
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].c();
        }
        t9 = space();
        h32 = element("h3");
        h32.textContent = "Combo Mods";
        t11 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t12 = space();
        div2 = element("div");
        div1 = element("div");
        img = element("img");
        t13 = space();
        h2 = element("h2");
        t14 = text(t14_value);
        t15 = space();
        b = element("b");
        t16 = text("(");
        t17 = text(t17_value);
        t18 = text(")");
        t19 = space();
        p1 = element("p");
        t20 = text(t20_value);
        t21 = space();
        if (if_block) if_block.c();
        attr(h30, "class", "svelte-15vhuqn");
        attr(h31, "class", "svelte-15vhuqn");
        attr(h32, "class", "svelte-15vhuqn");
        attr(div0, "class", "item-sidebar svelte-15vhuqn");
        if (!src_url_equal(img.src, img_src_value = "")) attr(img, "src", img_src_value);
        set_style(
          img,
          "content",
          /*selectedItem*/
          (_a3 = ctx[1]) == null ? void 0 : _a3.icon
        );
        attr(img, "alt", "icon");
        attr(img, "class", "svelte-15vhuqn");
        attr(b, "class", "svelte-15vhuqn");
        attr(div1, "class", "item-title svelte-15vhuqn");
        attr(div2, "class", "item-details svelte-15vhuqn");
        attr(div3, "class", "item-selection svelte-15vhuqn");
      },
      m(target, anchor) {
        insert(target, p0, anchor);
        insert(target, t3, anchor);
        insert(target, div3, anchor);
        append(div3, div0);
        append(div0, h30);
        append(div0, t5);
        for (let i = 0; i < each_blocks_2.length; i += 1) {
          if (each_blocks_2[i]) {
            each_blocks_2[i].m(div0, null);
          }
        }
        append(div0, t6);
        append(div0, h31);
        append(div0, t8);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          if (each_blocks_1[i]) {
            each_blocks_1[i].m(div0, null);
          }
        }
        append(div0, t9);
        append(div0, h32);
        append(div0, t11);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
        append(div3, t12);
        append(div3, div2);
        append(div2, div1);
        append(div1, img);
        append(div1, t13);
        append(div1, h2);
        append(h2, t14);
        append(div1, t15);
        append(div1, b);
        append(b, t16);
        append(b, t17);
        append(b, t18);
        append(div2, t19);
        append(div2, p1);
        append(p1, t20);
        append(div2, t21);
        if (if_block) if_block.m(div2, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        var _a3, _b3, _c2;
        if (dirty & /*selectedItem, $items*/
        3) {
          each_value_3 = ensure_array_like(
            /*$items*/
            ctx2[0].tools
          );
          let i;
          for (i = 0; i < each_value_3.length; i += 1) {
            const child_ctx = get_each_context_3(ctx2, each_value_3, i);
            if (each_blocks_2[i]) {
              each_blocks_2[i].p(child_ctx, dirty);
            } else {
              each_blocks_2[i] = create_each_block_3(child_ctx);
              each_blocks_2[i].c();
              each_blocks_2[i].m(div0, t6);
            }
          }
          for (; i < each_blocks_2.length; i += 1) {
            each_blocks_2[i].d(1);
          }
          each_blocks_2.length = each_value_3.length;
        }
        if (dirty & /*selectedItem, $items*/
        3) {
          each_value_2 = ensure_array_like(
            /*$items*/
            ctx2[0].mods.filter(
              /*func*/
              ctx2[5]
            )
          );
          let i;
          for (i = 0; i < each_value_2.length; i += 1) {
            const child_ctx = get_each_context_2(ctx2, each_value_2, i);
            if (each_blocks_1[i]) {
              each_blocks_1[i].p(child_ctx, dirty);
            } else {
              each_blocks_1[i] = create_each_block_2(child_ctx);
              each_blocks_1[i].c();
              each_blocks_1[i].m(div0, t9);
            }
          }
          for (; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d(1);
          }
          each_blocks_1.length = each_value_2.length;
        }
        if (dirty & /*selectedItem, $items*/
        3) {
          each_value_1 = ensure_array_like(
            /*$items*/
            ctx2[0].mods.filter(
              /*func_1*/
              ctx2[7]
            )
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1$1(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_1$1(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div0, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_1.length;
        }
        if (!current || dirty & /*selectedItem*/
        2) {
          set_style(
            img,
            "content",
            /*selectedItem*/
            (_a3 = ctx2[1]) == null ? void 0 : _a3.icon
          );
        }
        if ((!current || dirty & /*selectedItem*/
        2) && t14_value !== (t14_value = /*selectedItem*/
        ((_b3 = ctx2[1]) == null ? void 0 : _b3.name) + "")) set_data(t14, t14_value);
        if ((!current || dirty & /*selectedItem*/
        2) && t17_value !== (t17_value = /*selectedItem*/
        ctx2[1] instanceof ConstantDrawMod ? (
          /*selectedItem*/
          ctx2[1] instanceof TypoDrawTool ? "TOOL" : "COMBO MOD"
        ) : "MOD")) set_data(t17, t17_value);
        if ((!current || dirty & /*selectedItem*/
        2) && t20_value !== (t20_value = /*selectedItem*/
        ((_c2 = ctx2[1]) == null ? void 0 : _c2.description) + "")) set_data(t20, t20_value);
        if (
          /*selectedItem*/
          ctx2[1] !== void 0 && /*selectedItem*/
          ctx2[1].settings.length > 0
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & /*selectedItem*/
            2) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block$6(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(div2, null);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(p0);
          detach(t3);
          detach(div3);
        }
        destroy_each(each_blocks_2, detaching);
        destroy_each(each_blocks_1, detaching);
        destroy_each(each_blocks, detaching);
        if (if_block) if_block.d();
      }
    };
  }
  __name(create_fragment$g, "create_fragment$g");
  function instance$f($$self, $$props, $$invalidate) {
    let $items;
    let { feature } = $$props;
    const items = feature.toolbarItemsStore;
    component_subscribe($$self, items, (value) => $$invalidate(0, $items = value));
    let selectedItem;
    const click_handler2 = /* @__PURE__ */ __name((tool) => $$invalidate(1, selectedItem = tool.item), "click_handler");
    const func2 = /* @__PURE__ */ __name((mod) => !(mod.item instanceof ConstantDrawMod), "func");
    const click_handler_1 = /* @__PURE__ */ __name((mod) => $$invalidate(1, selectedItem = mod.item), "click_handler_1");
    const func_12 = /* @__PURE__ */ __name((mod) => mod.item instanceof ConstantDrawMod, "func_1");
    const click_handler_2 = /* @__PURE__ */ __name((mod) => $$invalidate(1, selectedItem = mod.item), "click_handler_2");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(3, feature = $$props2.feature);
    };
    $$self.$$.update = () => {
      var _a2;
      if ($$self.$$.dirty & /*$items*/
      1) {
        {
          $$invalidate(1, selectedItem = (_a2 = $items.tools.find((tool) => tool.active) ?? $items.mods.find((mod) => mod.active) ?? $items.tools[0]) == null ? void 0 : _a2.item);
        }
      }
    };
    return [
      $items,
      selectedItem,
      items,
      feature,
      click_handler2,
      func2,
      click_handler_1,
      func_12,
      click_handler_2
    ];
  }
  __name(instance$f, "instance$f");
  const _Drawing_brush_lab_manage = class _Drawing_brush_lab_manage extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$f, create_fragment$g, safe_not_equal, { feature: 3 });
    }
  };
  __name(_Drawing_brush_lab_manage, "Drawing_brush_lab_manage");
  let Drawing_brush_lab_manage = _Drawing_brush_lab_manage;
  var __defProp$k = Object.defineProperty;
  var __decorateClass$k = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$k(target, key2, result);
    return result;
  }, "__decorateClass$k");
  const _DrawingBrushLabFeature = class _DrawingBrushLabFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_toolsService");
      __publicField(this, "_elementsSetup");
      __publicField(this, "_modalService");
      __publicField(this, "name", "Brush Laboratory");
      __publicField(this, "description", "Add custom drawing tools for special effects to the toolbar");
      __publicField(this, "tags", [
        FeatureTag.DRAWING
      ]);
      __publicField(this, "featureId", 39);
      __publicField(this, "_labSwitchComponent");
      __publicField(this, "_labGroupComponent");
      __publicField(this, "_toolbarItems$", new BehaviorSubject({ tools: [], mods: [] }));
      __publicField(this, "_items", [
        ParallelLineMod,
        MandalaMod,
        SculptMod,
        DotTool,
        DashTool,
        RainbowMod,
        RandomColorMod,
        GridTool,
        NoiseMod,
        TiltMod
      ]);
      __publicField(this, "_brushLabToggleHotkey", this.useHotkey(
        new HotkeyAction(
          "toggle_lab",
          "Toggle Brush Lab",
          "Toggle the visibility of the brush lab below skribbl tools",
          this,
          () => {
            var _a2;
            return (_a2 = this._labSwitchComponent) == null ? void 0 : _a2.toggle();
          },
          true,
          ["ShiftLeft", "KeyL"]
        )
      ));
    }
    get featureInfoComponent() {
      return { componentType: Drawing_brush_lab_info, props: { feature: this } };
    }
    /*public override get featureManagementComponent(): componentData<BrushLabManage> {
      return { componentType: BrushLabManage, props: { feature: this } };
    }*/
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._labGroupComponent = new Drawing_brush_lab_group({
        target: elements2.skribblToolbar,
        props: { feature: this }
      });
      this._labSwitchComponent = new Drawing_brush_lab_switch({
        target: elements2.skribblActions,
        props: { feature: this }
      });
      this.createItems();
    }
    async onDestroy() {
      if (this._labSwitchComponent) {
        this._labSwitchComponent.$destroy();
        this._labSwitchComponent = void 0;
      }
      if (this._labGroupComponent) {
        this._labGroupComponent.$destroy();
        this._labGroupComponent = void 0;
      }
      const items = await firstValueFrom(this._toolbarItems$);
      items.mods.forEach(({ item }) => this._toolsService.removeMod(item));
      this._toolsService.activateTool(skribblTool.brush);
    }
    get toolbarItemsStore() {
      return fromObservable(this._toolbarItems$.pipe(
        combineLatestWith(this._toolsService.activeTool$, this._toolsService.activeMods$),
        map(([items, activeTool, activeMods]) => {
          return {
            mods: items.mods.map((item) => ({ item: item.item, active: activeMods.includes(item.item) })),
            tools: items.tools.map((item) => ({ item: item.item, active: activeTool === item.item }))
          };
        })
      ), this._toolbarItems$.value);
    }
    createItems() {
      const items = this._items.map((item) => this._toolsService.resolveModOrTool(item));
      const tools = items.filter((item) => item instanceof TypoDrawTool).map((item) => ({ item, active: false }));
      const mods = items.filter((item) => !(item instanceof TypoDrawTool)).map((item) => ({ item, active: false }));
      this._toolbarItems$.next({ tools, mods });
    }
    activateTool(tool) {
      this._toolsService.activateTool(tool);
    }
    activateMod(mod) {
      this._toolsService.activateMod(mod);
    }
    removeMod(mod) {
      this._toolsService.removeMod(mod);
    }
    openBrushLabSettings() {
      const componentData = {
        componentType: Drawing_brush_lab_manage,
        props: { feature: this }
      };
      this._modalService.showModal(componentData.componentType, componentData.props, "Brush Laboratory");
    }
  };
  __name(_DrawingBrushLabFeature, "DrawingBrushLabFeature");
  let DrawingBrushLabFeature = _DrawingBrushLabFeature;
  __decorateClass$k([
    inject(ToolsService)
  ], DrawingBrushLabFeature.prototype, "_toolsService");
  __decorateClass$k([
    inject(ElementsSetup)
  ], DrawingBrushLabFeature.prototype, "_elementsSetup");
  __decorateClass$k([
    inject(ModalService)
  ], DrawingBrushLabFeature.prototype, "_modalService");
  var __defProp$j = Object.defineProperty;
  var __decorateClass$j = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$j(target, key2, result);
    return result;
  }, "__decorateClass$j");
  const _DrawingSizeHotkeysFeature = class _DrawingSizeHotkeysFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_drawingService");
      __publicField(this, "name", "Brush Size Hotkeys");
      __publicField(this, "description", "Adds hotkeys to change the brush size");
      __publicField(this, "tags", [
        FeatureTag.DRAWING
      ]);
      __publicField(this, "featureId", 51);
      __publicField(this, "_sizeHotkeys", [1, 2, 3, 4, 5].map((level) => this.useHotkey(new HotkeyAction(
        `size_${level}`,
        `Brush size ${level}`,
        `Set the brush size to level ${level}`,
        this,
        () => this._drawingService.setSize([4, 10, 20, 32, 40][level - 1]),
        true,
        [`Digit${level}`]
      ))));
    }
  };
  __name(_DrawingSizeHotkeysFeature, "DrawingSizeHotkeysFeature");
  let DrawingSizeHotkeysFeature = _DrawingSizeHotkeysFeature;
  __decorateClass$j([
    inject(DrawingService)
  ], DrawingSizeHotkeysFeature.prototype, "_drawingService");
  function get_each_context$8(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[10] = list[i];
    return child_ctx;
  }
  __name(get_each_context$8, "get_each_context$8");
  function create_each_block$8(ctx) {
    let div;
    let b;
    let t0_value = (
      /*logger*/
      ctx[10].boundTo + ""
    );
    let t0;
    let t1;
    let select;
    let option0;
    let t2;
    let option0_selected_value;
    let option1;
    let t3;
    let option1_selected_value;
    let option2;
    let t4;
    let option2_selected_value;
    let option3;
    let t5;
    let option3_selected_value;
    let t6;
    let mounted;
    let dispose;
    function change_handler(...args) {
      return (
        /*change_handler*/
        ctx[9](
          /*logger*/
          ctx[10],
          ...args
        )
      );
    }
    __name(change_handler, "change_handler");
    return {
      c() {
        div = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = space();
        select = element("select");
        option0 = element("option");
        t2 = text("Debug");
        option1 = element("option");
        t3 = text("Information");
        option2 = element("option");
        t4 = text("Warn");
        option3 = element("option");
        t5 = text("Error");
        t6 = space();
        option0.__value = "debug";
        set_input_value(option0, option0.__value);
        option0.selected = option0_selected_value = /*logger*/
        ctx[10].level === "debug";
        option1.__value = "info";
        set_input_value(option1, option1.__value);
        option1.selected = option1_selected_value = /*logger*/
        ctx[10].level === "info";
        option2.__value = "warn";
        set_input_value(option2, option2.__value);
        option2.selected = option2_selected_value = /*logger*/
        ctx[10].level === "warn";
        option3.__value = "error";
        set_input_value(option3, option3.__value);
        option3.selected = option3_selected_value = /*logger*/
        ctx[10].level === "error";
        attr(div, "class", "typo-logs-logger svelte-oun24t");
        toggle_class(div, "hidden", !/*logger*/
        ctx[10].boundTo.toLowerCase().includes(
          /*loggerFilter*/
          ctx[3].toLowerCase()
        ));
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, b);
        append(b, t0);
        append(div, t1);
        append(div, select);
        append(select, option0);
        append(option0, t2);
        append(select, option1);
        append(option1, t3);
        append(select, option2);
        append(option2, t4);
        append(select, option3);
        append(option3, t5);
        append(div, t6);
        if (!mounted) {
          dispose = listen(select, "change", change_handler);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*loggers*/
        4 && t0_value !== (t0_value = /*logger*/
        ctx[10].boundTo + "")) set_data(t0, t0_value);
        if (dirty & /*loggers*/
        4 && option0_selected_value !== (option0_selected_value = /*logger*/
        ctx[10].level === "debug")) {
          option0.selected = option0_selected_value;
        }
        if (dirty & /*loggers*/
        4 && option1_selected_value !== (option1_selected_value = /*logger*/
        ctx[10].level === "info")) {
          option1.selected = option1_selected_value;
        }
        if (dirty & /*loggers*/
        4 && option2_selected_value !== (option2_selected_value = /*logger*/
        ctx[10].level === "warn")) {
          option2.selected = option2_selected_value;
        }
        if (dirty & /*loggers*/
        4 && option3_selected_value !== (option3_selected_value = /*logger*/
        ctx[10].level === "error")) {
          option3.selected = option3_selected_value;
        }
        if (dirty & /*loggers, loggerFilter*/
        12) {
          toggle_class(div, "hidden", !/*logger*/
          ctx[10].boundTo.toLowerCase().includes(
            /*loggerFilter*/
            ctx[3].toLowerCase()
          ));
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block$8, "create_each_block$8");
  function create_fragment$f(ctx) {
    let h30;
    let t1;
    let div0;
    let flatbutton0;
    let t2;
    let flatbutton1;
    let t3;
    let h31;
    let t5;
    let div1;
    let select;
    let option0;
    let option1;
    let option2;
    let option3;
    let t10;
    let flatbutton2;
    let t11;
    let h32;
    let t13;
    let div2;
    let input;
    let t14;
    let div3;
    let current;
    let mounted;
    let dispose;
    flatbutton0 = new Flat_button({
      props: { content: "Copy logs text", color: "blue" }
    });
    flatbutton0.$on(
      "click",
      /*click_handler*/
      ctx[4]
    );
    flatbutton1 = new Flat_button({
      props: { content: "Copy logs JSON", color: "blue" }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_1*/
      ctx[5]
    );
    flatbutton2 = new Flat_button({
      props: {
        content: "Reset to selection",
        color: "orange"
      }
    });
    flatbutton2.$on(
      "click",
      /*click_handler_2*/
      ctx[7]
    );
    let each_value = ensure_array_like(
      /*loggers*/
      ctx[2]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    }
    return {
      c() {
        h30 = element("h3");
        h30.textContent = "Export Logs";
        t1 = space();
        div0 = element("div");
        create_component(flatbutton0.$$.fragment);
        t2 = space();
        create_component(flatbutton1.$$.fragment);
        t3 = space();
        h31 = element("h3");
        h31.textContent = "Reset Log Level";
        t5 = space();
        div1 = element("div");
        select = element("select");
        option0 = element("option");
        option0.textContent = "Debug";
        option1 = element("option");
        option1.textContent = "Information";
        option2 = element("option");
        option2.textContent = "Warn";
        option3 = element("option");
        option3.textContent = "Error";
        t10 = space();
        create_component(flatbutton2.$$.fragment);
        t11 = space();
        h32 = element("h3");
        h32.textContent = "Customize Log Level";
        t13 = space();
        div2 = element("div");
        input = element("input");
        t14 = space();
        div3 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div0, "class", "typo-logs-export svelte-oun24t");
        option0.__value = "debug";
        set_input_value(option0, option0.__value);
        option1.__value = "info";
        set_input_value(option1, option1.__value);
        option2.__value = "warn";
        set_input_value(option2, option2.__value);
        option3.__value = "error";
        set_input_value(option3, option3.__value);
        set_style(select, "width", "auto");
        attr(div1, "class", "typo-logs-overwrite svelte-oun24t");
        set_style(input, "max-width", "20rem");
        attr(input, "type", "text");
        attr(input, "placeholder", "Filter loggers");
        attr(div2, "class", "typo-logs-logger-list svelte-oun24t");
        attr(div3, "class", "typo-logs-logger-list svelte-oun24t");
      },
      m(target, anchor) {
        insert(target, h30, anchor);
        insert(target, t1, anchor);
        insert(target, div0, anchor);
        mount_component(flatbutton0, div0, null);
        append(div0, t2);
        mount_component(flatbutton1, div0, null);
        insert(target, t3, anchor);
        insert(target, h31, anchor);
        insert(target, t5, anchor);
        insert(target, div1, anchor);
        append(div1, select);
        append(select, option0);
        append(select, option1);
        append(select, option2);
        append(select, option3);
        ctx[6](select);
        append(div1, t10);
        mount_component(flatbutton2, div1, null);
        insert(target, t11, anchor);
        insert(target, h32, anchor);
        insert(target, t13, anchor);
        insert(target, div2, anchor);
        append(div2, input);
        set_input_value(
          input,
          /*loggerFilter*/
          ctx[3]
        );
        insert(target, t14, anchor);
        insert(target, div3, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div3, null);
          }
        }
        current = true;
        if (!mounted) {
          dispose = listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[8]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*loggerFilter*/
        8 && input.value !== /*loggerFilter*/
        ctx2[3]) {
          set_input_value(
            input,
            /*loggerFilter*/
            ctx2[3]
          );
        }
        if (dirty & /*loggers, loggerFilter, feature*/
        13) {
          each_value = ensure_array_like(
            /*loggers*/
            ctx2[2]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$8(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$8(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div3, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        transition_in(flatbutton2.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        transition_out(flatbutton2.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(h30);
          detach(t1);
          detach(div0);
          detach(t3);
          detach(h31);
          detach(t5);
          detach(div1);
          detach(t11);
          detach(h32);
          detach(t13);
          detach(div2);
          detach(t14);
          detach(div3);
        }
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
        ctx[6](null);
        destroy_component(flatbutton2);
        destroy_each(each_blocks, detaching);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$f, "create_fragment$f");
  function instance$e($$self, $$props, $$invalidate) {
    let { feature } = $$props;
    let resetAll;
    let loggers = feature.loggers;
    let loggerFilter = "";
    const click_handler2 = /* @__PURE__ */ __name(() => feature.copyLogsToClipboard(false), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => feature.copyLogsToClipboard(true), "click_handler_1");
    function select_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        resetAll = $$value;
        $$invalidate(1, resetAll);
      });
    }
    __name(select_binding, "select_binding");
    const click_handler_2 = /* @__PURE__ */ __name(async () => {
      await feature.resetAllLogLevels(resetAll.value);
      $$invalidate(2, loggers = feature.loggers);
    }, "click_handler_2");
    function input_input_handler() {
      loggerFilter = this.value;
      $$invalidate(3, loggerFilter);
    }
    __name(input_input_handler, "input_input_handler");
    const change_handler = /* @__PURE__ */ __name((logger, e) => feature.setLogLevelOfLogger(logger, e.currentTarget.value), "change_handler");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      resetAll,
      loggers,
      loggerFilter,
      click_handler2,
      click_handler_1,
      select_binding,
      click_handler_2,
      input_input_handler,
      change_handler
    ];
  }
  __name(instance$e, "instance$e");
  const _Logging_manage = class _Logging_manage extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$e, create_fragment$f, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Logging_manage, "Logging_manage");
  let Logging_manage = _Logging_manage;
  function create_fragment$e(ctx) {
    let t0;
    let br0;
    let t1;
    let br1;
    let t2;
    let br2;
    let t3;
    let br3;
    let t4;
    return {
      c() {
        t0 = text("Logging collects debug data from events of all parts of the typo extension.");
        br0 = element("br");
        t1 = text("\nIn case of bugs or unexpected behavior, this data can be used to identify the cause of issues.");
        br1 = element("br");
        t2 = space();
        br2 = element("br");
        t3 = text("\nTo filter out irrelevant events, the log level of each instance can be adjusted.");
        br3 = element("br");
        t4 = text("\nLog level is stored permanently in the extension settings across reloads; existing logs are not affected by log level changes.");
      },
      m(target, anchor) {
        insert(target, t0, anchor);
        insert(target, br0, anchor);
        insert(target, t1, anchor);
        insert(target, br1, anchor);
        insert(target, t2, anchor);
        insert(target, br2, anchor);
        insert(target, t3, anchor);
        insert(target, br3, anchor);
        insert(target, t4, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(br0);
          detach(t1);
          detach(br1);
          detach(t2);
          detach(br2);
          detach(t3);
          detach(br3);
          detach(t4);
        }
      }
    };
  }
  __name(create_fragment$e, "create_fragment$e");
  const _Logging_info = class _Logging_info extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment$e, safe_not_equal, {});
    }
  };
  __name(_Logging_info, "Logging_info");
  let Logging_info = _Logging_info;
  var __defProp$i = Object.defineProperty;
  var __decorateClass$i = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$i(target, key2, result);
    return result;
  }, "__decorateClass$i");
  const _LoggingFeature = class _LoggingFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "name", "Logging");
      __publicField(this, "description", "Collect logs of services, features, setups and event processors.");
      __publicField(this, "tags", [
        FeatureTag.DEVELOPMENT
      ]);
      __publicField(this, "featureId", 24);
      __publicField(this, "toggleEnabled", false);
      __publicField(this, "developerFeature", true);
      __publicField(this, "_loggingService");
      __publicField(this, "_toastService");
    }
    get featureManagementComponent() {
      return { componentType: Logging_manage, props: { feature: this } };
    }
    get featureInfoComponent() {
      return { componentType: Logging_info, props: {} };
    }
    postConstruct() {
      this.useSetting(this._loggingService.printEnabledSetting);
    }
    get loggers() {
      return this._loggingService.loggers;
    }
    async copyLogsToClipboard(asJson) {
      const logs = this._loggingService.recordedEvents;
      const logsText = asJson ? JSON.stringify(logs) : logs.map((event) => `[${event.date.toISOString()}] [${event.logLevel}] (${event.bindingName}) ${event.message} ${event.data.join(", ")}`).join("\n");
      await navigator.clipboard.writeText(logsText);
      await this._toastService.showToast("Logs copied to clipboard");
    }
    async setLogLevelOfLogger(logger, level) {
      if (level !== "debug" && level !== "info" && level !== "warn" && level !== "error") {
        await this._toastService.showToast("Invalid log level");
        return;
      }
      try {
        const setting = this._loggingService.getLogLevelSetting(logger);
        await setting.setValue(level);
      } catch (e) {
        this._logger.error("Error updating log level", e);
        await this._toastService.showToast("Error updating log level");
        return;
      }
      await this._toastService.showToast("Updated Logger", `Log level of ${logger.boundTo} set to ${level}`);
    }
    async resetAllLogLevels(level) {
      if (level !== "debug" && level !== "info" && level !== "warn" && level !== "error") {
        await this._toastService.showToast("Invalid log level");
        return;
      }
      const toast = await this._toastService.showLoadingToast("Resetting log levels to " + level);
      const promises = this._loggingService.loggers.map((logger) => {
        const setting = this._loggingService.getLogLevelSetting(logger);
        return setting.setValue(level);
      });
      try {
        await Promise.all(promises);
      } catch (e) {
        this._logger.error("Error resetting log level to " + level, e);
        toast.reject("Error resetting log levels");
        return;
      }
      toast.resolve();
    }
  };
  __name(_LoggingFeature, "LoggingFeature");
  let LoggingFeature = _LoggingFeature;
  __decorateClass$i([
    inject(LoggingService)
  ], LoggingFeature.prototype, "_loggingService");
  __decorateClass$i([
    inject(ToastService)
  ], LoggingFeature.prototype, "_toastService");
  var __defProp$h = Object.defineProperty;
  var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
  var __decorateClass$h = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$h(target, key2, result);
    return result;
  }, "__decorateClass$h");
  var __decorateParam = /* @__PURE__ */ __name((index, decorator) => (target, key2) => decorator(target, key2, index), "__decorateParam");
  let LobbyItemsService = (_Fa = class {
    constructor(loggerFactory2) {
      __publicField(this, "_socketService");
      __publicField(this, "_logger");
      __publicField(this, "_onlineItems$", new BehaviorSubject([]));
      this._logger = loggerFactory2(this);
    }
    postConstruct() {
      this.setupConnection();
    }
    async setupConnection() {
      const connection = this._socketService.createConnection("IOnlineItemsHub");
      this._socketService.createReceiver("IOnlineItemsReceiver").register(connection, {
        onlineItemsUpdated: this.onOnlineItemsUpdated.bind(this)
      });
      await connection.start();
      this._socketService.reconnectOnUserInteraction(connection, () => this.setupConnection());
      return connection;
    }
    async onOnlineItemsUpdated(update2) {
      this._logger.info("Online items updated", update2);
      this._onlineItems$.next(update2.items);
    }
    get onlineItems$() {
      return this._onlineItems$.asObservable();
    }
  }, __name(_Fa, "LobbyItemsService"), _Fa);
  __decorateClass$h([
    inject(SocketService)
  ], LobbyItemsService.prototype, "_socketService", 2);
  __decorateClass$h([
    postConstruct()
  ], LobbyItemsService.prototype, "postConstruct", 1);
  LobbyItemsService = __decorateClass$h([
    injectable(),
    __decorateParam(0, inject(loggerFactory))
  ], LobbyItemsService);
  function get_each_context$7(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[10] = list[i];
    child_ctx[12] = i;
    return child_ctx;
  }
  __name(get_each_context$7, "get_each_context$7");
  function create_if_block$5(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        div.textContent = "No filters saved.";
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_if_block$5, "create_if_block$5");
  function create_each_block$7(ctx) {
    let div1;
    let checkbox;
    let t0;
    let div0;
    let iconbutton;
    let t1;
    let feature_createTooltip_action;
    let current;
    let mounted;
    let dispose;
    function change_handler(...args) {
      return (
        /*change_handler*/
        ctx[6](
          /*filter*/
          ctx[10],
          ...args
        )
      );
    }
    __name(change_handler, "change_handler");
    checkbox = new Checkbox({
      props: {
        description: (
          /*filter*/
          ctx[10].name
        ),
        checked: (
          /*filterStates*/
          ctx[3][
            /*i*/
            ctx[12]
          ]
        )
      }
    });
    checkbox.$on("change", change_handler);
    function click_handler2() {
      return (
        /*click_handler*/
        ctx[7](
          /*filter*/
          ctx[10]
        )
      );
    }
    __name(click_handler2, "click_handler");
    iconbutton = new Icon_button({
      props: {
        icon: "file-img-trash-gif",
        name: "Remove Filter",
        greyscaleInactive: true,
        hoverMove: false,
        size: "1.5rem"
      }
    });
    iconbutton.$on("click", click_handler2);
    return {
      c() {
        div1 = element("div");
        create_component(checkbox.$$.fragment);
        t0 = space();
        div0 = element("div");
        create_component(iconbutton.$$.fragment);
        t1 = space();
        attr(div0, "class", "typo-lobby-filters-item-remove svelte-lqoucf");
        attr(div1, "class", "typo-lobby-filters-item svelte-lqoucf");
        set_style(
          div1,
          "order",
          /*filter*/
          ctx[10].createdAt
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        mount_component(checkbox, div1, null);
        append(div1, t0);
        append(div1, div0);
        mount_component(iconbutton, div0, null);
        append(div1, t1);
        current = true;
        if (!mounted) {
          dispose = action_destroyer(feature_createTooltip_action = /*feature*/
          ctx[0].createTooltip(div1, {
            title: `${/*feature*/
          ctx[0].buildFilterTooltipText(
            /*filter*/
            ctx[10]
          )}`
          }));
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        const checkbox_changes = {};
        if (dirty & /*$filters*/
        4) checkbox_changes.description = /*filter*/
        ctx[10].name;
        if (dirty & /*filterStates*/
        8) checkbox_changes.checked = /*filterStates*/
        ctx[3][
          /*i*/
          ctx[12]
        ];
        checkbox.$set(checkbox_changes);
        if (!current || dirty & /*$filters*/
        4) {
          set_style(
            div1,
            "order",
            /*filter*/
            ctx[10].createdAt
          );
        }
        if (feature_createTooltip_action && is_function(feature_createTooltip_action.update) && dirty & /*feature, $filters*/
        5) feature_createTooltip_action.update.call(null, {
          title: `${/*feature*/
        ctx[0].buildFilterTooltipText(
          /*filter*/
          ctx[10]
        )}`
        });
      },
      i(local) {
        if (current) return;
        transition_in(checkbox.$$.fragment, local);
        transition_in(iconbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(checkbox.$$.fragment, local);
        transition_out(iconbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_component(checkbox);
        destroy_component(iconbutton);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block$7, "create_each_block$7");
  function create_fragment$d(ctx) {
    let div2;
    let div0;
    let t0;
    let t1;
    let div1;
    let flatbutton0;
    let t2;
    let flatbutton1;
    let current;
    let if_block = (
      /*$filters*/
      ctx[2].length === 0 && create_if_block$5()
    );
    let each_value = ensure_array_like(
      /*$filters*/
      ctx[2]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    flatbutton0 = new Flat_button({
      props: { content: "Start Search", color: "green" }
    });
    flatbutton0.$on(
      "click",
      /*click_handler_1*/
      ctx[8]
    );
    flatbutton1 = new Flat_button({
      props: {
        content: "Add Lobby Filter",
        color: "blue"
      }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_2*/
      ctx[9]
    );
    return {
      c() {
        div2 = element("div");
        div0 = element("div");
        if (if_block) if_block.c();
        t0 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t1 = space();
        div1 = element("div");
        create_component(flatbutton0.$$.fragment);
        t2 = space();
        create_component(flatbutton1.$$.fragment);
        attr(div0, "class", "typo-lobby-filters-list svelte-lqoucf");
        attr(div1, "class", "typo-lobby-filters-header svelte-lqoucf");
        attr(div2, "class", "typo-lobby-filters svelte-lqoucf");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, div0);
        if (if_block) if_block.m(div0, null);
        append(div0, t0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
        append(div2, t1);
        append(div2, div1);
        mount_component(flatbutton0, div1, null);
        append(div1, t2);
        mount_component(flatbutton1, div1, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (
          /*$filters*/
          ctx2[2].length === 0
        ) {
          if (if_block) ;
          else {
            if_block = create_if_block$5();
            if_block.c();
            if_block.m(div0, t0);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & /*$filters, feature, filterStates, $selectedFilters, selectedFilters*/
        47) {
          each_value = ensure_array_like(
            /*$filters*/
            ctx2[2]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$7(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$7(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div0, null);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        if (if_block) if_block.d();
        destroy_each(each_blocks, detaching);
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
      }
    };
  }
  __name(create_fragment$d, "create_fragment$d");
  function instance$d($$self, $$props, $$invalidate) {
    let filterStates;
    let $selectedFilters;
    let $filters;
    let { feature } = $$props;
    const filters = feature.savedFiltersStore;
    component_subscribe($$self, filters, (value) => $$invalidate(2, $filters = value));
    const selectedFilters = feature.selectedFiltersStore;
    component_subscribe($$self, selectedFilters, (value) => $$invalidate(1, $selectedFilters = value));
    const change_handler = /* @__PURE__ */ __name((filter2, checked) => {
      const other = $selectedFilters.filter((f) => f !== filter2.createdAt);
      selectedFilters.set(checked.detail ? [...other, filter2.createdAt] : other);
    }, "change_handler");
    const click_handler2 = /* @__PURE__ */ __name((filter2) => feature.removeFilter(filter2), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(async () => {
      await feature.startSearch();
    }, "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(async () => {
      const filter2 = await feature.promptFilterCreation();
      if (filter2) {
        await feature.addFilter(filter2);
      }
    }, "click_handler_2");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*$filters, $selectedFilters*/
      6) {
        $$invalidate(3, filterStates = $filters.map((filter2) => $selectedFilters.includes(filter2.createdAt)));
      }
    };
    return [
      feature,
      $selectedFilters,
      $filters,
      filterStates,
      filters,
      selectedFilters,
      change_handler,
      click_handler2,
      click_handler_1,
      click_handler_2
    ];
  }
  __name(instance$d, "instance$d");
  const _Panel_filters = class _Panel_filters extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$d, create_fragment$d, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Panel_filters, "Panel_filters");
  let Panel_filters = _Panel_filters;
  function create_fragment$c(ctx) {
    let div9;
    let div0;
    let t3;
    let div2;
    let div1;
    let input0;
    let t4;
    let flatbutton;
    let t5;
    let div8;
    let div3;
    let b0;
    let t7;
    let span0;
    let t9;
    let input1;
    let t10;
    let div4;
    let b1;
    let t12;
    let span1;
    let t14;
    let input2;
    let t15;
    let span2;
    let t17;
    let input3;
    let t18;
    let span3;
    let t20;
    let div5;
    let b2;
    let t22;
    let span4;
    let t24;
    let input4;
    let t25;
    let span5;
    let t27;
    let input5;
    let t28;
    let div6;
    let b3;
    let t30;
    let span6;
    let t32;
    let input6;
    let t33;
    let span7;
    let t35;
    let input7;
    let t36;
    let span8;
    let t38;
    let div7;
    let checkbox;
    let updating_checked;
    let current;
    let mounted;
    let dispose;
    flatbutton = new Flat_button({
      props: { content: "Add Filter", color: "blue" }
    });
    flatbutton.$on(
      "click",
      /*click_handler*/
      ctx[4]
    );
    function checkbox_checked_binding(value) {
      ctx[12](value);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    let checkbox_props = {
      description: "Match only lobbies with typo players"
    };
    if (
      /*filter*/
      ctx[1].containsTypoPlayers !== void 0
    ) {
      checkbox_props.checked = /*filter*/
      ctx[1].containsTypoPlayers;
    }
    checkbox = new Checkbox({ props: checkbox_props });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
    return {
      c() {
        div9 = element("div");
        div0 = element("div");
        div0.innerHTML = `A lobby filter checks if a lobby matches the filter criteria and skips automatically until a lobby is found.<br/>
    You can add multiple filters; at least one of them has to be matched for a lobby to be accepted.<br/>
    If you leave filter criteria empty, it will be ignored.`;
        t3 = space();
        div2 = element("div");
        div1 = element("div");
        input0 = element("input");
        t4 = space();
        create_component(flatbutton.$$.fragment);
        t5 = space();
        div8 = element("div");
        div3 = element("div");
        b0 = element("b");
        b0.textContent = "Names:";
        t7 = space();
        span0 = element("span");
        span0.textContent = "Match lobbies with names containing one of the comma-separated names";
        t9 = space();
        input1 = element("input");
        t10 = space();
        div4 = element("div");
        b1 = element("b");
        b1.textContent = "Players:";
        t12 = space();
        span1 = element("span");
        span1.textContent = "Match lobbies having at least";
        t14 = space();
        input2 = element("input");
        t15 = space();
        span2 = element("span");
        span2.textContent = "and at most";
        t17 = space();
        input3 = element("input");
        t18 = space();
        span3 = element("span");
        span3.textContent = "players.";
        t20 = space();
        div5 = element("div");
        b2 = element("b");
        b2.textContent = "Round:";
        t22 = space();
        span4 = element("span");
        span4.textContent = "Match lobbies that are currently at least in round";
        t24 = space();
        input4 = element("input");
        t25 = space();
        span5 = element("span");
        span5.textContent = "and at most in round";
        t27 = space();
        input5 = element("input");
        t28 = space();
        div6 = element("div");
        b3 = element("b");
        b3.textContent = "Average Score:";
        t30 = space();
        span6 = element("span");
        span6.textContent = "Match lobbies where the average player score is at least";
        t32 = space();
        input6 = element("input");
        t33 = space();
        span7 = element("span");
        span7.textContent = "points and at most";
        t35 = space();
        input7 = element("input");
        t36 = space();
        span8 = element("span");
        span8.textContent = "points.";
        t38 = space();
        div7 = element("div");
        create_component(checkbox.$$.fragment);
        attr(input0, "type", "text");
        attr(input0, "placeholder", "Filter name");
        attr(input0, "class", "svelte-9ect24");
        attr(div1, "class", "typo-filter-form-row svelte-9ect24");
        attr(div2, "class", "typo-filter-form-inputs svelte-9ect24");
        attr(input1, "type", "text");
        attr(input1, "placeholder", "ice king, princess bubblegum, finn");
        attr(input1, "class", "svelte-9ect24");
        attr(div3, "class", "typo-filter-form-row svelte-9ect24");
        attr(input2, "type", "number");
        attr(input2, "placeholder", "1");
        attr(input2, "class", "svelte-9ect24");
        attr(input3, "type", "number");
        attr(input3, "placeholder", "8");
        attr(input3, "class", "svelte-9ect24");
        attr(div4, "class", "typo-filter-form-row svelte-9ect24");
        attr(input4, "type", "number");
        attr(input4, "placeholder", "1");
        attr(input4, "class", "svelte-9ect24");
        attr(input5, "type", "number");
        attr(input5, "placeholder", "3");
        attr(input5, "class", "svelte-9ect24");
        attr(div5, "class", "typo-filter-form-row svelte-9ect24");
        attr(input6, "type", "number");
        attr(input6, "placeholder", "500");
        attr(input6, "class", "svelte-9ect24");
        attr(input7, "type", "number");
        attr(input7, "placeholder", "3000");
        attr(input7, "class", "svelte-9ect24");
        attr(div6, "class", "typo-filter-form-row svelte-9ect24");
        attr(div7, "class", "typo-filter-form-row svelte-9ect24");
        attr(div8, "class", "typo-filter-form-inputs svelte-9ect24");
        attr(div9, "class", "typo-filter-form svelte-9ect24");
      },
      m(target, anchor) {
        insert(target, div9, anchor);
        append(div9, div0);
        append(div9, t3);
        append(div9, div2);
        append(div2, div1);
        append(div1, input0);
        set_input_value(
          input0,
          /*filter*/
          ctx[1].name
        );
        append(div1, t4);
        mount_component(flatbutton, div1, null);
        append(div9, t5);
        append(div9, div8);
        append(div8, div3);
        append(div3, b0);
        append(div3, t7);
        append(div3, span0);
        append(div3, t9);
        append(div3, input1);
        append(div8, t10);
        append(div8, div4);
        append(div4, b1);
        append(div4, t12);
        append(div4, span1);
        append(div4, t14);
        append(div4, input2);
        set_input_value(
          input2,
          /*filter*/
          ctx[1].minAmountPlayers
        );
        append(div4, t15);
        append(div4, span2);
        append(div4, t17);
        append(div4, input3);
        set_input_value(
          input3,
          /*filter*/
          ctx[1].maxAmountPlayers
        );
        append(div4, t18);
        append(div4, span3);
        append(div8, t20);
        append(div8, div5);
        append(div5, b2);
        append(div5, t22);
        append(div5, span4);
        append(div5, t24);
        append(div5, input4);
        set_input_value(
          input4,
          /*filter*/
          ctx[1].minRound
        );
        append(div5, t25);
        append(div5, span5);
        append(div5, t27);
        append(div5, input5);
        set_input_value(
          input5,
          /*filter*/
          ctx[1].maxRound
        );
        append(div8, t28);
        append(div8, div6);
        append(div6, b3);
        append(div6, t30);
        append(div6, span6);
        append(div6, t32);
        append(div6, input6);
        set_input_value(
          input6,
          /*filter*/
          ctx[1].minAverageScore
        );
        append(div6, t33);
        append(div6, span7);
        append(div6, t35);
        append(div6, input7);
        set_input_value(
          input7,
          /*filter*/
          ctx[1].maxAverageScore
        );
        append(div6, t36);
        append(div6, span8);
        append(div8, t38);
        append(div8, div7);
        mount_component(checkbox, div7, null);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              input0,
              "input",
              /*input0_input_handler*/
              ctx[3]
            ),
            listen(
              input1,
              "change",
              /*change_handler*/
              ctx[5]
            ),
            listen(
              input2,
              "input",
              /*input2_input_handler*/
              ctx[6]
            ),
            listen(
              input3,
              "input",
              /*input3_input_handler*/
              ctx[7]
            ),
            listen(
              input4,
              "input",
              /*input4_input_handler*/
              ctx[8]
            ),
            listen(
              input5,
              "input",
              /*input5_input_handler*/
              ctx[9]
            ),
            listen(
              input6,
              "input",
              /*input6_input_handler*/
              ctx[10]
            ),
            listen(
              input7,
              "input",
              /*input7_input_handler*/
              ctx[11]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*filter*/
        2 && input0.value !== /*filter*/
        ctx2[1].name) {
          set_input_value(
            input0,
            /*filter*/
            ctx2[1].name
          );
        }
        if (dirty & /*filter*/
        2 && to_number(input2.value) !== /*filter*/
        ctx2[1].minAmountPlayers) {
          set_input_value(
            input2,
            /*filter*/
            ctx2[1].minAmountPlayers
          );
        }
        if (dirty & /*filter*/
        2 && to_number(input3.value) !== /*filter*/
        ctx2[1].maxAmountPlayers) {
          set_input_value(
            input3,
            /*filter*/
            ctx2[1].maxAmountPlayers
          );
        }
        if (dirty & /*filter*/
        2 && to_number(input4.value) !== /*filter*/
        ctx2[1].minRound) {
          set_input_value(
            input4,
            /*filter*/
            ctx2[1].minRound
          );
        }
        if (dirty & /*filter*/
        2 && to_number(input5.value) !== /*filter*/
        ctx2[1].maxRound) {
          set_input_value(
            input5,
            /*filter*/
            ctx2[1].maxRound
          );
        }
        if (dirty & /*filter*/
        2 && to_number(input6.value) !== /*filter*/
        ctx2[1].minAverageScore) {
          set_input_value(
            input6,
            /*filter*/
            ctx2[1].minAverageScore
          );
        }
        if (dirty & /*filter*/
        2 && to_number(input7.value) !== /*filter*/
        ctx2[1].maxAverageScore) {
          set_input_value(
            input7,
            /*filter*/
            ctx2[1].maxAverageScore
          );
        }
        const checkbox_changes = {};
        if (!updating_checked && dirty & /*filter*/
        2) {
          updating_checked = true;
          checkbox_changes.checked = /*filter*/
          ctx2[1].containsTypoPlayers;
          add_flush_callback(() => updating_checked = false);
        }
        checkbox.$set(checkbox_changes);
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div9);
        }
        destroy_component(flatbutton);
        destroy_component(checkbox);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_fragment$c, "create_fragment$c");
  function instance$c($$self, $$props, $$invalidate) {
    let { feature } = $$props;
    let { onCreate } = $$props;
    const filter2 = {
      name: "",
      createdAt: (/* @__PURE__ */ new Date()).getTime()
    };
    function input0_input_handler() {
      filter2.name = this.value;
      $$invalidate(1, filter2);
    }
    __name(input0_input_handler, "input0_input_handler");
    const click_handler2 = /* @__PURE__ */ __name(async () => {
      onCreate(filter2);
    }, "click_handler");
    const change_handler = /* @__PURE__ */ __name((e) => {
      const names = e.currentTarget.value.split(",").map((name) => name.trim());
      $$invalidate(1, filter2.containsUsernames = names.length > 0 ? names : void 0, filter2);
    }, "change_handler");
    function input2_input_handler() {
      filter2.minAmountPlayers = to_number(this.value);
      $$invalidate(1, filter2);
    }
    __name(input2_input_handler, "input2_input_handler");
    function input3_input_handler() {
      filter2.maxAmountPlayers = to_number(this.value);
      $$invalidate(1, filter2);
    }
    __name(input3_input_handler, "input3_input_handler");
    function input4_input_handler() {
      filter2.minRound = to_number(this.value);
      $$invalidate(1, filter2);
    }
    __name(input4_input_handler, "input4_input_handler");
    function input5_input_handler() {
      filter2.maxRound = to_number(this.value);
      $$invalidate(1, filter2);
    }
    __name(input5_input_handler, "input5_input_handler");
    function input6_input_handler() {
      filter2.minAverageScore = to_number(this.value);
      $$invalidate(1, filter2);
    }
    __name(input6_input_handler, "input6_input_handler");
    function input7_input_handler() {
      filter2.maxAverageScore = to_number(this.value);
      $$invalidate(1, filter2);
    }
    __name(input7_input_handler, "input7_input_handler");
    function checkbox_checked_binding(value) {
      if ($$self.$$.not_equal(filter2.containsTypoPlayers, value)) {
        filter2.containsTypoPlayers = value;
        $$invalidate(1, filter2);
      }
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(2, feature = $$props2.feature);
      if ("onCreate" in $$props2) $$invalidate(0, onCreate = $$props2.onCreate);
    };
    return [
      onCreate,
      filter2,
      feature,
      input0_input_handler,
      click_handler2,
      change_handler,
      input2_input_handler,
      input3_input_handler,
      input4_input_handler,
      input5_input_handler,
      input6_input_handler,
      input7_input_handler,
      checkbox_checked_binding
    ];
  }
  __name(instance$c, "instance$c");
  const _Filter_form = class _Filter_form extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$c, create_fragment$c, safe_not_equal, { feature: 2, onCreate: 0 });
    }
  };
  __name(_Filter_form, "Filter_form");
  let Filter_form = _Filter_form;
  function get_each_context$6(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[7] = list[i];
    return child_ctx;
  }
  __name(get_each_context$6, "get_each_context$6");
  function get_each_context_1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[10] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1, "get_each_context_1");
  function create_each_block_1(ctx) {
    let div1;
    let b;
    let t0_value = (
      /*filter*/
      ctx[10].name + ""
    );
    let t0;
    let t1;
    let div0;
    let t2_value = (
      /*feature*/
      ctx[0].buildFilterTooltipText(
        /*filter*/
        ctx[10]
      ) + ""
    );
    let t2;
    let t3;
    return {
      c() {
        div1 = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = space();
        div0 = element("div");
        t2 = text(t2_value);
        t3 = space();
        attr(b, "class", "svelte-1apd7dj");
        attr(div0, "class", "typo-filter-search-list-item-description svelte-1apd7dj");
        attr(div1, "class", "typo-filter-search-list-item svelte-1apd7dj");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, b);
        append(b, t0);
        append(div1, t1);
        append(div1, div0);
        append(div0, t2);
        append(div1, t3);
      },
      p(ctx2, dirty) {
        if (dirty & /*filters*/
        2 && t0_value !== (t0_value = /*filter*/
        ctx2[10].name + "")) set_data(t0, t0_value);
        if (dirty & /*feature, filters*/
        3 && t2_value !== (t2_value = /*feature*/
        ctx2[0].buildFilterTooltipText(
          /*filter*/
          ctx2[10]
        ) + "")) set_data(t2, t2_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
      }
    };
  }
  __name(create_each_block_1, "create_each_block_1");
  function create_each_block$6(ctx) {
    let div1;
    let b;
    let t0_value = (
      /*lobby*/
      ctx[7].players.length - 1 + ""
    );
    let t0;
    let t1;
    let t2_value = (
      /*lobby*/
      ctx[7].round + ""
    );
    let t2;
    let t3;
    let div0;
    let t4_value = (
      /*lobby*/
      ctx[7].players.filter(func_12).map(func_2).join(", ") + ""
    );
    let t4;
    let t5;
    let mounted;
    let dispose;
    function func_12(...args) {
      return (
        /*func_1*/
        ctx[5](
          /*lobby*/
          ctx[7],
          ...args
        )
      );
    }
    __name(func_12, "func_1");
    function click_handler2() {
      return (
        /*click_handler*/
        ctx[6](
          /*lobby*/
          ctx[7]
        )
      );
    }
    __name(click_handler2, "click_handler");
    return {
      c() {
        div1 = element("div");
        b = element("b");
        t0 = text(t0_value);
        t1 = text(" players, round ");
        t2 = text(t2_value);
        t3 = space();
        div0 = element("div");
        t4 = text(t4_value);
        t5 = space();
        attr(b, "class", "svelte-1apd7dj");
        attr(div0, "class", "typo-filter-search-list-item-description svelte-1apd7dj");
        attr(div1, "class", "typo-filter-search-list-item lobby svelte-1apd7dj");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, b);
        append(b, t0);
        append(b, t1);
        append(b, t2);
        append(div1, t3);
        append(div1, div0);
        append(div0, t4);
        append(div1, t5);
        if (!mounted) {
          dispose = listen(div1, "click", click_handler2);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*$visitedLobbies*/
        8 && t0_value !== (t0_value = /*lobby*/
        ctx[7].players.length - 1 + "")) set_data(t0, t0_value);
        if (dirty & /*$visitedLobbies*/
        8 && t2_value !== (t2_value = /*lobby*/
        ctx[7].round + "")) set_data(t2, t2_value);
        if (dirty & /*$visitedLobbies*/
        8 && t4_value !== (t4_value = /*lobby*/
        ctx[7].players.filter(func_12).map(func_2).join(", ") + "")) set_data(t4, t4_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block$6, "create_each_block$6");
  function create_fragment$b(ctx) {
    let div4;
    let div0;
    let t2;
    let div1;
    let t3;
    let div2;
    let t4;
    let t5_value = (
      /*$visitedLobbies*/
      ctx[3].length + ""
    );
    let t5;
    let br1;
    let t6;
    let br2;
    let t7;
    let t8;
    let div3;
    let each_value_1 = ensure_array_like(
      /*filters*/
      ctx[1]
    );
    let each_blocks_1 = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    }
    let each_value = ensure_array_like(
      /*$visitedLobbies*/
      ctx[3].filter(func)
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    }
    return {
      c() {
        div4 = element("div");
        div0 = element("div");
        div0.innerHTML = `Lobby search is currently running and joining through lobbies.<br/>
    The search will stop once a lobby is found that matches one of the filters:`;
        t2 = space();
        div1 = element("div");
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].c();
        }
        t3 = space();
        div2 = element("div");
        t4 = text("Discovered lobbies: ");
        t5 = text(t5_value);
        br1 = element("br");
        t6 = text("\n    If you click on a lobby, the search will stop and join the selected lobby instead.");
        br2 = element("br");
        t7 = text("\n    A lobby might have changed since it was discovered.");
        t8 = space();
        div3 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div1, "class", "typo-filter-search-list svelte-1apd7dj");
        attr(div3, "class", "typo-filter-search-list svelte-1apd7dj");
        attr(div4, "class", "typo-filter-search svelte-1apd7dj");
      },
      m(target, anchor) {
        insert(target, div4, anchor);
        append(div4, div0);
        append(div4, t2);
        append(div4, div1);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          if (each_blocks_1[i]) {
            each_blocks_1[i].m(div1, null);
          }
        }
        append(div4, t3);
        append(div4, div2);
        append(div2, t4);
        append(div2, t5);
        append(div2, br1);
        append(div2, t6);
        append(div2, br2);
        append(div2, t7);
        append(div4, t8);
        append(div4, div3);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div3, null);
          }
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*feature, filters*/
        3) {
          each_value_1 = ensure_array_like(
            /*filters*/
            ctx2[1]
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1(ctx2, each_value_1, i);
            if (each_blocks_1[i]) {
              each_blocks_1[i].p(child_ctx, dirty);
            } else {
              each_blocks_1[i] = create_each_block_1(child_ctx);
              each_blocks_1[i].c();
              each_blocks_1[i].m(div1, null);
            }
          }
          for (; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d(1);
          }
          each_blocks_1.length = each_value_1.length;
        }
        if (dirty & /*$visitedLobbies*/
        8 && t5_value !== (t5_value = /*$visitedLobbies*/
        ctx2[3].length + "")) set_data(t5, t5_value);
        if (dirty & /*lobbySelected, $visitedLobbies*/
        12) {
          each_value = ensure_array_like(
            /*$visitedLobbies*/
            ctx2[3].filter(func)
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$6(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$6(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div3, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div4);
        }
        destroy_each(each_blocks_1, detaching);
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_fragment$b, "create_fragment$b");
  const func = /* @__PURE__ */ __name((lobby) => lobby.players.length > 1, "func");
  const func_2 = /* @__PURE__ */ __name((p) => p.name, "func_2");
  function instance$b($$self, $$props, $$invalidate) {
    let $visitedLobbies;
    let { feature } = $$props;
    let { filters } = $$props;
    let { lobbySelected } = $$props;
    const visitedLobbies = feature.visitedLobbiesStore;
    component_subscribe($$self, visitedLobbies, (value) => $$invalidate(3, $visitedLobbies = value));
    const func_12 = /* @__PURE__ */ __name((lobby, p) => p.id !== lobby.meId, "func_1");
    const click_handler2 = /* @__PURE__ */ __name((lobby) => lobbySelected(lobby.id ?? ""), "click_handler");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
      if ("filters" in $$props2) $$invalidate(1, filters = $$props2.filters);
      if ("lobbySelected" in $$props2) $$invalidate(2, lobbySelected = $$props2.lobbySelected);
    };
    return [
      feature,
      filters,
      lobbySelected,
      $visitedLobbies,
      visitedLobbies,
      func_12,
      click_handler2
    ];
  }
  __name(instance$b, "instance$b");
  const _Filter_search = class _Filter_search extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$b, create_fragment$b, safe_not_equal, { feature: 0, filters: 1, lobbySelected: 2 });
    }
  };
  __name(_Filter_search, "Filter_search");
  let Filter_search = _Filter_search;
  var __defProp$g = Object.defineProperty;
  var __decorateClass$g = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$g(target, key2, result);
    return result;
  }, "__decorateClass$g");
  const _PanelFiltersFeature = class _PanelFiltersFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elements");
      __publicField(this, "_lobbyService");
      __publicField(this, "_modalService");
      __publicField(this, "_toastService");
      __publicField(this, "_lobbyItemsService");
      __publicField(this, "name", "Lobby Filters");
      __publicField(this, "description", "Lets you create custom filters for a quick lobby search");
      __publicField(this, "tags", [
        FeatureTag.SOCIAL
      ]);
      __publicField(this, "featureId", 5);
      __publicField(this, "_component");
      __publicField(this, "_savedFiltersSetting", new ExtensionSetting("saved_filters", [], this));
      __publicField(this, "_selectedFiltersSetting", new ExtensionSetting("selected_filters", [], this));
      __publicField(this, "_currentSearch", new Subject$1());
      __publicField(this, "_overrideSearch", new Subject$1());
      __publicField(this, "_visitedLobbies", new BehaviorSubject([]));
      __publicField(this, "_searchSubscription");
    }
    async onActivate() {
      const elements2 = await this._elements.complete();
      this._component = new Panel_filters({
        target: elements2.filterTab,
        props: {
          feature: this
        }
      });
      this._searchSubscription = this._currentSearch.pipe(
        startWith(null),
        distinctUntilChanged(),
        combineLatestWith(this._lobbyService.lobby$),
        pairwise(),
        withLatestFrom(this._overrideSearch.pipe(startWith(void 0)))
      ).subscribe(([[[previousFilter, previousLobby], [currentFilter, currentLobby]], override]) => this.handleSearchChange(previousFilter, previousLobby, currentFilter, currentLobby, override));
    }
    onDestroy() {
      var _a2, _b2;
      (_a2 = this._component) == null ? void 0 : _a2.$destroy();
      (_b2 = this._searchSubscription) == null ? void 0 : _b2.unsubscribe();
      this._visitedLobbies.next([]);
    }
    get savedFiltersStore() {
      return this._savedFiltersSetting.store;
    }
    get selectedFiltersStore() {
      return this._selectedFiltersSetting.store;
    }
    get visitedLobbiesStore() {
      return fromObservable(this._visitedLobbies, []);
    }
    /**
     * Handle update of filters and current lobby,
     * proceeds with joining/leaving if filters match
     *
     * Processes an override signal to abort or join other lobby
     *
     * @param previousFilter
     * @param previousLobby
     * @param currentFilter
     * @param currentLobby
     * @param override
     * @private
     */
    async handleSearchChange(previousFilter, previousLobby, currentFilter, currentLobby, override) {
      this._logger.debug("Search changed", previousFilter, previousLobby, currentFilter, currentLobby, override);
      if (!currentLobby) {
        if (override !== void 0) {
          if (override === null) {
            this._overrideSearch.next(void 0);
            this._currentSearch.next(null);
            return;
          } else {
            this._overrideSearch.next(void 0);
            this._currentSearch.next(null);
            await this._lobbyService.joinLobby(override);
            return;
          }
        }
        if (previousFilter === null && currentFilter !== null) {
          this._logger.info("Starting search");
          await this._lobbyService.joinLobby();
          await this.promptFilterSearch(currentFilter);
        }
        if (currentFilter !== null) {
          this._logger.info("Joining next lobby");
          await this._lobbyService.joinLobby();
        }
      } else {
        if (currentFilter !== null) {
          this._visitedLobbies.next([currentLobby, ...this._visitedLobbies.value.filter((lobby) => lobby.id !== currentLobby.id)]);
          const items = await firstValueFrom(this._lobbyItemsService.onlineItems$);
          if (!currentFilter.some((filter2) => this.checkLobbyFilterMatch(filter2, currentLobby, items))) {
            this._logger.info("Lobby does not match filter, leaving");
            this._lobbyService.leaveLobby();
          } else {
            this._logger.info("Lobby found");
            this._currentSearch.next(null);
          }
        }
      }
      if (currentFilter === null) {
        this._visitedLobbies.next([]);
      }
    }
    /**
     * Check if a lobby matches a filter
     * @param filter
     * @param lobby
     * @param items
     * @private
     */
    checkLobbyFilterMatch(filter2, lobby, items) {
      this._logger.info("Checking lobby filter match", filter2, lobby);
      if (filter2.minAmountPlayers !== void 0 && lobby.players.length < filter2.minAmountPlayers) return false;
      if (filter2.maxAmountPlayers !== void 0 && lobby.players.length > filter2.maxAmountPlayers) return false;
      const averageScore = lobby.players.map((p) => p.score).reduce((a, b) => a + b, 0) / lobby.players.length;
      if (filter2.minAverageScore !== void 0 && averageScore < filter2.minAverageScore) return false;
      if (filter2.maxAverageScore !== void 0 && averageScore > filter2.maxAverageScore) return false;
      if (filter2.minRound !== void 0 && lobby.round < filter2.minRound) return false;
      if (filter2.maxRound !== void 0 && lobby.round > filter2.maxRound) return false;
      if (filter2.containsUsernames && filter2.containsUsernames.length) {
        const usernames = lobby.players.map((p) => p.name);
        if (!filter2.containsUsernames.some((name) => usernames.includes(name))) return false;
      }
      if (filter2.containsTypoPlayers === true) {
        const lobbyKey = calculateLobbyKey(lobby.id ?? "");
        return items.some((item) => item.lobbyKey === lobbyKey);
      }
      return true;
    }
    async startSearch() {
      let filters = await this._savedFiltersSetting.getValue();
      const selectedFilters = await this._selectedFiltersSetting.getValue();
      filters = filters.filter((filter2) => selectedFilters.includes(filter2.createdAt));
      if (filters.length === 0) {
        await this._toastService.showToast("No filters selected", "Select search filters from the list above\n or create a new filter");
        return;
      }
      this._logger.debug("Starting search", filters);
      this._currentSearch.next(filters);
    }
    /**
     * Opens a prompt which indicates that the search is currently in progress.
     * If the user submits/closes, the search is aborted
     * If a search filter is removed while the prompt is open, the prompt is closed
     */
    async promptFilterSearch(filters) {
      let finishSubscription;
      const formComponent = {
        componentType: Filter_search,
        propsFactory: /* @__PURE__ */ __name((submit) => {
          finishSubscription = this._currentSearch.pipe(
            filter((filters2) => filters2 === null)
          ).subscribe(() => submit(null));
          return {
            feature: this,
            filters,
            lobbySelected: /* @__PURE__ */ __name((id2) => submit(id2), "lobbySelected")
            /* submit lobby id as search override  */
          };
        }, "propsFactory")
      };
      const result = await this._modalService.showPrompt(
        formComponent.componentType,
        formComponent.propsFactory,
        "Lobby Search",
        "card"
      );
      finishSubscription == null ? void 0 : finishSubscription.unsubscribe();
      if (result === void 0) {
        await this._toastService.showToast("Search aborted");
        this._overrideSearch.next(null);
      }
      if (typeof result === "string") {
        await this._toastService.showToast("Lobby selected", `Joining lobby ${result}`);
        this._overrideSearch.next(result);
      }
      if (result === null) {
        await this._toastService.showToast("Search finished");
      }
    }
    /**
     * Prompt the user to create a new filter
     */
    async promptFilterCreation() {
      const formComponent = {
        componentType: Filter_form,
        propsFactory: /* @__PURE__ */ __name((submit) => ({
          feature: this,
          onCreate: submit.bind(this)
        }), "propsFactory"),
        validate: /* @__PURE__ */ __name((filter2) => this.validateFilter(filter2), "validate")
      };
      const result = this._modalService.showPrompt(
        formComponent.componentType,
        formComponent.propsFactory,
        "Add Lobby Filter",
        "card",
        formComponent.validate
      );
      return await result;
    }
    /**
     * Remove a filter from the saved filters
     * @param filter
     */
    async removeFilter(filter2) {
      this._logger.debug("Removing filter", filter2);
      const toast = await this._toastService.showLoadingToast("Removing filter");
      try {
        let filters = await this._savedFiltersSetting.getValue();
        filters = filters.filter((f) => f.createdAt !== filter2.createdAt);
        await this._savedFiltersSetting.setValue(filters);
        const activeFilters = await this._selectedFiltersSetting.getValue();
        await this._selectedFiltersSetting.setValue(activeFilters.filter((id2) => id2 !== filter2.createdAt));
        toast.resolve(`Filter "${filter2.name}" removed`);
      } catch (e) {
        this._logger.error("Failed to remove filter", e);
        toast.reject("Failed to remove filter");
      }
    }
    /**
     * Add a filter to the saved filters
     * @param filter
     */
    async addFilter(filter2) {
      this._logger.debug("Adding filter", filter2);
      const toast = await this._toastService.showLoadingToast("Adding filter");
      try {
        let filters = await this._savedFiltersSetting.getValue();
        filters = [filter2, ...filters];
        await this._savedFiltersSetting.setValue(filters);
        const activeFilters = await this._selectedFiltersSetting.getValue();
        await this._selectedFiltersSetting.setValue([filter2.createdAt, ...activeFilters]);
        toast.resolve(`Filter "${filter2.name}" added`);
      } catch (e) {
        this._logger.error("Failed to add filter", e);
        toast.reject("Failed to add filter");
        return false;
      }
      return true;
    }
    /**
     * Validate a filter and show toasts if errors found
     * @param filter
     */
    async validateFilter(filter2) {
      var _a2;
      this._logger.debug("Validating filter", filter2);
      filter2.name = filter2.name.trim();
      if (filter2.name.length === 0) {
        await this._toastService.showToast("Invalid Filter", "Filter name cannot be empty");
        return false;
      }
      if (((_a2 = filter2.containsUsernames) == null ? void 0 : _a2.length) === 0) filter2.containsUsernames = void 0;
      if (filter2.minRound !== void 0 && filter2.minRound <= 0) filter2.minRound = void 0;
      if (filter2.maxRound !== void 0 && filter2.maxRound <= 0) filter2.maxRound = void 0;
      if (filter2.minAmountPlayers !== void 0 && filter2.minAmountPlayers <= 0) filter2.minAmountPlayers = void 0;
      if (filter2.maxAmountPlayers !== void 0 && filter2.maxAmountPlayers <= 0) filter2.maxAmountPlayers = void 0;
      if (filter2.minAverageScore !== void 0 && filter2.minAverageScore <= 0) filter2.minAverageScore = void 0;
      if (filter2.maxAverageScore !== void 0 && filter2.maxAverageScore <= 0) filter2.maxAverageScore = void 0;
      if (filter2.minAverageScore !== void 0 && filter2.maxAverageScore !== void 0 && filter2.minAverageScore > filter2.maxAverageScore) {
        await this._toastService.showToast("Invalid Filter", "Minimum average score cannot be higher than maximum average score");
        return false;
      }
      if (filter2.minRound !== void 0 && filter2.maxRound !== void 0 && filter2.minRound > filter2.maxRound) {
        await this._toastService.showToast("Invalid Filter", "Minimum round cannot be higher than maximum round");
        return false;
      }
      if (filter2.minAmountPlayers !== void 0 && filter2.maxAmountPlayers !== void 0 && filter2.minAmountPlayers > filter2.maxAmountPlayers) {
        await this._toastService.showToast("Invalid Filter", "Minimum amount of players cannot be higher than maximum amount of players");
        return false;
      }
      return true;
    }
    /**
     * Build tooltip text for a filter
     * @param filter
     */
    buildFilterTooltipText(filter2) {
      var _a2;
      let desc = "";
      if (filter2.minAmountPlayers != void 0 || filter2.maxAmountPlayers !== void 0) {
        desc += `
👤 ${filter2.minAmountPlayers ?? "x"} - ${filter2.maxAmountPlayers ?? "x"} players`;
      }
      if (filter2.minAverageScore != void 0 || filter2.maxAverageScore !== void 0) {
        desc += `
🏆 ${filter2.minAverageScore ?? "x"} - ${filter2.maxAverageScore ?? "x"} average score`;
      }
      if (filter2.minRound != void 0 || filter2.maxRound !== void 0) {
        desc += `
🔄 round ${filter2.minRound ?? "x"} - ${filter2.maxRound ?? "x"}`;
      }
      if ((_a2 = filter2.containsUsernames) == null ? void 0 : _a2.length) {
        desc += `
🔎 ${filter2.containsUsernames.join(", ")}`;
      }
      if (filter2.containsTypoPlayers) {
        desc += "\n🤖 Typo players";
      }
      return desc.length === 0 ? "Empty filter :(" : desc.trim();
    }
  };
  __name(_PanelFiltersFeature, "PanelFiltersFeature");
  let PanelFiltersFeature = _PanelFiltersFeature;
  __decorateClass$g([
    inject(ElementsSetup)
  ], PanelFiltersFeature.prototype, "_elements");
  __decorateClass$g([
    inject(LobbyService)
  ], PanelFiltersFeature.prototype, "_lobbyService");
  __decorateClass$g([
    inject(ModalService)
  ], PanelFiltersFeature.prototype, "_modalService");
  __decorateClass$g([
    inject(ToastService)
  ], PanelFiltersFeature.prototype, "_toastService");
  __decorateClass$g([
    inject(LobbyItemsService)
  ], PanelFiltersFeature.prototype, "_lobbyItemsService");
  const isAnonymousPlayerIdentification = /* @__PURE__ */ __name((value) => {
    return value.lobbyKey !== void 0 && value.lobbyPlayerId !== void 0;
  }, "isAnonymousPlayerIdentification");
  var OnlineItemTypeDto = /* @__PURE__ */ ((OnlineItemTypeDto2) => {
    OnlineItemTypeDto2[OnlineItemTypeDto2["Award"] = 3] = "Award";
    OnlineItemTypeDto2[OnlineItemTypeDto2["Sprite"] = 0] = "Sprite";
    OnlineItemTypeDto2[OnlineItemTypeDto2["SpriteShift"] = 1] = "SpriteShift";
    OnlineItemTypeDto2[OnlineItemTypeDto2["Scene"] = 2] = "Scene";
    OnlineItemTypeDto2[OnlineItemTypeDto2["SceneTheme"] = 6] = "SceneTheme";
    OnlineItemTypeDto2[OnlineItemTypeDto2["Rewardee"] = 5] = "Rewardee";
    return OnlineItemTypeDto2;
  })(OnlineItemTypeDto || {});
  function get_each_context$5(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[3] = list[i];
    return child_ctx;
  }
  __name(get_each_context$5, "get_each_context$5");
  function create_each_block$5(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        attr(div, "class", "icon visible typo-awards-icon svelte-19i0k4m");
        set_style(div, "background-image", "url(" + /*award*/
        ctx[3].url + ")");
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*awards*/
        1) {
          set_style(div, "background-image", "url(" + /*award*/
          ctx2[3].url + ")");
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_each_block$5, "create_each_block$5");
  function create_fragment$a(ctx) {
    let each_1_anchor;
    let each_value = ensure_array_like(
      /*awards*/
      ctx[0]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    }
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*awards*/
        1) {
          each_value = ensure_array_like(
            /*awards*/
            ctx2[0]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$5(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$5(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_fragment$a, "create_fragment$a");
  function instance$a($$self, $$props, $$invalidate) {
    let { playerDisplay } = $$props;
    let { awards } = $$props;
    const getAwards = /* @__PURE__ */ __name(() => {
      return awards;
    }, "getAwards");
    $$self.$$set = ($$props2) => {
      if ("playerDisplay" in $$props2) $$invalidate(1, playerDisplay = $$props2.playerDisplay);
      if ("awards" in $$props2) $$invalidate(0, awards = $$props2.awards);
    };
    return [awards, playerDisplay, getAwards];
  }
  __name(instance$a, "instance$a");
  const _Awards_display = class _Awards_display extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$a, create_fragment$a, safe_not_equal, {
        playerDisplay: 1,
        awards: 0,
        getAwards: 2
      });
    }
    get getAwards() {
      return this.$$.ctx[2];
    }
  };
  __name(_Awards_display, "Awards_display");
  let Awards_display = _Awards_display;
  function create_if_block_1$2(ctx) {
    let div;
    let iconbutton;
    let current;
    iconbutton = new Icon_button({
      props: {
        hoverMove: false,
        size: "48px",
        name: "Award this drawing",
        tooltipAction: (
          /*feature*/
          ctx[0].createTooltip
        ),
        icon: "file-img-award-gif"
      }
    });
    iconbutton.$on(
      "click",
      /*click_handler*/
      ctx[6]
    );
    return {
      c() {
        div = element("div");
        create_component(iconbutton.$$.fragment);
        attr(div, "class", "typo-awards-icon svelte-aldc0m");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(iconbutton, div, null);
        current = true;
      },
      p(ctx2, dirty) {
        const iconbutton_changes = {};
        if (dirty & /*feature*/
        1) iconbutton_changes.tooltipAction = /*feature*/
        ctx2[0].createTooltip;
        iconbutton.$set(iconbutton_changes);
      },
      i(local) {
        if (current) return;
        transition_in(iconbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(iconbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(iconbutton);
      }
    };
  }
  __name(create_if_block_1$2, "create_if_block_1$2");
  function create_if_block$4(ctx) {
    let previous_key = (
      /*currentAwardPresentation*/
      ctx[1]
    );
    let key_block_anchor;
    let key_block = create_key_block(ctx);
    return {
      c() {
        key_block.c();
        key_block_anchor = empty();
      },
      m(target, anchor) {
        key_block.m(target, anchor);
        insert(target, key_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*currentAwardPresentation*/
        2 && safe_not_equal(previous_key, previous_key = /*currentAwardPresentation*/
        ctx2[1])) {
          key_block.d(1);
          key_block = create_key_block(ctx2);
          key_block.c();
          key_block.m(key_block_anchor.parentNode, key_block_anchor);
        } else {
          key_block.p(ctx2, dirty);
        }
      },
      d(detaching) {
        if (detaching) {
          detach(key_block_anchor);
        }
        key_block.d(detaching);
      }
    };
  }
  __name(create_if_block$4, "create_if_block$4");
  function create_key_block(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        attr(div, "class", "typo-awards-presentation svelte-aldc0m");
        set_style(div, "background-image", "url(" + /*currentAwardPresentation*/
        ctx[1].url + ")");
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*currentAwardPresentation*/
        2) {
          set_style(div, "background-image", "url(" + /*currentAwardPresentation*/
          ctx2[1].url + ")");
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_key_block, "create_key_block");
  function create_fragment$9(ctx) {
    let t;
    let if_block1_anchor;
    let current;
    let if_block0 = (
      /*$member*/
      ctx[2] !== void 0 && /*$member*/
      ctx[2] !== null && /*$awardable*/
      ctx[3] && create_if_block_1$2(ctx)
    );
    let if_block1 = (
      /*currentAwardPresentation*/
      ctx[1] !== void 0 && create_if_block$4(ctx)
    );
    return {
      c() {
        if (if_block0) if_block0.c();
        t = space();
        if (if_block1) if_block1.c();
        if_block1_anchor = empty();
      },
      m(target, anchor) {
        if (if_block0) if_block0.m(target, anchor);
        insert(target, t, anchor);
        if (if_block1) if_block1.m(target, anchor);
        insert(target, if_block1_anchor, anchor);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (
          /*$member*/
          ctx2[2] !== void 0 && /*$member*/
          ctx2[2] !== null && /*$awardable*/
          ctx2[3]
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty & /*$member, $awardable*/
            12) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_1$2(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(t.parentNode, t);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        if (
          /*currentAwardPresentation*/
          ctx2[1] !== void 0
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
          } else {
            if_block1 = create_if_block$4(ctx2);
            if_block1.c();
            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block0);
        current = true;
      },
      o(local) {
        transition_out(if_block0);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t);
          detach(if_block1_anchor);
        }
        if (if_block0) if_block0.d(detaching);
        if (if_block1) if_block1.d(detaching);
      }
    };
  }
  __name(create_fragment$9, "create_fragment$9");
  function instance$9($$self, $$props, $$invalidate) {
    let $member;
    let $awardable;
    let { feature } = $$props;
    let { currentAwardPresentation = void 0 } = $$props;
    const member = feature.memberStore;
    component_subscribe($$self, member, (value) => $$invalidate(2, $member = value));
    const awardable = feature.playerAwardableStore;
    component_subscribe($$self, awardable, (value) => $$invalidate(3, $awardable = value));
    const click_handler2 = /* @__PURE__ */ __name(async () => {
      const award = await feature.promptAwardSelection($member);
      if (award !== void 0 && award.inventoryIds.length > 0) {
        await feature.giveAward(award.inventoryIds[0]);
      }
    }, "click_handler");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
      if ("currentAwardPresentation" in $$props2) $$invalidate(1, currentAwardPresentation = $$props2.currentAwardPresentation);
    };
    return [
      feature,
      currentAwardPresentation,
      $member,
      $awardable,
      member,
      awardable,
      click_handler2
    ];
  }
  __name(instance$9, "instance$9");
  const _Player_awards = class _Player_awards extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$9, create_fragment$9, safe_not_equal, { feature: 0, currentAwardPresentation: 1 });
    }
  };
  __name(_Player_awards, "Player_awards");
  let Player_awards = _Player_awards;
  function get_each_context$4(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[4] = list[i];
    return child_ctx;
  }
  __name(get_each_context$4, "get_each_context$4");
  function create_each_block$4(ctx) {
    let div1;
    let div0;
    let t0;
    let span0;
    let b;
    let t1_value = (
      /*award*/
      ctx[4].award.name + ""
    );
    let t1;
    let t2;
    let span1;
    let t3_value = (
      /*getAwardRarityName*/
      ctx[2](
        /*award*/
        ctx[4].award.rarity
      ) + ""
    );
    let t3;
    let t4;
    let span2;
    let t5;
    let t6_value = (
      /*award*/
      ctx[4].inventoryIds.length + ""
    );
    let t6;
    let t7;
    let mounted;
    let dispose;
    function click_handler2() {
      return (
        /*click_handler*/
        ctx[3](
          /*award*/
          ctx[4]
        )
      );
    }
    __name(click_handler2, "click_handler");
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        t0 = space();
        span0 = element("span");
        b = element("b");
        t1 = text(t1_value);
        t2 = space();
        span1 = element("span");
        t3 = text(t3_value);
        t4 = space();
        span2 = element("span");
        t5 = text("x");
        t6 = text(t6_value);
        t7 = space();
        attr(div0, "class", "typo-award-picker-award-thumb svelte-9q5vog");
        set_style(div0, "background-image", "url(" + /*award*/
        ctx[4].award.url + ")");
        attr(span0, "class", "svelte-9q5vog");
        attr(span1, "class", "svelte-9q5vog");
        attr(span2, "class", "svelte-9q5vog");
        attr(div1, "class", "typo-award-picker-award svelte-9q5vog");
        set_style(
          div1,
          "order",
          /*award*/
          ctx[4].award.id
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div1, t0);
        append(div1, span0);
        append(span0, b);
        append(b, t1);
        append(div1, t2);
        append(div1, span1);
        append(span1, t3);
        append(div1, t4);
        append(div1, span2);
        append(span2, t5);
        append(span2, t6);
        append(div1, t7);
        if (!mounted) {
          dispose = listen(div1, "click", click_handler2);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*awards*/
        2) {
          set_style(div0, "background-image", "url(" + /*award*/
          ctx[4].award.url + ")");
        }
        if (dirty & /*awards*/
        2 && t1_value !== (t1_value = /*award*/
        ctx[4].award.name + "")) set_data(t1, t1_value);
        if (dirty & /*awards*/
        2 && t3_value !== (t3_value = /*getAwardRarityName*/
        ctx[2](
          /*award*/
          ctx[4].award.rarity
        ) + "")) set_data(t3, t3_value);
        if (dirty & /*awards*/
        2 && t6_value !== (t6_value = /*award*/
        ctx[4].inventoryIds.length + "")) set_data(t6, t6_value);
        if (dirty & /*awards*/
        2) {
          set_style(
            div1,
            "order",
            /*award*/
            ctx[4].award.id
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_each_block$4, "create_each_block$4");
  function create_fragment$8(ctx) {
    let div1;
    let span;
    let t1;
    let div0;
    let each_value = ensure_array_like(
      /*awards*/
      ctx[1]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    }
    return {
      c() {
        div1 = element("div");
        span = element("span");
        span.textContent = "Choose an award from your inventory to award the current drawing.";
        t1 = space();
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(span, "class", "svelte-9q5vog");
        attr(div0, "class", "typo-award-picker-list color-scrollbar svelte-9q5vog");
        attr(div1, "class", "typo-award-picker svelte-9q5vog");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, span);
        append(div1, t1);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*awards, onPick, getAwardRarityName*/
        7) {
          each_value = ensure_array_like(
            /*awards*/
            ctx2[1]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$4(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$4(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div0, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_fragment$8, "create_fragment$8");
  function instance$8($$self, $$props, $$invalidate) {
    let { onPick } = $$props;
    let { awards } = $$props;
    const getAwardRarityName = /* @__PURE__ */ __name((rarity) => {
      switch (rarity) {
        case 0:
          return "Common";
        case 1:
          return "Special";
        case 2:
          return "Epic";
        default:
          return "Legendary";
      }
    }, "getAwardRarityName");
    const click_handler2 = /* @__PURE__ */ __name((award) => onPick(award), "click_handler");
    $$self.$$set = ($$props2) => {
      if ("onPick" in $$props2) $$invalidate(0, onPick = $$props2.onPick);
      if ("awards" in $$props2) $$invalidate(1, awards = $$props2.awards);
    };
    return [onPick, awards, getAwardRarityName, click_handler2];
  }
  __name(instance$8, "instance$8");
  const _Player_awards_award_picker = class _Player_awards_award_picker extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$8, create_fragment$8, safe_not_equal, { onPick: 0, awards: 1 });
    }
  };
  __name(_Player_awards_award_picker, "Player_awards_award_picker");
  let Player_awards_award_picker = _Player_awards_award_picker;
  var __defProp$f = Object.defineProperty;
  var __decorateClass$f = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$f(target, key2, result);
    return result;
  }, "__decorateClass$f");
  const _PlayerAwardsFeature = class _PlayerAwardsFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_apiDataSetup");
      __publicField(this, "_lobbyConnectionService");
      __publicField(this, "_chatService");
      __publicField(this, "_toastService");
      __publicField(this, "_lobbyItemsService");
      __publicField(this, "_lobbyService");
      __publicField(this, "_lobbyPlayersService");
      __publicField(this, "_memberService");
      __publicField(this, "_apiService");
      __publicField(this, "_modalService");
      __publicField(this, "_cloudService");
      __publicField(this, "_lobbyLeftEventListener");
      __publicField(this, "name", "Awards");
      __publicField(this, "description", "Award drawings of other typo players with special awards");
      __publicField(this, "tags", [
        FeatureTag.SOCIAL,
        FeatureTag.PALANTIR
      ]);
      __publicField(this, "featureId", 41);
      __publicField(this, "toggleEnabled", false);
      __publicField(this, "_enableAwardAnimationSetting", this.useSetting(
        new BooleanExtensionSetting("animation", true, this).withName("Award Animation").withDescription("Show an animation over the canvas when a player is awarded")
      ));
      __publicField(this, "_awardedSubscription");
      __publicField(this, "_lobbyItemsSubscription");
      __publicField(this, "_lobbyLeftSubscription");
      __publicField(this, "_awardsContainers", /* @__PURE__ */ new Map());
      __publicField(this, "_awardsComponent");
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      const apiData = await this._apiDataSetup.complete();
      const component = this._awardsComponent = new Player_awards({
        target: elements2.canvasWrapper,
        props: {
          feature: this,
          currentAwardPresentation: void 0
        }
      });
      this._lobbyLeftSubscription = this._lobbyLeftEventListener.events$.subscribe(() => {
        this._cloudService.clearPendingAwardInventoryIds();
        component.$set({ currentAwardPresentation: void 0 });
      });
      this._awardedSubscription = this._lobbyConnectionService.awardGifted$.pipe(
        withLatestFrom(this._lobbyService.lobby$)
      ).subscribe(async ([award, lobby]) => {
        var _a2;
        const awardDto = apiData.awards.find((a) => a.id === award.awardId);
        if (awardDto === void 0) {
          this._logger.warn("Award dto not found", award);
        }
        const awarder = ((_a2 = lobby == null ? void 0 : lobby.players.find((p) => p.id === award.awarderLobbyPlayerId)) == null ? void 0 : _a2.name) ?? "Unknown";
        const title = `${awarder} awarded this with a ${(awardDto == null ? void 0 : awardDto.name) ?? "Award"}!`;
        const message = `
${awardDto == null ? void 0 : awardDto.description}`;
        const messageComponent = await this._chatService.addChatMessage(message, title, "info");
        const chatMessage = await messageComponent.message;
        const awardIcon = createElement(`<img 
        src="${awardDto == null ? void 0 : awardDto.url}" 
        alt="${awardDto == null ? void 0 : awardDto.name}"
        style="height: 2rem; width: 2rem; margin: 0 .5rem"
      >`);
        chatMessage.wrapperElement.insertAdjacentElement("afterbegin", awardIcon);
        component.$set({ currentAwardPresentation: structuredClone(awardDto) });
        this._cloudService.addPendingAwardInventoryId(award.awardInventoryId);
      });
      this._lobbyItemsSubscription = this._lobbyItemsService.onlineItems$.pipe(
        withLatestFrom(this._lobbyPlayersService.players$)
      ).subscribe(([items, players]) => {
        this.updatePlayerAwards(players, items, apiData.awards);
      });
    }
    async onDestroy() {
      var _a2, _b2, _c2, _d2;
      (_a2 = this._awardsComponent) == null ? void 0 : _a2.$destroy();
      (_b2 = this._awardedSubscription) == null ? void 0 : _b2.unsubscribe();
      (_c2 = this._lobbyItemsSubscription) == null ? void 0 : _c2.unsubscribe();
      (_d2 = this._lobbyLeftSubscription) == null ? void 0 : _d2.unsubscribe();
      this._awardedSubscription = void 0;
      this._lobbyItemsSubscription = void 0;
      this._awardsComponent = void 0;
      this._lobbyLeftSubscription = void 0;
      this._cloudService.clearPendingAwardInventoryIds();
      this._awardsContainers.forEach((container) => container.$destroy());
      this._awardsContainers.clear();
    }
    get memberStore() {
      return fromObservable(this._memberService.member$, void 0);
    }
    /**
     * A store that determines whether it is currently allowed to gift an award
     */
    get playerAwardableStore() {
      return fromObservable(
        this._lobbyItemsService.onlineItems$.pipe(
          combineLatestWith(this._lobbyService.lobby$),
          map(([items, lobby]) => {
            if (lobby === null || lobby.id === null || lobby.drawerId === void 0 || lobby.drawerId === lobby.meId) return false;
            const lobbyKey = calculateLobbyKey(lobby.id);
            const isAwardee = items.some(
              (item) => item.lobbyKey === lobbyKey && item.lobbyPlayerId === lobby.drawerId
            );
            return isAwardee;
          })
        ),
        false
      );
    }
    get awardsAnimationSettingStore() {
      return this._enableAwardAnimationSetting.store;
    }
    /**
     * Updates the player award icons according to onlineitems and playerdisplays
     * @param players
     * @param items
     * @param awards
     * @private
     */
    async updatePlayerAwards(players, items, awards) {
      this._logger.debug("Updating player awards", players);
      for (const [playerDisplay, container] of this._awardsContainers) {
        if (!players.includes(playerDisplay)) {
          container.$destroy();
          this._awardsContainers.delete(playerDisplay);
        }
      }
      for (const player of players) {
        const iconsDisplay = player.iconsContainer;
        if (iconsDisplay === null) continue;
        const identification = player.typoId;
        let container = this._awardsContainers.get(player);
        if (!container) {
          container = new Awards_display({
            target: iconsDisplay,
            props: {
              awards: [],
              playerDisplay: player
            }
          });
          this._awardsContainers.set(player, container);
        }
        let playerAwards = [];
        if (isAnonymousPlayerIdentification(identification)) {
          playerAwards = this.getAwardsForAnonymousPlayerDisplay(identification, items, awards);
        } else if (!isAnonymousPlayerIdentification(identification)) {
          playerAwards = [];
        } else {
          this._logger.warn("Unknown player identification", identification);
        }
        const existingAwards = container.getAwards();
        const awardsUpdated = playerAwards.length !== existingAwards.length || playerAwards.some((award, index) => existingAwards[index].id !== award.id);
        if (awardsUpdated) {
          container.$set({ awards: playerAwards });
        }
      }
    }
    /**
     * Get award dtos for player based on current online items
     * @param identification
     * @param items
     * @param awards
     * @private
     */
    getAwardsForAnonymousPlayerDisplay(identification, items, awards) {
      const playerItems = items.filter(
        (item) => item.lobbyPlayerId === identification.lobbyPlayerId && item.lobbyKey === identification.lobbyKey
      );
      const playerAwards = playerItems.filter((item) => item.type === OnlineItemTypeDto.Award);
      return playerAwards.map((awardItem) => awards.find((award) => awardItem.itemId === award.id)).filter(
        (award) => award !== void 0
      );
    }
    /**
     * Open the award picker to select an award from  the current inventory
     * @param member
     */
    async promptAwardSelection(member) {
      this._logger.debug("Opening award picker");
      const awardInventory = await this._apiService.getApi(InventoryApi).getMemberAvailableAwardInventory({ login: Number(member.userLogin) });
      const pickerComponent = {
        componentType: Player_awards_award_picker,
        propsFactory: /* @__PURE__ */ __name((submit) => ({
          awards: awardInventory,
          onPick: submit.bind(this)
        }), "propsFactory")
      };
      const award = await this._modalService.showPrompt(
        pickerComponent.componentType,
        pickerComponent.propsFactory,
        "Award Picker",
        "card"
      );
      this._logger.debug("Award picker closed", award);
      return award;
    }
    /**
     * Give an award to the current drawer
     * @param inventoryId
     */
    async giveAward(inventoryId) {
      this._logger.debug("Giving award to current drawer", inventoryId);
      try {
        await this._lobbyConnectionService.connection.hub.giftAward({ awardInventoryId: inventoryId });
      } catch (e) {
        this._logger.error("Failed to gift award", e);
        await this._toastService.showToast("Failed to gift award");
      }
    }
  };
  __name(_PlayerAwardsFeature, "PlayerAwardsFeature");
  let PlayerAwardsFeature = _PlayerAwardsFeature;
  __decorateClass$f([
    inject(ElementsSetup)
  ], PlayerAwardsFeature.prototype, "_elementsSetup");
  __decorateClass$f([
    inject(ApiDataSetup)
  ], PlayerAwardsFeature.prototype, "_apiDataSetup");
  __decorateClass$f([
    inject(LobbyConnectionService)
  ], PlayerAwardsFeature.prototype, "_lobbyConnectionService");
  __decorateClass$f([
    inject(ChatService)
  ], PlayerAwardsFeature.prototype, "_chatService");
  __decorateClass$f([
    inject(ToastService)
  ], PlayerAwardsFeature.prototype, "_toastService");
  __decorateClass$f([
    inject(LobbyItemsService)
  ], PlayerAwardsFeature.prototype, "_lobbyItemsService");
  __decorateClass$f([
    inject(LobbyService)
  ], PlayerAwardsFeature.prototype, "_lobbyService");
  __decorateClass$f([
    inject(PlayersService)
  ], PlayerAwardsFeature.prototype, "_lobbyPlayersService");
  __decorateClass$f([
    inject(MemberService)
  ], PlayerAwardsFeature.prototype, "_memberService");
  __decorateClass$f([
    inject(ApiService)
  ], PlayerAwardsFeature.prototype, "_apiService");
  __decorateClass$f([
    inject(ModalService)
  ], PlayerAwardsFeature.prototype, "_modalService");
  __decorateClass$f([
    inject(CloudService)
  ], PlayerAwardsFeature.prototype, "_cloudService");
  __decorateClass$f([
    inject(LobbyLeftEventListener)
  ], PlayerAwardsFeature.prototype, "_lobbyLeftEventListener");
  function create_if_block$3(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        attr(div, "class", "typo-player-scene svelte-eg9tl1");
        set_style(div, "background-image", "url('" + /*getUrl*/
        ctx[1](
          /*scene*/
          ctx[0]
        ) + "')");
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*scene*/
        1) {
          set_style(div, "background-image", "url('" + /*getUrl*/
          ctx2[1](
            /*scene*/
            ctx2[0]
          ) + "')");
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_if_block$3, "create_if_block$3");
  function create_fragment$7(ctx) {
    let if_block_anchor;
    let if_block = (
      /*scene*/
      ctx[0] !== void 0 && create_if_block$3(ctx)
    );
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (
          /*scene*/
          ctx2[0] !== void 0
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block$3(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block) if_block.d(detaching);
      }
    };
  }
  __name(create_fragment$7, "create_fragment$7");
  function instance$7($$self, $$props, $$invalidate) {
    let { scene = void 0 } = $$props;
    let { playerDisplay } = $$props;
    const getScene = /* @__PURE__ */ __name(() => scene, "getScene");
    const getUrl = /* @__PURE__ */ __name((scene2) => {
      return scene2.shift === void 0 ? scene2.scene.url : `https://static.typo.rip/sprites/rainbow/modulate.php?url=${scene2.scene.url}&hue=${scene2.shift}`;
    }, "getUrl");
    onDestroy(() => {
      $$invalidate(2, playerDisplay.useSafeColor = false, playerDisplay);
      $$invalidate(2, playerDisplay.useBackground = false, playerDisplay);
    });
    $$self.$$set = ($$props2) => {
      if ("scene" in $$props2) $$invalidate(0, scene = $$props2.scene);
      if ("playerDisplay" in $$props2) $$invalidate(2, playerDisplay = $$props2.playerDisplay);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*scene*/
      1) {
        {
          $$invalidate(2, playerDisplay.useSafeColor = scene !== void 0, playerDisplay);
          $$invalidate(2, playerDisplay.useBackground = scene === void 0, playerDisplay);
        }
      }
    };
    return [scene, getUrl, playerDisplay, getScene];
  }
  __name(instance$7, "instance$7");
  const _Scene_container = class _Scene_container extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$7, create_fragment$7, safe_not_equal, { scene: 0, playerDisplay: 2, getScene: 3 });
    }
    get getScene() {
      return this.$$.ctx[3];
    }
  };
  __name(_Scene_container, "Scene_container");
  let Scene_container = _Scene_container;
  var __defProp$e = Object.defineProperty;
  var __decorateClass$e = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$e(target, key2, result);
    return result;
  }, "__decorateClass$e");
  const _PlayerScenesFeature = class _PlayerScenesFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_apiDataSetup");
      __publicField(this, "_lobbyItemsService");
      __publicField(this, "_lobbyPlayersService");
      __publicField(this, "_memberService");
      __publicField(this, "name", "Player Scenes");
      __publicField(this, "description", "Display scenes of typo players in lobbies and on the landing page");
      __publicField(this, "tags", [
        FeatureTag.SOCIAL,
        FeatureTag.PALANTIR
      ]);
      __publicField(this, "featureId", 21);
      __publicField(this, "toggleEnabled", false);
      __publicField(this, "developerFeature", true);
      __publicField(this, "_scenesSubscription");
      __publicField(this, "_sceneContainers", /* @__PURE__ */ new Map());
    }
    async onActivate() {
      const scenes = (await this._apiDataSetup.complete()).scenes;
      this._scenesSubscription = this._lobbyPlayersService.players$.pipe(
        combineLatestWith(this._lobbyItemsService.onlineItems$, this._memberService.memberData$)
        /* add member data to triggers */
      ).subscribe(([players, items]) => {
        this.updatePlayerScenes(players, items, scenes);
      });
    }
    async onDestroy() {
      var _a2;
      (_a2 = this._scenesSubscription) == null ? void 0 : _a2.unsubscribe();
      this._sceneContainers.forEach((container) => container.$destroy());
      this._sceneContainers.clear();
    }
    /**
     * Updates the scenes of the players in the lobby
     * @param players
     * @param lobbyItems
     * @param scenes
     * @private
     */
    async updatePlayerScenes(players, lobbyItems, scenes) {
      var _a2, _b2;
      this._logger.debug("Updating player scenes", players);
      for (const [playerDisplay, container] of this._sceneContainers) {
        if (!players.includes(playerDisplay)) {
          container.$destroy();
          this._sceneContainers.delete(playerDisplay);
        }
      }
      for (const player of players) {
        const identification = player.typoId;
        let container = this._sceneContainers.get(player);
        if (!container) {
          container = new Scene_container({
            target: player.backgroundContainer,
            props: {
              scene: void 0,
              playerDisplay: player
            }
          });
          this._sceneContainers.set(player, container);
        }
        let playerItems = [];
        if (isAnonymousPlayerIdentification(identification)) {
          playerItems = this.getItemsForAnonymousPlayerDisplay(identification, lobbyItems);
        } else if (!isAnonymousPlayerIdentification(identification)) {
          playerItems = await this.getItemsForConcretePlayerDisplay(identification);
        } else {
          this._logger.warn("Unknown player identification", identification);
        }
        const scene = this.createSceneFromItems(playerItems, scenes);
        const sceneUpdated = ((_a2 = container.getScene()) == null ? void 0 : _a2.scene.id) !== (scene == null ? void 0 : scene.scene.id) || ((_b2 = container.getScene()) == null ? void 0 : _b2.shift) !== (scene == null ? void 0 : scene.shift);
        if (sceneUpdated) {
          this._logger.info("Updating scene for player", player, scene, playerItems);
          container.$set({ scene });
        }
      }
    }
    getItemsForAnonymousPlayerDisplay(identification, items) {
      return items.filter((item) => item.lobbyPlayerId === identification.lobbyPlayerId && item.lobbyKey === identification.lobbyKey);
    }
    async getItemsForConcretePlayerDisplay(identification) {
      return await this.createItemsForMember(identification.login);
    }
    /**
     * Creates scene data from the online items of a player
     * @param playerItems
     * @param scenes
     * @private
     */
    createSceneFromItems(playerItems, scenes) {
      const playerScene = playerItems.find((scene2) => scene2.type === OnlineItemTypeDto.Scene);
      const playerShift = playerItems.find((item) => item.type === OnlineItemTypeDto.SceneTheme && item.slot === (playerScene == null ? void 0 : playerScene.itemId));
      if (playerScene === void 0) return void 0;
      const scene = scenes.find((scene2) => scene2.id === playerScene.itemId);
      if (scene === void 0) {
        this._logger.warn("Scene not found", playerScene.itemId);
        return void 0;
      }
      return {
        scene,
        shift: playerShift == null ? void 0 : playerShift.itemId
      };
    }
    /**
     * Creates dummy scene items for the currently logged in member
     * @private
     * @param login
     */
    async createItemsForMember(login) {
      var _a2;
      this._logger.debug("Creating demo scene items for member", login);
      const sceneInventory = (_a2 = await firstValueFrom(this._memberService.memberData$)) == null ? void 0 : _a2.sceneInventory;
      if (sceneInventory === void 0) return [];
      const items = [];
      if (sceneInventory.activeId !== void 0) {
        items.push({
          itemId: sceneInventory.activeId,
          type: OnlineItemTypeDto.Scene,
          lobbyPlayerId: 0,
          slot: 0,
          lobbyKey: "practice"
        });
        if (sceneInventory.activeShift !== void 0) {
          items.push({
            itemId: sceneInventory.activeShift,
            type: OnlineItemTypeDto.SceneTheme,
            lobbyPlayerId: 0,
            slot: sceneInventory.activeId,
            lobbyKey: "practice"
          });
        }
      }
      return items;
    }
  };
  __name(_PlayerScenesFeature, "PlayerScenesFeature");
  let PlayerScenesFeature = _PlayerScenesFeature;
  __decorateClass$e([
    inject(ApiDataSetup)
  ], PlayerScenesFeature.prototype, "_apiDataSetup");
  __decorateClass$e([
    inject(LobbyItemsService)
  ], PlayerScenesFeature.prototype, "_lobbyItemsService");
  __decorateClass$e([
    inject(PlayersService)
  ], PlayerScenesFeature.prototype, "_lobbyPlayersService");
  __decorateClass$e([
    inject(MemberService)
  ], PlayerScenesFeature.prototype, "_memberService");
  function get_each_context$3(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[4] = list[i];
    return child_ctx;
  }
  __name(get_each_context$3, "get_each_context$3");
  function create_each_block$3(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        attr(div, "class", "sprite-slot svelte-1uuttlm");
        set_style(div, "background-image", "url('" + /*getUrl*/
        ctx[1](
          /*slot*/
          ctx[4]
        ) + "')");
        set_style(
          div,
          "z-index",
          /*slot*/
          ctx[4].slot + 10
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*sprites*/
        1) {
          set_style(div, "background-image", "url('" + /*getUrl*/
          ctx2[1](
            /*slot*/
            ctx2[4]
          ) + "')");
        }
        if (dirty & /*sprites*/
        1) {
          set_style(
            div,
            "z-index",
            /*slot*/
            ctx2[4].slot + 10
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_each_block$3, "create_each_block$3");
  function create_fragment$6(ctx) {
    let each_1_anchor;
    let each_value = ensure_array_like(
      /*sprites*/
      ctx[0]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    }
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*getUrl, sprites*/
        3) {
          each_value = ensure_array_like(
            /*sprites*/
            ctx2[0]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$3(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block$3(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_fragment$6, "create_fragment$6");
  function instance$6($$self, $$props, $$invalidate) {
    let { sprites = [] } = $$props;
    let { playerDisplay } = $$props;
    const getSprites = /* @__PURE__ */ __name(() => sprites, "getSprites");
    const getUrl = /* @__PURE__ */ __name((slot) => {
      return slot.shift === void 0 ? slot.sprite.url : `https://static.typo.rip/sprites/rainbow/modulate.php?url=${slot.sprite.url}&hue=${slot.shift}`;
    }, "getUrl");
    onDestroy(() => {
      $$invalidate(2, playerDisplay.adjustToContainSprites = false, playerDisplay);
    });
    $$self.$$set = ($$props2) => {
      if ("sprites" in $$props2) $$invalidate(0, sprites = $$props2.sprites);
      if ("playerDisplay" in $$props2) $$invalidate(2, playerDisplay = $$props2.playerDisplay);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*sprites*/
      1) {
        {
          $$invalidate(2, playerDisplay.adjustToContainSprites = sprites.length > 0, playerDisplay);
          $$invalidate(2, playerDisplay.hideAvatar = sprites.some((sprite) => sprite.sprite.isSpecial), playerDisplay);
        }
      }
    };
    return [sprites, getUrl, playerDisplay, getSprites];
  }
  __name(instance$6, "instance$6");
  const _Sprite_container = class _Sprite_container extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$6, create_fragment$6, safe_not_equal, {
        sprites: 0,
        playerDisplay: 2,
        getSprites: 3
      });
    }
    get getSprites() {
      return this.$$.ctx[3];
    }
  };
  __name(_Sprite_container, "Sprite_container");
  let Sprite_container = _Sprite_container;
  var __defProp$d = Object.defineProperty;
  var __decorateClass$d = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$d(target, key2, result);
    return result;
  }, "__decorateClass$d");
  const _PlayerSpritesFeature = class _PlayerSpritesFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_apiDataSetup");
      __publicField(this, "_lobbyItemsService");
      __publicField(this, "_lobbyPlayersService");
      __publicField(this, "_memberService");
      __publicField(this, "name", "Player Sprites");
      __publicField(this, "description", "Display sprites of typo players in lobbies and on the landing page");
      __publicField(this, "tags", [
        FeatureTag.SOCIAL,
        FeatureTag.PALANTIR
      ]);
      __publicField(this, "featureId", 20);
      __publicField(this, "toggleEnabled", false);
      __publicField(this, "developerFeature", true);
      __publicField(this, "_spritesSubscription");
      __publicField(this, "_spriteContainers", /* @__PURE__ */ new Map());
    }
    async onActivate() {
      const sprites = (await this._apiDataSetup.complete()).sprites;
      this._spritesSubscription = this._lobbyPlayersService.players$.pipe(
        combineLatestWith(this._lobbyItemsService.onlineItems$, this._memberService.memberData$)
        /* add member data to triggers */
      ).subscribe(([players, items]) => {
        this.updatePlayerSprites(players, items, sprites);
      });
    }
    async onDestroy() {
      var _a2;
      (_a2 = this._spritesSubscription) == null ? void 0 : _a2.unsubscribe();
      this._spriteContainers.forEach((container) => container.$destroy());
      this._spriteContainers.clear();
    }
    async updatePlayerSprites(players, items, sprites) {
      this._logger.debug("Updating player sprites", players);
      for (const [playerDisplay, container] of this._spriteContainers) {
        if (!players.includes(playerDisplay)) {
          container.$destroy();
          this._spriteContainers.delete(playerDisplay);
        }
      }
      for (const player of players) {
        const identification = player.typoId;
        let container = this._spriteContainers.get(player);
        if (!container) {
          container = new Sprite_container({
            target: player.avatarContainer,
            props: {
              sprites: [],
              playerDisplay: player
            }
          });
          this._spriteContainers.set(player, container);
        }
        let playerItems = [];
        if (isAnonymousPlayerIdentification(identification)) {
          playerItems = this.getItemsForAnonymousPlayerDisplay(identification, items);
        } else if (!isAnonymousPlayerIdentification(identification)) {
          playerItems = await this.getItemsForConcretePlayerDisplay(identification);
        } else {
          this._logger.warn("Unknown player identification", identification);
        }
        const slots = this.createSpriteSlotsFromItems(playerItems, sprites);
        const existingPlayerSlots = container.getSprites();
        const slotsUpdated = slots.length !== existingPlayerSlots.length || slots.some((slot) => {
          const existingSlot = existingPlayerSlots.find((s) => s.slot === slot.slot);
          return !existingSlot || existingSlot.sprite.id !== slot.sprite.id || existingSlot.shift !== slot.shift;
        });
        if (slotsUpdated) {
          this._logger.info("Updating sprite slots for player", player, slots, playerItems);
          container.$set({ sprites: slots });
        }
      }
    }
    getItemsForAnonymousPlayerDisplay(identification, items) {
      return items.filter((item) => item.lobbyPlayerId === identification.lobbyPlayerId && item.lobbyKey === identification.lobbyKey);
    }
    async getItemsForConcretePlayerDisplay(identification) {
      return await this.createItemsForMember(identification.login);
    }
    /**
     * Creates sprite slot data from the online items of a player
     * @param playerItems
     * @param sprites
     * @private
     */
    createSpriteSlotsFromItems(playerItems, sprites) {
      const playerSprites = playerItems.filter((sprite) => sprite.type === OnlineItemTypeDto.Sprite);
      const playerShifts = playerItems.filter((sprite) => sprite.type === OnlineItemTypeDto.SpriteShift);
      const playerSlots = playerSprites.map((sprite) => {
        var _a2;
        const spriteData = sprites.find((s) => s.id === sprite.itemId);
        if (spriteData === void 0) {
          this._logger.warn(`Sprite with id ${sprite.itemId} not found`);
          return void 0;
        }
        return {
          sprite: spriteData,
          slot: sprite.slot,
          shift: (_a2 = playerShifts.find((shift) => shift.slot === sprite.slot)) == null ? void 0 : _a2.itemId
        };
      }).filter((slot) => slot !== void 0);
      return playerSlots;
    }
    /**
     * Creates dummy sprite items for the currently logged in member
     * @private
     * @param login
     */
    async createItemsForMember(login) {
      var _a2;
      this._logger.debug("Creating demo items for member", login);
      const spriteInventory = ((_a2 = await firstValueFrom(this._memberService.memberData$)) == null ? void 0 : _a2.spriteInventory) ?? [];
      const items = spriteInventory.map((sprite) => {
        const item = sprite.slot ? {
          itemId: sprite.spriteId,
          type: OnlineItemTypeDto.Sprite,
          lobbyPlayerId: 0,
          slot: sprite.slot,
          lobbyKey: "practice"
        } : void 0;
        const shift = sprite.colorShift !== void 0 && sprite.slot ? {
          itemId: sprite.colorShift,
          type: OnlineItemTypeDto.SpriteShift,
          lobbyPlayerId: 0,
          slot: sprite.slot,
          lobbyKey: "practice"
        } : void 0;
        return [item, shift];
      }).flat().filter((item) => item !== void 0);
      return items;
    }
  };
  __name(_PlayerSpritesFeature, "PlayerSpritesFeature");
  let PlayerSpritesFeature = _PlayerSpritesFeature;
  __decorateClass$d([
    inject(ApiDataSetup)
  ], PlayerSpritesFeature.prototype, "_apiDataSetup");
  __decorateClass$d([
    inject(LobbyItemsService)
  ], PlayerSpritesFeature.prototype, "_lobbyItemsService");
  __decorateClass$d([
    inject(PlayersService)
  ], PlayerSpritesFeature.prototype, "_lobbyPlayersService");
  __decorateClass$d([
    inject(MemberService)
  ], PlayerSpritesFeature.prototype, "_memberService");
  var __defProp$c = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __decorateClass$c = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result) __defProp$c(target, key2, result);
    return result;
  }, "__decorateClass$c");
  let TypoChallenge = (_Ga = class {
  }, __name(_Ga, "TypoChallenge"), _Ga);
  TypoChallenge = __decorateClass$c([
    injectable()
  ], TypoChallenge);
  var __defProp$b = Object.defineProperty;
  var __decorateClass$b = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$b(target, key2, result);
    return result;
  }, "__decorateClass$b");
  const _BlindGuessChallenge = class _BlindGuessChallenge extends TypoChallenge {
    constructor() {
      super(...arguments);
      __publicField(this, "_lobbyService");
      __publicField(this, "_drawingService");
      __publicField(this, "_elementsSetup");
      __publicField(this, "name", "Blind Guess");
      __publicField(this, "description", "You don't see what other people are drawing.");
    }
    createTriggerObservable() {
      return this._lobbyService.lobby$.pipe(
        combineLatestWith(this._drawingService.drawingState$),
        map(([lobby, drawing]) => {
          return drawing === "drawing" && lobby !== null && lobby.meId !== lobby.drawerId && !lobby.players.some((player) => player.id === lobby.meId && player.guessed);
        }),
        distinctUntilChanged()
      );
    }
    async apply(trigger) {
      const elements2 = await this._elementsSetup.complete();
      if (trigger) {
        elements2.canvas.style.opacity = "0";
      } else {
        elements2.canvas.style.opacity = "";
      }
      return;
    }
    destroy() {
      return this.apply(false);
    }
  };
  __name(_BlindGuessChallenge, "BlindGuessChallenge");
  let BlindGuessChallenge = _BlindGuessChallenge;
  __decorateClass$b([
    inject(LobbyService)
  ], BlindGuessChallenge.prototype, "_lobbyService");
  __decorateClass$b([
    inject(DrawingService)
  ], BlindGuessChallenge.prototype, "_drawingService");
  __decorateClass$b([
    inject(ElementsSetup)
  ], BlindGuessChallenge.prototype, "_elementsSetup");
  var __defProp$a = Object.defineProperty;
  var __decorateClass$a = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$a(target, key2, result);
    return result;
  }, "__decorateClass$a");
  const _DeafGuessChallenge = class _DeafGuessChallenge extends TypoChallenge {
    constructor() {
      super(...arguments);
      __publicField(this, "_lobbyService");
      __publicField(this, "_drawingService");
      __publicField(this, "_chatService");
      __publicField(this, "_blurredMessages");
      __publicField(this, "_style");
      __publicField(this, "_messagesSubscription");
      __publicField(this, "name", "Deaf Guess");
      __publicField(this, "description", "When guessing, you don't see hints or messages from other people.");
    }
    createTriggerObservable() {
      return this._lobbyService.lobby$.pipe(
        combineLatestWith(this._drawingService.drawingState$),
        map(([lobby, drawing]) => {
          return drawing === "drawing" && lobby !== null && lobby.meId !== lobby.drawerId && !lobby.players.some((player) => player.id === lobby.meId && player.guessed);
        }),
        distinctUntilChanged()
      );
    }
    async apply(trigger) {
      var _a2, _b2, _c2;
      if (trigger) {
        if (!this._messagesSubscription) {
          this._messagesSubscription = this._chatService.playerMessageReceived$.subscribe((message) => {
            if (this._blurredMessages) {
              this._blurredMessages.push(message.contentElement);
            } else {
              this._blurredMessages = [message.contentElement];
            }
            message.element.classList.add("typo-challenge-deaf-guess-hidden");
          });
        }
        if (!this._style) {
          this._style = createStylesheet();
          this._style.sheet.insertRule(".typo-challenge-deaf-guess-hidden span, .player-bubble .content .text { filter: blur(3px); }");
          this._style.sheet.insertRule("#game form.chat-form .characters, #game-word .hints { opacity: 0 }");
        }
      } else {
        (_a2 = this._messagesSubscription) == null ? void 0 : _a2.unsubscribe();
        this._messagesSubscription = void 0;
        (_b2 = this._blurredMessages) == null ? void 0 : _b2.forEach((message) => message.classList.remove("typo-challenge-deaf-guess-hidden"));
        this._blurredMessages = void 0;
        (_c2 = this._style) == null ? void 0 : _c2.remove();
        this._style = void 0;
      }
      return;
    }
    destroy() {
      return this.apply(false);
    }
  };
  __name(_DeafGuessChallenge, "DeafGuessChallenge");
  let DeafGuessChallenge = _DeafGuessChallenge;
  __decorateClass$a([
    inject(LobbyService)
  ], DeafGuessChallenge.prototype, "_lobbyService");
  __decorateClass$a([
    inject(DrawingService)
  ], DeafGuessChallenge.prototype, "_drawingService");
  __decorateClass$a([
    inject(ChatService)
  ], DeafGuessChallenge.prototype, "_chatService");
  var __defProp$9 = Object.defineProperty;
  var __decorateClass$9 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$9(target, key2, result);
    return result;
  }, "__decorateClass$9");
  const _DontClearChallenge = class _DontClearChallenge extends TypoChallenge {
    constructor() {
      super(...arguments);
      __publicField(this, "_canvasClearedEvent");
      __publicField(this, "_drawingService");
      __publicField(this, "_toastService");
      __publicField(this, "_style");
      __publicField(this, "_canvasClearedSubscription");
      __publicField(this, "name", "Dont Clear");
      __publicField(this, "description", "The canvas cannot be cleared; you draw over other previous drawings.");
    }
    createTriggerObservable() {
      return of(true);
    }
    async apply(trigger) {
      if (!trigger) return;
      this._style = createStylesheet();
      this._style.sheet.insertRule(".tool[data-tooltip='Undo'], .tool[data-tooltip='Clear'] { display: none }");
      this._canvasClearedSubscription = this._canvasClearedEvent.events$.subscribe(async (event) => {
        await this._drawingService.drawImage(event.data);
      });
      await this._toastService.showToast("Don't Clear active", "Attention: Your drawings will look different (likely as nonsense) for other people!");
    }
    destroy() {
      var _a2;
      if (this._style) {
        this._style.remove();
        this._style = void 0;
      }
      (_a2 = this._canvasClearedSubscription) == null ? void 0 : _a2.unsubscribe();
    }
  };
  __name(_DontClearChallenge, "DontClearChallenge");
  let DontClearChallenge = _DontClearChallenge;
  __decorateClass$9([
    inject(CanvasClearedEventListener)
  ], DontClearChallenge.prototype, "_canvasClearedEvent");
  __decorateClass$9([
    inject(DrawingService)
  ], DontClearChallenge.prototype, "_drawingService");
  __decorateClass$9([
    inject(ToastService)
  ], DontClearChallenge.prototype, "_toastService");
  var __defProp$8 = Object.defineProperty;
  var __decorateClass$8 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$8(target, key2, result);
    return result;
  }, "__decorateClass$8");
  const _DrunkVisionChallenge = class _DrunkVisionChallenge extends TypoChallenge {
    constructor() {
      super(...arguments);
      __publicField(this, "_lobbyService");
      __publicField(this, "_drawingService");
      __publicField(this, "_elementsSetup");
      __publicField(this, "name", "Drunk Vision");
      __publicField(this, "description", "You can only vaguely see what other people draw.");
      __publicField(this, "_overlay");
    }
    createTriggerObservable() {
      return this._lobbyService.lobby$.pipe(
        combineLatestWith(this._drawingService.drawingState$),
        map(([lobby, drawing]) => {
          return drawing === "drawing" && lobby !== null && lobby.meId !== lobby.drawerId && !lobby.players.some((player) => player.id === lobby.meId && player.guessed);
        }),
        distinctUntilChanged()
      );
    }
    async apply(trigger) {
      var _a2;
      const elements2 = await this._elementsSetup.complete();
      if (trigger) {
        if (this._overlay === void 0) {
          this._overlay = document.createElement("div");
          this._overlay.style.position = "absolute";
          this._overlay.style.width = "100%";
          this._overlay.style.height = "100%";
          this._overlay.style.backdropFilter = "blur(40px)";
          this._overlay.style.pointerEvents = "none";
          this._overlay.style.zIndex = "0";
          elements2.canvasWrapper.appendChild(this._overlay);
        }
      } else {
        (_a2 = this._overlay) == null ? void 0 : _a2.remove();
        this._overlay = void 0;
      }
      return;
    }
    destroy() {
      return this.apply(false);
    }
  };
  __name(_DrunkVisionChallenge, "DrunkVisionChallenge");
  let DrunkVisionChallenge = _DrunkVisionChallenge;
  __decorateClass$8([
    inject(LobbyService)
  ], DrunkVisionChallenge.prototype, "_lobbyService");
  __decorateClass$8([
    inject(DrawingService)
  ], DrunkVisionChallenge.prototype, "_drawingService");
  __decorateClass$8([
    inject(ElementsSetup)
  ], DrunkVisionChallenge.prototype, "_elementsSetup");
  var __defProp$7 = Object.defineProperty;
  var __decorateClass$7 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$7(target, key2, result);
    return result;
  }, "__decorateClass$7");
  const _MonochromeChallenge = class _MonochromeChallenge extends TypoChallenge {
    constructor() {
      super(...arguments);
      __publicField(this, "_lobbyService");
      __publicField(this, "_drawingService");
      __publicField(this, "_colorsService");
      __publicField(this, "name", "Monochrome");
      __publicField(this, "description", "You can only use shades of a random color column.");
    }
    createTriggerObservable() {
      return this._lobbyService.lobby$.pipe(
        combineLatestWith(this._drawingService.drawingState$),
        map(([lobby, drawing]) => drawing === "drawing" && lobby !== null && lobby.meId === lobby.drawerId),
        distinctUntilChanged()
      );
    }
    apply(trigger) {
      if (!trigger) {
        this._colorsService.resetColorSelector();
      } else {
        this._colorsService.setColorSelector((palette) => {
          palette = palette ?? defaultPalettes.skribblPalette;
          const random = Math.floor(Math.random() * palette.columns);
          return {
            preferredColumnWidth: Math.min(palette.columns, palette.colorHexCodes.length),
            columns: 1,
            colorHexCodes: palette.columns === 1 || palette.colorHexCodes.length === 1 ? palette.colorHexCodes : (palette == null ? void 0 : palette.colorHexCodes.filter((_, index) => index % palette.columns === random)) ?? []
          };
        });
      }
    }
    destroy() {
      this.apply(false);
    }
  };
  __name(_MonochromeChallenge, "MonochromeChallenge");
  let MonochromeChallenge = _MonochromeChallenge;
  __decorateClass$7([
    inject(LobbyService)
  ], MonochromeChallenge.prototype, "_lobbyService");
  __decorateClass$7([
    inject(DrawingService)
  ], MonochromeChallenge.prototype, "_drawingService");
  __decorateClass$7([
    inject(ColorsService)
  ], MonochromeChallenge.prototype, "_colorsService");
  var __defProp$6 = Object.defineProperty;
  var __decorateClass$6 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$6(target, key2, result);
    return result;
  }, "__decorateClass$6");
  const _OneShotChallenge = class _OneShotChallenge extends TypoChallenge {
    constructor() {
      super(...arguments);
      __publicField(this, "_lobbyService");
      __publicField(this, "_drawingService");
      __publicField(this, "_messageSentEventListener");
      __publicField(this, "_style");
      __publicField(this, "name", "One Shot");
      __publicField(this, "description", "You have only one try to guess the word.");
    }
    createTriggerObservable() {
      return this._lobbyService.lobby$.pipe(
        combineLatestWith(this._drawingService.drawingState$),
        map(([lobby, drawing]) => {
          return drawing === "drawing" && lobby !== null && lobby.meId !== lobby.drawerId && !lobby.players.some((player) => player.id === lobby.meId && player.guessed);
        }),
        distinctUntilChanged(),
        switchMap(
          (trigger) => trigger === false ? of(false) : this._messageSentEventListener.events$.pipe(
            take(1),
            map(() => true)
          )
        )
      );
    }
    async apply(trigger) {
      if (trigger) {
        if (!this._style) {
          this._style = createStylesheet();
          this._style.sheet.insertRule("#game form.chat-form { display: none }");
        }
      } else {
        if (this._style) {
          this._style.remove();
          this._style = void 0;
        }
      }
      return;
    }
    destroy() {
      return this.apply(false);
    }
  };
  __name(_OneShotChallenge, "OneShotChallenge");
  let OneShotChallenge = _OneShotChallenge;
  __decorateClass$6([
    inject(LobbyService)
  ], OneShotChallenge.prototype, "_lobbyService");
  __decorateClass$6([
    inject(DrawingService)
  ], OneShotChallenge.prototype, "_drawingService");
  __decorateClass$6([
    inject(MessageSentEventListener)
  ], OneShotChallenge.prototype, "_messageSentEventListener");
  function get_each_context$2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[5] = list[i];
    return child_ctx;
  }
  __name(get_each_context$2, "get_each_context$2");
  function create_each_block$2(ctx) {
    let div;
    let checkbox;
    let t0;
    let span;
    let t2;
    let current;
    function change_handler(...args) {
      return (
        /*change_handler*/
        ctx[4](
          /*challenge*/
          ctx[5],
          ...args
        )
      );
    }
    __name(change_handler, "change_handler");
    checkbox = new Checkbox({
      props: {
        checked: (
          /*$activeIds*/
          ctx[0].includes(
            /*challenge*/
            ctx[5].id
          )
        ),
        description: (
          /*challenge*/
          ctx[5].challenge.name
        )
      }
    });
    checkbox.$on("change", change_handler);
    return {
      c() {
        div = element("div");
        create_component(checkbox.$$.fragment);
        t0 = space();
        span = element("span");
        span.textContent = `${/*challenge*/
      ctx[5].challenge.description}`;
        t2 = space();
        attr(span, "class", "svelte-wy9tne");
        attr(div, "class", "challenge svelte-wy9tne");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(checkbox, div, null);
        append(div, t0);
        append(div, span);
        append(div, t2);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        const checkbox_changes = {};
        if (dirty & /*$activeIds*/
        1) checkbox_changes.checked = /*$activeIds*/
        ctx[0].includes(
          /*challenge*/
          ctx[5].id
        );
        checkbox.$set(checkbox_changes);
      },
      i(local) {
        if (current) return;
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(checkbox);
      }
    };
  }
  __name(create_each_block$2, "create_each_block$2");
  function create_fragment$5(ctx) {
    let div;
    let current;
    let each_value = ensure_array_like(
      /*challenges*/
      ctx[1]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div, "class", "typo-toolbar-challenges-list svelte-wy9tne");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (dirty & /*challenges, $activeIds*/
        3) {
          each_value = ensure_array_like(
            /*challenges*/
            ctx2[1]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$2(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$2(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div, null);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  __name(create_fragment$5, "create_fragment$5");
  function instance$5($$self, $$props, $$invalidate) {
    let $activeIds;
    let { feature } = $$props;
    const challenges = feature.challenges;
    const activeIds = feature.activatedChallengesSettingStore;
    component_subscribe($$self, activeIds, (value) => $$invalidate(0, $activeIds = value));
    const change_handler = /* @__PURE__ */ __name((challenge, event) => {
      const other = $activeIds.filter((id2) => id2 !== challenge.id);
      set_store_value(activeIds, $activeIds = event.detail ? [...other, challenge.id] : other, $activeIds);
    }, "change_handler");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(3, feature = $$props2.feature);
    };
    return [$activeIds, challenges, activeIds, feature, change_handler];
  }
  __name(instance$5, "instance$5");
  const _Toolbar_challenges = class _Toolbar_challenges extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$5, create_fragment$5, safe_not_equal, { feature: 3 });
    }
  };
  __name(_Toolbar_challenges, "Toolbar_challenges");
  let Toolbar_challenges = _Toolbar_challenges;
  var __defProp$5 = Object.defineProperty;
  var __decorateClass$5 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$5(target, key2, result);
    return result;
  }, "__decorateClass$5");
  const _ToolbarChallengesFeature = class _ToolbarChallengesFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_container");
      __publicField(this, "name", "Challenges");
      __publicField(this, "description", "Adds the option to enable game modifications to make the game more challenging");
      __publicField(this, "tags", [
        FeatureTag.GAMEPLAY
      ]);
      __publicField(this, "featureId", 8);
      __publicField(this, "_iconComponent");
      __publicField(this, "_iconClickSubscription");
      __publicField(this, "_challengeStatesSubscription");
      __publicField(this, "_challengeStates", /* @__PURE__ */ new Map());
      __publicField(this, "_activatedChallenges", new ExtensionSetting("activated_challenges", [], this));
      __publicField(this, "_challenges", [
        { challenge: BlindGuessChallenge, id: 1 },
        { challenge: DrunkVisionChallenge, id: 2 },
        { challenge: DeafGuessChallenge, id: 3 },
        { challenge: OneShotChallenge, id: 4 },
        { challenge: DontClearChallenge, id: 5 },
        { challenge: MonochromeChallenge, id: 6 }
      ]);
      __publicField(this, "_flyoutComponent");
      __publicField(this, "_flyoutSubscription");
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      for (const challenge of this._challenges) {
        const instance2 = await this.resolveChallenge(challenge.challenge);
        this._challengeStates.set(challenge.id, { challenge: instance2 });
      }
      this._challengeStatesSubscription = this.listenChallengeStates();
      this._iconComponent = new Icon_button({
        target: elements2.toolbar,
        props: {
          icon: "file-img-challenge-gif",
          name: "Challenges",
          order: 4,
          tooltipAction: this.createTooltip,
          lockTooltip: "Y"
        }
      });
      this._iconClickSubscription = this._iconComponent.click$.subscribe(() => {
        if (this._flyoutComponent) {
          return;
        }
        const flyoutContent = {
          componentType: Toolbar_challenges,
          props: {
            feature: this
          }
        };
        this._flyoutComponent = new Area_flyout({
          target: elements2.gameWrapper,
          props: {
            componentData: flyoutContent,
            areaName: "chat",
            maxHeight: "600px",
            maxWidth: "300px",
            title: "Challenges",
            iconName: "file-img-nochallenge-gif"
          }
        });
        this._flyoutSubscription = this._flyoutComponent.closed$.subscribe(() => {
          var _a2, _b2;
          this._logger.info("Destroyed flyout");
          (_a2 = this._flyoutComponent) == null ? void 0 : _a2.$destroy();
          (_b2 = this._flyoutSubscription) == null ? void 0 : _b2.unsubscribe();
          this._flyoutComponent = void 0;
        });
      });
    }
    onDestroy() {
      var _a2, _b2, _c2, _d2, _e2;
      (_a2 = this._iconClickSubscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._iconComponent) == null ? void 0 : _b2.$destroy();
      (_c2 = this._flyoutComponent) == null ? void 0 : _c2.$destroy();
      (_d2 = this._flyoutSubscription) == null ? void 0 : _d2.unsubscribe();
      this._flyoutSubscription = void 0;
      this._challengeStates.clear();
      (_e2 = this._challengeStatesSubscription) == null ? void 0 : _e2.unsubscribe();
      this._challengeStatesSubscription = void 0;
    }
    get activatedChallengesSettingStore() {
      return this._activatedChallenges.store;
    }
    get challenges() {
      const cs = [...this._challengeStates.entries().map(([id2, { challenge }]) => ({ id: id2, challenge }))];
      this._logger.debug(cs);
      return cs;
    }
    /**
     * Listen to active challenges and destroy/activate them accordingly
     * @private
     */
    listenChallengeStates() {
      return this._activatedChallenges.changes$.subscribe(async (ids) => {
        var _a2;
        ids.forEach((id2) => {
          const challenge = this._challengeStates.get(id2);
          if (!challenge) {
            this._logger.warn(`Challenge with id ${id2} not resolved`);
            return;
          }
          if (!challenge.destroy) {
            this._logger.debug(`Activating challenge ${challenge.challenge.name}`);
            challenge.destroy = this.activateChallenge(challenge.challenge);
          }
        });
        this._challengeStates.forEach((state, id2) => {
          if (!ids.includes(id2) && state.destroy) {
            this._logger.debug(`Deactivating challenge ${state.challenge.name}`);
            state.destroy();
            state.destroy = void 0;
          }
        });
        (_a2 = this._iconComponent) == null ? void 0 : _a2.$set({ icon: ids.length > 0 ? "file-img-challenge-gif" : "file-img-nochallenge-gif" });
      });
    }
    /**
     * Get an instance for a challenge type, resolves DI without being registered
     * @param challenge
     * @private
     */
    async resolveChallenge(challenge) {
      const instance2 = this._container.resolveService(challenge);
      this._logger.debug(`Resolved challenge: ${instance2.name}`);
      return instance2;
    }
    /**
     * Activate a challenge and return a function to destroy it
     * @param challenge
     * @private
     */
    activateChallenge(challenge) {
      this._logger.debug(`Activating challenge ${challenge.name}`);
      const triggerSubject = challenge.createTriggerObservable();
      const subscription = triggerSubject.subscribe(async (trigger) => {
        this._logger.debug(`Challenge trigger: ${trigger}`);
        try {
          await challenge.apply(trigger);
        } catch (error) {
          this._logger.error(`Error applying challenge: ${error}`);
        }
      });
      return () => {
        this._logger.debug(`Destroying challenge ${challenge.name}`);
        subscription.unsubscribe();
        try {
          challenge.destroy();
        } catch (error) {
          this._logger.error(`Error destroying challenge: ${error}`);
        }
      };
    }
  };
  __name(_ToolbarChallengesFeature, "ToolbarChallengesFeature");
  let ToolbarChallengesFeature = _ToolbarChallengesFeature;
  __decorateClass$5([
    inject(ElementsSetup)
  ], ToolbarChallengesFeature.prototype, "_elementsSetup");
  __decorateClass$5([
    inject(ExtensionContainer)
  ], ToolbarChallengesFeature.prototype, "_container");
  var __defProp$4 = Object.defineProperty;
  var __decorateClass$4 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$4(target, key2, result);
    return result;
  }, "__decorateClass$4");
  const _ToolbarFullscreenFeature = class _ToolbarFullscreenFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "name", "Fullscreen");
      __publicField(this, "description", "Adds a toggle in-game to quickly enter/exit the browser fullscreen mode");
      __publicField(this, "tags", [
        FeatureTag.GAMEPLAY
      ]);
      __publicField(this, "featureId", 9);
      __publicField(this, "_iconComponent");
      __publicField(this, "_iconClickSubscription");
      __publicField(this, "_toggleHotkey", this.useHotkey(new HotkeyAction(
        "toggle_fullscreen",
        "Toggle Fullscreen",
        "Toggle the browser fullscreen mode",
        this,
        async () => await this.toggleFullscreen(),
        true,
        ["ShiftLeft", "KeyF"]
      )));
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._iconComponent = new Icon_button({
        target: elements2.toolbar,
        props: {
          icon: "file-img-fullscreen-gif",
          name: "Fullscreen",
          order: 1,
          tooltipAction: this.createTooltip,
          lockTooltip: "Y"
        }
      });
      this._iconClickSubscription = this._iconComponent.click$.subscribe(async () => {
        await this.toggleFullscreen();
      });
    }
    onDestroy() {
      var _a2, _b2;
      (_a2 = this._iconClickSubscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._iconComponent) == null ? void 0 : _b2.$destroy();
    }
    async toggleFullscreen() {
      if (document.fullscreenElement === null) {
        this._logger.debug("Entering fullscreen");
        await document.documentElement.requestFullscreen();
      } else {
        this._logger.debug("Exiting fullscreen");
        await document.exitFullscreen();
      }
    }
  };
  __name(_ToolbarFullscreenFeature, "ToolbarFullscreenFeature");
  let ToolbarFullscreenFeature = _ToolbarFullscreenFeature;
  __decorateClass$4([
    inject(ElementsSetup)
  ], ToolbarFullscreenFeature.prototype, "_elementsSetup");
  const chooseFile = /* @__PURE__ */ __name(async (accept, multiple) => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = accept;
    input.multiple = multiple;
    input.click();
    return new Promise((resolve2) => {
      input.onchange = () => {
        if (input.files && input.files.length > 0) {
          resolve2(input.files);
        } else {
          resolve2(null);
        }
      };
    });
  }, "chooseFile");
  function get_each_context$1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[17] = list[i];
    return child_ctx;
  }
  __name(get_each_context$1, "get_each_context$1");
  function create_if_block_1$1(ctx) {
    let div;
    let iconbutton;
    let t0;
    let span;
    let current;
    iconbutton = new Icon_button({
      props: {
        icon: "file-img-disabled-gif",
        name: "Abort",
        size: "1.5rem",
        hoverMove: false
      }
    });
    iconbutton.$on(
      "click",
      /*click_handler*/
      ctx[7]
    );
    return {
      c() {
        div = element("div");
        create_component(iconbutton.$$.fragment);
        t0 = space();
        span = element("span");
        span.textContent = "Drawing in progress...";
        attr(span, "class", "svelte-1tv05w9");
        attr(div, "class", "lockedHint svelte-1tv05w9");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(iconbutton, div, null);
        append(div, t0);
        append(div, span);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(iconbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(iconbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(iconbutton);
      }
    };
  }
  __name(create_if_block_1$1, "create_if_block_1$1");
  function create_each_block$1(ctx) {
    let div1;
    let div0;
    let iconbutton;
    let t;
    let flatbutton;
    let current;
    function click_handler_1() {
      return (
        /*click_handler_1*/
        ctx[8](
          /*image*/
          ctx[17]
        )
      );
    }
    __name(click_handler_1, "click_handler_1");
    iconbutton = new Icon_button({
      props: {
        icon: "file-img-trash-gif",
        name: "Remove",
        size: "1.5rem",
        hoverMove: false
      }
    });
    iconbutton.$on("click", click_handler_1);
    function click_handler_2() {
      return (
        /*click_handler_2*/
        ctx[9](
          /*image*/
          ctx[17]
        )
      );
    }
    __name(click_handler_2, "click_handler_2");
    flatbutton = new Flat_button({
      props: {
        content: (
          /*image*/
          ctx[17].name
        ),
        color: "blue"
      }
    });
    flatbutton.$on("click", click_handler_2);
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        create_component(iconbutton.$$.fragment);
        t = space();
        create_component(flatbutton.$$.fragment);
        attr(div0, "class", "remove svelte-1tv05w9");
        attr(div1, "class", "saved-commands svelte-1tv05w9");
        toggle_class(
          div1,
          "locked",
          /*$locked*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        mount_component(iconbutton, div0, null);
        append(div1, t);
        mount_component(flatbutton, div1, null);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        const flatbutton_changes = {};
        if (dirty & /*$store*/
        4) flatbutton_changes.content = /*image*/
        ctx[17].name;
        flatbutton.$set(flatbutton_changes);
        if (!current || dirty & /*$locked*/
        2) {
          toggle_class(
            div1,
            "locked",
            /*$locked*/
            ctx[1]
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(iconbutton.$$.fragment, local);
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(iconbutton.$$.fragment, local);
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_component(iconbutton);
        destroy_component(flatbutton);
      }
    };
  }
  __name(create_each_block$1, "create_each_block$1");
  function create_if_block$2(ctx) {
    let checkbox;
    let updating_checked;
    let current;
    function checkbox_checked_binding_1(value) {
      ctx[16](value);
    }
    __name(checkbox_checked_binding_1, "checkbox_checked_binding_1");
    let checkbox_props = { description: "Paste instant (practice!)" };
    if (
      /*feature*/
      ctx[0].pasteInstant !== void 0
    ) {
      checkbox_props.checked = /*feature*/
      ctx[0].pasteInstant;
    }
    checkbox = new Checkbox({ props: checkbox_props });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));
    return {
      c() {
        create_component(checkbox.$$.fragment);
      },
      m(target, anchor) {
        mount_component(checkbox, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const checkbox_changes = {};
        if (!updating_checked && dirty & /*feature*/
        1) {
          updating_checked = true;
          checkbox_changes.checked = /*feature*/
          ctx2[0].pasteInstant;
          add_flush_callback(() => updating_checked = false);
        }
        checkbox.$set(checkbox_changes);
      },
      i(local) {
        if (current) return;
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(checkbox, detaching);
      }
    };
  }
  __name(create_if_block$2, "create_if_block$2");
  function create_fragment$4(ctx) {
    let div;
    let t0;
    let t1;
    let flatbutton0;
    let t2;
    let flatbutton1;
    let t3;
    let flatbutton2;
    let t4;
    let flatbutton3;
    let t5;
    let input;
    let t6;
    let checkbox;
    let updating_checked;
    let t7;
    let current;
    let mounted;
    let dispose;
    let if_block0 = (
      /*$locked*/
      ctx[1] && create_if_block_1$1(ctx)
    );
    let each_value = ensure_array_like(
      /*$store*/
      ctx[2]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    }
    const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    }), "out");
    flatbutton0 = new Flat_button({
      props: { content: "Paste Image", color: "green" }
    });
    flatbutton0.$on(
      "click",
      /*click_handler_3*/
      ctx[10]
    );
    flatbutton1 = new Flat_button({
      props: {
        content: "Save Current Image",
        color: "green"
      }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_4*/
      ctx[11]
    );
    flatbutton2 = new Flat_button({
      props: { content: "Load SKD File", color: "blue" }
    });
    flatbutton2.$on(
      "click",
      /*click_handler_5*/
      ctx[12]
    );
    flatbutton3 = new Flat_button({
      props: {
        content: "Download Current SKD",
        color: "blue"
      }
    });
    flatbutton3.$on(
      "click",
      /*click_handler_6*/
      ctx[13]
    );
    function checkbox_checked_binding(value) {
      ctx[15](value);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    let checkbox_props = { description: "Clear before paste" };
    if (
      /*feature*/
      ctx[0].clearBeforePaste !== void 0
    ) {
      checkbox_props.checked = /*feature*/
      ctx[0].clearBeforePaste;
    }
    checkbox = new Checkbox({ props: checkbox_props });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
    let if_block1 = (
      /*$devmode*/
      ctx[3] && create_if_block$2(ctx)
    );
    return {
      c() {
        div = element("div");
        if (if_block0) if_block0.c();
        t0 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t1 = space();
        create_component(flatbutton0.$$.fragment);
        t2 = space();
        create_component(flatbutton1.$$.fragment);
        t3 = space();
        create_component(flatbutton2.$$.fragment);
        t4 = space();
        create_component(flatbutton3.$$.fragment);
        t5 = space();
        input = element("input");
        t6 = space();
        create_component(checkbox.$$.fragment);
        t7 = space();
        if (if_block1) if_block1.c();
        attr(input, "type", "text");
        attr(input, "class", "typo");
        attr(input, "placeholder", "Custom save name");
        attr(div, "class", "typo-toolbar-imagelab-actions svelte-1tv05w9");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if (if_block0) if_block0.m(div, null);
        append(div, t0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
        append(div, t1);
        mount_component(flatbutton0, div, null);
        append(div, t2);
        mount_component(flatbutton1, div, null);
        append(div, t3);
        mount_component(flatbutton2, div, null);
        append(div, t4);
        mount_component(flatbutton3, div, null);
        append(div, t5);
        append(div, input);
        set_input_value(
          input,
          /*feature*/
          ctx[0].customName
        );
        append(div, t6);
        mount_component(checkbox, div, null);
        append(div, t7);
        if (if_block1) if_block1.m(div, null);
        current = true;
        if (!mounted) {
          dispose = listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[14]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (
          /*$locked*/
          ctx2[1]
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty & /*$locked*/
            2) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_1$1(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(div, t0);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        if (dirty & /*$locked, $store, feature*/
        7) {
          each_value = ensure_array_like(
            /*$store*/
            ctx2[2]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context$1(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block$1(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div, t1);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
        if (dirty & /*feature*/
        1 && input.value !== /*feature*/
        ctx2[0].customName) {
          set_input_value(
            input,
            /*feature*/
            ctx2[0].customName
          );
        }
        const checkbox_changes = {};
        if (!updating_checked && dirty & /*feature*/
        1) {
          updating_checked = true;
          checkbox_changes.checked = /*feature*/
          ctx2[0].clearBeforePaste;
          add_flush_callback(() => updating_checked = false);
        }
        checkbox.$set(checkbox_changes);
        if (
          /*$devmode*/
          ctx2[3]
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty & /*$devmode*/
            8) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block$2(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(div, null);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block0);
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        transition_in(flatbutton2.$$.fragment, local);
        transition_in(flatbutton3.$$.fragment, local);
        transition_in(checkbox.$$.fragment, local);
        transition_in(if_block1);
        current = true;
      },
      o(local) {
        transition_out(if_block0);
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        transition_out(flatbutton2.$$.fragment, local);
        transition_out(flatbutton3.$$.fragment, local);
        transition_out(checkbox.$$.fragment, local);
        transition_out(if_block1);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if (if_block0) if_block0.d();
        destroy_each(each_blocks, detaching);
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
        destroy_component(flatbutton2);
        destroy_component(flatbutton3);
        destroy_component(checkbox);
        if (if_block1) if_block1.d();
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$4, "create_fragment$4");
  function instance$4($$self, $$props, $$invalidate) {
    let $locked;
    let $store;
    let $devmode;
    let { feature } = $$props;
    const store = feature.savedDrawCommandsStore;
    component_subscribe($$self, store, (value) => $$invalidate(2, $store = value));
    const devmode = feature.devmodeStore;
    component_subscribe($$self, devmode, (value) => $$invalidate(3, $devmode = value));
    feature.customName = "";
    const locked = feature.locked;
    component_subscribe($$self, locked, (value) => $$invalidate(1, $locked = value));
    const click_handler2 = /* @__PURE__ */ __name(() => feature.abortPaste(), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name((image) => feature.removeDrawCommands($store, image), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name((image) => feature.pasteDrawCommands(image), "click_handler_2");
    const click_handler_3 = /* @__PURE__ */ __name(async () => {
      const data = await feature.pickImageFromLocal();
      if (data != null) await feature.pasteImageToLocation(data);
    }, "click_handler_3");
    const click_handler_4 = /* @__PURE__ */ __name(() => feature.saveCurrentDrawCommands(), "click_handler_4");
    const click_handler_52 = /* @__PURE__ */ __name(() => feature.addDrawCommandsFromFile(), "click_handler_5");
    const click_handler_6 = /* @__PURE__ */ __name(() => feature.downloadCurrentDrawCommands(), "click_handler_6");
    function input_input_handler() {
      feature.customName = this.value;
      $$invalidate(0, feature);
    }
    __name(input_input_handler, "input_input_handler");
    function checkbox_checked_binding(value) {
      if ($$self.$$.not_equal(feature.clearBeforePaste, value)) {
        feature.clearBeforePaste = value;
        $$invalidate(0, feature);
      }
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    function checkbox_checked_binding_1(value) {
      if ($$self.$$.not_equal(feature.pasteInstant, value)) {
        feature.pasteInstant = value;
        $$invalidate(0, feature);
      }
    }
    __name(checkbox_checked_binding_1, "checkbox_checked_binding_1");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      $locked,
      $store,
      $devmode,
      store,
      devmode,
      locked,
      click_handler2,
      click_handler_1,
      click_handler_2,
      click_handler_3,
      click_handler_4,
      click_handler_52,
      click_handler_6,
      input_input_handler,
      checkbox_checked_binding,
      checkbox_checked_binding_1
    ];
  }
  __name(instance$4, "instance$4");
  const _Toolbar_imagelab = class _Toolbar_imagelab extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$4, create_fragment$4, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Toolbar_imagelab, "Toolbar_imagelab");
  let Toolbar_imagelab = _Toolbar_imagelab;
  function create_fragment$3(ctx) {
    let div;
    let p;
    let t6;
    let br4;
    let t7;
    let flatbutton0;
    let t8;
    let flatbutton1;
    let t9;
    let flatbutton2;
    let t10;
    let flatbutton3;
    let current;
    flatbutton0 = new Flat_button({
      props: { content: "Fit on canvas", color: "green" }
    });
    flatbutton0.$on(
      "click",
      /*click_handler*/
      ctx[1]
    );
    flatbutton1 = new Flat_button({
      props: { content: "Fill canvas", color: "green" }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_1*/
      ctx[2]
    );
    flatbutton2 = new Flat_button({
      props: {
        content: "Paste top-right on click position",
        color: "blue"
      }
    });
    flatbutton2.$on(
      "click",
      /*click_handler_2*/
      ctx[3]
    );
    flatbutton3 = new Flat_button({
      props: {
        content: "Paste between two click positions",
        color: "blue"
      }
    });
    flatbutton3.$on(
      "click",
      /*click_handler_3*/
      ctx[4]
    );
    return {
      c() {
        div = element("div");
        p = element("p");
        p.innerHTML = `Pick a mode to paste the image on the canvas.<br/>
    &quot;Fill on canvas&quot; and &quot;Paste between click&quot; might change the source image ratio.<br/> <br/> <b>Warning: This should be used only in practice mode.</b><br/>
    No one else can see this image, and it will corrupt your drawing for others.`;
        t6 = space();
        br4 = element("br");
        t7 = space();
        create_component(flatbutton0.$$.fragment);
        t8 = space();
        create_component(flatbutton1.$$.fragment);
        t9 = space();
        create_component(flatbutton2.$$.fragment);
        t10 = space();
        create_component(flatbutton3.$$.fragment);
        attr(div, "class", "typo-imagelab-position-picker svelte-zwzp7f");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, p);
        append(div, t6);
        append(div, br4);
        append(div, t7);
        mount_component(flatbutton0, div, null);
        append(div, t8);
        mount_component(flatbutton1, div, null);
        append(div, t9);
        mount_component(flatbutton2, div, null);
        append(div, t10);
        mount_component(flatbutton3, div, null);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        transition_in(flatbutton2.$$.fragment, local);
        transition_in(flatbutton3.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        transition_out(flatbutton2.$$.fragment, local);
        transition_out(flatbutton3.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
        destroy_component(flatbutton2);
        destroy_component(flatbutton3);
      }
    };
  }
  __name(create_fragment$3, "create_fragment$3");
  function instance$3($$self, $$props, $$invalidate) {
    let { onPick } = $$props;
    const click_handler2 = /* @__PURE__ */ __name(() => onPick("fit"), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => onPick("fill"), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(() => onPick("position"), "click_handler_2");
    const click_handler_3 = /* @__PURE__ */ __name(() => onPick("range"), "click_handler_3");
    $$self.$$set = ($$props2) => {
      if ("onPick" in $$props2) $$invalidate(0, onPick = $$props2.onPick);
    };
    return [onPick, click_handler2, click_handler_1, click_handler_2, click_handler_3];
  }
  __name(instance$3, "instance$3");
  const _Imagelab_position_picker = class _Imagelab_position_picker extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$3, create_fragment$3, safe_not_equal, { onPick: 0 });
    }
  };
  __name(_Imagelab_position_picker, "Imagelab_position_picker");
  let Imagelab_position_picker = _Imagelab_position_picker;
  var __defProp$3 = Object.defineProperty;
  var __decorateClass$3 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$3(target, key2, result);
    return result;
  }, "__decorateClass$3");
  const _ToolbarImageLabFeature = class _ToolbarImageLabFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_drawingService");
      __publicField(this, "_drawCommandsService");
      __publicField(this, "_toastService");
      __publicField(this, "_modalService");
      __publicField(this, "_canvasEventsSetup");
      __publicField(this, "_lobbyService");
      __publicField(this, "_globalSettingsService");
      __publicField(this, "name", "Image Laboratory");
      __publicField(this, "description", "Adds an icon to the typo toolbar to save or paste skribbl drawings (SKDs) to a lobby");
      __publicField(this, "tags", [
        FeatureTag.DRAWING
      ]);
      __publicField(this, "featureId", 10);
      __publicField(this, "_iconComponent");
      __publicField(this, "_iconClickSubscription");
      __publicField(this, "_flyoutComponent");
      __publicField(this, "_flyoutSubscription");
      __publicField(this, "_customName");
      __publicField(this, "clearBeforePaste", false);
      __publicField(this, "pasteInstant", false);
    }
    get boundServices() {
      return [this._drawCommandsService];
    }
    set customName(value) {
      const val = (value == null ? void 0 : value.replace(/[^a-z0-9]/gi, "_")) ?? void 0;
      this._customName = val && val.length > 0 ? val : void 0;
    }
    get customName() {
      return this._customName;
    }
    get locked() {
      return fromObservable(this._drawingService.pasteInProgress$, false);
    }
    get devmodeStore() {
      return this._globalSettingsService.settings.devMode.store;
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._iconComponent = new Icon_button({
        target: elements2.toolbar,
        props: {
          icon: "file-img-dna-gif",
          name: "Image Laboratory",
          order: 3,
          tooltipAction: this.createTooltip,
          lockTooltip: "Y"
        }
      });
      this._iconClickSubscription = this._iconComponent.click$.subscribe(() => {
        if (this._flyoutComponent) {
          return;
        }
        const flyoutContent = {
          componentType: Toolbar_imagelab,
          props: {
            feature: this
          }
        };
        this._flyoutComponent = new Area_flyout({
          target: elements2.gameWrapper,
          props: {
            componentData: flyoutContent,
            areaName: "chat",
            maxHeight: "600px",
            maxWidth: "300px",
            title: "Image Laboratory",
            iconName: "file-img-dna-gif"
          }
        });
        this._flyoutSubscription = this._flyoutComponent.closed$.subscribe(() => {
          var _a2, _b2;
          this._logger.info("Destroyed flyout");
          (_a2 = this._flyoutComponent) == null ? void 0 : _a2.$destroy();
          (_b2 = this._flyoutSubscription) == null ? void 0 : _b2.unsubscribe();
          this._flyoutComponent = void 0;
        });
      });
    }
    onDestroy() {
      var _a2, _b2, _c2, _d2;
      (_a2 = this._iconClickSubscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._iconComponent) == null ? void 0 : _b2.$destroy();
      (_c2 = this._flyoutComponent) == null ? void 0 : _c2.$destroy();
      this._flyoutComponent = void 0;
      (_d2 = this._flyoutSubscription) == null ? void 0 : _d2.unsubscribe();
    }
    /**
     * Select files, parse content as draw commands json and save to draw commands store
     */
    async addDrawCommandsFromFile() {
      const files = await chooseFile(".skd", true);
      if (files === null) return;
      const commands = await Promise.all(
        [...files].map(async (file) => {
          let commands2;
          try {
            const text2 = await file.text();
            commands2 = JSON.parse(text2);
            if (typeof commands2 !== "object" || !Array.isArray(commands2)) {
              throw new Error("Invalid format");
            }
          } catch (e) {
            this._logger.error("Failed to read file", file, e);
            throw e;
          }
          return {
            name: file.name,
            commands: commands2
          };
        })
      );
      commands.forEach((c) => this._drawCommandsService.saveDrawCommands(c.name, c.commands));
    }
    /**
     * gets the draww commands of the current image and saves them to the service
     */
    saveCurrentDrawCommands() {
      combineLatest$1({
        commands: this._drawingService.commands$,
        state: this._drawingService.imageState$
      }).pipe(
        take(1)
      ).subscribe(({ commands, state }) => {
        if (state === null) {
          this._logger.warn("Attempted to save commands, but state null. In a lobby?");
          throw new Error("state is null");
        }
        this._drawCommandsService.saveDrawCommands(this._customName ?? state.word.hints, commands);
      });
    }
    /**
     * gets the draww commands of the current image and saves them locally as a file
     */
    downloadCurrentDrawCommands() {
      combineLatest$1({
        commands: this._drawingService.commands$,
        state: this._drawingService.imageState$
      }).pipe(
        take(1)
      ).subscribe(({ commands, state }) => {
        if (state === null) {
          this._logger.warn("Attempted to save commands, but state null. In a lobby?");
          throw new Error("state is null");
        }
        const name = this._customName ?? state.word.hints;
        const json = JSON.stringify(commands);
        downloadText(json, `${name}.skd`);
      });
    }
    /**
     * Get a svelte store based on the saved draw commands from the service
     */
    get savedDrawCommandsStore() {
      return fromObservable(this._drawCommandsService.savedDrawCommands$, []);
    }
    /**
     * Removes saved draw commands from the service
     * @param all
     * @param remove
     */
    removeDrawCommands(all, remove) {
      const index = all.indexOf(remove);
      if (index === -1) {
        this._logger.warn("Tried to remove commands, but not found");
        throw new Error();
      }
      this._drawCommandsService.removeSavedDrawCommands(index);
    }
    /**
     * Start a pasting process using the drawing service
     * @param commands
     * @param pasteInstant
     */
    async pasteDrawCommands(commands) {
      const lobby = await firstValueFrom(this._lobbyService.lobby$);
      if (lobby === null) {
        await this._toastService.showToast("Can't paste outside of a lobby");
        return;
      }
      if (lobby.drawerId !== lobby.meId) {
        await this._toastService.showToast("You can only paste while you are drawing");
        return;
      }
      if (this.clearBeforePaste) this._drawingService.clearImage();
      await this._drawingService.pasteDrawCommands(commands.commands, !this.pasteInstant);
    }
    /**
     * Stop a paste in progress
     */
    abortPaste() {
      this._drawingService.cancelPendingDrawCommands();
    }
    /**
     * Pick an image from the local file system and return it as a base64 string
     */
    async pickImageFromLocal() {
      const files = await chooseFile("image/*", false);
      if (files === null) return null;
      const file = files[0];
      const reader = new FileReader();
      const result = new BehaviorSubject(void 0);
      reader.onload = async (e) => {
        var _a2;
        const data = (_a2 = e.target) == null ? void 0 : _a2.result;
        if (typeof data !== "string") {
          this._logger.error("Failed to read file", file);
          await this._toastService.showToast("Failed to read file");
          result.next(null);
          return;
        }
        result.next(data);
      };
      reader.readAsDataURL(file);
      return await firstValueFrom(result.pipe(filter((v) => v !== void 0)));
    }
    async pasteImageToLocation(base64) {
      this._logger.debug("Pasting image to location");
      const pickerComponent = {
        componentType: Imagelab_position_picker,
        propsFactory: /* @__PURE__ */ __name((submit) => ({
          onPick: submit.bind(this)
        }), "propsFactory")
      };
      const mode = await this._modalService.showPrompt(
        pickerComponent.componentType,
        pickerComponent.propsFactory,
        "Paste Image"
      );
      this._logger.debug("Selected mode", mode);
      if (mode === void 0) return;
      let x, y, width, height;
      const canvas = (await this._elementsSetup.complete()).canvas;
      const img = new Image();
      img.src = base64;
      await new Promise((resolve2) => img.onload = resolve2);
      if (mode === "fit") {
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
        width = img.width * scale;
        height = img.height * scale;
        x = (canvas.width - width) / 2;
        y = (canvas.height - height) / 2;
      } else if (mode === "fill") {
        x = 0;
        y = 0;
        width = canvas.width;
        height = canvas.height;
      } else if (mode === "position") {
        const toast = await this._toastService.showStickyToast("Paste Image", "Click on the canvas to paste the image", true);
        let position;
        try {
          position = await this.waitForCanvasClick(firstValueFrom(toast.closed$));
        } catch (e) {
          this._logger.debug("Aborted paste image", e);
          toast.close();
          return;
        }
        x = position.offsetX;
        y = position.offsetY;
        width = img.width;
        height = img.height;
        toast.close();
      } else if (mode === "range") {
        const toast = await this._toastService.showStickyToast("Paste Image", "Click on the canvas to select the top-left corner", true);
        let start;
        let end;
        try {
          start = await this.waitForCanvasClick(firstValueFrom(toast.closed$));
          toast.update("Paste Image", "Click on the canvas to select the bottom-right corner");
          end = await this.waitForCanvasClick(firstValueFrom(toast.closed$));
        } catch (e) {
          this._logger.debug("Aborted paste image", e);
          toast.close();
          return;
        }
        x = Math.min(start.offsetX, end.offsetX);
        y = Math.min(start.offsetY, end.offsetY);
        width = Math.abs(start.offsetX - end.offsetX);
        height = Math.abs(start.offsetY - end.offsetY);
        toast.close();
      }
      await this._drawingService.drawImage(base64, x, y, width, height);
    }
    async waitForCanvasClick(cancel) {
      const click = new Subject$1();
      const listener = /* @__PURE__ */ __name((e) => {
        e.stopImmediatePropagation();
        click.next(e);
        return false;
      }, "listener");
      cancel == null ? void 0 : cancel.then(() => {
        click.complete();
        events.remove("pointerdown", listener);
      });
      const events = await this._canvasEventsSetup.complete();
      events.add("preDraw")("pointerdown", listener);
      const result = await firstValueFrom(click);
      events.remove("pointerdown", listener);
      return result;
    }
  };
  __name(_ToolbarImageLabFeature, "ToolbarImageLabFeature");
  let ToolbarImageLabFeature = _ToolbarImageLabFeature;
  __decorateClass$3([
    inject(ElementsSetup)
  ], ToolbarImageLabFeature.prototype, "_elementsSetup");
  __decorateClass$3([
    inject(DrawingService)
  ], ToolbarImageLabFeature.prototype, "_drawingService");
  __decorateClass$3([
    inject(ImagelabService)
  ], ToolbarImageLabFeature.prototype, "_drawCommandsService");
  __decorateClass$3([
    inject(ToastService)
  ], ToolbarImageLabFeature.prototype, "_toastService");
  __decorateClass$3([
    inject(ModalService)
  ], ToolbarImageLabFeature.prototype, "_modalService");
  __decorateClass$3([
    inject(PrioritizedCanvasEventsSetup)
  ], ToolbarImageLabFeature.prototype, "_canvasEventsSetup");
  __decorateClass$3([
    inject(LobbyService)
  ], ToolbarImageLabFeature.prototype, "_lobbyService");
  __decorateClass$3([
    inject(GlobalSettingsService)
  ], ToolbarImageLabFeature.prototype, "_globalSettingsService");
  function get_each_context(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[15] = list[i];
    return child_ctx;
  }
  __name(get_each_context, "get_each_context");
  function create_else_block$1(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        div.textContent = "The image history is empty. Check again later!";
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_else_block$1, "create_else_block$1");
  function create_if_block_1(ctx) {
    let input;
    let t0;
    let img;
    let img_src_value;
    let t1;
    let div0;
    let iconbutton0;
    let t2;
    let span;
    let t3_value = (
      /*$history*/
      ctx[1][
        /*viewIndex*/
        ctx[3]
      ].artist + ""
    );
    let t3;
    let t4;
    let t5_value = (
      /*$history*/
      ctx[1][
        /*viewIndex*/
        ctx[3]
      ].date.toLocaleTimeString() + ""
    );
    let t5;
    let t6;
    let iconbutton1;
    let t7;
    let checkbox;
    let updating_checked;
    let t8;
    let div1;
    let t10;
    let select;
    let t11;
    let if_block_anchor;
    let current;
    let mounted;
    let dispose;
    iconbutton0 = new Icon_button({
      props: {
        icon: "file-img-arrow-left-gif",
        name: "Previous",
        size: "1.5rem",
        hoverMove: false,
        disabled: (
          /*viewIndex*/
          ctx[3] <= 0
        )
      }
    });
    iconbutton0.$on(
      "click",
      /*click_handler*/
      ctx[10]
    );
    iconbutton1 = new Icon_button({
      props: {
        icon: "file-img-arrow-right-gif",
        name: "Next",
        size: "1.5rem",
        hoverMove: false,
        disabled: (
          /*viewIndex*/
          ctx[3] >= /*$history*/
          ctx[1].length - 1
        )
      }
    });
    iconbutton1.$on(
      "click",
      /*click_handler_1*/
      ctx[11]
    );
    function checkbox_checked_binding(value) {
      ctx[12](value);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    let checkbox_props = { description: "Send with Discord embed" };
    if (
      /*sendAsEmbed*/
      ctx[2] !== void 0
    ) {
      checkbox_props.checked = /*sendAsEmbed*/
      ctx[2];
    }
    checkbox = new Checkbox({ props: checkbox_props });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
    let each_value = ensure_array_like(
      /*$member*/
      ctx[6].webhooks
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    }
    let if_block = (
      /*selectedWebhook*/
      ctx[5] !== null && /*loading*/
      ctx[4] === null && create_if_block_2(ctx)
    );
    return {
      c() {
        input = element("input");
        t0 = space();
        img = element("img");
        t1 = space();
        div0 = element("div");
        create_component(iconbutton0.$$.fragment);
        t2 = space();
        span = element("span");
        t3 = text(t3_value);
        t4 = text(" at  ");
        t5 = text(t5_value);
        t6 = space();
        create_component(iconbutton1.$$.fragment);
        t7 = space();
        create_component(checkbox.$$.fragment);
        t8 = space();
        div1 = element("div");
        div1.textContent = "Select one of your connected discord servers. When you submit, the image will appear in a channel on the server!";
        t10 = space();
        select = element("select");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t11 = space();
        if (if_block) if_block.c();
        if_block_anchor = empty();
        attr(input, "type", "text");
        attr(input, "class", "typo");
        attr(input, "placeholder", "Custom image name");
        if (!src_url_equal(img.src, img_src_value = /*$history*/
        ctx[1][
          /*viewIndex*/
          ctx[3]
        ].image.getBase64())) attr(img, "src", img_src_value);
        attr(img, "alt", "Post image");
        attr(img, "class", "svelte-f411i0");
        attr(div0, "class", "navigate-image svelte-f411i0");
        attr(div1, "class", "typo-post-info svelte-f411i0");
        if (
          /*selectedWebhook*/
          ctx[5] === void 0
        ) add_render_callback(() => (
          /*select_change_handler*/
          ctx[13].call(select)
        ));
      },
      m(target, anchor) {
        insert(target, input, anchor);
        set_input_value(
          input,
          /*$history*/
          ctx[1][
            /*viewIndex*/
            ctx[3]
          ].name
        );
        insert(target, t0, anchor);
        insert(target, img, anchor);
        insert(target, t1, anchor);
        insert(target, div0, anchor);
        mount_component(iconbutton0, div0, null);
        append(div0, t2);
        append(div0, span);
        append(span, t3);
        append(span, t4);
        append(span, t5);
        append(div0, t6);
        mount_component(iconbutton1, div0, null);
        insert(target, t7, anchor);
        mount_component(checkbox, target, anchor);
        insert(target, t8, anchor);
        insert(target, div1, anchor);
        insert(target, t10, anchor);
        insert(target, select, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(select, null);
          }
        }
        select_option(
          select,
          /*selectedWebhook*/
          ctx[5],
          true
        );
        insert(target, t11, anchor);
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              input,
              "input",
              /*input_input_handler*/
              ctx[9]
            ),
            listen(
              select,
              "change",
              /*select_change_handler*/
              ctx[13]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*$history, viewIndex*/
        10 && input.value !== /*$history*/
        ctx2[1][
          /*viewIndex*/
          ctx2[3]
        ].name) {
          set_input_value(
            input,
            /*$history*/
            ctx2[1][
              /*viewIndex*/
              ctx2[3]
            ].name
          );
        }
        if (!current || dirty & /*$history, viewIndex*/
        10 && !src_url_equal(img.src, img_src_value = /*$history*/
        ctx2[1][
          /*viewIndex*/
          ctx2[3]
        ].image.getBase64())) {
          attr(img, "src", img_src_value);
        }
        const iconbutton0_changes = {};
        if (dirty & /*viewIndex*/
        8) iconbutton0_changes.disabled = /*viewIndex*/
        ctx2[3] <= 0;
        iconbutton0.$set(iconbutton0_changes);
        if ((!current || dirty & /*$history, viewIndex*/
        10) && t3_value !== (t3_value = /*$history*/
        ctx2[1][
          /*viewIndex*/
          ctx2[3]
        ].artist + "")) set_data(t3, t3_value);
        if ((!current || dirty & /*$history, viewIndex*/
        10) && t5_value !== (t5_value = /*$history*/
        ctx2[1][
          /*viewIndex*/
          ctx2[3]
        ].date.toLocaleTimeString() + "")) set_data(t5, t5_value);
        const iconbutton1_changes = {};
        if (dirty & /*viewIndex, $history*/
        10) iconbutton1_changes.disabled = /*viewIndex*/
        ctx2[3] >= /*$history*/
        ctx2[1].length - 1;
        iconbutton1.$set(iconbutton1_changes);
        const checkbox_changes = {};
        if (!updating_checked && dirty & /*sendAsEmbed*/
        4) {
          updating_checked = true;
          checkbox_changes.checked = /*sendAsEmbed*/
          ctx2[2];
          add_flush_callback(() => updating_checked = false);
        }
        checkbox.$set(checkbox_changes);
        if (dirty & /*$member*/
        64) {
          each_value = ensure_array_like(
            /*$member*/
            ctx2[6].webhooks
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(select, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
        if (dirty & /*selectedWebhook, $member*/
        96) {
          select_option(
            select,
            /*selectedWebhook*/
            ctx2[5]
          );
        }
        if (
          /*selectedWebhook*/
          ctx2[5] !== null && /*loading*/
          ctx2[4] === null
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & /*selectedWebhook, loading*/
            48) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block_2(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(iconbutton0.$$.fragment, local);
        transition_in(iconbutton1.$$.fragment, local);
        transition_in(checkbox.$$.fragment, local);
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(iconbutton0.$$.fragment, local);
        transition_out(iconbutton1.$$.fragment, local);
        transition_out(checkbox.$$.fragment, local);
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(input);
          detach(t0);
          detach(img);
          detach(t1);
          detach(div0);
          detach(t7);
          detach(t8);
          detach(div1);
          detach(t10);
          detach(select);
          detach(t11);
          detach(if_block_anchor);
        }
        destroy_component(iconbutton0);
        destroy_component(iconbutton1);
        destroy_component(checkbox, detaching);
        destroy_each(each_blocks, detaching);
        if (if_block) if_block.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_if_block_1, "create_if_block_1");
  function create_each_block(ctx) {
    let option;
    let t0_value = (
      /*webhook*/
      ctx[15].name + ""
    );
    let t0;
    let t1;
    let t2_value = (
      /*webhook*/
      ctx[15].guild.guildName + ""
    );
    let t2;
    let t3;
    let option_value_value;
    return {
      c() {
        option = element("option");
        t0 = text(t0_value);
        t1 = text(" (");
        t2 = text(t2_value);
        t3 = text(")");
        option.__value = option_value_value = /*webhook*/
        ctx[15];
        set_input_value(option, option.__value);
      },
      m(target, anchor) {
        insert(target, option, anchor);
        append(option, t0);
        append(option, t1);
        append(option, t2);
        append(option, t3);
      },
      p(ctx2, dirty) {
        if (dirty & /*$member*/
        64 && t0_value !== (t0_value = /*webhook*/
        ctx2[15].name + "")) set_data(t0, t0_value);
        if (dirty & /*$member*/
        64 && t2_value !== (t2_value = /*webhook*/
        ctx2[15].guild.guildName + "")) set_data(t2, t2_value);
        if (dirty & /*$member*/
        64 && option_value_value !== (option_value_value = /*webhook*/
        ctx2[15])) {
          option.__value = option_value_value;
          set_input_value(option, option.__value);
        }
      },
      d(detaching) {
        if (detaching) {
          detach(option);
        }
      }
    };
  }
  __name(create_each_block, "create_each_block");
  function create_if_block_2(ctx) {
    let flatbutton;
    let current;
    flatbutton = new Flat_button({
      props: {
        content: "Send to Server",
        color: "green"
      }
    });
    flatbutton.$on(
      "click",
      /*click_handler_2*/
      ctx[14]
    );
    return {
      c() {
        create_component(flatbutton.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(flatbutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(flatbutton, detaching);
      }
    };
  }
  __name(create_if_block_2, "create_if_block_2");
  function create_if_block$1(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        div.textContent = "Log in with your typo account to post images to one of your Discord servers!";
        attr(div, "class", "not-logged-in svelte-f411i0");
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  __name(create_if_block$1, "create_if_block$1");
  function create_fragment$2(ctx) {
    let div;
    let current_block_type_index;
    let if_block0;
    let t;
    let current;
    const if_block_creators = [create_if_block_1, create_else_block$1];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*$history*/
        ctx2[1].length > 0 && /*$member*/
        ctx2[6] !== void 0 && /*$member*/
        ctx2[6] !== null
      ) return 0;
      return 1;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    let if_block1 = (
      /*$member*/
      (ctx[6] === null || /*$member*/
      ctx[6] === void 0) && create_if_block$1()
    );
    return {
      c() {
        div = element("div");
        if_block0.c();
        t = space();
        if (if_block1) if_block1.c();
        attr(div, "class", "typo-image-post svelte-f411i0");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_blocks[current_block_type_index].m(div, null);
        append(div, t);
        if (if_block1) if_block1.m(div, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
        if (
          /*$member*/
          ctx2[6] === null || /*$member*/
          ctx2[6] === void 0
        ) {
          if (if_block1) ;
          else {
            if_block1 = create_if_block$1();
            if_block1.c();
            if_block1.m(div, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block0);
        current = true;
      },
      o(local) {
        transition_out(if_block0);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if_blocks[current_block_type_index].d();
        if (if_block1) if_block1.d();
      }
    };
  }
  __name(create_fragment$2, "create_fragment$2");
  function instance$2($$self, $$props, $$invalidate) {
    let $history;
    let $member;
    let { feature } = $$props;
    let sendAsEmbed = true;
    let viewIndex = 0;
    let loading = null;
    const history = feature.imageHistoryStore;
    component_subscribe($$self, history, (value) => $$invalidate(1, $history = value));
    const member = feature.memberStore;
    component_subscribe($$self, member, (value) => $$invalidate(6, $member = value));
    let selectedWebhook = ($member == null ? void 0 : $member.webhooks[0]) ?? null;
    function input_input_handler() {
      $history[viewIndex].name = this.value;
      history.set($history);
    }
    __name(input_input_handler, "input_input_handler");
    const click_handler2 = /* @__PURE__ */ __name(() => $$invalidate(3, viewIndex--, viewIndex), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => $$invalidate(3, viewIndex++, viewIndex), "click_handler_1");
    function checkbox_checked_binding(value) {
      sendAsEmbed = value;
      $$invalidate(2, sendAsEmbed);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    function select_change_handler() {
      selectedWebhook = select_value(this);
      $$invalidate(5, selectedWebhook);
    }
    __name(select_change_handler, "select_change_handler");
    const click_handler_2 = /* @__PURE__ */ __name(() => $$invalidate(4, loading = selectedWebhook ? feature.postWebhook(selectedWebhook, $history[viewIndex], !sendAsEmbed) : null), "click_handler_2");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*$history*/
      2) {
        $$invalidate(3, viewIndex = $history.length - 1);
      }
    };
    return [
      feature,
      $history,
      sendAsEmbed,
      viewIndex,
      loading,
      selectedWebhook,
      $member,
      history,
      member,
      input_input_handler,
      click_handler2,
      click_handler_1,
      checkbox_checked_binding,
      select_change_handler,
      click_handler_2
    ];
  }
  __name(instance$2, "instance$2");
  const _Toolbar_imagepost = class _Toolbar_imagepost extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$2, create_fragment$2, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Toolbar_imagepost, "Toolbar_imagepost");
  let Toolbar_imagepost = _Toolbar_imagepost;
  var __defProp$2 = Object.defineProperty;
  var __decorateClass$2 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$2(target, key2, result);
    return result;
  }, "__decorateClass$2");
  const _ToolbarImagePostFeature = class _ToolbarImagePostFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_imagePostService");
      __publicField(this, "_imageFinishedService");
      __publicField(this, "_drawingService");
      __publicField(this, "_memberService");
      __publicField(this, "_apiService");
      __publicField(this, "_toastService");
      __publicField(this, "name", "Image Post");
      __publicField(this, "description", "Adds an icon to the typo toolbar to send images from your lobby directly to one of your connected discord servers");
      __publicField(this, "tags", [
        FeatureTag.SOCIAL,
        FeatureTag.PALANTIR
      ]);
      __publicField(this, "featureId", 11);
      __publicField(this, "_iconComponent");
      __publicField(this, "_iconClickSubscription");
      __publicField(this, "_flyoutComponent");
      __publicField(this, "_flyoutSubscription");
      __publicField(this, "_popoutOpened$", new Subject$1());
      __publicField(this, "_submitted$", new Subject$1());
    }
    get boundServices() {
      return [this._imagePostService];
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._iconComponent = new Icon_button({
        target: elements2.toolbar,
        props: {
          icon: "file-img-letter-gif",
          name: "Post Image",
          order: 5,
          tooltipAction: this.createTooltip,
          lockTooltip: "Y"
        }
      });
      this._iconClickSubscription = this._iconComponent.click$.subscribe(() => {
        if (this._flyoutComponent) {
          return;
        }
        this._popoutOpened$.next();
        const flyoutContent = {
          componentType: Toolbar_imagepost,
          props: {
            feature: this
          }
        };
        this._flyoutComponent = new Area_flyout({
          target: elements2.gameWrapper,
          props: {
            componentData: flyoutContent,
            areaName: "chat",
            maxHeight: "600px",
            maxWidth: "300px",
            title: "Post Image",
            iconName: "file-img-letter-gif"
          }
        });
        this._flyoutSubscription = this._flyoutComponent.closed$.pipe(mergeWith(this._submitted$)).subscribe(() => {
          var _a2, _b2;
          this._logger.info("Destroyed flyout");
          (_a2 = this._flyoutComponent) == null ? void 0 : _a2.$destroy();
          (_b2 = this._flyoutSubscription) == null ? void 0 : _b2.unsubscribe();
          this._flyoutComponent = void 0;
        });
      });
    }
    onDestroy() {
      var _a2, _b2, _c2, _d2;
      (_a2 = this._iconClickSubscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._iconComponent) == null ? void 0 : _b2.$destroy();
      (_c2 = this._flyoutComponent) == null ? void 0 : _c2.$destroy();
      (_d2 = this._flyoutSubscription) == null ? void 0 : _d2.unsubscribe();
      this._flyoutComponent = void 0;
    }
    /**
     * Gets a store based on the saved image history, joined with the current image
     * state if someone is currently drawing
     */
    get imageHistoryStore() {
      const observable2 = this._imagePostService.history$.pipe(
        /* take current history as base */
        switchMap((history) => this._drawingService.drawingState$.pipe(
          take(1),
          /* get current drawing state once */
          switchMap((state) => {
            if (state === "drawing") return this._imageFinishedService.mapToImageState(of(1));
            else return of(null);
          }),
          map((currentImage) => currentImage === null ? history : [...history, currentImage])
          /* if someone drawing, temporary add current state to history */
        ))
      );
      return fromObservable(observable2, []);
    }
    /**
     * Gets a store based on the authenticated member
     */
    get memberStore() {
      return fromObservable(this._memberService.memberData$, null);
    }
    /**
     * Post an image to discord
     * @param webhook
     * @param image
     * @param onlyImage
     */
    async postWebhook(webhook, image, onlyImage) {
      const toast = await this._toastService.showLoadingToast("Posting image to " + webhook.name);
      try {
        await this._apiService.getApi(GuildsApi).postImageToGuild({
          token: webhook.guild.invite,
          id: webhook.name,
          postImageDto: {
            title: image.name,
            author: image.artist,
            posterName: image.player,
            onlyImage,
            imageBase64: image.image.base64ApiTruncated
          }
        });
        this._submitted$.next();
        toast.resolve();
      } catch (e) {
        this._logger.error("Failed to post image to discord", e);
        toast.reject();
      }
    }
  };
  __name(_ToolbarImagePostFeature, "ToolbarImagePostFeature");
  let ToolbarImagePostFeature = _ToolbarImagePostFeature;
  __decorateClass$2([
    inject(ElementsSetup)
  ], ToolbarImagePostFeature.prototype, "_elementsSetup");
  __decorateClass$2([
    inject(ImagePostService)
  ], ToolbarImagePostFeature.prototype, "_imagePostService");
  __decorateClass$2([
    inject(ImageFinishedService)
  ], ToolbarImagePostFeature.prototype, "_imageFinishedService");
  __decorateClass$2([
    inject(DrawingService)
  ], ToolbarImagePostFeature.prototype, "_drawingService");
  __decorateClass$2([
    inject(MemberService)
  ], ToolbarImagePostFeature.prototype, "_memberService");
  __decorateClass$2([
    inject(ApiService)
  ], ToolbarImagePostFeature.prototype, "_apiService");
  __decorateClass$2([
    inject(ToastService)
  ], ToolbarImagePostFeature.prototype, "_toastService");
  const copyBlobToClipboard = /* @__PURE__ */ __name(async (blob) => {
    const data = [new ClipboardItem({ [blob.type]: blob })];
    await navigator.clipboard.write(data);
  }, "copyBlobToClipboard");
  function create_fragment$1(ctx) {
    let div;
    let input;
    let t0;
    let flatbutton0;
    let t1;
    let flatbutton1;
    let t2;
    let flatbutton2;
    let t3;
    let flatbutton3;
    let t4;
    let flatbutton4;
    let current;
    let mounted;
    let dispose;
    flatbutton0 = new Flat_button({
      props: { content: "Download PNG", color: "green" }
    });
    flatbutton0.$on(
      "click",
      /*click_handler*/
      ctx[2]
    );
    flatbutton1 = new Flat_button({
      props: { content: "Download GIF", color: "green" }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_1*/
      ctx[3]
    );
    flatbutton2 = new Flat_button({
      props: {
        content: "Download Draw Progress",
        color: "green"
      }
    });
    flatbutton2.$on(
      "click",
      /*click_handler_2*/
      ctx[4]
    );
    flatbutton3 = new Flat_button({
      props: {
        content: "Copy to Clipboard",
        color: "blue"
      }
    });
    flatbutton3.$on(
      "click",
      /*click_handler_3*/
      ctx[5]
    );
    flatbutton4 = new Flat_button({
      props: { content: "Save in Cloud", color: "blue" }
    });
    flatbutton4.$on(
      "click",
      /*click_handler_4*/
      ctx[6]
    );
    return {
      c() {
        div = element("div");
        input = element("input");
        t0 = space();
        create_component(flatbutton0.$$.fragment);
        t1 = space();
        create_component(flatbutton1.$$.fragment);
        t2 = space();
        create_component(flatbutton2.$$.fragment);
        t3 = space();
        create_component(flatbutton3.$$.fragment);
        t4 = space();
        create_component(flatbutton4.$$.fragment);
        attr(input, "type", "text");
        attr(input, "class", "typo");
        attr(input, "placeholder", "Custom image name");
        attr(div, "class", "typo-toolbar-save-actions svelte-1xyzs78");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, input);
        set_input_value(
          input,
          /*feature*/
          ctx[0].customName
        );
        append(div, t0);
        mount_component(flatbutton0, div, null);
        append(div, t1);
        mount_component(flatbutton1, div, null);
        append(div, t2);
        mount_component(flatbutton2, div, null);
        append(div, t3);
        mount_component(flatbutton3, div, null);
        append(div, t4);
        mount_component(flatbutton4, div, null);
        current = true;
        if (!mounted) {
          dispose = listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[1]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*feature*/
        1 && input.value !== /*feature*/
        ctx2[0].customName) {
          set_input_value(
            input,
            /*feature*/
            ctx2[0].customName
          );
        }
      },
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        transition_in(flatbutton2.$$.fragment, local);
        transition_in(flatbutton3.$$.fragment, local);
        transition_in(flatbutton4.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        transition_out(flatbutton2.$$.fragment, local);
        transition_out(flatbutton3.$$.fragment, local);
        transition_out(flatbutton4.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(flatbutton0);
        destroy_component(flatbutton1);
        destroy_component(flatbutton2);
        destroy_component(flatbutton3);
        destroy_component(flatbutton4);
        mounted = false;
        dispose();
      }
    };
  }
  __name(create_fragment$1, "create_fragment$1");
  function instance$1($$self, $$props, $$invalidate) {
    let { feature } = $$props;
    feature.customName = "";
    function input_input_handler() {
      feature.customName = this.value;
      $$invalidate(0, feature);
    }
    __name(input_input_handler, "input_input_handler");
    const click_handler2 = /* @__PURE__ */ __name(() => feature.saveAsPng(), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => feature.saveAsGif(), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(() => feature.saveAsDrawCommands(), "click_handler_2");
    const click_handler_3 = /* @__PURE__ */ __name(() => feature.saveToClipboard(), "click_handler_3");
    const click_handler_4 = /* @__PURE__ */ __name(() => feature.saveInCloud(), "click_handler_4");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      input_input_handler,
      click_handler2,
      click_handler_1,
      click_handler_2,
      click_handler_3,
      click_handler_4
    ];
  }
  __name(instance$1, "instance$1");
  const _Toolbar_save = class _Toolbar_save extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance$1, create_fragment$1, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Toolbar_save, "Toolbar_save");
  let Toolbar_save = _Toolbar_save;
  var __defProp$1 = Object.defineProperty;
  var __decorateClass$1 = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp$1(target, key2, result);
    return result;
  }, "__decorateClass$1");
  const _ToolbarSaveFeature = class _ToolbarSaveFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_drawingService");
      __publicField(this, "_lobbyService");
      __publicField(this, "_toastService");
      __publicField(this, "_cloudService");
      __publicField(this, "_memberService");
      __publicField(this, "_imageFinishedService");
      __publicField(this, "name", "Save Image");
      __publicField(this, "description", "Adds an icon to the typo toolbar to save the current image locally, to cloud, as gif or as draw command file");
      __publicField(this, "tags", [
        FeatureTag.DRAWING
      ]);
      __publicField(this, "featureId", 12);
      __publicField(this, "_iconComponent");
      __publicField(this, "_iconClickSubscription");
      __publicField(this, "_flyoutComponent");
      __publicField(this, "_flyoutSubscription");
      __publicField(this, "_customName");
      __publicField(this, "_saveCommand", this.useCommand(
        new ExtensionCommand("save", this, "Save Image", "Downloads the current image")
      ).withParameters(
        (params) => params.addParam(new StringOptionalCommandParameter("File name", "The filename of the downloaded image", (name) => ({ name }))).run(async (args, command) => {
          this._customName = args.name;
          await this.saveAsPng();
          return new InterpretableSilentSuccess(command);
        })
      ));
      __publicField(this, "_copyHotkey", this.useHotkey(
        new HotkeyAction(
          "save",
          "Copy to Clipboard",
          "Copy the current image to the clipboard",
          this,
          () => this.saveToClipboard(),
          true,
          ["AltLeft", "KeyC"]
        )
      ));
    }
    set customName(value) {
      const val = (value == null ? void 0 : value.replace(/[^a-z0-9]/gi, "_")) ?? void 0;
      this._customName = val && val.length > 0 ? val : void 0;
    }
    get customName() {
      return this._customName;
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._iconComponent = new Icon_button({
        target: elements2.toolbar,
        props: {
          icon: "file-img-floppy-drive-gif",
          name: "Save Image",
          order: 2,
          tooltipAction: this.createTooltip,
          lockTooltip: "Y"
        }
      });
      this._iconClickSubscription = this._iconComponent.click$.subscribe(() => {
        if (this._flyoutComponent) {
          return;
        }
        const flyoutContent = {
          componentType: Toolbar_save,
          props: {
            feature: this
          }
        };
        this._flyoutComponent = new Area_flyout({
          target: elements2.gameWrapper,
          props: {
            componentData: flyoutContent,
            areaName: "chat",
            maxHeight: "600px",
            maxWidth: "300px",
            title: "Save Image",
            iconName: "file-img-floppy-drive-gif"
          }
        });
        this._flyoutSubscription = this._flyoutComponent.closed$.subscribe(() => {
          var _a2, _b2;
          this._logger.info("Destroyed flyout");
          (_a2 = this._flyoutComponent) == null ? void 0 : _a2.$destroy();
          (_b2 = this._flyoutSubscription) == null ? void 0 : _b2.unsubscribe();
          this._flyoutComponent = void 0;
        });
      });
    }
    async saveInCloud() {
      const toast = await this._toastService.showLoadingToast("Uploading image");
      this._imageFinishedService.mapToImageState().pipe(
        withLatestFrom(this._memberService.member$),
        catchError((err) => {
          this._logger.error("Failed to save image", err);
          toast.reject("Unknown error :(");
          throw err;
        })
      ).subscribe(async ([image, member]) => {
        if (!image) {
          this._logger.error("Failed to get image data, no drawing active?");
          toast.reject("Failed to get image");
          throw new Error("No drawing active");
        }
        if (!member) {
          this._logger.error("Failed to get member, not logged in?");
          toast.reject("You need to log in to use the cloud");
          return of(false);
        }
        if (this._customName) {
          image.name = this._customName;
        }
        await this._cloudService.uploadToCloud(image, member);
        toast.resolve();
      });
    }
    async saveAsPng() {
      const toast = await this._toastService.showLoadingToast("Downloading image");
      combineLatest$1({
        blob: fromPromise(this._drawingService.getCurrentImageData()).pipe(map((data) => data.blob)),
        meta: this._drawingService.imageState$.pipe(take(1)),
        lobby: this._lobbyService.lobby$.pipe(take(1))
      }).pipe(
        catchError((err) => {
          this._logger.error("Failed to download image", err);
          toast.reject();
          throw err;
        })
      ).subscribe(({ blob, meta, lobby }) => {
        var _a2;
        if (!meta) {
          this._logger.error("Failed to get image meta data, no drawing active?");
          toast.reject("Failed to get image");
          throw new Error("No drawing active");
        }
        if (!lobby) {
          this._logger.error("Failed to get lobby, not joined?");
          toast.reject("failed to get lobby details");
          throw new Error("Not joined in lobby");
        }
        const drawer = ((_a2 = lobby.players.find((player) => player.id === meta.drawerId)) == null ? void 0 : _a2.name) ?? "unknown";
        downloadBlob(blob, (this._customName ?? `skribbl-${meta.word.hints}-by-${drawer}`) + ".png");
        toast.resolve();
      });
    }
    async saveToClipboard() {
      this._logger.debug("Saving to clipboard");
      const toast = await this._toastService.showLoadingToast("Saving image to clipboard");
      combineLatest$1({
        blob: fromPromise(this._drawingService.getCurrentImageData()).pipe(map((data) => data.blob))
      }).pipe(
        catchError((err) => {
          this._logger.error("Failed to copy image", err);
          toast.reject();
          throw err;
        })
      ).subscribe(async ({ blob }) => {
        try {
          await copyBlobToClipboard(blob);
          toast.resolve();
        } catch (err) {
          this._logger.error("Failed to copy image", err);
          toast.reject("Failed to copy image");
        }
      });
    }
    async saveAsGif() {
      this._logger.debug("Saving as gif");
      const toast = await this._toastService.showStickyToast("Saving as GIF");
      combineLatest$1({
        commands: this._drawingService.commands$,
        lobby: this._lobbyService.lobby$.pipe(take(1)),
        state: this._drawingService.imageState$,
        duration: fromPromise(this._toastService.showPromptToast("Enter GIF duration", "Enter the preferred duration in seconds")).pipe(
          switchMap((v) => v.result)
        )
      }).pipe(
        take(1)
      ).subscribe(async ({ commands, lobby, state, duration }) => {
        var _a2;
        const durationMs = parseFloat(duration ?? "") * 1e3;
        if (duration === null) {
          toast.close();
          return;
        }
        if (Number.isNaN(durationMs)) {
          toast.resolve("Invalid duration entered");
          return;
        }
        if (state === null) {
          this._logger.warn("Attempted to gif commands, but state null. In a lobby?");
          toast.resolve("No drawing active");
          throw new Error("state is null");
        }
        if (!lobby) {
          this._logger.error("Failed to get lobby, not joined?");
          toast.resolve("Failed to get lobby details");
          throw new Error("Not joined in lobby");
        }
        const progressBar = /* @__PURE__ */ __name((progress) => {
          const doneChar = "█";
          const leftChar = "░";
          const length = 10;
          const done = Math.floor(progress * length);
          const left = length - done;
          return `${doneChar.repeat(done)}${leftChar.repeat(left)}`;
        }, "progressBar");
        const drawer = ((_a2 = lobby.players.find((player) => player.id === state.drawerId)) == null ? void 0 : _a2.name) ?? "unknown";
        const name = this._customName ?? `skribbl-${state.word.hints}-by-${drawer}`;
        const workerBlob = new Blob([gifRendererWorkerJs], { type: "application/javascript" });
        const worker = new TypedWorkerExecutor(
          URL.createObjectURL(workerBlob),
          {
            frameRendered: /* @__PURE__ */ __name((index, total) => {
              toast.update(`Rendering GIF..   ${progressBar(index / total)} (${Math.floor(index * 100 / total).toString().padStart(2, " ")}%)`);
            }, "frameRendered")
          }
        );
        const gif = await worker.run("renderGif", commands, durationMs);
        toast.resolve(`${name} saved as GIF`, 3e3);
        downloadBlob(gif, `${name}.gif`);
      });
    }
    async saveAsDrawCommands() {
      this._logger.debug("Saving as draw commands");
      const toast = await this._toastService.showLoadingToast("Downloading commands");
      combineLatest$1({
        meta: this._drawingService.imageState$.pipe(take(1)),
        lobby: this._lobbyService.lobby$.pipe(take(1)),
        commands: this._drawingService.commands$.pipe(take(1))
      }).pipe(
        catchError((err) => {
          this._logger.error("Failed to download commands", err);
          toast.reject();
          throw err;
        })
      ).subscribe(({ meta, lobby, commands }) => {
        var _a2;
        if (!meta) {
          this._logger.error("Failed to get image meta data, no drawing active?");
          toast.reject("Failed to get image");
          throw new Error("No drawing active");
        }
        if (!lobby) {
          this._logger.error("Failed to get lobby, not joined?");
          toast.reject("failed to get lobby details");
          throw new Error("Not joined in lobby");
        }
        const json = JSON.stringify(commands);
        const drawer = ((_a2 = lobby.players.find((player) => player.id === meta.drawerId)) == null ? void 0 : _a2.name) ?? "unknown";
        downloadText(json, (this._customName ?? `skribbl-${meta.word.hints}-by-${drawer}`) + ".skd");
        toast.resolve();
      });
    }
    onDestroy() {
      var _a2, _b2, _c2, _d2;
      (_a2 = this._iconClickSubscription) == null ? void 0 : _a2.unsubscribe();
      (_b2 = this._iconComponent) == null ? void 0 : _b2.$destroy();
      (_c2 = this._flyoutComponent) == null ? void 0 : _c2.$destroy();
      (_d2 = this._flyoutSubscription) == null ? void 0 : _d2.unsubscribe();
    }
  };
  __name(_ToolbarSaveFeature, "ToolbarSaveFeature");
  let ToolbarSaveFeature = _ToolbarSaveFeature;
  __decorateClass$1([
    inject(ElementsSetup)
  ], ToolbarSaveFeature.prototype, "_elementsSetup");
  __decorateClass$1([
    inject(DrawingService)
  ], ToolbarSaveFeature.prototype, "_drawingService");
  __decorateClass$1([
    inject(LobbyService)
  ], ToolbarSaveFeature.prototype, "_lobbyService");
  __decorateClass$1([
    inject(ToastService)
  ], ToolbarSaveFeature.prototype, "_toastService");
  __decorateClass$1([
    inject(CloudService)
  ], ToolbarSaveFeature.prototype, "_cloudService");
  __decorateClass$1([
    inject(MemberService)
  ], ToolbarSaveFeature.prototype, "_memberService");
  __decorateClass$1([
    inject(ImageFinishedService)
  ], ToolbarSaveFeature.prototype, "_imageFinishedService");
  function create_else_block(ctx) {
    let img0;
    let img0_src_value;
    let t;
    let img1;
    let img1_src_value;
    let mounted;
    let dispose;
    return {
      c() {
        img0 = element("img");
        t = space();
        img1 = element("img");
        if (!src_url_equal(img0.src, img0_src_value = "")) attr(img0, "src", img0_src_value);
        attr(img0, "alt", "Exit Lobby");
        attr(img0, "class", "lobby-exit lobbyNavIcon exit svelte-yw7ztm");
        if (!src_url_equal(img1.src, img1_src_value = "")) attr(img1, "src", img1_src_value);
        attr(img1, "alt", "Next Lobby");
        attr(img1, "class", "lobby-next lobbyNavIcon next svelte-yw7ztm");
      },
      m(target, anchor) {
        insert(target, img0, anchor);
        insert(target, t, anchor);
        insert(target, img1, anchor);
        if (!mounted) {
          dispose = [
            listen(
              img0,
              "click",
              /*click_handler_2*/
              ctx[5]
            ),
            action_destroyer(
              /*feature*/
              ctx[0].createTooltip(img0, { title: "Exit Lobby", lock: "Y" })
            ),
            listen(
              img1,
              "click",
              /*click_handler_3*/
              ctx[6]
            ),
            action_destroyer(
              /*feature*/
              ctx[0].createTooltip(img1, { title: "Next Lobby", lock: "Y" })
            )
          ];
          mounted = true;
        }
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(img0);
          detach(t);
          detach(img1);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  __name(create_else_block, "create_else_block");
  function create_if_block(ctx) {
    let flatbutton0;
    let t;
    let flatbutton1;
    let current;
    flatbutton0 = new Flat_button({
      props: { content: "Exit Lobby", color: "orange" }
    });
    flatbutton0.$on(
      "click",
      /*click_handler*/
      ctx[3]
    );
    flatbutton1 = new Flat_button({
      props: { content: "Next Lobby", color: "blue" }
    });
    flatbutton1.$on(
      "click",
      /*click_handler_1*/
      ctx[4]
    );
    return {
      c() {
        create_component(flatbutton0.$$.fragment);
        t = space();
        create_component(flatbutton1.$$.fragment);
      },
      m(target, anchor) {
        mount_component(flatbutton0, target, anchor);
        insert(target, t, anchor);
        mount_component(flatbutton1, target, anchor);
        current = true;
      },
      p: noop,
      i(local) {
        if (current) return;
        transition_in(flatbutton0.$$.fragment, local);
        transition_in(flatbutton1.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(flatbutton0.$$.fragment, local);
        transition_out(flatbutton1.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t);
        }
        destroy_component(flatbutton0, detaching);
        destroy_component(flatbutton1, detaching);
      }
    };
  }
  __name(create_if_block, "create_if_block");
  function create_fragment(ctx) {
    let div;
    let current_block_type_index;
    let if_block;
    let current;
    const if_block_creators = [create_if_block, create_else_block];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*$flat*/
        ctx2[1]
      ) return 0;
      return 1;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div = element("div");
        if_block.c();
        attr(div, "class", "lobby-navigation svelte-yw7ztm");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_blocks[current_block_type_index].m(div, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if_blocks[current_block_type_index].d();
      }
    };
  }
  __name(create_fragment, "create_fragment");
  function instance($$self, $$props, $$invalidate) {
    let $flat;
    let { feature } = $$props;
    const flat = feature.flatButtonsStore;
    component_subscribe($$self, flat, (value) => $$invalidate(1, $flat = value));
    const click_handler2 = /* @__PURE__ */ __name(() => feature.exitLobby(), "click_handler");
    const click_handler_1 = /* @__PURE__ */ __name(() => feature.nextLobby(), "click_handler_1");
    const click_handler_2 = /* @__PURE__ */ __name(() => feature.exitLobby(), "click_handler_2");
    const click_handler_3 = /* @__PURE__ */ __name(() => feature.nextLobby(), "click_handler_3");
    $$self.$$set = ($$props2) => {
      if ("feature" in $$props2) $$invalidate(0, feature = $$props2.feature);
    };
    return [
      feature,
      $flat,
      flat,
      click_handler2,
      click_handler_1,
      click_handler_2,
      click_handler_3
    ];
  }
  __name(instance, "instance");
  const _Lobby_navigation = class _Lobby_navigation extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance, create_fragment, safe_not_equal, { feature: 0 });
    }
  };
  __name(_Lobby_navigation, "Lobby_navigation");
  let Lobby_navigation = _Lobby_navigation;
  var __defProp2 = Object.defineProperty;
  var __decorateClass = /* @__PURE__ */ __name((decorators, target, key2, kind) => {
    var result = void 0;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = decorator(target, key2, result) || result;
    if (result) __defProp2(target, key2, result);
    return result;
  }, "__decorateClass");
  const _LobbyNavigationFeature = class _LobbyNavigationFeature extends TypoFeature {
    constructor() {
      super(...arguments);
      __publicField(this, "_elementsSetup");
      __publicField(this, "_lobbyService");
      __publicField(this, "name", "Lobby Navigation");
      __publicField(this, "description", "Show a navigation bar in-game to exit or skip the current lobby");
      __publicField(this, "tags", [
        FeatureTag.SOCIAL
      ]);
      __publicField(this, "featureId", 2);
      __publicField(this, "_component");
      __publicField(this, "_overrideLogoExitSetting", this.useSetting(
        new BooleanExtensionSetting("overrideLogoExit", true, this).withName("Enhanced Logo Exit").withDescription("Exit the lobby instead reloading skribbl when clicking the logo")
      ));
      __publicField(this, "_useFlatButtonsSetting", this.useSetting(
        new BooleanExtensionSetting("useFlatButtons", false, this).withName("Text Buttons").withDescription("Use text buttons instead of icons")
      ));
      __publicField(this, "_nextCommand", this.useCommand(
        new ExtensionCommand("skip", this, "Skip Lobby", "Leave the current lobby and join another")
      ).run(async (command) => {
        this.nextLobby();
        return new InterpretableSuccess(command, "Skipping lobby");
      }));
      __publicField(this, "_leaveCommand", this.useCommand(
        new ExtensionCommand("leave", this, "Left Lobby", "Leave the current lobby")
      ).run(async (command) => {
        this.exitLobby();
        return new InterpretableSuccess(command, "Skipped lobby");
      }));
      __publicField(this, "_logoClickListener", this.onLogoClick.bind(this));
      __publicField(this, "_settingChangeSubscription");
    }
    async onActivate() {
      const elements2 = await this._elementsSetup.complete();
      this._component = new Lobby_navigation({
        target: elements2.gameBar,
        anchor: elements2.gameSettings,
        props: {
          feature: this
        }
      });
      this._settingChangeSubscription = this._overrideLogoExitSetting.changes$.subscribe((value) => {
        if (value) {
          elements2.logoIngame.addEventListener("click", this._logoClickListener);
        } else {
          elements2.logoIngame.removeEventListener("click", this._logoClickListener);
        }
      });
    }
    async onDestroy() {
      var _a2;
      (_a2 = this._component) == null ? void 0 : _a2.$destroy();
      const elements2 = await this._elementsSetup.complete();
      elements2.logoIngame.removeEventListener("click", this._logoClickListener);
    }
    onLogoClick(event) {
      var _a2;
      event.stopImmediatePropagation();
      event.preventDefault();
      (_a2 = this._settingChangeSubscription) == null ? void 0 : _a2.unsubscribe();
      this._settingChangeSubscription = void 0;
      this.exitLobby();
    }
    nextLobby() {
      this._lobbyService.lobby$.pipe(
        tap((lobby) => {
          if (lobby !== null) {
            this._lobbyService.leaveLobby();
          }
        }),
        filter((lobby) => lobby === null),
        take(1)
      ).subscribe(() => {
        this._lobbyService.joinLobby();
      });
    }
    exitLobby() {
      this._lobbyService.lobby$.pipe(
        take(1),
        filter((lobby) => lobby !== null)
      ).subscribe(() => {
        this._lobbyService.leaveLobby();
      });
    }
    get flatButtonsStore() {
      return this._useFlatButtonsSetting.store;
    }
  };
  __name(_LobbyNavigationFeature, "LobbyNavigationFeature");
  let LobbyNavigationFeature = _LobbyNavigationFeature;
  __decorateClass([
    inject(ElementsSetup)
  ], LobbyNavigationFeature.prototype, "_elementsSetup");
  __decorateClass([
    inject(LobbyService)
  ], LobbyNavigationFeature.prototype, "_lobbyService");
  const interceptor = new Interceptor(true);
  LoggingService.defaultLogLevel = "warn";
  new ExtensionContainer(interceptor).registerServices(
    /* register services to the application */
    { type: ModalService, scope: "scoped" },
    { type: ApiService, scope: "singleton" },
    { type: MemberService, scope: "singleton" },
    { type: LobbyService, scope: "singleton" },
    { type: DrawingService, scope: "singleton" },
    { type: ToolsService, scope: "singleton" },
    { type: GlobalSettingsService, scope: "singleton" },
    { type: ImageFinishedService, scope: "singleton" },
    { type: ImagelabService, scope: "singleton" },
    { type: ImagePostService, scope: "singleton" },
    { type: CloudService, scope: "singleton" },
    { type: ToastService, scope: "scoped" },
    { type: SocketService, scope: "scoped" },
    { type: LobbyItemsService, scope: "singleton" },
    { type: PlayersService, scope: "singleton" },
    { type: ChatService, scope: "singleton" },
    { type: LobbyInteractionsService, scope: "singleton" },
    { type: ThemesService, scope: "singleton" },
    { type: LobbyConnectionService, scope: "singleton" },
    { type: ColorsService, scope: "singleton" },
    { type: OnboardingService, scope: "singleton" }
  ).registerSetups(
    /* register setup dependencies to the application */
    PanelSetup,
    ElementsSetup,
    GameSettingsSetup,
    GamePatchReadySetup,
    SkribblMessageRelaySetup,
    ToolbarSetup,
    SkribblEmitRelaySetup,
    ControlsSetup,
    SkribblInitializedSetup,
    ApiDataSetup,
    ToastSetup,
    ChatControlsSetup,
    PrioritizedCanvasEventsSetup,
    CssColorVarSelectorsSetup,
    LandingPlayerSetup,
    CustomizerActionsSetup
  ).registerEventProcessors(
    /* register event processors and their listeners */
    lobbyJoinedEventRegistration,
    lobbyLeftEventRegistration,
    lobbyStateChangedEventRegistration,
    hintsAddedEventRegistration,
    lobbyPlayerChangedEventRegistration,
    roundStartedEventRegistration,
    wordGuessedEventRegistration,
    drawEventRegistration,
    imageResetEventRegistration,
    messageSentEventRegistration,
    messageReceivedEventRegistration,
    chatTypedEventRegistration,
    toolChangedEventRegistration,
    sizeChangedEventRegistration,
    colorChangedEventRegistration,
    scoreboardVisibilityChangedEventRegistration,
    playerPopupVisibilityChangedEventRegistration,
    textOverlayVisibilityChangedEventRegistration,
    lobbyInteractedEventRegistration,
    canvasClearedEventRegistration,
    lobbyJoinFailedEventRegistration
  ).registerFeatures(
    /* register application features */
    UserInfoFeature,
    PanelNewsFeature,
    LobbyNavigationFeature,
    ToolbarSaveFeature,
    ToolbarImagePostFeature,
    ToolbarChallengesFeature,
    ToolbarFullscreenFeature,
    ToolbarImageLabFeature,
    ControlsSettingsFeature,
    PanelChangelogFeature,
    PanelLobbiesFeature,
    PanelCabinFeature,
    PanelFiltersFeature,
    ChatRecallFeature,
    ImageAgentFeature,
    ControlsCloudFeature,
    GuessCheckFeature,
    LobbyStatusFeature,
    PlayerSpritesFeature,
    PlayerScenesFeature,
    ChatEmojisFeature,
    ChatProfileLinkFeature,
    LoggingFeature,
    HotkeysFeature,
    CanvasZoomFeature,
    LineToolFeature,
    ChatFocusFeature,
    PlayerIdsFeature,
    LobbyTimeVisualizerFeature,
    DrawingColorToolsFeature,
    DrawingColorPalettesFeature,
    ChatQuickReactFeature,
    ControlsThemesFeature,
    TooltipsFeature,
    ChatCopyFormattedFeature,
    DrawingPressureFeature,
    ChatCommandsFeature,
    DrawingBrushLabFeature,
    DropsFeature,
    PlayerAwardsFeature,
    ChatClearFeature,
    ChatMessageSplitsFeature,
    CustomizerPracticeJoinFeature,
    CustomizerOutfitToggleFeature,
    CanvasRateIconsFeature,
    ControlsOnboardingFeature,
    ControlsProfilesFeature,
    ChatAvatarsFeature,
    DrawingSizeHotkeysFeature,
    ChatPingFeature
  );
  interceptor.triggerPatchInjection();
  const assets = { "img-arrow-left-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAOttGgAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0MzY4MTg5MjdGN0ExMUVGOUYzNEJFMUNFMjc0Njc1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0MzY4MTg5MzdGN0ExMUVGOUYzNEJFMUNFMjc0Njc1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQzNjgxODkwN0Y3QTExRUY5RjM0QkUxQ0UyNzQ2NzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQzNjgxODkxN0Y3QTExRUY5RjM0QkUxQ0UyNzQ2NzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAgAsAAAAADAAMAAAApaUj6nL7Q+jnLTai7PevPsPhuJIYsEZlA2KqgoLuwccy3Rd3gHA5jcA7Il0wKLwQywadcwTJKkMNpurX1Q5pTKs1+sv+6J1x+QoLcwqq8nnBGwN7+Jm77idd0SI7/C5vs5X5veHEmhWOOi255XF9ASI1ej4CIknmVgFidmR1OJi5WkzKSMwSlq6qZJ6ytrq+gobKzurUQAAIfkEBRQAAgAsAAAAADAAMAAAApCUj6nL7Q+jnLTai7PevPsPhuJIZkFQPueaLuuLtgYMywJdpzit4wDwKvl+wN3uAiMqjcwJTblkGiNPaFSKUyWt3C4xy6h6x1aea0tOQ4Pnl/r9ZYXRcDK77a7b5Q2x/nrXR1eGZQbh91M4JYGoCOZE53iiIRZIUsXX0mQz88h5k/N5YClaanqKmqq6ytq6UAAAOw==", "img-arrow-left-gif"), "img-arrow-right-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAFhY8AAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3RDM1NjE4QTdGN0ExMUVGQUQ1MERCQkMxMEFENzI4NSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo3RDM1NjE4QjdGN0ExMUVGQUQ1MERCQkMxMEFENzI4NSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjdEMzU2MTg4N0Y3QTExRUZBRDUwREJCQzEwQUQ3Mjg1IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjdEMzU2MTg5N0Y3QTExRUZBRDUwREJCQzEwQUQ3Mjg1Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAgAsAAAAADAAMAAAApiUj6nL7Q+jnLTai7PevPsPhuJIcsEZlA+KqgsLuwgcywJduyyAp+oO4OFKwKCQNukpUcZmD7KMNp1DR3Q5nT4V12Mxq0VyYeCyOZw70M5ss3j2bcuNaQN5jveexsy8/A3X53cGmEAWN1hneKVUVtXAiJVVCBm5RqXYcRf0ONK3RXTCSSmyZHMDakOqw3Lq+gobKztLW7tRAAAh+QQFFAACACwAAAAAMAAwAAACk5SPqcvtD6OctNqLs968+w+G4kh2QVBC55oy64u2CAzLBl3LON2+ALDL7Ia/H84yTBaXOUlSuSzyVM9dNDpt4K7cLrO5oHnH3azCR05fzbOV+i0Ft0/wN3seqKePLrF+LRdW5VcWKDi4hWXYhwij+ILRSBcHWYIGtAjihlnZM2QjEAQammnJMoqaqrrK2ur6CjtRAAA7", "img-arrow-right-gif"), "img-arrow-small-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAKioqAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDNTJFRTk3MDdGNzkxMUVGQjZGNUUxMjE2NTEyMzA0MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDNTJFRTk3MTdGNzkxMUVGQjZGNUUxMjE2NTEyMzA0MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkM1MkVFOTZFN0Y3OTExRUZCNkY1RTEyMTY1MTIzMDQxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkM1MkVFOTZGN0Y3OTExRUZCNkY1RTEyMTY1MTIzMDQxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAgAsAAAAADAAMAAAApaUj6nL7Q+jnLTai7PevPsPhuJIYsEZlA2KqgoLuwccy3Rd3gHA5jcA7Il0wKLwQywadcwTJKkMNpurX1Q5pTKs1+sv+6J1x+QoLcwqq8nnBGwN7+Jm77idd0SI7/C5vs5X5veHEmhWOOi255XF9ASI1ej4CIknmVgFidmR1OJi5WkzKSMwSlq6qZJ6ytrq+gobKzurUQAAIfkEBRQAAgAsAAAAADAAMAAAApCUj6nL7Q+jnLTai7PevPsPhuJIZkFQPueaLuuLtgYMywJdpzit4wDwKvl+wN3uAiMqjcwJTblkGiNPaFSKUyWt3C4xy6h6x1aea0tOQ4Pnl/r9ZYXRcDK77a7b5Q2x/nrXR1eGZQbh91M4JYGoCOZE53iiIRZIUsXX0mQz88h5k/N5YClaanqKmqq6ytq6UAAAOw==", "img-arrow-small-gif"), "img-award-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAKIEAAD/zv/QAP///wAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxOTNBRDQwRkVBNDAxMUVGOUEzMUMwREIwREMxNDhGRiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxOTNBRDQxMEVBNDAxMUVGOUEzMUMwREIwREMxNDhGRiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE5M0FENDBERUE0MDExRUY5QTMxQzBEQjBEQzE0OEZGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE5M0FENDBFRUE0MDExRUY5QTMxQzBEQjBEQzE0OEZGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQABAAsAAAAADAAMAAAA/9Iutz+MMpJq7046827/9sgjkNIjtV5NqijrtILEyojzw8p7LW8nDseCaILCm+oolEwzI2WR1IgIDsaW6xnNDqYTl9MJdamRXa932p5rFgPuGd0GigMsmmielgql6useyVkb25xfX10eYGDhG+Bh2gikWt2IoN6I5BefHN6e5dMlYaInFSKoUegV5KaKpunq4JtsEd+ZyMAmZ1QY1qxk5K4uqaOS720e68qALmsxJ7HjorDwrjNcZSpP9PSutYizHxF3JbbeeSs1szXypXa5o2it+qcbu+z5+jKA9fY9p9ZGhWr56rdHlEu8g0kOOwZoDt4usHxZ2icGyfdBJYi9cRFF0R7SRoCAyOECLoWG4ndAJhQIZYTIyPeiICE0bxys2RCxBeyZQ2TO+HJwtiEJs4YR40mBcG0qdOnUKNKnUq1qtWrExIAACH5BAkUAAQALAAAAAAwADAAAAP/SLrc/jDKSau9OOvNux4gyIWhRZ4DhpLTii5s48YPKgivcsLnje+1kM+3WxF6Q6LIQUoqZzbnrcQEPa2/U2B1HTyr3mxTPAiYkWQslae2CrXmc3PcTjHo4XQ5Hnc9szJ1XXyEW1FTXjRHbYOFhFyIYmxhWGKOl2hua3RXl30gn5U4iHaLeUMhnnKpq1Kbok+qKKGuS6a1e5ggAKCtTq+nsaGrALy5Qr+2yEmshqkhxb3OuGxKpKso0dLIlcCUmqDQxrvjtD+kpXjfe+LkzXikgevXzgPF2tuCgHfd6+zt77jVkfdNWD0SfJb1K6VDoL9QzeqR+iJvIr1VjxQOBGMNSp2sZVnicYyELldGdRSrdFxRiMuYfSPfpICDbYbIIIlywAECxRbOHA1d8JsJJEIRhkGL4jThE4IiD1CjSp1KtarVq1izat3KlUECADs=", "img-award-gif"), "img-challenge-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDAOttGsfHxwAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Mjc2QjBFQUVBNDAxMUVGODUzQTk0OUFGQ0MwRjE0NSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Mjc2QjBFQkVBNDAxMUVGODUzQTk0OUFGQ0MwRjE0NSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQyNzZCMEU4RUE0MDExRUY4NTNBOTQ5QUZDQzBGMTQ1IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQyNzZCMEU5RUE0MDExRUY4NTNBOTQ5QUZDQzBGMTQ1Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAwAsAAAAADAAMAAAAv+cj6nL7Q+jnLRaJ7KQuuvqfU9IQmRnnl5zBoGIZe78hkk7w6xM5+tA6rl0DI2QpuIdiYvO0Rd81jYjo68XEipRVeUUa4UKxKnwd2iejtEZTtroQZq5Eac8Lr5T3XM8e/23x+dl96cnOJFVqHZ4YZCUF4hogcMo6XjjV2iDmbkVxtl5oPkZKrpZOvbTiQqIt0I3CCVmlTSJ8PGaamlbhAPaGggQO/qbChwCoMykwkbbmqEszayxnBUI5OQhbX1bPQ29p8I93Nb0DS6z+pjMzYSL3r1eHN/dJUBuSo9PLt/VX86cJ3f8/PmKBpBYtoIdCAqEh9CaQwUN29nzVDAgw4cq+0hMhOiwmkJ2IhpeLBbyxA5BKjKlo6KvTkyV+zCNLCGK0rucPHv69FkAACH5BAkUAAMALAAAAAAwADAAAAL/nI+py+0Po5y02oup2FzMDnpPGEZkuZzoqHbJGcQxZ26yvA7gfdMQx8OBdMCgUMQSGI+75WxTUzoDpCkV+iteg01hz5eUXsVj25fsymqL3fIZq0ZXmbxh1PzsvOtpSbur94b0EQiolQdX0UInmEEUwsg0iAGJyAfm+CgWKJl50MSJOJkBenjiaSh36liqamZ30Sr46tLHQFOIV8bZ0qAyNgssCovwK7xLK9UBAGBrsLgGgyzAzIz5zGFduaupvFzdnIhNDd4K1wIeLq6Z3ltM0n79+V1NkgISLz+/ka6+vk+unDOA/erpo5dvHcJwAsUh5GcQ08KHDiFqs+jvHcYQMBcnZeu4EcxHkKsInmg4ryEUewpO0RMJERaxFzKz9VERS2GObqM8dbvX0+c4oUILAAA7", "img-challenge-gif"), "img-cloud-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDAP/uANzc3AAAAP///yH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkYyRDc4OTIzMjMzQTExRUY4RjE5RjQ0M0VDNEJFOUNCIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkYyRDc4OTI0MjMzQTExRUY4RjE5RjQ0M0VDNEJFOUNCIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RjJENzg5MjEyMzNBMTFFRjhGMTlGNDQzRUM0QkU5Q0IiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RjJENzg5MjIyMzNBMTFFRjhGMTlGNDQzRUM0QkU5Q0IiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4B//79/Pv6+fj39vX08/Lx8O/u7ezr6uno5+bl5OPi4eDf3t3c29rZ2NfW1dTT0tHQz87NzMvKycjHxsXEw8LBwL++vby7urm4t7a1tLOysbCvrq2sq6qpqKempaSjoqGgn56dnJuamZiXlpWUk5KRkI+OjYyLiomIh4aFhIOCgYB/fn18e3p5eHd2dXRzcnFwb25tbGtqaWhnZmVkY2JhYF9eXVxbWllYV1ZVVFNSUVBPTk1MS0pJSEdGRURDQkFAPz49PDs6OTg3NjU0MzIxMC8uLSwrKikoJyYlJCMiISAfHh0cGxoZGBcWFRQTEhEQDw4NDAsKCQgHBgUEAwIBAAAh+QQJFAADACwAAAAAMAAwAAAC/5yPqcvtr4ScAtpFs977Ig6GlGeIJkhKwcq27ttm0AbXtuycZz09+q9a9XJAHWvYmNiWMcpRQgwymU4hNFIUWaXIQ3ZXDXRLX214PNBMYWox9+oNs6lV5TZhX0qfz2B+/Ldn5RLo91bxcfiyl+emcgZHJtA02dRHqASJGFe5ZcL2WIgnaLQYejja6SkA0Ooqt+XYCUgq4Xr7augYe5eoSoHbagugZifqKztMzLo8nLEL7ZiazAwM3FxpjIpsKDzhfftrOBuZVpsb7E3JO4JMGay8vA6N1ugY/u0tnj2OpbqFr1otfgT9YcqH69kleuXM7QOykIPBZKvqaCOIw509XjqW2GnAIAhUyHntGGwUqadflDUn+2Q0OdIUnY8+Yq5xWTIKh5vUNs0oE4KEQ6A0hSYRYTSp0qVMjRYAACH5BAUUAAMALAAAAAAwADAAAAL/nI+py+0Po5y0KoGz3rzb0YUiZ43mKHXByrbuu2rRSQuv/NQ6FmPQrusJFiGY8cYREoEbWDKQuTBNLI0SMT1VM9dD8+gUCW1QH5YLhqatZV47wS6HXW7huGtA2+nkvR8dddbn19NS9+cW6HXYZlint8emmMfYRoVkI2m2ODg2EpYJuEnJuAFwihq3FZo4CgLZhiqbWsqjOSTYZzoLgHGaJEo2+Wq72yvwm5HMFYxHzKp87Cu9XCzcisvZOR3N2+t4HQ4HO+0te9j8lsuHPNtOCx7pSsx+Xi4d34gjiEn7rtpsGCl29/zpCTjv2aodq+wIVGjJ061wErOtU0VIXrh9NevkYFqDjaM2kJ0+ipRSCQnJDTlgzQET4kfKNJhYyswiogJOFBR2xvzA4ATQoUSLGj2KFEEBADs=", "img-cloud-gif"), "img-coin-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDAMWMCvHKBQAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxRjcxOTIzOTA0QjMxMUYwQTJDOEI0NTRDREE1NEVEMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxRjcxOTIzQTA0QjMxMUYwQTJDOEI0NTRDREE1NEVEMiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjFGNzE5MjM3MDRCMzExRjBBMkM4QjQ1NENEQTU0RUQyIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjFGNzE5MjM4MDRCMzExRjBBMkM4QjQ1NENEQTU0RUQyIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAwAsAAAAADAAMAAAAv+cj6nL7Q+jnLTai7PenIkPhl+XiOYZcui6ZuwXxHLAVicNz7puTuYOnIFiIskvGBQRUxAl8BWSMR3RHdQpHVGrvGtOCNp+u0NyOatdYM3J9VTBtcbZ6DD8/FzXwe8DPn/EV2dXMoZ0g4RTVGiYGAgIQOj3l6jYWBeZNilQCcjZ9pEpcHepN4cpSvppxuIpAJCqKgflKjoq6/o4+NpncGq56hgCa6t2qldLLImg+8tKXGw8RzkLYru8iVxpAnvSgNK5NKy86LEizA1dLs3rlQ4d/W197dUdet10bw8F35KvL6ofQHI9IpwIqA5gDSPuGtpo+EIFRGwkKlq8iDFjxgIAIfkECRQAAwAsAAAAADAAMAAAAv+cj6nL7Q+jnLTai7NuovcteeJIfmCJpualdkErWmhA1/aNUvPN92NY6uE8vN9jJ6yJfJ7jKFlcRleMJxQ2FTikSRhR2eS4oC/vmGZUfK9rMLccVp+7bdubtKgz9fSYXEAG99YXh8CXdWiXZjjHZkVIdZC4l1iS1xhIImT5BzjkSbnZAVAoqTfoBqo4WmraqPmpmkoaafCY+gW7KgBAq9WJ6YXo+5ugi4uENkJ8eSsYFOvhWwWtjInI2Qw7+cy6aKwS2M3b+82IFU1S7ic2SmzmHs9OLf3u1Uv7HrG8roKPn2Mfv3z/fBW0V0ygiHUH6wHEU8HfQ28BZcBTceIiRBAL5zBy/AgypEiOBQAAOw==", "img-coin-gif"), "img-connection-loading-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDAAO+AHOJ2gAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NDZCOUY0MUVBMTYxMUVGQjM4MzhFQjY5NUE1QUM2MCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NDZCOUY0MkVBMTYxMUVGQjM4MzhFQjY5NUE1QUM2MCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg0NkI5RjNGRUExNjExRUZCMzgzOEVCNjk1QTVBQzYwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg0NkI5RjQwRUExNjExRUZCMzgzOEVCNjk1QTVBQzYwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAwAsAAAAADAAMAAAAtGcj6nL7Q+jnLTai7MWvPvvaQhIliFmpiqVBu4LvysExvYdg3SNk3jweXxgqpLttPAQi8WlgNGRkYRG6VMRdQVZPCAHy7FeL7wOWKA1H5jfROnsbQ/YunV9dKeb7HI8svvzFvE39JNzx5VlGKiW6NQkVqGoN9k4GJbWl6Qk5Rg3RoXplbg1M5elGXrCxIckQchqgEhW+DhmiaLICCoii2li1esHidtLmSqydYZszHsmfOkKrSo9vTll7VDpnI132N2wDQ4lOL5cbN7Knc7e7k5RAAAh+QQJFAADACwAAAAAMAAwAAAC2pyPqcvtD6OctNqLs958iA+GosiN5jle6MqCERvE8jy3zkjnum425h47AQOkhYjWEuZCilAtCX0KEiAZCrJ6Uj/WIkVJnB6qQdcYiviF09zw5wxlsr0errwe7xlScLl6eLX3NmeGM4Sk51PohPgnNShBVhbVZfbS5nZHKFkW2UanyAn5cFLBuHbpZdOnSWqJtwr7anHEY9lKy2k7WiJaO9kh+IkyKdaRB6rB15S8McvMGyw9TW26XG1Uip0tAOD9vA3iPR4d/jH+bbw9R15unri+6R7fHG9/n1AAACH5BAkUAAMALAAAAAAwADAAAALbnI+py+0Po5y02ouzFrz772kISJYhZqYqlQbuC78rBMb2HYN0jZN48Hl8YKqS7bTwEIvFpYDRkZGERulTEXUFWTwgB8uxXi+8DligNR+Y30Tp7G0P2Lp1fXSnm+xyPLL78xbxN/STc8eVZRiolujUJFahqDfZOBiW1pekJOUYN0aF6ZW4NTOXpRl6wsSHJEHIaoBI9gFge7t1CorScev7aykiy2Frgpu6wVaMnEwp7ObqxywyPbz7DJWLvTO7vTnl7dC7fB2OB1xubn2crr6nnq0Nf1Y9b3+PX1EAACH5BAkUAAMALAAAAAAwADAAAALcnI+py+0Po5y02ouz3nyID4aiyI3mOV7oyoIRG8TyPLfOSOe6bjbmHjsBA6SFiNYS5kKKUC0JfQoSIBkKsnpSP9YiRUmcHqpB1xiK+IXT3PDnDGWyvR6uvB7vGVJwuQkAGCgIeLX3Nmc2Mrg4ePLgF7KIwkiH9SGYh3lnKRCotyXSKMZJuOkT6Tn6+CmBCnDIeWfTZ3pjZphEC6viKgpbW9FLedvRq5iquoG6UrqrnAeMwddUWeJMfd2hvc0tPd3NUAhudNk8Tt6peY4tus5u7o5Y7c4aT2uPn69QAAAh+QQJFAADACwAAAAAMAAwAAAC0ZyPqcvtD6OctNqLsxa8++9pCEiWIWamKpUC7gu/KwTG9h2DdI2TOPB5fGCqku208BCLxaWA0ZGRhEbpUxF1BVk8IAfLsV4vvA5YoDUfmN9E6extD9i6dX10p5vscjyy+/MW8Tf0k3PHlWUYqJbo1CRWoag32TgYltaXpCTlGDdGhemVuDUzl6UZesLEhyRByGqASFb4OGaJosgIKiKLaWLV6weJ20uZKrJ1hmzMeyZ86QqtKj29OWXtUOmcjXfY3bANDiU4vlxs3sqdzt7uTlEAACH5BAkUAAMALAAAAAAwADAAAALUnI+py+0Po5y02ouz3nyID4aiyI3mOV7oyoIRC8TyPLfOSOe6bjbmHjsBAaSFiNYS5kKKUC0JfQoSIBkKsnpSP9YiRUmcHqpB1xiK+IXT3PDnDGWyvR6uvB7vGVJwuXp4tfc2Z4YzhKTnU+iE+Cc1KEFWFtVl9tLmdkcoWRbZRqfICflwUsG4dull06dJaom3CvtqccRj2UrLaTtaIlo72SH4iTIp1pEHqsHXlLwxy8wbLD1NbbpcbVSKnS1QuQ2N+L3VrSU+523OiiuemM7qDh9/UAAAOw==", "img-connection-loading-gif"), "img-connection-open-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAP9VAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpERjRERTc2MkVBMTgxMUVGQjU3Q0FDQzFCMzQ0OUJBMCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpERjRERTc2M0VBMTgxMUVGQjU3Q0FDQzFCMzQ0OUJBMCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkRGNERFNzYwRUExODExRUZCNTdDQUNDMUIzNDQ5QkEwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkRGNERFNzYxRUExODExRUZCNTdDQUNDMUIzNDQ5QkEwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAgAsAAAAADAAMAAAAtGUj6nL7Q+jnLTai7MOvPvvaQhIliFmpiqVAu4LvysExvYdg3SNkzjweXxgqpLttPAQi8VlgNGRkYRG6VMRdQVZPCAHy7FeL7wOOKA1H5jfROnsbQvYunV9dKeb7HI8svvzFvE39JNzx5VlGKiW6NQkVqGoN9k4GJbWl6Qk5Rg3RoXplbg1M5elGXrCxIckQchqgEhW+DhmiaLICCoii2li1esHidtLmSqydYZszHsmfOkKrSo9vTll7VDpnI132N2wDQ4lOL5cbN7Knc7e7k5RAAAh+QQJFAACACwAAAAAMAAwAAAC1JSPqcvtD6OctNqLs95chA+GosiN5jle6MqCEQvE8jy3zkjnum425h47AQGkhYjWEuZCilAtCX0GEiAZCrJ6Uj/WIkVJnB6qQdcYiviF09zw5wxlsr0errwe7xlScLl6eLX3NmeGM4Sk51PohPgnNShBVhbVZfbS5nZHKFkW2UanyAn5cFLBuHbpZdOnSWqJtwr7anHEY9lKy2k7WiJaO9kh+IkyKdaRB6rB15S8McvMGyw9TW26XG1Uip0dULkNjfi91a0lPudtzoornpjO6g4ff1AAADs=", "img-connection-open-gif"), "img-connection-paused-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAAO+AAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmViYzgzMDYyNywgMjAyNS8wMi8xNy0yMDo0MTozOCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRTE5RTA5NDI4MTUxMUYwOENGOEIxMjc0Q0U3MERBQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRTE5RTA5NTI4MTUxMUYwOENGOEIxMjc0Q0U3MERBQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBFMTlFMDkyMjgxNTExRjA4Q0Y4QjEyNzRDRTcwREFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBFMTlFMDkzMjgxNTExRjA4Q0Y4QjEyNzRDRTcwREFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAgAsAAAAADAAMAAAAuyUj6nL7Q+jnLTai7MOvPvvaQhIliFmpiqVAu4LvysExvYdg3SNkzjweXxgqpLttPAQi8VlgNGRkYRG6VMRdQVZPCAHy7FeL7wOOKA1H5jfROnsbQvYunV9dKeb7HI8svvzFvE39JNzx5VlGKiW6NQkVqGoN9k4GJbWl6Qk5Rg3RoXplbg1M5elGXrCxIckQchqgEhW+DhmiaLICCoii2li1esHidtLmSqydYZszHsmfOnqKydNi6gzKyk4bRbF/Cpq6f00voG2hJd2qp5RCfpLfv4dfS0fz94+W16eXL0fNk8YNmXQNqmpVtBCAQAh+QQJFAACACwAAAAAMAAwAAAC8pSPqcvtD6OctNqLs95chA+GosiN5jle6MqCEQvE8jy3zkjnum425h47AQGkhYjWEuZCilAtCX0GEiAZCrJ6Uj/WIkVJnB6qQdcYiviF09zw5wxlsr0errwe7xlScLl6eLX3NmeGM4Sk51PohPgnNShBVhbVZfbS5nZHKFkW2UanyAn5cFLBuHbpZdOnSWqJtwr7anHEY9lKy2k7WiJaO9kh+IkyKdaRB6rB15S8McvMG5xrjCd9Q9JsuizsYhf9VXrWOayM+UpOjqE7ih7QqY75Ljjujgpf78ZGL68SPr+WLkMiYQCzgXuWYpu1TdwWaigAADs=", "img-connection-paused-gif"), "img-connection-secure-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAAO+AAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQzRFMzQ0MUYwNjIxMUVGQUJFMEU4QThEMDQ1NzY3MiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQzRFMzQ0MkYwNjIxMUVGQUJFMEU4QThEMDQ1NzY3MiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBDNEUzNDNGRjA2MjExRUZBQkUwRThBOEQwNDU3NjcyIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBDNEUzNDQwRjA2MjExRUZBQkUwRThBOEQwNDU3NjcyIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAgAsAAAAADAAMAAAAuiUj6nL7Q+jnLTai7MOvPvvaQhIliFmpiqVAu4LvysExvYdg3SNkzjweXxgqpLttPAQi8VlgNGRkYRG6VMRdQVZPCAHy7FeL7wOOKA1H5jfROnsbQvYunV9dKeb7HI8svvzFvE39JNzx5VlGKiW6NQkVqGoN9k4GJbWl6Qk5Rg3RoXplbg1M5elGXrCxIckQchqgEhW+DhmiaLICCoii2li1esHidtLmSqydYbcKsl75jDr7NqgxHyJqMl5raoMixaXCx5+WkVOe+iLVlvsSV6Z+Tydp0stTm1tn6E8rC9c7e8fFYEEDRQAACH5BAkUAAIALAAAAAAwADAAAALtlI+py+0Po5y02ouz3lyED4aiyI3mOV7oyoIRC8TyPLfOSOe6bjbmHjsBAaSFiNYS5kKKUC0JfQYSIBkKsnpSP9YiRUmcHqpB1xiK+IXT3PDnDGWyvR6uvB7vGVJwuXp4tfc2Z4YzhKTnU+iE+Cc1KEFWFtVl9tLmdkcoWRbZRqfICflwUsG4dull06dJaom3CvtqccRj2UrLaTtaIlo72SH4iTIp1pEHqsHXlNz3xcsMzWocjDVc7RlglZEY2oURKDwHrIJ5SyIpnYoonDlMbYrZiVdMzm0+mK6duRF+yt8LVLhjuISpw6YIIbYCADs=", "img-connection-secure-gif"), "img-connection-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAAO+AAAAAP///wAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmI3YzY0Y2NmOSwgMjAyNC8wNy8xNi0xMjozOTowNCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI2LjAgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjFDRkVGNDhGOUI2OTExRUY5NDQyRkJFMDQyMEQwNkJEIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjFDRkVGNDkwOUI2OTExRUY5NDQyRkJFMDQyMEQwNkJEIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MUNGRUY0OEQ5QjY5MTFFRjk0NDJGQkUwNDIwRDA2QkQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MUNGRUY0OEU5QjY5MTFFRjk0NDJGQkUwNDIwRDA2QkQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4B//79/Pv6+fj39vX08/Lx8O/u7ezr6uno5+bl5OPi4eDf3t3c29rZ2NfW1dTT0tHQz87NzMvKycjHxsXEw8LBwL++vby7urm4t7a1tLOysbCvrq2sq6qpqKempaSjoqGgn56dnJuamZiXlpWUk5KRkI+OjYyLiomIh4aFhIOCgYB/fn18e3p5eHd2dXRzcnFwb25tbGtqaWhnZmVkY2JhYF9eXVxbWllYV1ZVVFNSUVBPTk1MS0pJSEdGRURDQkFAPz49PDs6OTg3NjU0MzIxMC8uLSwrKikoJyYlJCMiISAfHh0cGxoZGBcWFRQTEhEQDw4NDAsKCQgHBgUEAwIBAAAh+QQJFAACACwAAAAAMAAwAAAC0ZSPqcvtD6OctNqLsw68++9pCEiWIWamKpUC7gu/KwTG9h2DdI2TOPB5fGCqku208BCLxWWA0ZGRhEbpUxF1BVk8IAfLsV4vvA44oDUfmN9E6extC9i6dX10p5vscjyy+/MW8Tf0k3PHlWUYqJbo1CRWoag32TgYltaXpCTlGDdGhemVuDUzl6UZesLEhyRByGqASFb4OGaJosgIKiKLaWLV6weJ20uZKrJ1hmzMeyZ86QqtKj29OWXtUOmcjXfY3bANDiU4vlxs3sqdzt7uTlEAACH5BAkUAAIALAAAAAAwADAAAALUlI+py+0Po5y02ouz3lyED4aiyI3mOV7oyoIRC8TyPLfOSOe6bjbmHjsBAaSFiNYS5kKKUC0JfQYSIBkKsnpSP9YiRUmcHqpB1xiK+IXT3PDnDGWyvR6uvB7vGVJwuXp4tfc2Z4YzhKTnU+iE+Cc1KEFWFtVl9tLmdkcoWRbZRqfICflwUsG4dull06dJaom3CvtqccRj2UrLaTtaIlo72SH4iTIp1pEHqsHXlLwxy8wbLD1NbbpcbVSKnR1QuQ2N+L3VrSU+523OiiuemM7qDh9/UAAAOw==", "img-connection-gif"), "img-crosshair-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhGAAYAIABAAAAAP///yH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkU1NzZBRjAwMjAwOTExRUY4NzMzQzE2Njk3MUU1MDg5IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkU1NzZBRjAxMjAwOTExRUY4NzMzQzE2Njk3MUU1MDg5Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RTU3NkFFRkUyMDA5MTFFRjg3MzNDMTY2OTcxRTUwODkiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RTU3NkFFRkYyMDA5MTFFRjg3MzNDMTY2OTcxRTUwODkiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4B//79/Pv6+fj39vX08/Lx8O/u7ezr6uno5+bl5OPi4eDf3t3c29rZ2NfW1dTT0tHQz87NzMvKycjHxsXEw8LBwL++vby7urm4t7a1tLOysbCvrq2sq6qpqKempaSjoqGgn56dnJuamZiXlpWUk5KRkI+OjYyLiomIh4aFhIOCgYB/fn18e3p5eHd2dXRzcnFwb25tbGtqaWhnZmVkY2JhYF9eXVxbWllYV1ZVVFNSUVBPTk1MS0pJSEdGRURDQkFAPz49PDs6OTg3NjU0MzIxMC8uLSwrKikoJyYlJCMiISAfHh0cGxoZGBcWFRQTEhEQDw4NDAsKCQgHBgUEAwIBAAAh+QQJFAABACwAAAAAGAAYAAACSoyPAZDtuJ6Ei01Xc71667kZ0RFilniiT6mkremOVCOj7pvUrY7v3Q8MCjOkGHFGMdJ4OuZthyw+jz3biiijXoUXqbYrBV/F5EYBACH5BAUUAAEALAAAAAAYABgAAAJHjI+pu8CvgINU0ifzvEb7DX2OVlndlmHmiaTNGsAx2NKyfMBkXYv+PvsJbSAgK6KjzRjJBC63uimhqaiLOeScPlpeF/kNGwoAOw==", "img-crosshair-gif"), "img-disabled-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAP8AAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NjgwRDQ5NUVBNDAxMUVGQTBFQkNDQjM1MjgyM0Q0MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NjgwRDQ5NkVBNDAxMUVGQTBFQkNDQjM1MjgyM0Q0MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjU2ODBENDkzRUE0MDExRUZBMEVCQ0NCMzUyODIzRDQxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU2ODBENDk0RUE0MDExRUZBMEVCQ0NCMzUyODIzRDQxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAgAsAAAAADAAMAAAAtCUj6nL7Q+jnLTai7PevPcABlIobiQInSGmrk1LUvC5zHEEAwB9tHqbUul+PN8Q6DgNlzTh8nh7hZ7MGbWKSiqvuSvRJd1SnVzewzieepFnNDawNuPc3qfqQq/v5Bay/m4iFhel4ZdGmGF4WMKhWJZVKPgHlkjyaIdYIQkFh0kps7mn9oa32cUJOWF6iso4Z/mWxxc2+rWy+knb2VqiOFtTK0rpm6sgCIhg+JsshswMK5yqy2asRD293GPjGuSMLT3iPf0BTutxjp6uvs7eXlEAACH5BAUUAAIALAAAAAAwADAAAALJlI+py+0Po5y02ouz3rzzAIZSGGwkCZ0lpqJMu1qwm8zxZNNCDlIwAFAZWsCgzvEr8gJFoyhCbDqj0mNDJVVSmyfcKQskgac9r3gMGpNlXzVYyG67tVbzeQ7PbN/dDxbd1/HH9yQ4mBVossdVFxcyR3ZzceiW55iGiMlYWEEZdkdX5iO3CRppZxr5WCqJ5GmTyemamkPY+nIoRBqKyvRJs/srOrtquWNqfMVTI9fSm7x0mYiQw+KsnHyZMu2xPdwNHi4+Tl5uvlAAADs=", "img-disabled-gif"), "img-discord-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDAP///wAAAFhY8AAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5MjE5RThCOUNGNzAxMUVGQjk4REFDREU2MTE2NkRDNCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MjE5RThCQUNGNzAxMUVGQjk4REFDREU2MTE2NkRDNCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjkyMTlFOEI3Q0Y3MDExRUZCOThEQUNERTYxMTY2REM0IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjkyMTlFOEI4Q0Y3MDExRUZCOThEQUNERTYxMTY2REM0Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAwAsAAAAADAAMAAAAvOcj6nL7Q+jnLTai7PevNsAhmIgjWFpjk9qrqzovjAjz0ut0qLA87YS6gkFrRtoSMSZkL4T8IhULplJUmJHzWqZTkRwCwb/sOEytzv4ClPb6XAM7b20rLct3gwA9gB1NLRHVgVi4FfFF4i3BoJoOOOoh5hIxSip+HhZyWcoF9kYYEeYlunZp7ioyemkWpc1F1p42krnhhoLenZqlnu768s7ivs7XNVLPLyqy1m2nCyMqusq2Gk1PRj9t1wc/EwtVQvLTfk9Ii0qnvvd1gW+7aBddMCWZ/X+JWNUg4Kj8zLBHyMHBRYeCho8iDChwoUMGzo0UAAAIfkECRQAAwAsAAAAADAAMAAAAuycj6nL7Q+jnLTai7PevNcAhiIIjWZkpk6qNiy7vG0cCvZtyyLOi8zOy+mAQUHoVysSg0nlMbEsSqfOgKJJzWp9h6j2y3wOvCaw18iNvqisMGmMFQHmWPfIbliG5nwQO8AHUJcWBxgoGPB36IdDmNgIEljXY0jHeONIGYl4WVUG+TbZlpWCB/eoOTl1hmZ1igoWW5WnKiv7xGprFlqr+4Xb60v6duokjDZLC4vZudvc6lpstyxVqglFDT1knYqdrb39LBTddRZ+Z4rwCVoi3oqkJ+ayPS8jQQ//MmGPwuXxDzCgwIEECxo8iBBgAQA7", "img-discord-gif"), "img-dna-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAKIEAFhY8LcA/////wAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2RTI0REI4QUVBNDAxMUVGQkM5RDk4M0VEMjc0MzVDOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2RTI0REI4QkVBNDAxMUVGQkM5RDk4M0VEMjc0MzVDOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjZFMjREQjg4RUE0MDExRUZCQzlEOTgzRUQyNzQzNUM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjZFMjREQjg5RUE0MDExRUZCQzlEOTgzRUQyNzQzNUM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQABAAsAAAAADAAMAAAA/9Iutz+MMoJh72Wao173mDjjUNojkEaYCboqfDVbphas/NUr2SZ6xeeRdD5AS2pi2BZNFaQSSWx6WTsosMpbiGbXYVZD3cbCto6S61s1DJjMekeoFuGgtFMD2D/qQ/OPnhqA3t8Pn6AgXgYhXOHR190PYSNfU89gFYklZYik3ZCBHKNjo+aHZx/iSOkhp0Keq1um62uprCMtaUxF7qFVGO9pb8dvBa6Yg6MeiTGqcmex5/Fq5OXrnk4V9NH2HHas2wclN7ZinZ0daRS5riqoW3HtgPfa+iv45Qj9dTwJ9P8QKXzYw+OuXf+4lkStG1gFVFwIjl82CzRw0sS8V2E6OYezkZlHT1+jAZD5MhTxjR+vAHs5CloLkGSiUmzpokEACH5BAkUAAQALAAAAAAwADAAAAP/SLrc/jDKCYe9NOvLuf5OJ2IgOAZo4JVbl74kS3Hpha6yRKtjnFc23kAg+k2CQgGxYwRaYBbl0tdU7IQXJbO6QGKzUwvX+rz1tCtcCdmLhkcyNqaDbg9YcjGB/h4AAFQZV2kcdX5/gQ9tNTF0HH+AehF2A1AkbZCJZJSVZpyHiJIMmKFlnnaQkaKbj6mlnaetrqp3o7KztJa4rmp7jx2vgxe7mVStn6ZCxEVdw7SfjBbFPQ3HblsusZQh0qVSW76mn06pYG+s0cw63c/fhLBCa8Mj7nPJmut29dmeeEwi+7zgy1crHBgRL+KNAfjGUkEuAK/0G9Osh0OK1filw5jRHgsWjraSxQJZMeGXhxwlqiPJiSQ3ai5fgotJs2aGBAA7", "img-dna-gif"), "img-drop-pink-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAKIEAPaD8oUAmeAA5AAAAP///wAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAzIDc5Ljk2OTBhODdmYywgMjAyNS8wMy8wNi0yMDo1MDoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI2LjEwIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRjdCNTI0RjkzMzMxMUYwOTNCNzgyN0VGRTUzRkMwMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRjdCNTI1MDkzMzMxMUYwOTNCNzgyN0VGRTUzRkMwMyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBGN0I1MjREOTMzMzExRjA5M0I3ODI3RUZFNTNGQzAzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBGN0I1MjRFOTMzMzExRjA5M0I3ODI3RUZFNTNGQzAzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQABAAsAAAAADAAMAAAA9VIutz+MMpJq6Vj3G1z5mDkaWHJjGZKjKTKsa17wbGMwXZH5xVd8w7fBwgZCVjEB0tw9CSDHmbT+VQsmcjqKiqd/ngsAECaTY7EYjKVGEar1+CzG4tie9Dp9zDXntPhMnJ+el8lfWNdf3suh4mENoJ5jmUqkY5ddYx3g4kBlIaWlwKemSahogGki6AZeKJMqaWsAwKSqKqFG0avXbGAIbu8sLiaGcLDxJVcwqnJKcGvzc6mIwG30rLA1dLc3NnaHt3in7Pb3TuBQuq54Ovk6e6rQO5aVQkAIfkECRQABAAsAAAAADAAMAAAA+lIutz+MMq5xqA4O2u1p1z3jU8okqjJoal6sZ97wpk801MomDhmCrtQL8cBBldDyA+oSpaKxuPNSdBFm1SFCQC4CrNVDpfrRVJD466Rd0aTo9JX0v0uT2l0NZw9zMOZXz1bY39xcnhihIVxfYl1f3wwg49wAZEtjnp/loEsk4tAnGaemaACAaJ3GpOam6mHI36mqKmSpbOonbFFlIW0ujFQpka/o7sWw8TFqjXCw7S1pMjJ0NGYA8mny8w+zovVl8EhAd/gwB4qqJXVr7DHFuzxWLbj8bkugi7m+I02Nm3+5gH0B+aJwA8JAAA7", "img-drop-pink-gif"), "img-drop-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAKIEAIPQ9gBImQCf5AAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBMTg4MjFEREQ2QTExMUVGQkYxM0RDOEQyMUQ1RUI5RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBMTg4MjFERUQ2QTExMUVGQkYxM0RDOEQyMUQ1RUI5RCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkExODgyMURCRDZBMTExRUZCRjEzREM4RDIxRDVFQjlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkExODgyMURDRDZBMTExRUZCRjEzREM4RDIxRDVFQjlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQABAAsAAAAADAAMAAAA9VIutz+MMpJq6Vj3G1z5mDkaWHJjGZKjKTKsa17wbGMwXZH5xVd8w7fBwgZCVjEB0tw9CSDHmbT+VQsmcjqKiqd/ngsAECaTY7EYjKVGEar1+CzG4tie9Dp9zDXntPhMnJ+el8lfWNdf3suh4mENoJ5jmUqkY5ddYx3g4kBlIaWlwKemSahogGki6AZeKJMqaWsAwKSqKqFG0avXbGAIbu8sLiaGcLDxJVcwqnJKcGvzc6mIwG30rLA1dLc3NnaHt3in7Pb3TuBQuq54Ovk6e6rQO5aVQkAIfkECRQABAAsAAAAADAAMAAAA+lIutz+MMq5xqA4O2u1p1z3jU8okqjJoal6sZ97wpk801MomDhmCrtQL8cBBldDyA+oSpaKxuPNSdBFm1SFCQC4CrNVDpfrRVJD466Rd0aTo9JX0v0uT2l0NZw9zMOZXz1bY39xcnhihIVxfYl1f3wwg49wAZEtjnp/loEsk4tAnGaemaACAaJ3GpOam6mHI36mqKmSpbOonbFFlIW0ujFQpka/o7sWw8TFqjXCw7S1pMjJ0NGYA8mny8w+zovVl8EhAd/gwB4qqJXVr7DHFuzxWLbj8bkugi7m+I02Nm3+5gH0B+aJwA8JAAA7", "img-drop-gif"), "img-enabled-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAAPBAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NTYyQ0QxNEVBNDAxMUVGODE5MENDQzhERUY5MUFDNCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NTYyQ0QxNUVBNDAxMUVGODE5MENDQzhERUY5MUFDNCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg1NjJDRDEyRUE0MDExRUY4MTkwQ0NDOERFRjkxQUM0IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg1NjJDRDEzRUE0MDExRUY4MTkwQ0NDOERFRjkxQUM0Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAgAsAAAAADAAMAAAAsOUj6nL7Q+jnLTai7PeJgSueR5oiSM5mSIaqSvruCbMuMBMIzJwv7lg4/FwOZVQSGQFj8MTzMg8+kDLaPODglqRzkZyUbV+E65YmDlVyLBg7TZNXrN1Zyn8IO923OL73nSlVxc4pyZiNzXY4/cX0HcyWGbm8TjCxzVmeBiVV6lXA8i55lk4SYm2g6pCcZaKmfkQJitZchlKWFox6/j6eaG4yFh7qyr8a7tK4xqcS5Ka/NPoCB0tTV0NRIutud3t/Q0OUwAAIfkEBRQAAgAsAAAAADAAMAAAArWUj6nL7Q+jnLTai7PevPsdhMFXiSMpmSf6qCHruC+8yCKduICKGyoA3N1wv6BwyNIZjyuScmlKFqFR59Tois0iTypSkYV0vducrHUllw+2tVm0DJ7BOh4dHme6fVc725Sn1/SGB+QnkCZ3eBcSZzdmuMiYx5MoOFhTqJYYJgZIKeMo2QAZ+Yk1qnWKqnl5Ubo6h1G62UFr+gViKesx1okSKtjTVjVM3IPQhpy5t+z8DB0tzVIAADs=", "img-enabled-gif"), "img-floppy-drive-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAKIEAMfHx1hY8P///wAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5NkI2MzAwMkVBNDAxMUVGODY3MUExN0FEMjIzM0NGQiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5NkI2MzAwM0VBNDAxMUVGODY3MUExN0FEMjIzM0NGQiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjk2QjYzMDAwRUE0MDExRUY4NjcxQTE3QUQyMjMzQ0ZCIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjk2QjYzMDAxRUE0MDExRUY4NjcxQTE3QUQyMjMzQ0ZCIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQABAAsAAAAADAAMAAAA/9Iutz+MMpJq724js27/2CmgGRJYmaqXmpbWl0QdEBt1xzOzZ+2ybzN7ZYDxIIdyk5GG+oGzwEQOVD+mEVn8YhNSpZI5zMqBfYi4KYWSp5Sv9eweOhxvyHp7Lxt9z7yLh92XVV/cVSBZX0ceIeJdYNBjYqEgZFdk5eam1OMhpScoW6eDmCip5ifqKuSqqOPh50bmbKwpqmljraQhLSVu4p+DaYdAsbHyMnGvMIMxBvK0cpczQvPA8kf0tSkw7rYyyrH3LOuXeHi6MHdzt/qJuOAhbmUHOrx9sjk89710NIABezzFSQgwIHmkOgjkU0ewWL4tC2MU22EPHACGUZcV44h3hUP+AIeOfMJWCA0Jl1YSWkCBTARMGPKnEmzps2bExIAACH5BAkUAAQALAAAAAAwADAAAAP/SLrc/jDKSWsdOOvNs4VdKGpfM55iqaAsV2pBoAF0DWR0FncWLOO2HEY42LkumNhvGLwxdcrjBLpsCmtUI2ma1Fqd2K5y6ZFQZ81nNrqNnIFfp3hMxrjF6LiPrrWD8HlWe3xkd0V9LYeEhX+KdSyLfYZjiWt0bQ6WkZuEmCZznKGXZQ+aoqGeDKanm6kLmpWRriuglRt8swRZthyjfqVzvL1sv5nBGQLJysvMAoO5uxjN08zRxZ+OyNTb1gOTxMki093fWuEtzsfXqurnLOnZpMbxA9Ti5I2U0tv26t754PiN81duSbMQy/ABo5dQnDKF8/TVe+jQncR/CyU21DZQJtEGQ104CqQY8mMjhCNJpjgprAWFlolUwAyhoqbNmzhz6tzJk0ICADs=", "img-floppy-drive-gif"), "img-fullscreen-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAOttGgAAAP///wAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkM1QTUyQUNFMkU2NTExRUZBRjM2QTJBMTI1RDA0M0U3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkM1QTUyQUNGMkU2NTExRUZBRjM2QTJBMTI1RDA0M0U3Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QzVBNTJBQ0MyRTY1MTFFRkFGMzZBMkExMjVEMDQzRTciIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QzVBNTJBQ0QyRTY1MTFFRkFGMzZBMkExMjVEMDQzRTciLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4B//79/Pv6+fj39vX08/Lx8O/u7ezr6uno5+bl5OPi4eDf3t3c29rZ2NfW1dTT0tHQz87NzMvKycjHxsXEw8LBwL++vby7urm4t7a1tLOysbCvrq2sq6qpqKempaSjoqGgn56dnJuamZiXlpWUk5KRkI+OjYyLiomIh4aFhIOCgYB/fn18e3p5eHd2dXRzcnFwb25tbGtqaWhnZmVkY2JhYF9eXVxbWllYV1ZVVFNSUVBPTk1MS0pJSEdGRURDQkFAPz49PDs6OTg3NjU0MzIxMC8uLSwrKikoJyYlJCMiISAfHh0cGxoZGBcWFRQTEhEQDw4NDAsKCQgHBgUEAwIBAAAh+QQJFAACACwAAAAAMAAwAAACrZSPqcvtD6OctNqLs9ah+y154ggq44kG5ZG23+qOACCuQjvneQ17+q/j9TrAn9AmKu5eNkNSeUT6oEzpFBgtyZbLTvP2pD2znHDMeo2ptNtZDVWpgq9uJinuZYXreX0/xNMmJue0RhETRIaB2PUH4pLo+DhFd9e0FynJFkBFuMmJpThJFOr52ak5Ctr5NbeK+oVZJHohO3hyqQaXq9vql+K7kBpMXGx8jJysfFwAACH5BAUUAAIALAAAAAAwADAAAAKzlI+py+0Po5y02otr2DxbDoIeFJbduJggwJ7ooW7sDLivSuc2aua0+DKsfLrdKET8bYIIZLK2ZMKGPqBUyEkag85q9EqFBmbbY5a8KnvCsQD43Gozu+Kolce23idfLLzuduNCFzInQri31qakdrGI1ujYw9gnKANVFCl56aW5qZVoOdZZachJGXglEJaZajr6FKp4Cuoq+hTnyUebayIF16a7G1z66quqoIK8zNzs/AwNXQAAOw==", "img-fullscreen-gif"), "img-grid_cur-png": /* @__PURE__ */ __name(() => "data:text/plain;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABoUlEQVRYhe1ZSQ7DIAy0q/z/y+6hSkSJtzEgUqlzqhpsxisOYRGhIjxBriqNcIDrs9YJLSKNEL6RZf7m1EXLIj0UmVe0wNTMd93afx2iCIURzHq4nOiWjtY4pI4yHg5TAZHV5AF9qofrbUP3FKrPLdjewzNC70LzZjUllpMFIGTwMYsOyStPZuBgIlLSgxuF148K2dkQESaFcLkP74JKeDCMS2F6+KmkW8K3xN1F2spfou+iu9Z7yqyCzBhX6CI3AS0l9reID1QeVg5DpKve9ZZbD7y2tsPTHO0b9eGlpLvIpPaKCJsz7AKkWtLU8XICzr33jpeFyJg8pkxrlSkt0VlSB4dYBFbDMCB1cGxB1kn/aW013HuJlvTqvM46qCd8jnVDm6DGZQuOCL8MhAkUX0yh4Wf3eFkbfoo5G05bo7LlPqyENUUUyVcNqw4OxMtQRA5KdgURecQFi9kltNA94TA5iMyrfyYiCT4LnDBd30ZmhsEsc9yGfsuIZE1k25qndCSxYdlXIxT1Qe3ZiCElQ8+iywqjm0xvK48Z4LP4uXn4DcalnWAUAAtmAAAAAElFTkSuQmCC", "img-grid_cur-png"), "img-inspect-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhGAAYAIABAAAAAP///yH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkQzNDgxODNEMjAwQTExRUZBMTU5RjY2MzMwMzJGQzMyIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkQzNDgxODNFMjAwQTExRUZBMTU5RjY2MzMwMzJGQzMyIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RDM0ODE4M0IyMDBBMTFFRkExNTlGNjYzMzAzMkZDMzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RDM0ODE4M0MyMDBBMTFFRkExNTlGNjYzMzAzMkZDMzIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4B//79/Pv6+fj39vX08/Lx8O/u7ezr6uno5+bl5OPi4eDf3t3c29rZ2NfW1dTT0tHQz87NzMvKycjHxsXEw8LBwL++vby7urm4t7a1tLOysbCvrq2sq6qpqKempaSjoqGgn56dnJuamZiXlpWUk5KRkI+OjYyLiomIh4aFhIOCgYB/fn18e3p5eHd2dXRzcnFwb25tbGtqaWhnZmVkY2JhYF9eXVxbWllYV1ZVVFNSUVBPTk1MS0pJSEdGRURDQkFAPz49PDs6OTg3NjU0MzIxMC8uLSwrKikoJyYlJCMiISAfHh0cGxoZGBcWFRQTEhEQDw4NDAsKCQgHBgUEAwIBAAAh+QQJFAABACwAAAAAGAAYAAACO4yPqcvtCWJ8S1p6rJ70Zu5IFTgCjcig5WmG7fiQkIyo653ahj5rO9/bAGsoX2x4pGE8GKJy+YQ2p9MCACH5BAUUAAEALAAAAAAYABgAAAI7jI+py+0PE5gURFOzhfnU9ykTOC6UUzKpuakt+yInGnsrLN55F4SNpiGVeMLLzijRXXzInnJZa0qniwIAOw==", "img-inspect-gif"), "img-letter-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDANHR0f///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBODk3REMxNEVBNDAxMUVGQkY3MTk3NTg3RjJGQjU0MCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBODk3REMxNUVBNDAxMUVGQkY3MTk3NTg3RjJGQjU0MCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkE4OTdEQzEyRUE0MDExRUZCRjcxOTc1ODdGMkZCNTQwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkE4OTdEQzEzRUE0MDExRUZCRjcxOTc1ODdGMkZCNTQwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAwAsAAAAADAAMAAAAuCcj6nL7Q+jnLTai7PevPsPhiInlOaJpuoZre4LN/BMs4oa5PrO9726SPmGxJ8tgSsqjUfEagkNAG8lACpaPFlLwSpgW8L6tOCu4Pu9inOoNJd6RoPD2DbaZJa7T1D7/Y3kpTcnoESmhwc3+Gcy5IcI6CS4qLbzCCmQt8hIx3ZIGXlgsrnHt0KaGBgHWjMplyq5ill1ermn+fr4OTcIK+qaQto7mpupyCkrXCzoa0DMq7wZXKZoGz171jxweq28YrbbLZ0C7iqO2qTauo4iw/6u/QvfOlJvf4+fr7/P349fAAAh+QQJFAADACwAAAAAMAAwAAAC3pyPqcvtD6OctNqLs968+w+G4iaU5ommagqt7gs38EyfDBrk+s73fo664X7EIkuhKip5q8VquXQ5SwDACUpEWU1TQXVrwjJPXy6SWr6KA9q0oPutqrFtNzwOFtDJeHPChCc391MX54cAGJin51PYV3KnOLTj+Ph25qUoGKajogkWGZjEtqJ5eJAoSrMoCYmpSla6iWbo+kc7i+vIV3t5m+mG+xlsGVo5PNt7l4L8yXtqAHjcHJwJPSBL7Rxri8isjdyEmQo+rCJUky6Ort7uy+5OMzJPX29/j5+vv39fAAA7", "img-letter-gif"), "img-light-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDALCwsP/zFwAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBQ0M1MEExMzdFQkIxMUVGQTY5MEFENjlFQzhBNkEwNCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBQ0M1MEExNDdFQkIxMUVGQTY5MEFENjlFQzhBNkEwNCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkFDQzUwQTExN0VCQjExRUZBNjkwQUQ2OUVDOEE2QTA0IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkFDQzUwQTEyN0VCQjExRUZBNjkwQUQ2OUVDOEE2QTA0Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAwAsAAAAADAAMAAAAuGcj6nL7Q+jnLTai5XYvOfZheHniOZIIufqpSwXxLFInvKNo5iJ9zK9C/mGAWBFSCTqKJ2ks3WEOZVQkPR2TVYlTaxIy7Egi6vhNjJmmcPRa7fbO0OQcLLAt+S+N15+XF5C5zeT9QPI8GXXN7goYCX0cpeT9xCZOEkZaAl2iLgBYIO50iYAADpm90JaavpluSEWYnr62ukpMlsLG8tBy+pr4tLrm2skPNwx65uSkFz8a8v7+dzKxnyQPH0KfK3Sq/3s2I09PVxtPZ5dnsks+2k8PvAar6FKX39y38Cu3++fUgAAIfkECRQAAwAsAAAAADAAMAAAAtqcj6nL7Q+jnLTai5HYvIsseaIHMuNJlge6BQGqDqdLu6cq1jo9lvkOFIE6wKKtkyEajUiMcllsWp7QnbRCrdauFOpoyQ1xeLMo5/JEFWXn6fg4flvDkbRg2wrSHx44PK8j1NXHcje3Z1L4E5gyoZhF1lj3aKgnCUHJ1OOoWDOAJ8jZ+fLo1gGAShkqNoIKoPphyvG64UpbmORxK+B6E6ObWmt7mStyO4woezob3BbDZiy8+6zRKkyMM3va60wNzXu8u+G9sly76q1KnlC6zs7ivgATT19vf69QAAA7", "img-light-gif"), "img-line-dash-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAIABAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDQUEyMURDRUVBNDAxMUVGQUY1OUJGRjA1QTVDMTI0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDQUEyMURDRkVBNDAxMUVGQUY1OUJGRjA1QTVDMTI0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkNBQTIxRENDRUE0MDExRUZBRjU5QkZGMDVBNUMxMjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkNBQTIxRENERUE0MDExRUZBRjU5QkZGMDVBNUMxMjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAQAsAAAAADAAMAAAAnaMj6nL7Q+jnLTai7PeF/jvcRNIfuJTpqeTkoi5Gi14uPFb1vadhPrOa6iCLCBxkTsKaUqGsfnzQXHMaaBlvWKzQ+7TKs2Ke2Fw0nyebtVd9vfYdlfRMHEcupbP9XXtW9M20wcIJDi4EWZ4GKNYppQ3Fik5GVMAACH5BAUUAAEALAAAAAAwADAAAAJ9jI+py+0Po5y02ouz3hr4z03fSIYOiYJICmBsur7Xi8ayRatH3prQ7XuwgpIa8Tc6RkrKE7O5MEIVsGmiarXpsgYpt5v8XnvZrTjg/WK5Q/Xa+i4/3eFzml2358V3+X5pJtLWAERBQ8XjUsjjkbGY2JEGudFIOHiGmakJVQAAOw==", "img-line-dash-gif"), "img-line-dot-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAIABAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMEQzNjJCNEVBNDAxMUVGQjI4NzhCNURBRkFBOERFNyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMEQzNjJCNUVBNDAxMUVGQjI4NzhCNURBRkFBOERFNyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUwRDM2MkIyRUE0MDExRUZCMjg3OEI1REFGQUE4REU3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUwRDM2MkIzRUE0MDExRUZCMjg3OEI1REFGQUE4REU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAQAsAAAAADAAMAAAAmuMj6nL7Q+jnLQigIHdKmcOBh4WcqNWWme6jd3HMvDlxtKJ2hCuR3y/8wCHxKLxWDsmfsoDsylaQQ1SopBGKlanW2i3+QXPpmTqlfwUh7Vp5Ro5Lsvnvrg3ycXfz+i4Xs0HaAf35xZIh2hRAAAh+QQFFAABACwAAAAAMAAwAAACeYyPqcvtD6OctNobgda4hw16FxgmpWiSHKKiKamogMvC70l/2yLnk+2T7ILEogNn5AGTtyGzuXrWllIDleZUzoit6kG29YK93y65R7Yiz9G0u9xmr59o+ZxZt4fd8fd0rwdYVXeH1ZXngzZWBLRo1OY4aKbnV2lJUwAAOw==", "img-line-dot-gif"), "img-line-grid-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAIABAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGMkJCQkRFQkVBNDAxMUVGQTY2REY3QUMwRDE1RjA4MCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGMkJCQkRFQ0VBNDAxMUVGQTY2REY3QUMwRDE1RjA4MCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkYyQkJCREU5RUE0MDExRUZBNjZERjdBQzBEMTVGMDgwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkYyQkJCREVBRUE0MDExRUZBNjZERjdBQzBEMTVGMDgwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAQAsAAAAADAAMAAAApmMj6nL7Q+jnLTai7PevPsAhMBHiSIpmSEaqaNzfi4cezOjWrexK3nlCtZ8Jp3wOPyVkEzhpQlFTqJUJbDafFqxK2Nx8Qtieghrx1z+ytQJMgfNg2vk7mkWLIdUiewl16n1R9UiOHhVKHbYFccVuMh3NNeXNnQ2eZA3dsn4aFlJ+UKSt5lRx4liCvK5kUpauprGIjtLW2tLUQAAIfkEBRQAAQAsAAAAADAAMAAAApGMj6nL7Q+jnLTai7PevHsDhMBHiSIpmaFzfurKqK7c0N1bmyQe69gLtAWEpaDxSGQhl8Yi89maQKeWKXPDWyQ1WcU28x2GL+Eup+zzmBHjKjp6+64rVFD6Z0WS83o3P4j3N+ckeHZndxQHl9DmB6N1aLjIFok1Sfk4k+l1abnJ2MkVKvYZB1GKkqq6ytrqSlIAADs=", "img-line-grid-gif"), "img-line-mandala-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAIABAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMzhFRjAwRUVBNDExMUVGODQ1QkY0RTQ2NkVDODhEMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowMzhFRjAwRkVBNDExMUVGODQ1QkY0RTQ2NkVDODhEMyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAzOEVGMDBDRUE0MTExRUY4NDVCRjRFNDY2RUM4OEQzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAzOEVGMDBERUE0MTExRUY4NDVCRjRFNDY2RUM4OEQzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAQAsAAAAADAAMAAAAqmMj6nL7Q+jnLTai7PevPs/ASJIiSYpmScKqWPkcnHjzpqN1Lq85vp/6xl+REDGVjQGasHXEnfYYVRR6kJqQQoVzIvWSduGhFZHuXQ+M9SpspbLbqWt6ric3JuL7+CnU69UAfXk82f3cFiVtwfDWBg42NYHtzg5ZtflF+gViZPItwX1CZqUMIqYVHdqlrqp6DpVtLZ6aTmUyTIbmftqy6v4Gyw8TFxsPFwAACH5BAUUAAEALAAAAAAwADAAAAKrjI+py+0Po5y02ouz3hd4jnkiaIkjSZkfOqkAK7lwrD5uHZrNzXf6wgv6ToigsPQ79Iq4SjNwYzxbSeg0cYU8s0wi1ctVVmlgr3Qc2ZqBaG21jV2nk81V154q28fh3ZtYB2fD9yIGKOjQJ2OAmIgYKDcXaUU36dYWxWh5iae52Md5uEhZqGE0Sgpyatb4dXRXyvEat4kUywY6Q1o7k6nryKsb/EtcbHyMTFIAADs=", "img-line-mandala-gif"), "img-line-noise-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAIABAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxOTdCQjFGNEVBNDExMUVGQTJDNThFNzA5RjhGRjYwMSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxOTdCQjFGNUVBNDExMUVGQTJDNThFNzA5RjhGRjYwMSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE5N0JCMUYyRUE0MTExRUZBMkM1OEU3MDlGOEZGNjAxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE5N0JCMUYzRUE0MTExRUZBMkM1OEU3MDlGOEZGNjAxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAQAsAAAAADAAMAAAAnqMj6nL7Q+jnLTai7OGoINdeWIHPuNJlgnKfmrQsmosvzDt2WusN2cPDO6EnBEj1asdRMHWMtd0Mok3HtVAu2JxV662ivpmu1aiceuinr9PKBuNfK/l7jcYURdOwWm9ex4VBwgUB1coNqj1Y8d3SJaotmgH+choeZlRAAAh+QQFFAABACwAAAAAMAAwAAACeIyPqcvtD6OctNqLs94cgv91EkiColGmaoitrqu9chnP62mfjar3vmjq0RhDYGpxxN0OPJ0s0BTaWD9orsp8YRPPLULrRYG3V+wxWUVbAV51WBx8Z0nyb7GOprbjUTMb3rcH89YVVkg4KLdUt0bHCPj3KDlJWXlSAAA7", "img-line-noise-gif"), "img-line-parallel-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAIABAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyQTM1MzU2NUVBNDExMUVGOTNCMkM3OTdGMTIzRDE3OCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyQTM1MzU2NkVBNDExMUVGOTNCMkM3OTdGMTIzRDE3OCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJBMzUzNTYzRUE0MTExRUY5M0IyQzc5N0YxMjNEMTc4IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJBMzUzNTY0RUE0MTExRUY5M0IyQzc5N0YxMjNEMTc4Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAQAsAAAAADAAMAAAApGMj6nL7Q+jnLTai7PeFvgPcBNIfqJTpuaZqK7HHq8bM3NYP2oOpbxeOu0WQc6tRRLdcLKk8YgobpZRZ4zWBPGGBunV6/1qs+OajwzbWgNhVrgtXMOV8rW5zJ4/V2jmHX/2x9cV6IaXV0h3CDVlh4jVePiYiDH3ojhYRXmxqekX6fjTF6oGKUrIdTqqytrqGlEAACH5BAUUAAEALAAAAAAwADAAAAKWjI+py+0Po5y02ouzBLz7rznfSAKhUqbeiagum7gpLMomXc94PmZkVLq8eKuK7fGj2G6MoPLYSD5l0Z5GVS2GdCjtidsC0ZwxL0sa7uzIB+vY3Ra/4QH6mW7/otEwfn6L9+cTKDdnxqdXWAcGaLbIdqVowBjp+Gg5iIlYqbYgKETZiYO1k7VZOgmJmia52sXkGis7W1EAADs=", "img-line-parallel-gif"), "img-line-rainbow-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAKIEAFzJO/rlTNs0JAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNkZFM0Q1NkVBNDExMUVGOTE5MTk1RkQ2OEM3N0IzRCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNkZFM0Q1N0VBNDExMUVGOTE5MTk1RkQ2OEM3N0IzRCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM2RkUzRDU0RUE0MTExRUY5MTkxOTVGRDY4Qzc3QjNEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM2RkUzRDU1RUE0MTExRUY5MTkxOTVGRDY4Qzc3QjNEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQABAAsAAAAADAAMAAAA/RIutz+MMpJq7046827t0MojuT3kGgamoTqpt8rzHQ9i51q7za+pbwgzYcBCo9EEOlYCzifziQFxRRAr9GVcnTEegPSCJX3/Y4qS3LZrJ2kbesAYE6nhx1vWrnOr98bXHBefYRzfwt5VliFfDBigXpXjAAvbSciglCFlWePIZlOhJwlEJCRoX2jhwqmik+pjhqYTZqNpByttX63uLMzuna8vQOgtp0xn6eowatFyb/AKCymwJTHyM+ucruW2JnG3R6+0NvM4TnZruAsiOmv5gPsrOPvhtcm1MvWzRmmItznxKm6h28gv34G48lbyLChw4cQHyQAACH5BAUUAAQALAAAAAAwADAAAAP/SLrc/jDKSau9OOvNu49DOBBiaZafcq4surVwq8WiYN+4YGJx7v+iy+pHJAYrp6LSd5wkl7eAdBrANUEmJXXLlV4fT193vP06sjmymmpmhG1rKmBOp7cX6Ki6zuffSSViY32EdiFYIYJchYwAd3lwXY0sjodgNTiSfTQ7lwOKU5ucnQ2BmXKio4+YeqF+pGcusYmnUqmWHqaRroayHboCW6+4H8DCvSMpKrStAcPJyqy7znW+xczT1X8v2MG2yNDR3byVxOKftdrmKcbfc9bs0uTbHO3U5eHKgNi88PH832Dps/fO378SUwbgyzdQFcNznPRBiCjRE4uKGDNqhJAAADs=", "img-line-rainbow-gif"), "img-line-random-color-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAKIEANs0JPrlTFzJOwAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0NjM4NUIzMkVFRDAxMUVGOTZGRDlDODk1MDYzQ0JDRCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0NjM4NUIzM0VFRDAxMUVGOTZGRDlDODk1MDYzQ0JDRCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2Mzg1QjMwRUVEMDExRUY5NkZEOUM4OTUwNjNDQkNEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQ2Mzg1QjMxRUVEMDExRUY5NkZEOUM4OTUwNjNDQkNEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQABAAsAAAAADAAMAAAA/9Iutz+MMpJq704683f+F34jUO4kaR5oaw6sR8Auw4M3PdM23gvoy6Wb5gDcoTDEbGVQfpIxJ+R4kwql8xX9XnlZiOwbtSrk4Sh4yJKIBhRR4FAOApjs93aT1x+xoXtdyB5e4RndYCBJYOEhYYDiIB4ZnpxcI1riCN2kmCUfAOMlSSZo22Ck6CiqXyqj6Sapoqoe5a1sJG3nBCWoby3uK6xb6uMvh+QyLoevKGXyJDKNbbEzs/Aw6nM1aWvFdPNn4nHwLKzvZ6wmJvR0p606OPc4uWd2sbBySkWLI3v+K+n9vE7928ePYEoCAIMeCJhNYM7HJYqE9GRPhoMLLLD6AgOY54pHvOEHEmypMkJCQAAIfkEBRQABAAsAAAAADAAMAAAA/9Iutz+MMpJq704683f+EMngqSIkehnVmm7Ri0guy+TyjjQhmuc/7uODwf66VKbG7BoDFqUTWYUSRkuP1OaZIc1ermgKnjgJbYE6PAEFGhzczu0XKDeftru8XmeVq3veHh6H3xzdTCAgXlxhXyHEGyKgXuNhn52AwEkkpoklY6XiJmbnCCVnnShkHekkqaNqI8eiYqRr4WxqrOZpYC3oANysg62icXBn5Y8mJ3GvoTJwrrErJGu0NGpy6LNvNfI2qfTDdacgtiowGLe5ovS2H3D5OXn1eDp2vI2KLVsv7glnvCrNwqeMn2iWtUDGDBJin7g8iEUOLDZu4kZHnbTUoMVwCCMI8Z0/MNx5KqGJlOqXMmyZYcEADs=", "img-line-random-color-gif"), "img-line-sculpt-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAIABAAcHBwAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0NDNFODk1QUVBNDExMUVGQkY1NkVDQ0I5QjNDMjEzRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0NDNFODk1QkVBNDExMUVGQkY1NkVDQ0I5QjNDMjEzRSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ0M0U4OTU4RUE0MTExRUZCRjU2RUNDQjlCM0MyMTNFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQ0M0U4OTU5RUE0MTExRUZCRjU2RUNDQjlCM0MyMTNFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAQAsAAAAADAAMAAAAnWMj6nL7Q+jnLTai7PeFXiOeSJoiSNJmScaqSYLuS/MyDOt2B+e63zv+x10O6GBCDAOkcojselEymhSG6xqJWGz2u2t6y2Cwt8NeWU+izXqdabtvsCT4zb4jFKz9HsyNYzj97fFA/izNgW1VKYYENcIGSkJUgAAIfkEBRQAAQAsAAAAADAAMAAAAnKMj6nL7Q+jnLTaizMFXGveeRcIihZZmhvKqg8Luw3cyguN2gqe6wdP8v2AKR+xqDuGjEqhoekMKGmuKdVkjdmySBUXkORuxbIvuGpGf73ms6jt9sDVZGyavaZny3m+lfknNBXFUEO4E3R4s6TY6Pj4WAAAOw==", "img-line-sculpt-gif"), "img-line-tilt-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAIABAAcHBwAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NDE5Njg4Q0VBNDExMUVGOUVCQTlDOTNBNkFGREFBNCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NDE5Njg4REVBNDExMUVGOUVCQTlDOTNBNkFGREFBNCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjU0MTk2ODhBRUE0MTExRUY5RUJBOUM5M0E2QUZEQUE0IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU0MTk2ODhCRUE0MTExRUY5RUJBOUM5M0E2QUZEQUE0Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAQAsAAAAADAAMAAAApyMj6nL7Q+jnLTai7PevPsPhuJIlubZAADKqG6qiu67zGtLS/at2Pis2/1iNSFkx0MYe0tH84Ac5mDAoo/5xFa1U2iWm0x8kWFr17sVf7nUcyB6vIKlxIecbXbPpfRy3v+WprSmJoimRzh4p1hXaPhHFxm3aLCWePhoSfnnB+fY6DQm+sgHaRqxGUiaShUKWsgSKztLW2t7i5srUgAAIfkEBRQAAQAsAAAAADAAMAAAAqOMj6nL7Q+jnLTai7PevPsPhuIIlGNUpueTmowbtnDSxjKwyOCNK/c7Q/18tVxRqCMeaUsHr8dsGoYQnlE6TbKsUSx1q0V8xeHGU+kdA8tZdkB9Tbvf864KfbdDnVzyHI4X1Jant7fG1qeHJMdIaAYHCFh4KEiHFVdp6XggqYhpyHn5SUkJ+rg5mNlpV9o6gRqaqSm7oll7i5uru8vb6/sLPFEAADs=", "img-line-tilt-gif"), "img-lock-restricted-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDAA//M2lqagAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NDM5RDdBN0VBNDExMUVGQkNEMkJFRkVFMDBCNjUxMiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2NDM5RDdBOEVBNDExMUVGQkNEMkJFRkVFMDBCNjUxMiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY0MzlEN0E1RUE0MTExRUZCQ0QyQkVGRUUwMEI2NTEyIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY0MzlEN0E2RUE0MTExRUZCQ0QyQkVGRUUwMEI2NTEyIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAwAsAAAAADAAMAAAAv+cj6nL7Q+jnLRCgbOwVvuPcQ5IfqJSptp5fMELx7B5evJ9r3UWp7Le4c1Ugl6IoxkSi6+MKNkEDkDRYwUqTWCdQUx10xAGuFfvd2QeWyliMqO9nsDB4bRbbo+j8nQ2/zGH9Fc3WMbkQWiWBbjUiBjhGHmXKNl44YKTiUODJqa5uTW55/mpZKOmN8pUapQBEMi42grqCvC6KqqVZiqLKmALXEj4g+kLbAvb2fp7W6Rx3Iybqitbi+xxfFp1WY2R/RwMpcRN7H3NfL67HZtjjR7du67cbh5O2sodb5yufxbbX6LUIlUAi9HKRU3dMoEDF5BglYlTvkopulAk8eTiIxYGHDt6dFAAACH5BAkUAAMALAAAAAAwADAAAAL/nI+py+0Po5y0PoGztlx7z0nfmIUOiWLmMgbu634r8sH2C86a7d3buoOReKVQEJdCFi0ZYaoZW1KOAdmgFlUxodUfLeidYpRaxVE64YbN42yn3S2z4GgRXT4XKN969+kuwLf31xcnGIf3BVUX8eQ4IvYoycgwaZnYgHWzuWl1QcXpA7ZWyRUq2oMY+Al36qRJytYax6kBcAu4SkhkmiVwi1sYm2Da4vsLXIxJnBus5wEMcEapqBT9cU01XE2WjBEtDbp90GuLC576qps5iwge3uvb2O7uHC8PAXqc3kmtWMiLX79lzO4dc5WDlUFX6tYppIeQRJpLkrZQhATkor8ZBhw7ejRQAAA7", "img-lock-restricted-gif"), "img-lock-unrestricted-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDAP8ABGlqagAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3QUVGRjNGRUVBNDExMUVGOTlCRkY0Q0RFODg0NTY1NCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo3QUVGRjNGRkVBNDExMUVGOTlCRkY0Q0RFODg0NTY1NCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjdBRUZGM0ZDRUE0MTExRUY5OUJGRjRDREU4ODQ1NjU0IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjdBRUZGM0ZERUE0MTExRUY5OUJGRjRDREU4ODQ1NjU0Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAwAsAAAAADAAMAAAAv+cj6nL7Q+jnLRCgbOwVvuPcQ5IfqJSptp5fMELx7B5evJ9r3UWp7Le4c1Ugl6IoxkSi6+MKNkEDkDRYwUqTWCdQV5Wi1EiS6NwdQx6CAPc7rTNWMNZEbmVXjez7/iyft4Xt8WntmToIXGoCCi4qHjhgiOJQ+OnVwWFeYlYuKYpRGJEiOJZBQBAcorKJNZJmaHqEXu5t+H6ijEroMt6dpujEau62uvrNyk7TFxcC8ksujucKeo8WRutK8kI9owpfDpt3FCqhA0LXrqNQH7Na06r3pJ+vkxvN8pdfJ6UfG9r2SvUJzOVAEKjdY0VJ2c2rCFbyNBRii4SSTypCDGQxo0DJwoAACH5BAkUAAMALAAAAAAwADAAAAL+nI+py+0Po5y0PoGztlx7z0nfmIUOiWLmMgbu634r8sH2C86a7d3buoOReKVQEJdCFi0ZYaoZW1KOAdmgFlUxgzkaVzp5Mo5gEeqEUXY2v3E6u9Ze5ax3lT6DQO+CfNhe5lcHFaj3dGhlhrhYOMjI+Ed1M0nUhraXZZep2XUpUEnWooTnWAkA0KRxSmXppsl3iuoRu/o5amjrhBGryovZOjjZK0sryYdLOeyLmYmcvFtszNd38apLK2vdXJ1rWrvcvX0pDJ0tEN0NHOxtnrF8ixvuvjMbSlqqa98Dz/2KtZlOnYJ/WZ4FbDRwHyWDieI9OrTlIQkdEgUKuojRRAEAOw==", "img-lock-unrestricted-gif"), "img-mask-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAOMAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowODlFQjYwRkUyODMxMUVGOEJGMTlBRTFDMzk3ODVCNyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowODlFQjYxMEUyODMxMUVGOEJGMTlBRTFDMzk3ODVCNyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA4OUVCNjBERTI4MzExRUY4QkYxOUFFMUMzOTc4NUI3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA4OUVCNjBFRTI4MzExRUY4QkYxOUFFMUMzOTc4NUI3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAgAsAAAAADAAMAAAAs6Uj6nL7Q+jnLTai7PevPsPhuJIlk8QIKiZoKvgpiwcG7FL3q/O12ffswGDjCFQaOSpkkcaCsCMAqE4ZwCAzWqpzK2XK7t9v8Ox9naImb289dlnfbrnZvTStdXVxXl7XI7VQ9b2VoWkFjiVZVT4cshmiLcYKZloh9iYBgimuWm5UznpGAqHmWk1qNdI2Aca+mkKGysaNgvmSft6ykfHS8d5eDWn+gv3Jzwm2Gt8/Irmm8scHDVNvSA1iu3YYF3dRKGkYDRDXm5+jp6uvs5SAAAh+QQJFAACACwAAAAAMAAwAAACxZSPqcvtD6OctNqLs968+w+G4kgGZkAyp3CuqdHGcinXtgnd+r4nPA/4zVjCU1AGOBaXxqQtCY1KlcCp82bNPrPTFrHF7cbC0hhsTIaC01fvucmOl81vk3g9R95xB7R626aXh9KH9weItUf4ZTdYd1gYoOVmeEiI5/I16VIZ+Bjop8hopWMZujdKWjMIp4giyCrnennKVas6BIh7G2XjszrbuEv3m1hlSrywVFf00Bz5I8GjPI2RTF3zor3N3e39DR4u3lAAADs=", "img-mask-gif"), "img-nochallenge-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDAFhY8MfHxwAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5Rjk2NjhBN0VBNDExMUVGOTY4MUQwQjkyNDQ4NUU3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5Rjk2NjhBOEVBNDExMUVGOTY4MUQwQjkyNDQ4NUU3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlGOTY2OEE1RUE0MTExRUY5NjgxRDBCOTI0NDg1RTcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlGOTY2OEE2RUE0MTExRUY5NjgxRDBCOTI0NDg1RTcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAwAsAAAAADAAMAAAAv+cj6nL7Q+jnLRaJ7KQuuvqfU9IQmRnnl5zBoGIZe78hkk7w6xM5+tA6rl0DI2QpuIdiYvO0Rd81jYjo68XEipRVeUUa4UKxKnwd2iejtEZTtroQZq5Eac8Lr5T3XM8e/23x+dl96cnOJFVqHZ4YZCUF4hogcMo6XjjV2iDmbkVxtl5oPkZKrpZOvbTiQqIt0I3CCVmlTSJ8PGaamlbhAPaGggQO/qbChwCoMykwkbbmqEszayxnBUI5OQhbX1bPQ29p8I93Nb0DS6z+pjMzYSL3r1eHN/dJUBuSo9PLt/VX86cJ3f8/PmKBpBYtoIdCAqEh9CaQwUN29nzVDAgw4cq+0hMhOiwmkJ2IhpeLBbyxA5BKjKlo6KvTkyV+zCNLCGK0rucPHv69FkAACH5BAkUAAMALAAAAAAwADAAAAL/nI+py+0Po5y02oup2FzMDnpPGEZkuZzoqHbJGcQxZ26yvA7gfdMQx8OBdMCgUMQSGI+75WxTUzoDpCkV+iteg01hz5eUXsVj25fsymqL3fIZq0ZXmbxh1PzsvOtpSbur94b0EQiolQdX0UInmEEUwsg0iAGJyAfm+CgWKJl50MSJOJkBenjiaSh36liqamZ30Sr46tLHQFOIV8bZ0qAyNgssCovwK7xLK9UBAGBrsLgGgyzAzIz5zGFduaupvFzdnIhNDd4K1wIeLq6Z3ltM0n79+V1NkgISLz+/ka6+vk+unDOA/erpo5dvHcJwAsUh5GcQ08KHDiFqs+jvHcYQMBcnZeu4EcxHkKsInmg4ryEUewpO0RMJERaxFzKz9VERS2GObqM8dbvX0+c4oUILAAA7", "img-nochallenge-gif"), "img-palantir-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAKIFAOrK/4g8BFgAk5BIwAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1RTI4MTIxREYwNkExMUVGQTBBRDk1RTM4QTY4QkVEMCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1RTI4MTIxRUYwNkExMUVGQTBBRDk1RTM4QTY4QkVEMCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFMjgxMjFCRjA2QTExRUZBMEFEOTVFMzhBNjhCRUQwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjVFMjgxMjFDRjA2QTExRUZBMEFEOTVFMzhBNjhCRUQwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQABQAsAAAAADAAMAAAA/9Yutz+MMpJq704Q8K7/1r1jSQXbmUKnovqriEpzPRg22r80bxw/4NSZtTjAY+jC7E4OzqDHsuO+azCIsti1dqhTKlVgBhpmkxvvbAYAIxKPDW00bke/7rvTlzefNbbZSh6ewOEdHY3bg9ffYU+W1yBDnBMjZBOipODYJdPmQ2UWnydiXiLm2l8j52fDKGpNrCQra4clUBzl6aCt7iWW7untpykd8Gaw73FOMegqJW/kQQiz42ymM3CyYTExpJmr6ux11C0gs8/0DNJGDJ70CRDL0wvSi/38dQcAQH4KvzfsHTgR9AfAYIIsznbh7Chw4cNFdY6CLGixX4BhV3c6FAgYosPHC9eETgiZMR8UkhszKHBYD0WLtmxWHhvpk0NCQAAIfkECRQABQAsAAAAADAAMAAAA/9Yutz+MMpJq7046827f0Qoip80nuhYKmnrEt47DvTboUKu03yfbiedoEcsojLBXXHJO15GwiFzOjg9RVGeklpTVbBRqZDbJFGgYVqWB2gvvSZwejBmtwFGc5wQ3m4Hd25EehFya1SBeTAThnVcd4pnIX1kXIQQjVKVU5cgjZtUnQ5of6CDIV+Tjqani4yqpUuxXaiSsHNEq2W1r7d9OVq6VaKefI6HdKVwtsbAwcfOu67MzbnIrdOptz2/mrS8FjjR3UJO2uLk5S3hMuQy2Zjv8iMBy4X0AfXzJ/n5xA34+vmTJ7DfPwYBCypcuPDggoQMIyq0Fw+iRIbm9ry4qG8U3bl98zSAfLeiwEh4JVOqXMlyQgIAOw==", "img-palantir-gif"), "img-palette-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDAP///99xJgAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpENTI3ODQ4NkUyODQxMUVGQTRCREZGRkQ3MkFFREFCNSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpENTI3ODQ4N0UyODQxMUVGQTRCREZGRkQ3MkFFREFCNSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQ1Mjc4NDg0RTI4NDExRUZBNEJERkZGRDcyQUVEQUI1IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQ1Mjc4NDg1RTI4NDExRUZBNEJERkZGRDcyQUVEQUI1Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAwAsAAAAADAAMAAAAv+cj6nL7Q+jVKLai3OdTftvcQdIfmKJZpwWtO4Lw2qUxfbtYlCN97LewfiGrxlF+KsQY8AEr/hcBpqjC9MjzYWclmQFALBexdoNAlkWgMHkKQtqriq9a/bcjYWf261LPXznZ3eHt0eYpjYI99dVZihwA7JY14gn8IjzMblWeSF3aFOJyBnoacBnCQqXZ4mJKBqq2bd12imb+TYbN0AmiJpF1ftFqkpExWubSJz1ylWqrOiVcvTMeJhi6gypq9yGTav9ipZK4uB92/q4uzDOyi2ivZ0WmQ2PDOtjBD9urD8R1U/DiV/5BK7gt8TgP4QJ60nI1dAhDYhD/D2U1MPiwW8SHuyp47jO4z2Ql0Qy4GgyJbwCACH5BAkUAAMALAAAAAAwADAAAAL/nI+py+0Po5y0PoGz1vbuD2adEpbhOJjByrJlB7byHIDUR+fzJ+H679pAfKsYsChsEGulI5OzWJowskwVStJcM4AuwBoEhzFZbUvj7YpDY0GZuhWkv3DVk5zY7Lhe7aZvlXSgt6eCBkglaEBYaHSoFoi1aEbDhoSBWCeCQJkjNXXnNti5VGmnyNikc7o5uqbq6SiZYvbY6dSWV4uZJoZ7ice5K9cL92ujC/ZIJ3CMnKwpwgg8FQzdHPpZ3fqGne27zR1FWsozMh3aiDLpe6RogQ70Dn8r/3xTb38fUep+gt/O2TwP+XDN4mfk151z/X4cBNjwzMAK4V6sE1ZR3EVXCdU2IjTnMeSEAgA7", "img-palette-gif"), "img-pipette_cur-png": /* @__PURE__ */ __name(() => "data:text/plain;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAE7mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDIgNzkuYjdjNjRjYywgMjAyNC8wNy8xNi0wNzo1OTo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI2LjAgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0xMS0yMVQwMTo0NDo1NSswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMTEtMjFUMDI6MDA6MzQrMDE6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMTEtMjFUMDI6MDA6MzQrMDE6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjE5ZGJlZGNkLTAwNTktZjg0My04YzFiLTA4ZGY1NjFjY2Y4OSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxOWRiZWRjZC0wMDU5LWY4NDMtOGMxYi0wOGRmNTYxY2NmODkiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoxOWRiZWRjZC0wMDU5LWY4NDMtOGMxYi0wOGRmNTYxY2NmODkiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjE5ZGJlZGNkLTAwNTktZjg0My04YzFiLTA4ZGY1NjFjY2Y4OSIgc3RFdnQ6d2hlbj0iMjAyNC0xMS0yMVQwMTo0NDo1NSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI2LjAgKFdpbmRvd3MpIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Po5YI9IAAAJHSURBVFiFzZk9bsMwDIXJIFfokrt07R5kzZ6pp+nUzNmKIDfo0it07dClS4deoIA6JHIomqR+TCt9gAHHf/r0/ETLDoYQ4MYqAcC4spwRxFKVS4h4Xb+Bw2KDFAoAQOJCRPR22Oo98v0cUtrHwRfNaGPlblUxrCUvYJdcrTdbWG+2eiMhBPdBpzlHby0/xoJExORcD4eL3NU6IsFaHXB1OJfL1txSeQ66kXKZtPZpcgXWanoLmKZuT7r1Zgun42FYlxT3U7HBih4OJ8GkDUgA0vbT8aAey+WeYT6wKAh1Nm63QKWIzTroJEnQVCGEYZHkMfkZLmCVLSm3HFhhQXrdKQ4HyMDmqgMve0qHk160AmdvC4e1BhaHNmdxjZEwZ14SrKZ4rBUPmokW4CpYqtLSBaAD10aiGXa/eq1sijRKqkbNky47AX95+FRPXu6+RhAlU1EutzpsTgl3byIQr7dW/Y1CqadxGznZdPf3+T75/fP+MazfPY2drdR1wCHqkaiFpZBRDrAjVc3WOsGas/wcsPok4zGgKoBtfvVIBh27sGoJheXuzgkLIDisfHEZ1ntnlkuLhNlSI+z0N1AoqMM8uxIslwU79c25qkp8P67E7dTdEtgp0Cow/+IiwdbEwOObBEDDWzOHjJors6OLKiM5RIctZ4wqkJzk5S7A2WGzImhzDUPuMUguHvyK5aygUUupgUsfEC7REPZRdQEd2pjgcFfQqNKyJhL1BI1awBmGLsW6xX98k1+RekO7fG7tCa06/A/+0hX1B0kNQenek4JbAAAAAElFTkSuQmCC", "img-pipette_cur-png"), "img-settings-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhLQAtAPEAAAAAAGlqagAAAAAAACH5BAkUAAIAIf4RQ3JlYXRlZCB3aXRoIEdJTVAAIf8LTkVUU0NBUEUyLjADAQAAACwAAAAALQAtAAAC15SPqQftvqKc4llIc7xce2QF4oh9WjiKD9iYi5OqKzO7xhNbrG5XTRwo0QDBVg+Wqt1+RaMLSXIOZdIPlJrAYW1aKmDZFVqvTU6yOmZGLzn0qbsmKz1soH3Nhd+B87d6z9dHodemdvFEVsghlkF4tug2mPi4mFZnd5i3uMeDCMkp2HgJWNbjM3kXKoqKyZhGqvh1lDipuhr712QKFjfq+ur1BWcrSbQFZnysSTR39Uv3IzYcCd2JHLeLLDuUXJp9muVMbKo3Tv5n/a0A+ax+muk+AR9P/1EAACH5BAkUAAIAIf4RQ3JlYXRlZCB3aXRoIEdJTVAALAAAAAAtAC0AAALVlI+pCO2wopzmWUjzvFf7ZAViYH3fM6aP6TnpuB4Oq6BvXJV0DrzkzOjQbDCgzGU0uVRJXhGjbNyaxKZm+WwcsdYM8cfBgodiMGcKjfZ8ZzRZ6ouj09evPN7dhO54XL3Ml0VHsScnJvQHKBg2GMR4x6gTEblmOMOhF8kneXIRKPgG9ynC2Sk6WtqiuJnntQqptSMA6Okmexg2dyuqyRT7Bjp7SvrLguJn10qICTKsvJxa9gxd7OTbaExXSFwtWyM9vZPs5/19Sl5uzphOjcguEfYuT1MAADs=", "img-settings-gif"), "img-status-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODdhMAAwAHcAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJFAAAACwAAAAAMAAwAIAAAAD///8Ca4SPqcvtD6OctNqLs968+w+GVECWgdiYKoke61ui8HyCNP3dd6frXL/TAH2YYa9oDFqSxBFTOXk2JVJopIpzYl/L7arrNYHDrApZbD6XteeLupYmZ9pI78bOe8qALQSsDxgoOEhYaHiIKFIAACH5BAkUAAAALAgACQAeACAAgAAAAP///wJAhI8Wy5sPQZssWoqdPbmHLXndJXpQWSZoiqxs6IpwbNKpjef6zvf+DwwKhzQF0OhrJZW7R++k2+BAyBeVk9kUAAA7", "img-status-gif"), "img-tasks-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAKIFAISEhIaGht7e3v///wAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQzQ3NzU0NjA0NkQxMUYwODVGNUI5REE3NDZFMUQyMCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQzQ3NzU0NzA0NkQxMUYwODVGNUI5REE3NDZFMUQyMCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBDNDc3NTQ0MDQ2RDExRjA4NUY1QjlEQTc0NkUxRDIwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBDNDc3NTQ1MDQ2RDExRjA4NUY1QjlEQTc0NkUxRDIwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQABQAsAAAAADAAMAAAA/9Yutz+MMpJq20ka6W7593FeGRpbiIZBCqrrSeRejDtZrV5dQLuCj3CzUcCoCo8ElCZzACMmZ1myaNmrIQg4XmkTIHgsHis5UaRX7JarDHL0Ne13Oq2pMPxeRn69ubBd2QDAx1mdlNxX39gg4RtUIdXSlgdjY5OkHCUWZsZlo+Zfpxao4KWl3WaemGnqHxwpautj10RVWyxjKe0ZxOBpGqzmLUQilm3Y8Jbr6JUWmoan7x9EsZ3JtLDvdWJgSW7mMy+ed6x4Muh47lzyk/p3Oty7YaquOvz77aLwMnn7sQPEI36BQRfvoCSEpbyYHCbvmMe8GAbBOqgA2t/rlzyRDFFnEUM5Ba1wgfw4p+RKLP9c1iMY8qXHdGVBEkAps02IeDYhKkD1s5GMWaaDEq0xIyiSFmqS1pUxIKeTqNKnUq1qtWrEhIAACH5BAkUAAUALAAAAAAwADAAAAP/WLrc/jDKR+q8ONatNi8e0XlZE55oSpagFwThe8opO8Munqt2jAsVmgBIoKFKHmLyNEzpRJllSLlpop7IKpVgrQyHg4Hvc0l+z2h0eGzBmNNw8HrXLmvPXnh4Xnzp3HddXGl7fH5/dl55gV2FG4dkElpMXyh7j36REGaUWx6GmXUad29njgSgRomDVnGFp32qE4xxAq+XmLKSebVft3yxiLuseMS/wJCim7yCgp/IoVDDRFSVltC6o1ydtrivOdnLg6Xdx2K5wtpdaubY6eK95cfg7xTM1nLm9Jr2xOtK89Dxc1Bl0qIQ3wQq6+eJ1TmE7gaaOPgGFqqICwnyqtjuSWEwiQwCVemIK1g9jf7ykUR3cqI/kgk/glxwB+atXCES2QxYY9XFncCO+PwJU8XMkEaTJs2itGnOHk6VspgVdarVq1izat2qNQEAOw==", "img-tasks-gif"), "img-themes-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDAClrnOLi4gAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCMDM1Qzc2QUVBNDExMUVGOTBDRUQ0Nzk3Q0E2QUZCRCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCMDM1Qzc2QkVBNDExMUVGOTBDRUQ0Nzk3Q0E2QUZCRCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkIwMzVDNzY4RUE0MTExRUY5MENFRDQ3OTdDQTZBRkJEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkIwMzVDNzY5RUE0MTExRUY5MENFRDQ3OTdDQTZBRkJEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAwAsAAAAADAAMAAAAt+cj6nL7Q+jnDSKi0Vt+bKebQqIjaQmIieqlinUmewLe4lL17OB507P2/k+woGNszoOZcnY0thMDqPUVxOAzTZFyawXG6WQApiveSvpBNZlszdDBlng7Iv7fFnHQz96XXD3haG3B9QySNgWCOCnx7fQ+Ae4GCkJiUhYSImZ+XgokOmoKFhZWKQWCvKG2ul5U0oFmurKJNu6EiqpRMSZCJJrustbCnxLi/RbPCtXgau8khJbZSV98lRtODX9xN1i0s0rAy7+WtRtmM1Ne3yNTrJkXe7k837JHj0/rr/PL1EAACH5BAkUAAMALAAAAAAwADAAAALMnI+py+0Po5xUiotrw3lxrjHf5Y2hYybfGYFqx0LwMcco+Qp2iyP1LtIpesCi8YhMKmmjprIJXQGjVOmpirVOsoCuN7ulesfkKu8TCGDIbAAmDb290/BLe8yh113DvF69duc2p5eSI/BHx3HnlwhIxHTh+BjYNTKp5UP4lzVJKVTSyBnlaRi6OSqaaBqE5vn6CbnRBJvK+lCFaVaR1Qsa4ktVFPwz1btkJGugjPRT3Cz7fOTMPB3Nl4S9fGuTuc0NDD4gzuuNfI6ejlAAADs=", "img-themes-gif"), "img-thumbsdown-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAPEBAAAAAHMLC7EPD3MLCyH5BAkUAAMAIf4RQ3JlYXRlZCB3aXRoIEdJTVAAIf8LTkVUU0NBUEUyLjADAQAAACwAAAAAMAAwAAAC/pyPqcvtD6OctNqLFdi898s13kgCUpmUqgetBynE8iywz1rSuhx8IjdT7YaCQG/jAOpGxKHRt1AuN83mE8mQVre0K1ZD5Yp53mx4LDYeTeAzeqsOtQHvdLkdqNuhr01eD7fGhsDxB2h1R+h3WBUn1wdgxEiktpbiZzg5U2mpGFmpSeY4aNDBqdaYqcP5WFro9akqirp52jqAs7hzysv6BbnitNbrSwqM5bErSAxb0bEqGGt7G/EMnWvjrBUDm5thvYn9C7LdmdFSbn6epJW4zk4XTv1+6eZOH2UviP8Tz73PL5++eQFxDRxX0FWkf+oSKpxmzKGpZg7njKhokQ/GBWMIHxQAACH5BAkUAAMAIf4RQ3JlYXRlZCB3aXRoIEdJTVAALAAAAAAwADAAAAL+nI+py+0Po5y02osR2Lz7yzXeSFIkoJ1qB62qAMeyMLauN+dywIqdfNIJBQFeiPHLJYfC4nHBYUqZzmciOs3mqijoRguOcZHfMHjsBZjDxk06sNairxt4fDpPAex3arurx9fX9KfAITg4U5RncJhIyAXYWIf4SLTYRrdXmYjJeOj56PlJObo4FCpmajXQgelRpGM6G6npwrlYStujt4L7tzlaYzi8tAN8IylhDBOZDMJ8maxcgXPMm+FTtoOdTbbdXOitrXbNOm57nIlObu7GnlYe3g1/gKV6Xt8KLv2ur8mH0b99e/D5GzhpU7+DCF3lYoiQ4EOIDU9EjEfPQQEAOw==", "img-thumbsdown-gif"), "img-thumbsup-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAPECAAAAADBzC0qxD0qxDyH5BAkUAAMAIf4RQ3JlYXRlZCB3aXRoIEdJTVAAIf8LTkVUU0NBUEUyLjADAQAAACwAAAAAMAAwAAAC/pyPqcvtD6OcoFowc7tce8R1n3YJ5jWSlWkGgZVSK+vCcWTRdXVDZbvD9Bw5HWq4mQGPSMVP4Hrxmovi0kYFWaFSYfbwvHq/g3CQDN5yQ+zpJyxui1RKXVc+l9W5dwDrHzSmdcTxB3RnCHjnhLdn5KjYldAImWgZiWXwBHfZiemmqeY5ahmVWVZJqsp3Krq6agqK6vdayyc5aFsbK+uqe8nLCBDwqxoo7FLsySs4O6zcGSz8DJ0YhYtMbJ1se32aNqwdGfV6jT1ZwX1oLj7q/R0ars1rTmoOH8/eJ39tqM807R0bfQSlJaF0oSA7gFXkgEuoMM9BiQgd6plYsRmSB4poOnpcUAAAIfkECRQAAwAh/hFDcmVhdGVkIHdpdGggR0lNUAAsAAAAADAAMAAAAv6cj6nL7b+AlLDaMzO4nOnchcgklKDYZaUQTGgqrez5VuQatFRtx2Wu2/Aet1/ONXQUWcddMrJsOp8JlTEopI6iUm11yaR5B9arWFs2nqkaWRjpbcuAn3o2lFbb7Y26Ia+356cgCIaDBeC28vFVmKioB3l4liYneekmdUfmg+npSTfF+fhZChm6aWhaChTUuAp75bpFGsuq+Wp725WrC4rb63uJujkqjNkKRxtwLJks+ieR05xJDAUwfcoc+1wcjb0917rayksonS07/luuvAzEVC6vKG99Dd4+Ub8v706LrikDP35r/jnCN9Ben4MaEjLq8fAbQw0c/GGYCO3JxAYxHDtaKAAAOw==", "img-thumbsup-gif"), "img-trash-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAExMTAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCRjhBOTZGNEVBNDExMUVGQkNEREJDNjJBNzc1OTAwNCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCRjhBOTZGNUVBNDExMUVGQkNEREJDNjJBNzc1OTAwNCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkJGOEE5NkYyRUE0MTExRUZCQ0REQkM2MkE3NzU5MDA0IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkJGOEE5NkYzRUE0MTExRUZCQ0REQkM2MkE3NzU5MDA0Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAgAsAAAAADAAMAAAAueUj6nL7Q+jnLTaO4PevHOseOLYgeQ5YugqVicAaPBMw20m1voel1HOC9J8EI/wOPMUjUih8jFqBp8NlNRGgrICuq1G6w1/HB2suNz7kjfJM7c2rrKd0R2RwbnyZObAcp52BRgnNwjYYzd3h4eGFgjHl6a2ltf2JjmkSEgZ+YhpaTkJ1llZ+Snp9+Noahi5yUnqqnkpSeH4WRqbimP6mJe74XI7ywUsqtpLjPv6p2uGlXkswQTtS8vcHPvcKo18mLmHnR0e3j192yTuTZsebAJ0pH7u5g4iQC/Pe2afQM//DzCgwIEKCgAAIfkEBRQAAgAsAAAAADAAMAAAAuGUj6nL7Q+jnLTai7NGofsPBlsSlqaonWp5re45vcBMz29U1vq+m1DICwpDv4/w2AMVPcimTekAOpvQxmmaJEZX2NX2BYZZw2QtQwooG9PVBSjI5bXPzFqnG6DN3eun/G6Xx/axBPhUdxgoaDaGeCiY+PiIUgg5aImYSYjTd6moB8j4ZegJCgq510g6GHg6SVmJSWpIm6paKxt5CcvZ57sYajuKa8p26tHyG8y6yxvzVnpXJ9xLbDy9iSG1mtWxgXZELQE+lJ0CHW6eQd7tvK7mPWIA7/5dJq8Qhr/P3++fUQAAOw==", "img-trash-gif"), "img-typo-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAKIEABcrcJ2v8D5RlAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4N0U4OUJGN0U0QTYxMUVGQTU4QUFGRDdFRjZEQ0Q4RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4N0U4OUJGOEU0QTYxMUVGQTU4QUFGRDdFRjZEQ0Q4RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg3RTg5QkY1RTRBNjExRUZBNThBQUZEN0VGNkRDRDhFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg3RTg5QkY2RTRBNjExRUZBNThBQUZEN0VGNkRDRDhFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQABAAsAAAAADAAMAAAA+pIutz+MMpJq704692G/2AojmTolGiqesvqvqACz6tMAniu7zyP2h6BUNgrGosmAmjIbDqfzV5yCa1ambvpRxjoXr/OnDYo6JrN4Ks4ptyWz/BA+rn+AMnx8zyMG7v3YCUtK01eUC4MMENoTi8dioxNiA8vXIZDkxgilnJMSRwnVJECn6CPbqOlpomol6R2q5StnUJssacDnJ6wt6x4rra9d7qYvMJtv7SvLMfDb8rBwqLAxtKzu8zN09DVvdvYA83Oqd2338XZxyFvkuWx60/R3lSN7qsl6OnWjuIz4ncp/g0KKLCgwYO9EgAAIfkECRQABAAsAAAAADAAMAAAA/NIutz+MMpJq724js27/2A4RGJpnuOCriyntPBKgEJtC0Cu73zPg7PObegrGn8uz3DJbDKRm+DGSa0Sd0mOLcC1eq+57FTALQe+aJ14UDO7z2inOipsv7vx53ykvL3zeh5SfYA2LYModkwxLzBkcEMwDI5lS4cOLZWRHxkkSng3gp0Sn6A1oqMQpZCnLqmeWpqGrq8Pq5tRtbZCsq25ug23obTAKrymAh3FwcesycTLwrO/y4iPzsrVjbHIqNHNuNTF0r7iwHW9z9DnWtfhKdXo3dnx7ene4+1N+Ox1lvTfJGmLAa8eC22TZCBkVmKhw4epEgAAOw==", "img-typo-gif"), "img-wand-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJEDAN9xJv/sWwAAAP///yH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkE3RTJCRDcyMjMzMzExRUZCQzQzRTYzQjk2NDc2NjUyIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkE3RTJCRDczMjMzMzExRUZCQzQzRTYzQjk2NDc2NjUyIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QTdFMkJENzAyMzMzMTFFRkJDNDNFNjNCOTY0NzY2NTIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QTdFMkJENzEyMzMzMTFFRkJDNDNFNjNCOTY0NzY2NTIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4B//79/Pv6+fj39vX08/Lx8O/u7ezr6uno5+bl5OPi4eDf3t3c29rZ2NfW1dTT0tHQz87NzMvKycjHxsXEw8LBwL++vby7urm4t7a1tLOysbCvrq2sq6qpqKempaSjoqGgn56dnJuamZiXlpWUk5KRkI+OjYyLiomIh4aFhIOCgYB/fn18e3p5eHd2dXRzcnFwb25tbGtqaWhnZmVkY2JhYF9eXVxbWllYV1ZVVFNSUVBPTk1MS0pJSEdGRURDQkFAPz49PDs6OTg3NjU0MzIxMC8uLSwrKikoJyYlJCMiISAfHh0cGxoZGBcWFRQTEhEQDw4NDAsKCQgHBgUEAwIBAAAh+QQJFAADACwAAAAAMAAwAAACz5yPqcvtD6OctNqLs2ZCbN2FTuh9B0kqaGcaazq8bBt3QSDbcBve+Orb8QS+Xy84o9WISGZTeXIWiyKoyzalJpWkbHP76Xq/4Ix4rK2Cjuis0MKeYsdvCorcNpbgubN+ZSYDEJdD0wGASFg2JIA4OPdjddWYKKbGdeh4Z2QV4vh4d2lCoinSI7pBWlmFgpkJure0iOH5iVpj+LoqmaC6GivpC8sbpVsHJXycW/tLLEvZzCsMC4ysS13t+kntPGk72+nZ2l08Tl4O3n17zm5QAAAh+QQFFAADACwAAAAAMAAwAAACyJyPqcvtD6OctNqLjdi5jw0KTeglIWmeYqltQXC2IMyx7Uur7lvbM6/C5WwyYc44JH4ESGaz59shhSDl8jfNraLYaYzrzOK+nq6YWu2Yz2hoJZSVPt2UIHDd3lp0ujz5wicA0MVHBAKASEjHcpgId2d1hegIh2K4MTkYZMk1iaKj1Ei59VciqunGWYaZmRaJcIr6msJKOQt76nob0qr7yuvp+1uLqjebq2oFPGqsjCzsLNgLHSqafHxYenulvc296C0TPk5eblUAADs=", "img-wand-gif"), "img-wrench-gif": /* @__PURE__ */ __name(() => "data:text/plain;base64,R0lGODlhMAAwAJECAGlqagAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMS1jMDAyIDc5LmE2YTYzOTY4YSwgMjAyNC8wMy8wNi0xMTo1MjowNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEyIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDQ0U0NDQxMUVBNDExMUVGOEI2RkMzMDI1RTNDQkVBRCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDQ0U0NDQxMkVBNDExMUVGOEI2RkMzMDI1RTNDQkVBRCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkNDRTQ0NDBGRUE0MTExRUY4QjZGQzMwMjVFM0NCRUFEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkNDRTQ0NDEwRUE0MTExRUY4QjZGQzMwMjVFM0NCRUFEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkECRQAAgAsAAAAADAAMAAAAsGUj6nL7Q+jnLTai1fYfGfbhd4niSEZdcC6cuijskB3jK/BybOLn3cus/UCu5sA2BICeShkEbEUfpzSaOC3CY5CyevLuROxmM2sNtbFmsfo9Bes00kz3Hic9oZb55j62aS21mXiRSL2J2JIKOdTtvhndERIBGl0aIdnCcfIR0dpxxkJptfZJ3j5pEn5mBQpuepCVXphVXNamBeGe+uaRSbb2/jKhhsIdVvsOvQZpqyxlul8TCj9nFhtPYu9zd3t7VoAACH5BAkUAAIALAAAAAAwADAAAALKlI+py+0Po5y02otb2Dxk24XeN4khGXXACpyotrFy98IySxtcrcd33tuhVDjhgdPaDH0r4DFQHGWQUWkwSqI2gcSk9dI1db1Zrdc0U5ahP1H7Czbf5uc1kz43Ytz4t3of0ucHR8GXJqZXiDYoVoIodyKi+Mh2mAgSKHhGWJGp6WKnifUyJuj0Udp3OnW3WVlUYyb2RsqESLtUmQP5h4qkN3YZB/r0Kjx8Kdtbi+C5xclTehzNu8xTbGx9jW2yDdPozQAeTl5ufi5QAAA7", "img-wrench-gif") };
  document.documentElement.dataset["typo_loading_screen_disabled"] = (window.location.pathname === "/terms" || window.location.pathname === "/credits") + "";
  const loaded = new Promise((resolve2) => {
    if (document.readyState === "interactive" || document.readyState === "complete" || Object.keys(window).includes("io")) resolve2();
    document.addEventListener("DOMContentLoaded", () => resolve2());
  });
  const scriptObserver = new MutationObserver((nodes) => {
    nodes.forEach((node) => {
      if (node instanceof HTMLScriptElement) {
        if (node.src.includes("game.js")) {
          node.addEventListener("beforescriptexecute", (e) => e.preventDefault(), { once: true });
          node.src = "";
          node.remove();
        }
      }
    });
  });
  scriptObserver.observe(document, {
    childList: true,
    subtree: true
  });
  const content = new Promise(async (resolve2) => {
    let html = await (await fetch(window.location.href)).text();
    html = html.replaceAll("game.js", "game.jsblocked");
    const newDoc = document.createElement("html");
    newDoc.innerHTML = html;
    const body = requireElement("body", newDoc);
    body.dataset["typo_loader"] = "true";
    resolve2(body);
  });
  loaded.then(async () => {
    const body = await content;
    document.body = body;
    scriptObserver.disconnect();
    signature();
  });
  const css = `
:root {
  ${Object.entries(assets).map(([key2, value]) => `--file-${key2}: url("${value()}");`).join("\n")}
}
`;
  const style = createElement(`<style>${css}</style>`);
  document.head.append(style);
  const signature = /* @__PURE__ */ __name(() => {
    console.clear();
    console.log(
      `%c
        _             _   _       _       _   _                           
       | |           (_) | |     | |     | | | |     %cskribbl modded with%c
  ___  | | __  _ __   _  | |__   | |__   | | | |_   _   _   _ __     ___  
 / __| | |/ / | '__| | | | '_ \\  | '_ \\  | | | __| | | | | | '_ \\   / _ \\ 
 \\__ \\ |   <  | |    | | | |_) | | |_) | | | | |_  | |_| | | |_) | | (_) |
 |___/ |_|\\_\\ |_|    |_| |_.__/  |_.__/  |_|  \\__|  \\__, | | .__/   \\___/ 
                                                     __/ | | |            
                                                    |___/  |_|     %cby @tobeh %c

        ➜ Typo & all its backend is open source: https://github.com/toobeeh/skribbltypo
        ➜ Join the community: https://discord.com/invite/pAapmUmWAM
        ➜ Find more infos at: https://www.typo.rip/
        ➜ Support development: https://patreon.com/skribbltypo
        
        [ ${typoRuntime.getReleaseDetails().versionName} @ ${typoRuntime.getReleaseDetails().runtime} ]
                                                                    
                                                    `,
      "color: lightblue",
      "color:#2596be; font-family:'Arial'; font-weight:bold; font-style:italic; letter-spacing:2em",
      "color: lightblue",
      "color:#2596be; font-family:'Arial'; font-weight:bold; font-style:italic; letter-spacing:2em",
      "color:#f39656"
    );
  }, "signature");

})();